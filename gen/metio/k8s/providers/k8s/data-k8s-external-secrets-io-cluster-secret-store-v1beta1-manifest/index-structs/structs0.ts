import * as cdktf from 'cdktf';
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#annotations DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#labels DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestMetadataToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestMetadataToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#operator DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#values DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#match_expressions DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#match_labels DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditions {
  /**
  * Choose namespaces by using regex matching
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace_regexes DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace_regexes}
  */
  readonly namespaceRegexes?: string[];
  /**
  * Choose namespace using a labelSelector
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace_selector DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector;
  /**
  * Choose namespaces by name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespaces DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    namespace_regexes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaceRegexes),
    namespace_selector: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    namespace_regexes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaceRegexes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    namespace_selector: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._namespaceRegexes !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceRegexes = this._namespaceRegexes;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._namespaceRegexes = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._namespaceRegexes = value.namespaceRegexes;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
    }
  }

  // namespace_regexes - computed: false, optional: true, required: false
  private _namespaceRegexes?: string[]; 
  public get namespaceRegexes() {
    return this.getListAttribute('namespace_regexes');
  }
  public set namespaceRegexes(value: string[]) {
    this._namespaceRegexes = value;
  }
  public resetNamespaceRegexes() {
    this._namespaceRegexes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceRegexesInput() {
    return this._namespaceRegexes;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsOutputReference {
    return new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecConditionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth {
  /**
  * the Akeyless Kubernetes auth-method access-id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#access_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#access_id}
  */
  readonly accessId: string;
  /**
  * Kubernetes-auth configuration name in Akeyless-Gateway
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#k8s_conf_name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#k8s_conf_name}
  */
  readonly k8SConfName: string;
  /**
  * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, 'token' is the default. If one is not specified, the one bound to the controller will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef;
  /**
  * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_id: cdktf.stringToTerraform(struct!.accessId),
    k8s_conf_name: cdktf.stringToTerraform(struct!.k8SConfName),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRefToTerraform(struct!.secretRef),
    service_account_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRefToTerraform(struct!.serviceAccountRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_id: {
      value: cdktf.stringToHclTerraform(struct!.accessId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    k8s_conf_name: {
      value: cdktf.stringToHclTerraform(struct!.k8SConfName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessId !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessId = this._accessId;
    }
    if (this._k8SConfName !== undefined) {
      hasAnyValues = true;
      internalValueResult.k8SConfName = this._k8SConfName;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessId = undefined;
      this._k8SConfName = undefined;
      this._secretRef.internalValue = undefined;
      this._serviceAccountRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessId = value.accessId;
      this._k8SConfName = value.k8SConfName;
      this._secretRef.internalValue = value.secretRef;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
    }
  }

  // access_id - computed: false, optional: false, required: true
  private _accessId?: string; 
  public get accessId() {
    return this.getStringAttribute('access_id');
  }
  public set accessId(value: string) {
    this._accessId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessIdInput() {
    return this._accessId;
  }

  // k8s_conf_name - computed: false, optional: false, required: true
  private _k8SConfName?: string; 
  public get k8SConfName() {
    return this.getStringAttribute('k8s_conf_name');
  }
  public set k8SConfName(value: string) {
    this._k8SConfName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get k8SConfNameInput() {
    return this._k8SConfName;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessIdToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessIdToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParamToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParamToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef {
  /**
  * The SecretAccessID is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#access_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#access_id}
  */
  readonly accessId?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#access_type DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#access_type}
  */
  readonly accessType?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#access_type_param DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#access_type_param}
  */
  readonly accessTypeParam?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_id: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessIdToTerraform(struct!.accessId),
    access_type: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeToTerraform(struct!.accessType),
    access_type_param: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParamToTerraform(struct!.accessTypeParam),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_id: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessIdToHclTerraform(struct!.accessId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    },
    access_type: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeToHclTerraform(struct!.accessType),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    },
    access_type_param: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParamToHclTerraform(struct!.accessTypeParam),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessId = this._accessId?.internalValue;
    }
    if (this._accessType?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessType = this._accessType?.internalValue;
    }
    if (this._accessTypeParam?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessTypeParam = this._accessTypeParam?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessId.internalValue = undefined;
      this._accessType.internalValue = undefined;
      this._accessTypeParam.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessId.internalValue = value.accessId;
      this._accessType.internalValue = value.accessType;
      this._accessTypeParam.internalValue = value.accessTypeParam;
    }
  }

  // access_id - computed: false, optional: true, required: false
  private _accessId = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessIdOutputReference(this, "access_id");
  public get accessId() {
    return this._accessId;
  }
  public putAccessId(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId) {
    this._accessId.internalValue = value;
  }
  public resetAccessId() {
    this._accessId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessIdInput() {
    return this._accessId.internalValue;
  }

  // access_type - computed: false, optional: true, required: false
  private _accessType = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeOutputReference(this, "access_type");
  public get accessType() {
    return this._accessType;
  }
  public putAccessType(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType) {
    this._accessType.internalValue = value;
  }
  public resetAccessType() {
    this._accessType.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTypeInput() {
    return this._accessType.internalValue;
  }

  // access_type_param - computed: false, optional: true, required: false
  private _accessTypeParam = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParamOutputReference(this, "access_type_param");
  public get accessTypeParam() {
    return this._accessTypeParam;
  }
  public putAccessTypeParam(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam) {
    this._accessTypeParam.internalValue = value;
  }
  public resetAccessTypeParam() {
    this._accessTypeParam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTypeParamInput() {
    return this._accessTypeParam.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef {
  /**
  * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#kubernetes_auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#kubernetes_auth}
  */
  readonly kubernetesAuth?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth;
  /**
  * Reference to a Secret that contains the details to authenticate with Akeyless.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    kubernetes_auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthToTerraform(struct!.kubernetesAuth),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    kubernetes_auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthToHclTerraform(struct!.kubernetesAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._kubernetesAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesAuth = this._kubernetesAuth?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._kubernetesAuth.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._kubernetesAuth.internalValue = value.kubernetesAuth;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // kubernetes_auth - computed: false, optional: true, required: false
  private _kubernetesAuth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthOutputReference(this, "kubernetes_auth");
  public get kubernetesAuth() {
    return this._kubernetesAuth;
  }
  public putKubernetesAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth) {
    this._kubernetesAuth.internalValue = value;
  }
  public resetKubernetesAuth() {
    this._kubernetesAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesAuthInput() {
    return this._kubernetesAuth.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider {
  /**
  * The key where the CA certificate can be found in the Secret or ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the object located at the provider type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * The type of provider to use such as 'Secret', or 'ConfigMap'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#type DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProviderToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProviderToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeyless {
  /**
  * Akeyless GW API Url from which the secrets to be fetched from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#akeyless_gw_api_url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#akeyless_gw_api_url}
  */
  readonly akeylessGwApiUrl: string;
  /**
  * Auth configures how the operator authenticates with Akeyless.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth_secret_ref}
  */
  readonly authSecretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef;
  /**
  * PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates are used to validate the TLS connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#ca_bundle DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#ca_provider DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#ca_provider}
  */
  readonly caProvider?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeyless | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    akeyless_gw_api_url: cdktf.stringToTerraform(struct!.akeylessGwApiUrl),
    auth_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefToTerraform(struct!.authSecretRef),
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    ca_provider: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProviderToTerraform(struct!.caProvider),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeyless | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    akeyless_gw_api_url: {
      value: cdktf.stringToHclTerraform(struct!.akeylessGwApiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefToHclTerraform(struct!.authSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef",
    },
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_provider: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProviderToHclTerraform(struct!.caProvider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeyless | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._akeylessGwApiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.akeylessGwApiUrl = this._akeylessGwApiUrl;
    }
    if (this._authSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authSecretRef = this._authSecretRef?.internalValue;
    }
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._caProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caProvider = this._caProvider?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeyless | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._akeylessGwApiUrl = undefined;
      this._authSecretRef.internalValue = undefined;
      this._caBundle = undefined;
      this._caProvider.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._akeylessGwApiUrl = value.akeylessGwApiUrl;
      this._authSecretRef.internalValue = value.authSecretRef;
      this._caBundle = value.caBundle;
      this._caProvider.internalValue = value.caProvider;
    }
  }

  // akeyless_gw_api_url - computed: false, optional: false, required: true
  private _akeylessGwApiUrl?: string; 
  public get akeylessGwApiUrl() {
    return this.getStringAttribute('akeyless_gw_api_url');
  }
  public set akeylessGwApiUrl(value: string) {
    this._akeylessGwApiUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get akeylessGwApiUrlInput() {
    return this._akeylessGwApiUrl;
  }

  // auth_secret_ref - computed: false, optional: false, required: true
  private _authSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefOutputReference(this, "auth_secret_ref");
  public get authSecretRef() {
    return this._authSecretRef;
  }
  public putAuthSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef) {
    this._authSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authSecretRefInput() {
    return this._authSecretRef.internalValue;
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // ca_provider - computed: false, optional: true, required: false
  private _caProvider = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProviderOutputReference(this, "ca_provider");
  public get caProvider() {
    return this._caProvider;
  }
  public putCaProvider(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider) {
    this._caProvider.internalValue = value;
  }
  public resetCaProvider() {
    this._caProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caProviderInput() {
    return this._caProvider.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#oidc_provider_arn DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#oidc_provider_arn}
  */
  readonly oidcProviderArn: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#oidc_token_file_path DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#oidc_token_file_path}
  */
  readonly oidcTokenFilePath: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#role_arn DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#role_arn}
  */
  readonly roleArn: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#session_name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#session_name}
  */
  readonly sessionName: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsaToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    oidc_provider_arn: cdktf.stringToTerraform(struct!.oidcProviderArn),
    oidc_token_file_path: cdktf.stringToTerraform(struct!.oidcTokenFilePath),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    session_name: cdktf.stringToTerraform(struct!.sessionName),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsaToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    oidc_provider_arn: {
      value: cdktf.stringToHclTerraform(struct!.oidcProviderArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oidc_token_file_path: {
      value: cdktf.stringToHclTerraform(struct!.oidcTokenFilePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    session_name: {
      value: cdktf.stringToHclTerraform(struct!.sessionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._oidcProviderArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.oidcProviderArn = this._oidcProviderArn;
    }
    if (this._oidcTokenFilePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.oidcTokenFilePath = this._oidcTokenFilePath;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._sessionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionName = this._sessionName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._oidcProviderArn = undefined;
      this._oidcTokenFilePath = undefined;
      this._roleArn = undefined;
      this._sessionName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._oidcProviderArn = value.oidcProviderArn;
      this._oidcTokenFilePath = value.oidcTokenFilePath;
      this._roleArn = value.roleArn;
      this._sessionName = value.sessionName;
    }
  }

  // oidc_provider_arn - computed: false, optional: false, required: true
  private _oidcProviderArn?: string; 
  public get oidcProviderArn() {
    return this.getStringAttribute('oidc_provider_arn');
  }
  public set oidcProviderArn(value: string) {
    this._oidcProviderArn = value;
  }
  // Temporarily expose input value. Use with caution.
  public get oidcProviderArnInput() {
    return this._oidcProviderArn;
  }

  // oidc_token_file_path - computed: false, optional: false, required: true
  private _oidcTokenFilePath?: string; 
  public get oidcTokenFilePath() {
    return this.getStringAttribute('oidc_token_file_path');
  }
  public set oidcTokenFilePath(value: string) {
    this._oidcTokenFilePath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get oidcTokenFilePathInput() {
    return this._oidcTokenFilePath;
  }

  // role_arn - computed: false, optional: false, required: true
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // session_name - computed: false, optional: false, required: true
  private _sessionName?: string; 
  public get sessionName() {
    return this.getStringAttribute('session_name');
  }
  public set sessionName(value: string) {
    this._sessionName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionNameInput() {
    return this._sessionName;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef {
  /**
  * The AccessKeyID is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#access_key_id_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#access_key_id_secret_ref}
  */
  readonly accessKeyIdSecretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef;
  /**
  * The AccessKeySecret is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#access_key_secret_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#access_key_secret_secret_ref}
  */
  readonly accessKeySecretSecretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key_id_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRefToTerraform(struct!.accessKeyIdSecretRef),
    access_key_secret_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRefToTerraform(struct!.accessKeySecretSecretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key_id_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRefToHclTerraform(struct!.accessKeyIdSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    },
    access_key_secret_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRefToHclTerraform(struct!.accessKeySecretSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKeyIdSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKeyIdSecretRef = this._accessKeyIdSecretRef?.internalValue;
    }
    if (this._accessKeySecretSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKeySecretSecretRef = this._accessKeySecretSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessKeyIdSecretRef.internalValue = undefined;
      this._accessKeySecretSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessKeyIdSecretRef.internalValue = value.accessKeyIdSecretRef;
      this._accessKeySecretSecretRef.internalValue = value.accessKeySecretSecretRef;
    }
  }

  // access_key_id_secret_ref - computed: false, optional: false, required: true
  private _accessKeyIdSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRefOutputReference(this, "access_key_id_secret_ref");
  public get accessKeyIdSecretRef() {
    return this._accessKeyIdSecretRef;
  }
  public putAccessKeyIdSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef) {
    this._accessKeyIdSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyIdSecretRefInput() {
    return this._accessKeyIdSecretRef.internalValue;
  }

  // access_key_secret_secret_ref - computed: false, optional: false, required: true
  private _accessKeySecretSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRefOutputReference(this, "access_key_secret_secret_ref");
  public get accessKeySecretSecretRef() {
    return this._accessKeySecretSecretRef;
  }
  public putAccessKeySecretSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef) {
    this._accessKeySecretSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeySecretSecretRefInput() {
    return this._accessKeySecretSecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth {
  /**
  * Authenticate against Alibaba using RRSA.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#rrsa DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#rrsa}
  */
  readonly rrsa?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa;
  /**
  * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    rrsa: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsaToTerraform(struct!.rrsa),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    rrsa: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsaToHclTerraform(struct!.rrsa),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._rrsa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rrsa = this._rrsa?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._rrsa.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._rrsa.internalValue = value.rrsa;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // rrsa - computed: false, optional: true, required: false
  private _rrsa = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsaOutputReference(this, "rrsa");
  public get rrsa() {
    return this._rrsa;
  }
  public putRrsa(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa) {
    this._rrsa.internalValue = value;
  }
  public resetRrsa() {
    this._rrsa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rrsaInput() {
    return this._rrsa.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibaba {
  /**
  * AlibabaAuth contains a secretRef for credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth;
  /**
  * Alibaba Region to be used for the provider
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#region_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#region_id}
  */
  readonly regionId: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibaba | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthToTerraform(struct!.auth),
    region_id: cdktf.stringToTerraform(struct!.regionId),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibaba | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth",
    },
    region_id: {
      value: cdktf.stringToHclTerraform(struct!.regionId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibaba | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._regionId !== undefined) {
      hasAnyValues = true;
      internalValueResult.regionId = this._regionId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibaba | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._regionId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._regionId = value.regionId;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // region_id - computed: false, optional: false, required: true
  private _regionId?: string; 
  public get regionId() {
    return this.getStringAttribute('region_id');
  }
  public set regionId(value: string) {
    this._regionId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionIdInput() {
    return this._regionId;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt {
  /**
  * A reference to a ServiceAccount resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    service_account_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRefToTerraform(struct!.serviceAccountRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    service_account_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._serviceAccountRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
    }
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef {
  /**
  * The AccessKeyID is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#access_key_id_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#access_key_id_secret_ref}
  */
  readonly accessKeyIdSecretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef;
  /**
  * The SecretAccessKey is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_access_key_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_access_key_secret_ref}
  */
  readonly secretAccessKeySecretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef;
  /**
  * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#session_token_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#session_token_secret_ref}
  */
  readonly sessionTokenSecretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key_id_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRefToTerraform(struct!.accessKeyIdSecretRef),
    secret_access_key_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRefToTerraform(struct!.secretAccessKeySecretRef),
    session_token_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRefToTerraform(struct!.sessionTokenSecretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key_id_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRefToHclTerraform(struct!.accessKeyIdSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    },
    secret_access_key_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRefToHclTerraform(struct!.secretAccessKeySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    },
    session_token_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRefToHclTerraform(struct!.sessionTokenSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKeyIdSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKeyIdSecretRef = this._accessKeyIdSecretRef?.internalValue;
    }
    if (this._secretAccessKeySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKeySecretRef = this._secretAccessKeySecretRef?.internalValue;
    }
    if (this._sessionTokenSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionTokenSecretRef = this._sessionTokenSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessKeyIdSecretRef.internalValue = undefined;
      this._secretAccessKeySecretRef.internalValue = undefined;
      this._sessionTokenSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessKeyIdSecretRef.internalValue = value.accessKeyIdSecretRef;
      this._secretAccessKeySecretRef.internalValue = value.secretAccessKeySecretRef;
      this._sessionTokenSecretRef.internalValue = value.sessionTokenSecretRef;
    }
  }

  // access_key_id_secret_ref - computed: false, optional: true, required: false
  private _accessKeyIdSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRefOutputReference(this, "access_key_id_secret_ref");
  public get accessKeyIdSecretRef() {
    return this._accessKeyIdSecretRef;
  }
  public putAccessKeyIdSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef) {
    this._accessKeyIdSecretRef.internalValue = value;
  }
  public resetAccessKeyIdSecretRef() {
    this._accessKeyIdSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyIdSecretRefInput() {
    return this._accessKeyIdSecretRef.internalValue;
  }

  // secret_access_key_secret_ref - computed: false, optional: true, required: false
  private _secretAccessKeySecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRefOutputReference(this, "secret_access_key_secret_ref");
  public get secretAccessKeySecretRef() {
    return this._secretAccessKeySecretRef;
  }
  public putSecretAccessKeySecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef) {
    this._secretAccessKeySecretRef.internalValue = value;
  }
  public resetSecretAccessKeySecretRef() {
    this._secretAccessKeySecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeySecretRefInput() {
    return this._secretAccessKeySecretRef.internalValue;
  }

  // session_token_secret_ref - computed: false, optional: true, required: false
  private _sessionTokenSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRefOutputReference(this, "session_token_secret_ref");
  public get sessionTokenSecretRef() {
    return this._sessionTokenSecretRef;
  }
  public putSessionTokenSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef) {
    this._sessionTokenSecretRef.internalValue = value;
  }
  public resetSessionTokenSecretRef() {
    this._sessionTokenSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTokenSecretRefInput() {
    return this._sessionTokenSecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuth {
  /**
  * Authenticate against AWS using service account tokens.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#jwt DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#jwt}
  */
  readonly jwt?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt;
  /**
  * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    jwt: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtToTerraform(struct!.jwt),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    jwt: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtToHclTerraform(struct!.jwt),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jwt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwt = this._jwt?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jwt.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jwt.internalValue = value.jwt;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // jwt - computed: false, optional: true, required: false
  private _jwt = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtOutputReference(this, "jwt");
  public get jwt() {
    return this._jwt;
  }
  public putJwt(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt) {
    this._jwt.internalValue = value;
  }
  public resetJwt() {
    this._jwt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwtInput() {
    return this._jwt.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager {
  /**
  * Specifies whether to delete the secret without any recovery window. You can't use both this parameter and RecoveryWindowInDays in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#force_delete_without_recovery DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#force_delete_without_recovery}
  */
  readonly forceDeleteWithoutRecovery?: boolean | cdktf.IResolvable;
  /**
  * The number of days from 7 to 30 that Secrets Manager waits before permanently deleting the secret. You can't use both this parameter and ForceDeleteWithoutRecovery in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#recovery_window_in_days DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#recovery_window_in_days}
  */
  readonly recoveryWindowInDays?: number;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManagerToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    force_delete_without_recovery: cdktf.booleanToTerraform(struct!.forceDeleteWithoutRecovery),
    recovery_window_in_days: cdktf.numberToTerraform(struct!.recoveryWindowInDays),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManagerToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    force_delete_without_recovery: {
      value: cdktf.booleanToHclTerraform(struct!.forceDeleteWithoutRecovery),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    recovery_window_in_days: {
      value: cdktf.numberToHclTerraform(struct!.recoveryWindowInDays),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManagerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._forceDeleteWithoutRecovery !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceDeleteWithoutRecovery = this._forceDeleteWithoutRecovery;
    }
    if (this._recoveryWindowInDays !== undefined) {
      hasAnyValues = true;
      internalValueResult.recoveryWindowInDays = this._recoveryWindowInDays;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._forceDeleteWithoutRecovery = undefined;
      this._recoveryWindowInDays = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._forceDeleteWithoutRecovery = value.forceDeleteWithoutRecovery;
      this._recoveryWindowInDays = value.recoveryWindowInDays;
    }
  }

  // force_delete_without_recovery - computed: false, optional: true, required: false
  private _forceDeleteWithoutRecovery?: boolean | cdktf.IResolvable; 
  public get forceDeleteWithoutRecovery() {
    return this.getBooleanAttribute('force_delete_without_recovery');
  }
  public set forceDeleteWithoutRecovery(value: boolean | cdktf.IResolvable) {
    this._forceDeleteWithoutRecovery = value;
  }
  public resetForceDeleteWithoutRecovery() {
    this._forceDeleteWithoutRecovery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceDeleteWithoutRecoveryInput() {
    return this._forceDeleteWithoutRecovery;
  }

  // recovery_window_in_days - computed: false, optional: true, required: false
  private _recoveryWindowInDays?: number; 
  public get recoveryWindowInDays() {
    return this.getNumberAttribute('recovery_window_in_days');
  }
  public set recoveryWindowInDays(value: number) {
    this._recoveryWindowInDays = value;
  }
  public resetRecoveryWindowInDays() {
    this._recoveryWindowInDays = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recoveryWindowInDaysInput() {
    return this._recoveryWindowInDays;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value}
  */
  readonly value: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsList extends cdktf.ComplexList {
  public internalValue? : DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsOutputReference {
    return new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAws {
  /**
  * AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#additional_roles DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#additional_roles}
  */
  readonly additionalRoles?: string[];
  /**
  * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuth;
  /**
  * AWS External ID set on assumed IAM roles
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#external_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#external_id}
  */
  readonly externalId?: string;
  /**
  * Prefix adds a prefix to all retrieved values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#prefix DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * AWS Region to be used for the provider
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#region DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#region}
  */
  readonly region: string;
  /**
  * Role is a Role ARN which the provider will assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#role DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#role}
  */
  readonly role?: string;
  /**
  * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secrets_manager DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secrets_manager}
  */
  readonly secretsManager?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager;
  /**
  * Service defines which service should be used to fetch the secrets
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service}
  */
  readonly service: string;
  /**
  * AWS STS assume role session tags
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#session_tags DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#session_tags}
  */
  readonly sessionTags?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags[] | cdktf.IResolvable;
  /**
  * AWS STS assume role transitive session tags. Required when multiple rules are used with the provider
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#transitive_tag_keys DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#transitive_tag_keys}
  */
  readonly transitiveTagKeys?: string[];
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAws | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.additionalRoles),
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthToTerraform(struct!.auth),
    external_id: cdktf.stringToTerraform(struct!.externalId),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    region: cdktf.stringToTerraform(struct!.region),
    role: cdktf.stringToTerraform(struct!.role),
    secrets_manager: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManagerToTerraform(struct!.secretsManager),
    service: cdktf.stringToTerraform(struct!.service),
    session_tags: cdktf.listMapper(dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsToTerraform, false)(struct!.sessionTags),
    transitive_tag_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.transitiveTagKeys),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAws | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.additionalRoles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuth",
    },
    external_id: {
      value: cdktf.stringToHclTerraform(struct!.externalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secrets_manager: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManagerToHclTerraform(struct!.secretsManager),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    session_tags: {
      value: cdktf.listMapperHcl(dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsToHclTerraform, false)(struct!.sessionTags),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsList",
    },
    transitive_tag_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.transitiveTagKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAws | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalRoles !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalRoles = this._additionalRoles;
    }
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._externalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalId = this._externalId;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._secretsManager?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretsManager = this._secretsManager?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._sessionTags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionTags = this._sessionTags?.internalValue;
    }
    if (this._transitiveTagKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.transitiveTagKeys = this._transitiveTagKeys;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAws | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalRoles = undefined;
      this._auth.internalValue = undefined;
      this._externalId = undefined;
      this._prefix = undefined;
      this._region = undefined;
      this._role = undefined;
      this._secretsManager.internalValue = undefined;
      this._service = undefined;
      this._sessionTags.internalValue = undefined;
      this._transitiveTagKeys = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalRoles = value.additionalRoles;
      this._auth.internalValue = value.auth;
      this._externalId = value.externalId;
      this._prefix = value.prefix;
      this._region = value.region;
      this._role = value.role;
      this._secretsManager.internalValue = value.secretsManager;
      this._service = value.service;
      this._sessionTags.internalValue = value.sessionTags;
      this._transitiveTagKeys = value.transitiveTagKeys;
    }
  }

  // additional_roles - computed: false, optional: true, required: false
  private _additionalRoles?: string[]; 
  public get additionalRoles() {
    return this.getListAttribute('additional_roles');
  }
  public set additionalRoles(value: string[]) {
    this._additionalRoles = value;
  }
  public resetAdditionalRoles() {
    this._additionalRoles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalRolesInput() {
    return this._additionalRoles;
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // external_id - computed: false, optional: true, required: false
  private _externalId?: string; 
  public get externalId() {
    return this.getStringAttribute('external_id');
  }
  public set externalId(value: string) {
    this._externalId = value;
  }
  public resetExternalId() {
    this._externalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalIdInput() {
    return this._externalId;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // secrets_manager - computed: false, optional: true, required: false
  private _secretsManager = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManagerOutputReference(this, "secrets_manager");
  public get secretsManager() {
    return this._secretsManager;
  }
  public putSecretsManager(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager) {
    this._secretsManager.internalValue = value;
  }
  public resetSecretsManager() {
    this._secretsManager.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsManagerInput() {
    return this._secretsManager.internalValue;
  }

  // service - computed: false, optional: false, required: true
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // session_tags - computed: false, optional: true, required: false
  private _sessionTags = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsList(this, "session_tags", false);
  public get sessionTags() {
    return this._sessionTags;
  }
  public putSessionTags(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags[] | cdktf.IResolvable) {
    this._sessionTags.internalValue = value;
  }
  public resetSessionTags() {
    this._sessionTags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTagsInput() {
    return this._sessionTags.internalValue;
  }

  // transitive_tag_keys - computed: false, optional: true, required: false
  private _transitiveTagKeys?: string[]; 
  public get transitiveTagKeys() {
    return this.getListAttribute('transitive_tag_keys');
  }
  public set transitiveTagKeys(value: string[]) {
    this._transitiveTagKeys = value;
  }
  public resetTransitiveTagKeys() {
    this._transitiveTagKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transitiveTagKeysInput() {
    return this._transitiveTagKeys;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificateToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificateToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientIdToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientIdToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecretToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecretToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantIdToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantIdToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef {
  /**
  * The Azure ClientCertificate of the service principle used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_certificate DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_certificate}
  */
  readonly clientCertificate?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate;
  /**
  * The Azure clientId of the service principle or managed identity used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_id}
  */
  readonly clientId?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId;
  /**
  * The Azure ClientSecret of the service principle used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_secret DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_secret}
  */
  readonly clientSecret?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret;
  /**
  * The Azure tenantId of the managed identity used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#tenant_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#tenant_id}
  */
  readonly tenantId?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_certificate: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificateToTerraform(struct!.clientCertificate),
    client_id: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientIdToTerraform(struct!.clientId),
    client_secret: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecretToTerraform(struct!.clientSecret),
    tenant_id: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantIdToTerraform(struct!.tenantId),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_certificate: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificateToHclTerraform(struct!.clientCertificate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate",
    },
    client_id: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientIdToHclTerraform(struct!.clientId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId",
    },
    client_secret: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecretToHclTerraform(struct!.clientSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret",
    },
    tenant_id: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantIdToHclTerraform(struct!.tenantId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientCertificate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate?.internalValue;
    }
    if (this._clientId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId?.internalValue;
    }
    if (this._clientSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret?.internalValue;
    }
    if (this._tenantId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientCertificate.internalValue = undefined;
      this._clientId.internalValue = undefined;
      this._clientSecret.internalValue = undefined;
      this._tenantId.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientCertificate.internalValue = value.clientCertificate;
      this._clientId.internalValue = value.clientId;
      this._clientSecret.internalValue = value.clientSecret;
      this._tenantId.internalValue = value.tenantId;
    }
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificateOutputReference(this, "client_certificate");
  public get clientCertificate() {
    return this._clientCertificate;
  }
  public putClientCertificate(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate) {
    this._clientCertificate.internalValue = value;
  }
  public resetClientCertificate() {
    this._clientCertificate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate.internalValue;
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientIdOutputReference(this, "client_id");
  public get clientId() {
    return this._clientId;
  }
  public putClientId(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId) {
    this._clientId.internalValue = value;
  }
  public resetClientId() {
    this._clientId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId.internalValue;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecretOutputReference(this, "client_secret");
  public get clientSecret() {
    return this._clientSecret;
  }
  public putClientSecret(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret) {
    this._clientSecret.internalValue = value;
  }
  public resetClientSecret() {
    this._clientSecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret.internalValue;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantIdOutputReference(this, "tenant_id");
  public get tenantId() {
    return this._tenantId;
  }
  public putTenantId(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId) {
    this._tenantId.internalValue = value;
  }
  public resetTenantId() {
    this._tenantId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekv {
  /**
  * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth_secret_ref}
  */
  readonly authSecretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef;
  /**
  * Auth type defines how to authenticate to the keyvault service. Valid values are: - 'ServicePrincipal' (default): Using a service principal (tenantId, clientId, clientSecret) - 'ManagedIdentity': Using Managed Identity assigned to the pod (see aad-pod-identity)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth_type DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth_type}
  */
  readonly authType?: string;
  /**
  * EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#environment_type DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#environment_type}
  */
  readonly environmentType?: string;
  /**
  * If multiple Managed Identity is assigned to the pod, you can select the one to be used
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#identity_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#identity_id}
  */
  readonly identityId?: string;
  /**
  * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef;
  /**
  * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#tenant_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#tenant_id}
  */
  readonly tenantId?: string;
  /**
  * Vault Url from which the secrets to be fetched from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#vault_url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#vault_url}
  */
  readonly vaultUrl: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefToTerraform(struct!.authSecretRef),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    environment_type: cdktf.stringToTerraform(struct!.environmentType),
    identity_id: cdktf.stringToTerraform(struct!.identityId),
    service_account_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRefToTerraform(struct!.serviceAccountRef),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    vault_url: cdktf.stringToTerraform(struct!.vaultUrl),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefToHclTerraform(struct!.authSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment_type: {
      value: cdktf.stringToHclTerraform(struct!.environmentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_id: {
      value: cdktf.stringToHclTerraform(struct!.identityId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vault_url: {
      value: cdktf.stringToHclTerraform(struct!.vaultUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authSecretRef = this._authSecretRef?.internalValue;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._environmentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.environmentType = this._environmentType;
    }
    if (this._identityId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityId = this._identityId;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._vaultUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.vaultUrl = this._vaultUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authSecretRef.internalValue = undefined;
      this._authType = undefined;
      this._environmentType = undefined;
      this._identityId = undefined;
      this._serviceAccountRef.internalValue = undefined;
      this._tenantId = undefined;
      this._vaultUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authSecretRef.internalValue = value.authSecretRef;
      this._authType = value.authType;
      this._environmentType = value.environmentType;
      this._identityId = value.identityId;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
      this._tenantId = value.tenantId;
      this._vaultUrl = value.vaultUrl;
    }
  }

  // auth_secret_ref - computed: false, optional: true, required: false
  private _authSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefOutputReference(this, "auth_secret_ref");
  public get authSecretRef() {
    return this._authSecretRef;
  }
  public putAuthSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef) {
    this._authSecretRef.internalValue = value;
  }
  public resetAuthSecretRef() {
    this._authSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authSecretRefInput() {
    return this._authSecretRef.internalValue;
  }

  // auth_type - computed: false, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // environment_type - computed: false, optional: true, required: false
  private _environmentType?: string; 
  public get environmentType() {
    return this.getStringAttribute('environment_type');
  }
  public set environmentType(value: string) {
    this._environmentType = value;
  }
  public resetEnvironmentType() {
    this._environmentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentTypeInput() {
    return this._environmentType;
  }

  // identity_id - computed: false, optional: true, required: false
  private _identityId?: string; 
  public get identityId() {
    return this.getStringAttribute('identity_id');
  }
  public set identityId(value: string) {
    this._identityId = value;
  }
  public resetIdentityId() {
    this._identityId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityIdInput() {
    return this._identityId;
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // vault_url - computed: false, optional: false, required: true
  private _vaultUrl?: string; 
  public get vaultUrl() {
    return this.getStringAttribute('vault_url');
  }
  public set vaultUrl(value: string) {
    this._vaultUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vaultUrlInput() {
    return this._vaultUrl;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeyToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeyToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth {
  /**
  * Content of the certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#certificate DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#certificate}
  */
  readonly certificate?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate;
  /**
  * Certificate private key (key.pem). For use when authenticating with an OAuth client Id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#certificate_key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#certificate_key}
  */
  readonly certificateKey?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_id}
  */
  readonly clientId: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_secret DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_secret}
  */
  readonly clientSecret: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    certificate: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateToTerraform(struct!.certificate),
    certificate_key: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeyToTerraform(struct!.certificateKey),
    client_id: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdToTerraform(struct!.clientId),
    client_secret: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretToTerraform(struct!.clientSecret),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    certificate: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateToHclTerraform(struct!.certificate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate",
    },
    certificate_key: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeyToHclTerraform(struct!.certificateKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey",
    },
    client_id: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdToHclTerraform(struct!.clientId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId",
    },
    client_secret: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretToHclTerraform(struct!.clientSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certificate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificate = this._certificate?.internalValue;
    }
    if (this._certificateKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateKey = this._certificateKey?.internalValue;
    }
    if (this._clientId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId?.internalValue;
    }
    if (this._clientSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certificate.internalValue = undefined;
      this._certificateKey.internalValue = undefined;
      this._clientId.internalValue = undefined;
      this._clientSecret.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certificate.internalValue = value.certificate;
      this._certificateKey.internalValue = value.certificateKey;
      this._clientId.internalValue = value.clientId;
      this._clientSecret.internalValue = value.clientSecret;
    }
  }

  // certificate - computed: false, optional: true, required: false
  private _certificate = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateOutputReference(this, "certificate");
  public get certificate() {
    return this._certificate;
  }
  public putCertificate(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate) {
    this._certificate.internalValue = value;
  }
  public resetCertificate() {
    this._certificate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateInput() {
    return this._certificate.internalValue;
  }

  // certificate_key - computed: false, optional: true, required: false
  private _certificateKey = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeyOutputReference(this, "certificate_key");
  public get certificateKey() {
    return this._certificateKey;
  }
  public putCertificateKey(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey) {
    this._certificateKey.internalValue = value;
  }
  public resetCertificateKey() {
    this._certificateKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateKeyInput() {
    return this._certificateKey.internalValue;
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdOutputReference(this, "client_id");
  public get clientId() {
    return this._clientId;
  }
  public putClientId(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId) {
    this._clientId.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId.internalValue;
  }

  // client_secret - computed: false, optional: false, required: true
  private _clientSecret = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretOutputReference(this, "client_secret");
  public get clientSecret() {
    return this._clientSecret;
  }
  public putClientSecret(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret) {
    this._clientSecret.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#api_url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#api_url}
  */
  readonly apiUrl: string;
  /**
  * Timeout specifies a time limit for requests made by this Client. The timeout includes connection time, any redirects, and reading the response body. Defaults to 45 seconds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_time_out_seconds DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_time_out_seconds}
  */
  readonly clientTimeOutSeconds?: number;
  /**
  * The secret retrieval type. SECRET = Secrets Safe (credential, text, file). MANAGED_ACCOUNT = Password Safe account associated with a system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#retrieval_type DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#retrieval_type}
  */
  readonly retrievalType?: string;
  /**
  * A character that separates the folder names.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#separator DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#separator}
  */
  readonly separator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#verify_ca DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#verify_ca}
  */
  readonly verifyCa: boolean | cdktf.IResolvable;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServerToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    client_time_out_seconds: cdktf.numberToTerraform(struct!.clientTimeOutSeconds),
    retrieval_type: cdktf.stringToTerraform(struct!.retrievalType),
    separator: cdktf.stringToTerraform(struct!.separator),
    verify_ca: cdktf.booleanToTerraform(struct!.verifyCa),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServerToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_time_out_seconds: {
      value: cdktf.numberToHclTerraform(struct!.clientTimeOutSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retrieval_type: {
      value: cdktf.stringToHclTerraform(struct!.retrievalType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    separator: {
      value: cdktf.stringToHclTerraform(struct!.separator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_ca: {
      value: cdktf.booleanToHclTerraform(struct!.verifyCa),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._clientTimeOutSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientTimeOutSeconds = this._clientTimeOutSeconds;
    }
    if (this._retrievalType !== undefined) {
      hasAnyValues = true;
      internalValueResult.retrievalType = this._retrievalType;
    }
    if (this._separator !== undefined) {
      hasAnyValues = true;
      internalValueResult.separator = this._separator;
    }
    if (this._verifyCa !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyCa = this._verifyCa;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiUrl = undefined;
      this._clientTimeOutSeconds = undefined;
      this._retrievalType = undefined;
      this._separator = undefined;
      this._verifyCa = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiUrl = value.apiUrl;
      this._clientTimeOutSeconds = value.clientTimeOutSeconds;
      this._retrievalType = value.retrievalType;
      this._separator = value.separator;
      this._verifyCa = value.verifyCa;
    }
  }

  // api_url - computed: false, optional: false, required: true
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // client_time_out_seconds - computed: false, optional: true, required: false
  private _clientTimeOutSeconds?: number; 
  public get clientTimeOutSeconds() {
    return this.getNumberAttribute('client_time_out_seconds');
  }
  public set clientTimeOutSeconds(value: number) {
    this._clientTimeOutSeconds = value;
  }
  public resetClientTimeOutSeconds() {
    this._clientTimeOutSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientTimeOutSecondsInput() {
    return this._clientTimeOutSeconds;
  }

  // retrieval_type - computed: false, optional: true, required: false
  private _retrievalType?: string; 
  public get retrievalType() {
    return this.getStringAttribute('retrieval_type');
  }
  public set retrievalType(value: string) {
    this._retrievalType = value;
  }
  public resetRetrievalType() {
    this._retrievalType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retrievalTypeInput() {
    return this._retrievalType;
  }

  // separator - computed: false, optional: true, required: false
  private _separator?: string; 
  public get separator() {
    return this.getStringAttribute('separator');
  }
  public set separator(value: string) {
    this._separator = value;
  }
  public resetSeparator() {
    this._separator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get separatorInput() {
    return this._separator;
  }

  // verify_ca - computed: false, optional: false, required: true
  private _verifyCa?: boolean | cdktf.IResolvable; 
  public get verifyCa() {
    return this.getBooleanAttribute('verify_ca');
  }
  public set verifyCa(value: boolean | cdktf.IResolvable) {
    this._verifyCa = value;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyCaInput() {
    return this._verifyCa;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrust {
  /**
  * Auth configures how the operator authenticates with Beyondtrust.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth;
  /**
  * Auth configures how API server works.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#server DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#server}
  */
  readonly server: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrust | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthToTerraform(struct!.auth),
    server: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServerToTerraform(struct!.server),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrust | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth",
    },
    server: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServerToHclTerraform(struct!.server),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrust | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._server?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrust | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._server.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._server.internalValue = value.server;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // server - computed: false, optional: false, required: true
  private _server = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServerOutputReference(this, "server");
  public get server() {
    return this._server;
  }
  public putServer(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer) {
    this._server.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentialsToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentialsToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef {
  /**
  * AccessToken used for the bitwarden instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#credentials DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#credentials}
  */
  readonly credentials: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentialsToTerraform(struct!.credentials),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentials.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentials.internalValue = value.credentials;
    }
  }

  // credentials - computed: false, optional: false, required: true
  private _credentials = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials) {
    this._credentials.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth {
  /**
  * BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider {
  /**
  * The key where the CA certificate can be found in the Secret or ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the object located at the provider type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * The type of provider to use such as 'Secret', or 'ConfigMap'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#type DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProviderToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProviderToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanager {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#api_url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#api_url}
  */
  readonly apiUrl?: string;
  /**
  * Auth configures how secret-manager authenticates with a bitwarden machine account instance. Make sure that the token being used has permissions on the given secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#bitwarden_server_sdk_url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#bitwarden_server_sdk_url}
  */
  readonly bitwardenServerSdkUrl?: string;
  /**
  * Base64 encoded certificate for the bitwarden server sdk. The sdk MUST run with HTTPS to make sure no MITM attack can be performed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#ca_bundle DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#ca_provider DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#ca_provider}
  */
  readonly caProvider?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#identity_url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#identity_url}
  */
  readonly identityUrl?: string;
  /**
  * OrganizationID determines which organization this secret store manages.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#organization_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#organization_id}
  */
  readonly organizationId: string;
  /**
  * ProjectID determines which project this secret store manages.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#project_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#project_id}
  */
  readonly projectId: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanager | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthToTerraform(struct!.auth),
    bitwarden_server_sdk_url: cdktf.stringToTerraform(struct!.bitwardenServerSdkUrl),
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    ca_provider: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProviderToTerraform(struct!.caProvider),
    identity_url: cdktf.stringToTerraform(struct!.identityUrl),
    organization_id: cdktf.stringToTerraform(struct!.organizationId),
    project_id: cdktf.stringToTerraform(struct!.projectId),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanager | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth",
    },
    bitwarden_server_sdk_url: {
      value: cdktf.stringToHclTerraform(struct!.bitwardenServerSdkUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_provider: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProviderToHclTerraform(struct!.caProvider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider",
    },
    identity_url: {
      value: cdktf.stringToHclTerraform(struct!.identityUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    organization_id: {
      value: cdktf.stringToHclTerraform(struct!.organizationId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanager | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._bitwardenServerSdkUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.bitwardenServerSdkUrl = this._bitwardenServerSdkUrl;
    }
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._caProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caProvider = this._caProvider?.internalValue;
    }
    if (this._identityUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityUrl = this._identityUrl;
    }
    if (this._organizationId !== undefined) {
      hasAnyValues = true;
      internalValueResult.organizationId = this._organizationId;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanager | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiUrl = undefined;
      this._auth.internalValue = undefined;
      this._bitwardenServerSdkUrl = undefined;
      this._caBundle = undefined;
      this._caProvider.internalValue = undefined;
      this._identityUrl = undefined;
      this._organizationId = undefined;
      this._projectId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiUrl = value.apiUrl;
      this._auth.internalValue = value.auth;
      this._bitwardenServerSdkUrl = value.bitwardenServerSdkUrl;
      this._caBundle = value.caBundle;
      this._caProvider.internalValue = value.caProvider;
      this._identityUrl = value.identityUrl;
      this._organizationId = value.organizationId;
      this._projectId = value.projectId;
    }
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // bitwarden_server_sdk_url - computed: false, optional: true, required: false
  private _bitwardenServerSdkUrl?: string; 
  public get bitwardenServerSdkUrl() {
    return this.getStringAttribute('bitwarden_server_sdk_url');
  }
  public set bitwardenServerSdkUrl(value: string) {
    this._bitwardenServerSdkUrl = value;
  }
  public resetBitwardenServerSdkUrl() {
    this._bitwardenServerSdkUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bitwardenServerSdkUrlInput() {
    return this._bitwardenServerSdkUrl;
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // ca_provider - computed: false, optional: true, required: false
  private _caProvider = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProviderOutputReference(this, "ca_provider");
  public get caProvider() {
    return this._caProvider;
  }
  public putCaProvider(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider) {
    this._caProvider.internalValue = value;
  }
  public resetCaProvider() {
    this._caProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caProviderInput() {
    return this._caProvider.internalValue;
  }

  // identity_url - computed: false, optional: true, required: false
  private _identityUrl?: string; 
  public get identityUrl() {
    return this.getStringAttribute('identity_url');
  }
  public set identityUrl(value: string) {
    this._identityUrl = value;
  }
  public resetIdentityUrl() {
    this._identityUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityUrlInput() {
    return this._identityUrl;
  }

  // organization_id - computed: false, optional: false, required: true
  private _organizationId?: string; 
  public get organizationId() {
    return this.getStringAttribute('organization_id');
  }
  public set organizationId(value: string) {
    this._organizationId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get organizationIdInput() {
    return this._organizationId;
  }

  // project_id - computed: false, optional: false, required: true
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef {
  /**
  * SecretKey is the Signing Key in PEM format, used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#private_key_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#private_key_secret_ref}
  */
  readonly privateKeySecretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    private_key_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRefToTerraform(struct!.privateKeySecretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    private_key_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRefToHclTerraform(struct!.privateKeySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._privateKeySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKeySecretRef = this._privateKeySecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._privateKeySecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._privateKeySecretRef.internalValue = value.privateKeySecretRef;
    }
  }

  // private_key_secret_ref - computed: false, optional: false, required: true
  private _privateKeySecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRefOutputReference(this, "private_key_secret_ref");
  public get privateKeySecretRef() {
    return this._privateKeySecretRef;
  }
  public putPrivateKeySecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef) {
    this._privateKeySecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeySecretRefInput() {
    return this._privateKeySecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuth {
  /**
  * ChefAuthSecretRef holds secret references for chef server login credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChef {
  /**
  * Auth defines the information necessary to authenticate against chef Server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuth;
  /**
  * ServerURL is the chef server URL used to connect to. If using orgs you should include your org in the url and terminate the url with a '/'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#server_url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#server_url}
  */
  readonly serverUrl: string;
  /**
  * UserName should be the user ID on the chef server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#username DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#username}
  */
  readonly username: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthToTerraform(struct!.auth),
    server_url: cdktf.stringToTerraform(struct!.serverUrl),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuth",
    },
    server_url: {
      value: cdktf.stringToHclTerraform(struct!.serverUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._serverUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverUrl = this._serverUrl;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._serverUrl = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._serverUrl = value.serverUrl;
      this._username = value.username;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderChefAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // server_url - computed: false, optional: false, required: true
  private _serverUrl?: string; 
  public get serverUrl() {
    return this.getStringAttribute('server_url');
  }
  public set serverUrl(value: string) {
    this._serverUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serverUrlInput() {
    return this._serverUrl;
  }

  // username - computed: false, optional: false, required: true
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#account DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#account}
  */
  readonly account: string;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#api_key_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#api_key_ref}
  */
  readonly apiKeyRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#user_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#user_ref}
  */
  readonly userRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    account: cdktf.stringToTerraform(struct!.account),
    api_key_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRefToTerraform(struct!.apiKeyRef),
    user_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRefToTerraform(struct!.userRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    account: {
      value: cdktf.stringToHclTerraform(struct!.account),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_key_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRefToHclTerraform(struct!.apiKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef",
    },
    user_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRefToHclTerraform(struct!.userRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._account !== undefined) {
      hasAnyValues = true;
      internalValueResult.account = this._account;
    }
    if (this._apiKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKeyRef = this._apiKeyRef?.internalValue;
    }
    if (this._userRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.userRef = this._userRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._account = undefined;
      this._apiKeyRef.internalValue = undefined;
      this._userRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._account = value.account;
      this._apiKeyRef.internalValue = value.apiKeyRef;
      this._userRef.internalValue = value.userRef;
    }
  }

  // account - computed: false, optional: false, required: true
  private _account?: string; 
  public get account() {
    return this.getStringAttribute('account');
  }
  public set account(value: string) {
    this._account = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accountInput() {
    return this._account;
  }

  // api_key_ref - computed: false, optional: false, required: true
  private _apiKeyRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRefOutputReference(this, "api_key_ref");
  public get apiKeyRef() {
    return this._apiKeyRef;
  }
  public putApiKeyRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef) {
    this._apiKeyRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyRefInput() {
    return this._apiKeyRef.internalValue;
  }

  // user_ref - computed: false, optional: false, required: true
  private _userRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRefOutputReference(this, "user_ref");
  public get userRef() {
    return this._userRef;
  }
  public putUserRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef) {
    this._userRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userRefInput() {
    return this._userRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#account DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#account}
  */
  readonly account: string;
  /**
  * Optional HostID for JWT authentication. This may be used depending on how the Conjur JWT authenticator policy is configured.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#host_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#host_id}
  */
  readonly hostId?: string;
  /**
  * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef;
  /**
  * Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the 'TokenRequest' API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef;
  /**
  * The conjur authn jwt webservice id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service_id}
  */
  readonly serviceId: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    account: cdktf.stringToTerraform(struct!.account),
    host_id: cdktf.stringToTerraform(struct!.hostId),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRefToTerraform(struct!.secretRef),
    service_account_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRefToTerraform(struct!.serviceAccountRef),
    service_id: cdktf.stringToTerraform(struct!.serviceId),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    account: {
      value: cdktf.stringToHclTerraform(struct!.account),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_id: {
      value: cdktf.stringToHclTerraform(struct!.hostId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef",
    },
    service_id: {
      value: cdktf.stringToHclTerraform(struct!.serviceId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._account !== undefined) {
      hasAnyValues = true;
      internalValueResult.account = this._account;
    }
    if (this._hostId !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostId = this._hostId;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    if (this._serviceId !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceId = this._serviceId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._account = undefined;
      this._hostId = undefined;
      this._secretRef.internalValue = undefined;
      this._serviceAccountRef.internalValue = undefined;
      this._serviceId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._account = value.account;
      this._hostId = value.hostId;
      this._secretRef.internalValue = value.secretRef;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
      this._serviceId = value.serviceId;
    }
  }

  // account - computed: false, optional: false, required: true
  private _account?: string; 
  public get account() {
    return this.getStringAttribute('account');
  }
  public set account(value: string) {
    this._account = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accountInput() {
    return this._account;
  }

  // host_id - computed: false, optional: true, required: false
  private _hostId?: string; 
  public get hostId() {
    return this.getStringAttribute('host_id');
  }
  public set hostId(value: string) {
    this._hostId = value;
  }
  public resetHostId() {
    this._hostId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostIdInput() {
    return this._hostId;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }

  // service_id - computed: false, optional: false, required: true
  private _serviceId?: string; 
  public get serviceId() {
    return this.getStringAttribute('service_id');
  }
  public set serviceId(value: string) {
    this._serviceId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceIdInput() {
    return this._serviceId;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#apikey DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#apikey}
  */
  readonly apikey?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#jwt DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#jwt}
  */
  readonly jwt?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    apikey: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyToTerraform(struct!.apikey),
    jwt: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtToTerraform(struct!.jwt),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    apikey: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyToHclTerraform(struct!.apikey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey",
    },
    jwt: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtToHclTerraform(struct!.jwt),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apikey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apikey = this._apikey?.internalValue;
    }
    if (this._jwt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwt = this._jwt?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apikey.internalValue = undefined;
      this._jwt.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apikey.internalValue = value.apikey;
      this._jwt.internalValue = value.jwt;
    }
  }

  // apikey - computed: false, optional: true, required: false
  private _apikey = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyOutputReference(this, "apikey");
  public get apikey() {
    return this._apikey;
  }
  public putApikey(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey) {
    this._apikey.internalValue = value;
  }
  public resetApikey() {
    this._apikey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apikeyInput() {
    return this._apikey.internalValue;
  }

  // jwt - computed: false, optional: true, required: false
  private _jwt = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtOutputReference(this, "jwt");
  public get jwt() {
    return this._jwt;
  }
  public putJwt(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt) {
    this._jwt.internalValue = value;
  }
  public resetJwt() {
    this._jwt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwtInput() {
    return this._jwt.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider {
  /**
  * The key where the CA certificate can be found in the Secret or ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the object located at the provider type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * The type of provider to use such as 'Secret', or 'ConfigMap'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#type DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProviderToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProviderToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjur {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#ca_bundle DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * Used to provide custom certificate authority (CA) certificates for a secret store. The CAProvider points to a Secret or ConfigMap resource that contains a PEM-encoded certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#ca_provider DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#ca_provider}
  */
  readonly caProvider?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#url}
  */
  readonly url: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjur | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthToTerraform(struct!.auth),
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    ca_provider: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProviderToTerraform(struct!.caProvider),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjur | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuth",
    },
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_provider: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProviderToHclTerraform(struct!.caProvider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjur | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._caProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caProvider = this._caProvider?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjur | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._caBundle = undefined;
      this._caProvider.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._caBundle = value.caBundle;
      this._caProvider.internalValue = value.caProvider;
      this._url = value.url;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // ca_provider - computed: false, optional: true, required: false
  private _caProvider = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProviderOutputReference(this, "ca_provider");
  public get caProvider() {
    return this._caProvider;
  }
  public putCaProvider(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider) {
    this._caProvider.internalValue = value;
  }
  public resetCaProvider() {
    this._caProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caProviderInput() {
    return this._caProvider.internalValue;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientId {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelinea {
  /**
  * ClientID is the non-secret part of the credential.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_id}
  */
  readonly clientId: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientId;
  /**
  * ClientSecret is the secret part of the credential.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_secret DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_secret}
  */
  readonly clientSecret: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret;
  /**
  * Tenant is the chosen hostname / site name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#tenant DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#tenant}
  */
  readonly tenant: string;
  /**
  * TLD is based on the server location that was chosen during provisioning. If unset, defaults to 'com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#tld DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#tld}
  */
  readonly tld?: string;
  /**
  * URLTemplate If unset, defaults to 'https://%s.secretsvaultcloud.%s/v1/%s%s'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#url_template DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#url_template}
  */
  readonly urlTemplate?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelinea | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdToTerraform(struct!.clientId),
    client_secret: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretToTerraform(struct!.clientSecret),
    tenant: cdktf.stringToTerraform(struct!.tenant),
    tld: cdktf.stringToTerraform(struct!.tld),
    url_template: cdktf.stringToTerraform(struct!.urlTemplate),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelinea | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdToHclTerraform(struct!.clientId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientId",
    },
    client_secret: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretToHclTerraform(struct!.clientSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret",
    },
    tenant: {
      value: cdktf.stringToHclTerraform(struct!.tenant),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tld: {
      value: cdktf.stringToHclTerraform(struct!.tld),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url_template: {
      value: cdktf.stringToHclTerraform(struct!.urlTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelinea | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId?.internalValue;
    }
    if (this._clientSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret?.internalValue;
    }
    if (this._tenant !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenant = this._tenant;
    }
    if (this._tld !== undefined) {
      hasAnyValues = true;
      internalValueResult.tld = this._tld;
    }
    if (this._urlTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlTemplate = this._urlTemplate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelinea | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientId.internalValue = undefined;
      this._clientSecret.internalValue = undefined;
      this._tenant = undefined;
      this._tld = undefined;
      this._urlTemplate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientId.internalValue = value.clientId;
      this._clientSecret.internalValue = value.clientSecret;
      this._tenant = value.tenant;
      this._tld = value.tld;
      this._urlTemplate = value.urlTemplate;
    }
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdOutputReference(this, "client_id");
  public get clientId() {
    return this._clientId;
  }
  public putClientId(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientId) {
    this._clientId.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId.internalValue;
  }

  // client_secret - computed: false, optional: false, required: true
  private _clientSecret = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretOutputReference(this, "client_secret");
  public get clientSecret() {
    return this._clientSecret;
  }
  public putClientSecret(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret) {
    this._clientSecret.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret.internalValue;
  }

  // tenant - computed: false, optional: false, required: true
  private _tenant?: string; 
  public get tenant() {
    return this.getStringAttribute('tenant');
  }
  public set tenant(value: string) {
    this._tenant = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantInput() {
    return this._tenant;
  }

  // tld - computed: false, optional: true, required: false
  private _tld?: string; 
  public get tld() {
    return this.getStringAttribute('tld');
  }
  public set tld(value: string) {
    this._tld = value;
  }
  public resetTld() {
    this._tld = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tldInput() {
    return this._tld;
  }

  // url_template - computed: false, optional: true, required: false
  private _urlTemplate?: string; 
  public get urlTemplate() {
    return this.getStringAttribute('url_template');
  }
  public set urlTemplate(value: string) {
    this._urlTemplate = value;
  }
  public resetUrlTemplate() {
    this._urlTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlTemplateInput() {
    return this._urlTemplate;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentialsToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentialsToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef {
  /**
  * Username / Password is used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#credentials DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#credentials}
  */
  readonly credentials?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentialsToTerraform(struct!.credentials),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentials.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentials.internalValue = value.credentials;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42Auth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42Auth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42Auth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42Auth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42Auth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42 {
  /**
  * Auth configures how secret-manager authenticates with a Device42 instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42Auth;
  /**
  * URL configures the Device42 instance URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#host DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#host}
  */
  readonly host: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42ToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthToTerraform(struct!.auth),
    host: cdktf.stringToTerraform(struct!.host),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42ToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42Auth",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._host = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._host = value.host;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42AuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDevice42Auth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerTokenToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerTokenToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef {
  /**
  * The DopplerToken is used for authentication. See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#doppler_token DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#doppler_token}
  */
  readonly dopplerToken: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    doppler_token: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerTokenToTerraform(struct!.dopplerToken),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    doppler_token: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerTokenToHclTerraform(struct!.dopplerToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dopplerToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dopplerToken = this._dopplerToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dopplerToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dopplerToken.internalValue = value.dopplerToken;
    }
  }

  // doppler_token - computed: false, optional: false, required: true
  private _dopplerToken = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerTokenOutputReference(this, "doppler_token");
  public get dopplerToken() {
    return this._dopplerToken;
  }
  public putDopplerToken(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken) {
    this._dopplerToken.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dopplerTokenInput() {
    return this._dopplerToken.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDoppler {
  /**
  * Auth configures how the Operator authenticates with the Doppler API
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuth;
  /**
  * Doppler config (required if not using a Service Token)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#config DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#config}
  */
  readonly config?: string;
  /**
  * Format enables the downloading of secrets as a file (string)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#format DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#format}
  */
  readonly format?: string;
  /**
  * Environment variable compatible name transforms that change secret names to a different format
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name_transformer DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name_transformer}
  */
  readonly nameTransformer?: string;
  /**
  * Doppler project (required if not using a Service Token)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#project DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#project}
  */
  readonly project?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDoppler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthToTerraform(struct!.auth),
    config: cdktf.stringToTerraform(struct!.config),
    format: cdktf.stringToTerraform(struct!.format),
    name_transformer: cdktf.stringToTerraform(struct!.nameTransformer),
    project: cdktf.stringToTerraform(struct!.project),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDoppler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuth",
    },
    config: {
      value: cdktf.stringToHclTerraform(struct!.config),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name_transformer: {
      value: cdktf.stringToHclTerraform(struct!.nameTransformer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project: {
      value: cdktf.stringToHclTerraform(struct!.project),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDoppler | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._config !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._nameTransformer !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameTransformer = this._nameTransformer;
    }
    if (this._project !== undefined) {
      hasAnyValues = true;
      internalValueResult.project = this._project;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDoppler | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._config = undefined;
      this._format = undefined;
      this._nameTransformer = undefined;
      this._project = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._config = value.config;
      this._format = value.format;
      this._nameTransformer = value.nameTransformer;
      this._project = value.project;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderDopplerAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // config - computed: false, optional: true, required: false
  private _config?: string; 
  public get config() {
    return this.getStringAttribute('config');
  }
  public set config(value: string) {
    this._config = value;
  }
  public resetConfig() {
    this._config = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // name_transformer - computed: false, optional: true, required: false
  private _nameTransformer?: string; 
  public get nameTransformer() {
    return this.getStringAttribute('name_transformer');
  }
  public set nameTransformer(value: string) {
    this._nameTransformer = value;
  }
  public resetNameTransformer() {
    this._nameTransformer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameTransformerInput() {
    return this._nameTransformer;
  }

  // project - computed: false, optional: true, required: false
  private _project?: string; 
  public get project() {
    return this.getStringAttribute('project');
  }
  public set project(value: string) {
    this._project = value;
  }
  public resetProject() {
    this._project = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectInput() {
    return this._project;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeData {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
  /**
  * Deprecated: ValueMap is deprecated and is intended to be removed in the future, use the 'value' field instead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value_map DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value_map}
  */
  readonly valueMap?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#version DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#version}
  */
  readonly version?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeDataToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
    value_map: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.valueMap),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeDataToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_map: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.valueMap),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeDataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeData | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueMap !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueMap = this._valueMap;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeData | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
      this._valueMap = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
      this._valueMap = value.valueMap;
      this._version = value.version;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_map - computed: false, optional: true, required: false
  private _valueMap?: { [key: string]: string }; 
  public get valueMap() {
    return this.getStringMapAttribute('value_map');
  }
  public set valueMap(value: { [key: string]: string }) {
    this._valueMap = value;
  }
  public resetValueMap() {
    this._valueMap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueMapInput() {
    return this._valueMap;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeDataList extends cdktf.ComplexList {
  public internalValue? : DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeData[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeDataOutputReference {
    return new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeDataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFake {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#data DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#data}
  */
  readonly data: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeData[] | cdktf.IResolvable;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data: cdktf.listMapper(dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeDataToTerraform, false)(struct!.data),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data: {
      value: cdktf.listMapperHcl(dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeDataToHclTerraform, false)(struct!.data),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeDataList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFake | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._data?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFake | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._data.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._data.internalValue = value.data;
    }
  }

  // data - computed: false, optional: false, required: true
  private _data = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeDataList(this, "data", false);
  public get data() {
    return this._data;
  }
  public putData(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFakeData[] | cdktf.IResolvable) {
    this._data.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey {
  /**
  * SecretRef is a reference to a secret containing the SDKMS API Key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeyToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeyToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanix {
  /**
  * APIKey is the API token to access SDKMS Applications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#api_key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#api_key}
  */
  readonly apiKey?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey;
  /**
  * APIURL is the URL of SDKMS API. Defaults to 'sdkms.fortanix.com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#api_url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#api_url}
  */
  readonly apiUrl?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_key: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeyToTerraform(struct!.apiKey),
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_key: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeyToHclTerraform(struct!.apiKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey",
    },
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey?.internalValue;
    }
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiKey.internalValue = undefined;
      this._apiUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiKey.internalValue = value.apiKey;
      this._apiUrl = value.apiUrl;
    }
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeyOutputReference(this, "api_key");
  public get apiKey() {
    return this._apiKey;
  }
  public putApiKey(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey) {
    this._apiKey.internalValue = value;
  }
  public resetApiKey() {
    this._apiKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey.internalValue;
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef {
  /**
  * The SecretAccessKey is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_access_key_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_access_key_secret_ref}
  */
  readonly secretAccessKeySecretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_access_key_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRefToTerraform(struct!.secretAccessKeySecretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_access_key_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRefToHclTerraform(struct!.secretAccessKeySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretAccessKeySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKeySecretRef = this._secretAccessKeySecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretAccessKeySecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretAccessKeySecretRef.internalValue = value.secretAccessKeySecretRef;
    }
  }

  // secret_access_key_secret_ref - computed: false, optional: true, required: false
  private _secretAccessKeySecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRefOutputReference(this, "secret_access_key_secret_ref");
  public get secretAccessKeySecretRef() {
    return this._secretAccessKeySecretRef;
  }
  public putSecretAccessKeySecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef) {
    this._secretAccessKeySecretRef.internalValue = value;
  }
  public resetSecretAccessKeySecretRef() {
    this._secretAccessKeySecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeySecretRefInput() {
    return this._secretAccessKeySecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#cluster_location DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#cluster_location}
  */
  readonly clusterLocation: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#cluster_name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#cluster_name}
  */
  readonly clusterName: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#cluster_project_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#cluster_project_id}
  */
  readonly clusterProjectId?: string;
  /**
  * A reference to a ServiceAccount resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_location: cdktf.stringToTerraform(struct!.clusterLocation),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    cluster_project_id: cdktf.stringToTerraform(struct!.clusterProjectId),
    service_account_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRefToTerraform(struct!.serviceAccountRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_location: {
      value: cdktf.stringToHclTerraform(struct!.clusterLocation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_project_id: {
      value: cdktf.stringToHclTerraform(struct!.clusterProjectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterLocation !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterLocation = this._clusterLocation;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._clusterProjectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterProjectId = this._clusterProjectId;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterLocation = undefined;
      this._clusterName = undefined;
      this._clusterProjectId = undefined;
      this._serviceAccountRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterLocation = value.clusterLocation;
      this._clusterName = value.clusterName;
      this._clusterProjectId = value.clusterProjectId;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
    }
  }

  // cluster_location - computed: false, optional: false, required: true
  private _clusterLocation?: string; 
  public get clusterLocation() {
    return this.getStringAttribute('cluster_location');
  }
  public set clusterLocation(value: string) {
    this._clusterLocation = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterLocationInput() {
    return this._clusterLocation;
  }

  // cluster_name - computed: false, optional: false, required: true
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // cluster_project_id - computed: false, optional: true, required: false
  private _clusterProjectId?: string; 
  public get clusterProjectId() {
    return this.getStringAttribute('cluster_project_id');
  }
  public set clusterProjectId(value: string) {
    this._clusterProjectId = value;
  }
  public resetClusterProjectId() {
    this._clusterProjectId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterProjectIdInput() {
    return this._clusterProjectId;
  }

  // service_account_ref - computed: false, optional: false, required: true
  private _serviceAccountRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#workload_identity DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#workload_identity}
  */
  readonly workloadIdentity?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefToTerraform(struct!.secretRef),
    workload_identity: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityToTerraform(struct!.workloadIdentity),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef",
    },
    workload_identity: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityToHclTerraform(struct!.workloadIdentity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._workloadIdentity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.workloadIdentity = this._workloadIdentity?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._workloadIdentity.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._workloadIdentity.internalValue = value.workloadIdentity;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // workload_identity - computed: false, optional: true, required: false
  private _workloadIdentity = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityOutputReference(this, "workload_identity");
  public get workloadIdentity() {
    return this._workloadIdentity;
  }
  public putWorkloadIdentity(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity) {
    this._workloadIdentity.internalValue = value;
  }
  public resetWorkloadIdentity() {
    this._workloadIdentity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workloadIdentityInput() {
    return this._workloadIdentity.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsm {
  /**
  * Auth defines the information necessary to authenticate against GCP
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth;
  /**
  * Location optionally defines a location for a secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#location DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#location}
  */
  readonly location?: string;
  /**
  * ProjectID project where secret is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#project_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#project_id}
  */
  readonly projectId?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthToTerraform(struct!.auth),
    location: cdktf.stringToTerraform(struct!.location),
    project_id: cdktf.stringToTerraform(struct!.projectId),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth",
    },
    location: {
      value: cdktf.stringToHclTerraform(struct!.location),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._location !== undefined) {
      hasAnyValues = true;
      internalValueResult.location = this._location;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._location = undefined;
      this._projectId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._location = value.location;
      this._projectId = value.projectId;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // location - computed: false, optional: true, required: false
  private _location?: string; 
  public get location() {
    return this.getStringAttribute('location');
  }
  public set location(value: string) {
    this._location = value;
  }
  public resetLocation() {
    this._location = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationInput() {
    return this._location;
  }

  // project_id - computed: false, optional: true, required: false
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  public resetProjectId() {
    this._projectId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessTokenToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessTokenToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef {
  /**
  * AccessToken is used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#access_token DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#access_token}
  */
  readonly accessToken?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessTokenToTerraform(struct!.accessToken),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessTokenToHclTerraform(struct!.accessToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = value.accessToken;
    }
  }

  // access_token - computed: false, optional: true, required: false
  private _accessToken = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessTokenOutputReference(this, "access_token");
  public get accessToken() {
    return this._accessToken;
  }
  public putAccessToken(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken) {
    this._accessToken.internalValue = value;
  }
  public resetAccessToken() {
    this._accessToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlab {
  /**
  * Auth configures how secret-manager authenticates with a GitLab instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuth;
  /**
  * Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#environment DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#environment}
  */
  readonly environment?: string;
  /**
  * GroupIDs specify, which gitlab groups to pull secrets from. Group secrets are read from left to right followed by the project variables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#group_i_ds DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#group_i_ds}
  */
  readonly groupIDs?: string[];
  /**
  * InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#inherit_from_groups DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#inherit_from_groups}
  */
  readonly inheritFromGroups?: boolean | cdktf.IResolvable;
  /**
  * ProjectID specifies a project where secrets are located.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#project_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#project_id}
  */
  readonly projectId?: string;
  /**
  * URL configures the GitLab instance URL. Defaults to https://gitlab.com/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlab | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthToTerraform(struct!.auth),
    environment: cdktf.stringToTerraform(struct!.environment),
    group_i_ds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupIDs),
    inherit_from_groups: cdktf.booleanToTerraform(struct!.inheritFromGroups),
    project_id: cdktf.stringToTerraform(struct!.projectId),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlab | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuth",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_i_ds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupIDs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    inherit_from_groups: {
      value: cdktf.booleanToHclTerraform(struct!.inheritFromGroups),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlab | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._groupIDs !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupIDs = this._groupIDs;
    }
    if (this._inheritFromGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.inheritFromGroups = this._inheritFromGroups;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlab | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._environment = undefined;
      this._groupIDs = undefined;
      this._inheritFromGroups = undefined;
      this._projectId = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._environment = value.environment;
      this._groupIDs = value.groupIDs;
      this._inheritFromGroups = value.inheritFromGroups;
      this._projectId = value.projectId;
      this._url = value.url;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderGitlabAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // group_i_ds - computed: false, optional: true, required: false
  private _groupIDs?: string[]; 
  public get groupIDs() {
    return this.getListAttribute('group_i_ds');
  }
  public set groupIDs(value: string[]) {
    this._groupIDs = value;
  }
  public resetGroupIDs() {
    this._groupIDs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupIDsInput() {
    return this._groupIDs;
  }

  // inherit_from_groups - computed: false, optional: true, required: false
  private _inheritFromGroups?: boolean | cdktf.IResolvable; 
  public get inheritFromGroups() {
    return this.getBooleanAttribute('inherit_from_groups');
  }
  public set inheritFromGroups(value: boolean | cdktf.IResolvable) {
    this._inheritFromGroups = value;
  }
  public resetInheritFromGroups() {
    this._inheritFromGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inheritFromGroupsInput() {
    return this._inheritFromGroups;
  }

  // project_id - computed: false, optional: true, required: false
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  public resetProjectId() {
    this._projectId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#iam_endpoint DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#iam_endpoint}
  */
  readonly iamEndpoint?: string;
  /**
  * the IBM Trusted Profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#profile DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#profile}
  */
  readonly profile: string;
  /**
  * Location the token is mounted on the pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#token_location DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#token_location}
  */
  readonly tokenLocation?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    iam_endpoint: cdktf.stringToTerraform(struct!.iamEndpoint),
    profile: cdktf.stringToTerraform(struct!.profile),
    token_location: cdktf.stringToTerraform(struct!.tokenLocation),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    iam_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.iamEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_location: {
      value: cdktf.stringToHclTerraform(struct!.tokenLocation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._iamEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.iamEndpoint = this._iamEndpoint;
    }
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    if (this._tokenLocation !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenLocation = this._tokenLocation;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._iamEndpoint = undefined;
      this._profile = undefined;
      this._tokenLocation = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._iamEndpoint = value.iamEndpoint;
      this._profile = value.profile;
      this._tokenLocation = value.tokenLocation;
    }
  }

  // iam_endpoint - computed: false, optional: true, required: false
  private _iamEndpoint?: string; 
  public get iamEndpoint() {
    return this.getStringAttribute('iam_endpoint');
  }
  public set iamEndpoint(value: string) {
    this._iamEndpoint = value;
  }
  public resetIamEndpoint() {
    this._iamEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iamEndpointInput() {
    return this._iamEndpoint;
  }

  // profile - computed: false, optional: false, required: true
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }

  // token_location - computed: false, optional: true, required: false
  private _tokenLocation?: string; 
  public get tokenLocation() {
    return this.getStringAttribute('token_location');
  }
  public set tokenLocation(value: string) {
    this._tokenLocation = value;
  }
  public resetTokenLocation() {
    this._tokenLocation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenLocationInput() {
    return this._tokenLocation;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef {
  /**
  * The SecretAccessKey is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_api_key_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_api_key_secret_ref}
  */
  readonly secretApiKeySecretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_api_key_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRefToTerraform(struct!.secretApiKeySecretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_api_key_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRefToHclTerraform(struct!.secretApiKeySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretApiKeySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretApiKeySecretRef = this._secretApiKeySecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretApiKeySecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretApiKeySecretRef.internalValue = value.secretApiKeySecretRef;
    }
  }

  // secret_api_key_secret_ref - computed: false, optional: true, required: false
  private _secretApiKeySecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRefOutputReference(this, "secret_api_key_secret_ref");
  public get secretApiKeySecretRef() {
    return this._secretApiKeySecretRef;
  }
  public putSecretApiKeySecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef) {
    this._secretApiKeySecretRef.internalValue = value;
  }
  public resetSecretApiKeySecretRef() {
    this._secretApiKeySecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretApiKeySecretRefInput() {
    return this._secretApiKeySecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuth {
  /**
  * IBM Container-based auth with IAM Trusted Profile.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#container_auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#container_auth}
  */
  readonly containerAuth?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuthToTerraform(struct!.containerAuth),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuthToHclTerraform(struct!.containerAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerAuth = this._containerAuth?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerAuth.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerAuth.internalValue = value.containerAuth;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // container_auth - computed: false, optional: true, required: false
  private _containerAuth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuthOutputReference(this, "container_auth");
  public get containerAuth() {
    return this._containerAuth;
  }
  public putContainerAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth) {
    this._containerAuth.internalValue = value;
  }
  public resetContainerAuth() {
    this._containerAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerAuthInput() {
    return this._containerAuth.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbm {
  /**
  * Auth configures how secret-manager authenticates with the IBM secrets manager.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuth;
  /**
  * ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service_url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service_url}
  */
  readonly serviceUrl?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthToTerraform(struct!.auth),
    service_url: cdktf.stringToTerraform(struct!.serviceUrl),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuth",
    },
    service_url: {
      value: cdktf.stringToHclTerraform(struct!.serviceUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._serviceUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceUrl = this._serviceUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._serviceUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._serviceUrl = value.serviceUrl;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderIbmAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // service_url - computed: false, optional: true, required: false
  private _serviceUrl?: string; 
  public get serviceUrl() {
    return this.getStringAttribute('service_url');
  }
  public set serviceUrl(value: string) {
    this._serviceUrl = value;
  }
  public resetServiceUrl() {
    this._serviceUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceUrlInput() {
    return this._serviceUrl;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientIdToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientIdToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecretToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecretToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials {
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_id}
  */
  readonly clientId: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_secret DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_secret}
  */
  readonly clientSecret: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientIdToTerraform(struct!.clientId),
    client_secret: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecretToTerraform(struct!.clientSecret),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientIdToHclTerraform(struct!.clientId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId",
    },
    client_secret: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecretToHclTerraform(struct!.clientSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId?.internalValue;
    }
    if (this._clientSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientId.internalValue = undefined;
      this._clientSecret.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientId.internalValue = value.clientId;
      this._clientSecret.internalValue = value.clientSecret;
    }
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientIdOutputReference(this, "client_id");
  public get clientId() {
    return this._clientId;
  }
  public putClientId(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId) {
    this._clientId.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId.internalValue;
  }

  // client_secret - computed: false, optional: false, required: true
  private _clientSecret = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecretOutputReference(this, "client_secret");
  public get clientSecret() {
    return this._clientSecret;
  }
  public putClientSecret(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret) {
    this._clientSecret.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#universal_auth_credentials DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#universal_auth_credentials}
  */
  readonly universalAuthCredentials?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    universal_auth_credentials: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsToTerraform(struct!.universalAuthCredentials),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    universal_auth_credentials: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsToHclTerraform(struct!.universalAuthCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._universalAuthCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.universalAuthCredentials = this._universalAuthCredentials?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._universalAuthCredentials.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._universalAuthCredentials.internalValue = value.universalAuthCredentials;
    }
  }

  // universal_auth_credentials - computed: false, optional: true, required: false
  private _universalAuthCredentials = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsOutputReference(this, "universal_auth_credentials");
  public get universalAuthCredentials() {
    return this._universalAuthCredentials;
  }
  public putUniversalAuthCredentials(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials) {
    this._universalAuthCredentials.internalValue = value;
  }
  public resetUniversalAuthCredentials() {
    this._universalAuthCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get universalAuthCredentialsInput() {
    return this._universalAuthCredentials.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#environment_slug DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#environment_slug}
  */
  readonly environmentSlug: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#project_slug DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#project_slug}
  */
  readonly projectSlug: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#recursive DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#recursive}
  */
  readonly recursive?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secrets_path DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secrets_path}
  */
  readonly secretsPath?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScopeToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    environment_slug: cdktf.stringToTerraform(struct!.environmentSlug),
    project_slug: cdktf.stringToTerraform(struct!.projectSlug),
    recursive: cdktf.booleanToTerraform(struct!.recursive),
    secrets_path: cdktf.stringToTerraform(struct!.secretsPath),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScopeToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    environment_slug: {
      value: cdktf.stringToHclTerraform(struct!.environmentSlug),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project_slug: {
      value: cdktf.stringToHclTerraform(struct!.projectSlug),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    recursive: {
      value: cdktf.booleanToHclTerraform(struct!.recursive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secrets_path: {
      value: cdktf.stringToHclTerraform(struct!.secretsPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScopeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._environmentSlug !== undefined) {
      hasAnyValues = true;
      internalValueResult.environmentSlug = this._environmentSlug;
    }
    if (this._projectSlug !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectSlug = this._projectSlug;
    }
    if (this._recursive !== undefined) {
      hasAnyValues = true;
      internalValueResult.recursive = this._recursive;
    }
    if (this._secretsPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretsPath = this._secretsPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._environmentSlug = undefined;
      this._projectSlug = undefined;
      this._recursive = undefined;
      this._secretsPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._environmentSlug = value.environmentSlug;
      this._projectSlug = value.projectSlug;
      this._recursive = value.recursive;
      this._secretsPath = value.secretsPath;
    }
  }

  // environment_slug - computed: false, optional: false, required: true
  private _environmentSlug?: string; 
  public get environmentSlug() {
    return this.getStringAttribute('environment_slug');
  }
  public set environmentSlug(value: string) {
    this._environmentSlug = value;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentSlugInput() {
    return this._environmentSlug;
  }

  // project_slug - computed: false, optional: false, required: true
  private _projectSlug?: string; 
  public get projectSlug() {
    return this.getStringAttribute('project_slug');
  }
  public set projectSlug(value: string) {
    this._projectSlug = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectSlugInput() {
    return this._projectSlug;
  }

  // recursive - computed: false, optional: true, required: false
  private _recursive?: boolean | cdktf.IResolvable; 
  public get recursive() {
    return this.getBooleanAttribute('recursive');
  }
  public set recursive(value: boolean | cdktf.IResolvable) {
    this._recursive = value;
  }
  public resetRecursive() {
    this._recursive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recursiveInput() {
    return this._recursive;
  }

  // secrets_path - computed: false, optional: true, required: false
  private _secretsPath?: string; 
  public get secretsPath() {
    return this.getStringAttribute('secrets_path');
  }
  public set secretsPath(value: string) {
    this._secretsPath = value;
  }
  public resetSecretsPath() {
    this._secretsPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsPathInput() {
    return this._secretsPath;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisical {
  /**
  * Auth configures how the Operator authenticates with the Infisical API
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#host_api DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#host_api}
  */
  readonly hostApi?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secrets_scope DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secrets_scope}
  */
  readonly secretsScope: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisical | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthToTerraform(struct!.auth),
    host_api: cdktf.stringToTerraform(struct!.hostApi),
    secrets_scope: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScopeToTerraform(struct!.secretsScope),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisical | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth",
    },
    host_api: {
      value: cdktf.stringToHclTerraform(struct!.hostApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secrets_scope: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScopeToHclTerraform(struct!.secretsScope),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisical | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._hostApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostApi = this._hostApi;
    }
    if (this._secretsScope?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretsScope = this._secretsScope?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisical | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._hostApi = undefined;
      this._secretsScope.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._hostApi = value.hostApi;
      this._secretsScope.internalValue = value.secretsScope;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // host_api - computed: false, optional: true, required: false
  private _hostApi?: string; 
  public get hostApi() {
    return this.getStringAttribute('host_api');
  }
  public set hostApi(value: string) {
    this._hostApi = value;
  }
  public resetHostApi() {
    this._hostApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostApiInput() {
    return this._hostApi;
  }

  // secrets_scope - computed: false, optional: false, required: true
  private _secretsScope = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScopeOutputReference(this, "secrets_scope");
  public get secretsScope() {
    return this._secretsScope;
  }
  public putSecretsScope(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope) {
    this._secretsScope.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsScopeInput() {
    return this._secretsScope.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurity {
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth_ref}
  */
  readonly authRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#folder_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#folder_id}
  */
  readonly folderId: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRefToTerraform(struct!.authRef),
    folder_id: cdktf.stringToTerraform(struct!.folderId),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRefToHclTerraform(struct!.authRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef",
    },
    folder_id: {
      value: cdktf.stringToHclTerraform(struct!.folderId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authRef = this._authRef?.internalValue;
    }
    if (this._folderId !== undefined) {
      hasAnyValues = true;
      internalValueResult.folderId = this._folderId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authRef.internalValue = undefined;
      this._folderId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authRef.internalValue = value.authRef;
      this._folderId = value.folderId;
    }
  }

  // auth_ref - computed: false, optional: false, required: true
  private _authRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRefOutputReference(this, "auth_ref");
  public get authRef() {
    return this._authRef;
  }
  public putAuthRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef) {
    this._authRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authRefInput() {
    return this._authRef.internalValue;
  }

  // folder_id - computed: false, optional: false, required: true
  private _folderId?: string; 
  public get folderId() {
    return this.getStringAttribute('folder_id');
  }
  public set folderId(value: string) {
    this._folderId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get folderIdInput() {
    return this._folderId;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCertToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCertToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKeyToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKeyToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert {
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_cert DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_cert}
  */
  readonly clientCert?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_key}
  */
  readonly clientKey?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_cert: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCertToTerraform(struct!.clientCert),
    client_key: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKeyToTerraform(struct!.clientKey),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_cert: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCertToHclTerraform(struct!.clientCert),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert",
    },
    client_key: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKeyToHclTerraform(struct!.clientKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientCert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCert = this._clientCert?.internalValue;
    }
    if (this._clientKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientKey = this._clientKey?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientCert.internalValue = undefined;
      this._clientKey.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientCert.internalValue = value.clientCert;
      this._clientKey.internalValue = value.clientKey;
    }
  }

  // client_cert - computed: false, optional: true, required: false
  private _clientCert = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCertOutputReference(this, "client_cert");
  public get clientCert() {
    return this._clientCert;
  }
  public putClientCert(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert) {
    this._clientCert.internalValue = value;
  }
  public resetClientCert() {
    this._clientCert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertInput() {
    return this._clientCert.internalValue;
  }

  // client_key - computed: false, optional: true, required: false
  private _clientKey = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKeyOutputReference(this, "client_key");
  public get clientKey() {
    return this._clientKey;
  }
  public putClientKey(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey) {
    this._clientKey.internalValue = value;
  }
  public resetClientKey() {
    this._clientKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientKeyInput() {
    return this._clientKey.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccountToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccountToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerTokenToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerTokenToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken {
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#bearer_token DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#bearer_token}
  */
  readonly bearerToken?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerTokenToTerraform(struct!.bearerToken),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerTokenToHclTerraform(struct!.bearerToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bearerToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bearerToken.internalValue = value.bearerToken;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerTokenOutputReference(this, "bearer_token");
  public get bearerToken() {
    return this._bearerToken;
  }
  public putBearerToken(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken) {
    this._bearerToken.internalValue = value;
  }
  public resetBearerToken() {
    this._bearerToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth {
  /**
  * has both clientCert and clientKey as secretKeySelector
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#cert DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#cert}
  */
  readonly cert?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert;
  /**
  * points to a service account that should be used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service_account DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount;
  /**
  * use static token to authenticate with
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#token DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#token}
  */
  readonly token?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cert: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertToTerraform(struct!.cert),
    service_account: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccountToTerraform(struct!.serviceAccount),
    token: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenToTerraform(struct!.token),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cert: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertToHclTerraform(struct!.cert),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert",
    },
    service_account: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount",
    },
    token: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenToHclTerraform(struct!.token),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cert = this._cert?.internalValue;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    if (this._token?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cert.internalValue = undefined;
      this._serviceAccount.internalValue = undefined;
      this._token.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cert.internalValue = value.cert;
      this._serviceAccount.internalValue = value.serviceAccount;
      this._token.internalValue = value.token;
    }
  }

  // cert - computed: false, optional: true, required: false
  private _cert = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertOutputReference(this, "cert");
  public get cert() {
    return this._cert;
  }
  public putCert(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert) {
    this._cert.internalValue = value;
  }
  public resetCert() {
    this._cert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certInput() {
    return this._cert.internalValue;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenOutputReference(this, "token");
  public get token() {
    return this._token;
  }
  public putToken(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken) {
    this._token.internalValue = value;
  }
  public resetToken() {
    this._token.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider {
  /**
  * The key where the CA certificate can be found in the Secret or ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the object located at the provider type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * The type of provider to use such as 'Secret', or 'ConfigMap'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#type DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProviderToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProviderToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServer {
  /**
  * CABundle is a base64-encoded CA certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#ca_bundle DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#ca_provider DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#ca_provider}
  */
  readonly caProvider?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider;
  /**
  * configures the Kubernetes server Address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    ca_provider: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProviderToTerraform(struct!.caProvider),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_provider: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProviderToHclTerraform(struct!.caProvider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._caProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caProvider = this._caProvider?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caBundle = undefined;
      this._caProvider.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caBundle = value.caBundle;
      this._caProvider.internalValue = value.caProvider;
      this._url = value.url;
    }
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // ca_provider - computed: false, optional: true, required: false
  private _caProvider = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProviderOutputReference(this, "ca_provider");
  public get caProvider() {
    return this._caProvider;
  }
  public putCaProvider(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider) {
    this._caProvider.internalValue = value;
  }
  public resetCaProvider() {
    this._caProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caProviderInput() {
    return this._caProvider.internalValue;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetes {
  /**
  * Auth configures how secret-manager authenticates with a Kubernetes instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth;
  /**
  * A reference to a secret that contains the auth information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth_ref}
  */
  readonly authRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef;
  /**
  * Remote namespace to fetch the secrets from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#remote_namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#remote_namespace}
  */
  readonly remoteNamespace?: string;
  /**
  * configures the Kubernetes server Address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#server DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#server}
  */
  readonly server?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServer;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToTerraform(struct!.auth),
    auth_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRefToTerraform(struct!.authRef),
    remote_namespace: cdktf.stringToTerraform(struct!.remoteNamespace),
    server: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerToTerraform(struct!.server),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth",
    },
    auth_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRefToHclTerraform(struct!.authRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef",
    },
    remote_namespace: {
      value: cdktf.stringToHclTerraform(struct!.remoteNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerToHclTerraform(struct!.server),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServer",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._authRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authRef = this._authRef?.internalValue;
    }
    if (this._remoteNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteNamespace = this._remoteNamespace;
    }
    if (this._server?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._authRef.internalValue = undefined;
      this._remoteNamespace = undefined;
      this._server.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._authRef.internalValue = value.authRef;
      this._remoteNamespace = value.remoteNamespace;
      this._server.internalValue = value.server;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // auth_ref - computed: false, optional: true, required: false
  private _authRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRefOutputReference(this, "auth_ref");
  public get authRef() {
    return this._authRef;
  }
  public putAuthRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef) {
    this._authRef.internalValue = value;
  }
  public resetAuthRef() {
    this._authRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authRefInput() {
    return this._authRef.internalValue;
  }

  // remote_namespace - computed: false, optional: true, required: false
  private _remoteNamespace?: string; 
  public get remoteNamespace() {
    return this.getStringAttribute('remote_namespace');
  }
  public set remoteNamespace(value: string) {
    this._remoteNamespace = value;
  }
  public resetRemoteNamespace() {
    this._remoteNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteNamespaceInput() {
    return this._remoteNamespace;
  }

  // server - computed: false, optional: true, required: false
  private _server = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServerOutputReference(this, "server");
  public get server() {
    return this._server;
  }
  public putServer(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderKubernetesServer) {
    this._server.internalValue = value;
  }
  public resetServer() {
    this._server.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth {
  /**
  * OnboardbaseAPIKey is the APIKey generated by an admin account. It is used to recognize and authorize access to a project and environment within onboardbase
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#api_key_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#api_key_ref}
  */
  readonly apiKeyRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef;
  /**
  * OnboardbasePasscode is the passcode attached to the API Key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#passcode_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#passcode_ref}
  */
  readonly passcodeRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_key_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRefToTerraform(struct!.apiKeyRef),
    passcode_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRefToTerraform(struct!.passcodeRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_key_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRefToHclTerraform(struct!.apiKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef",
    },
    passcode_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRefToHclTerraform(struct!.passcodeRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKeyRef = this._apiKeyRef?.internalValue;
    }
    if (this._passcodeRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passcodeRef = this._passcodeRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiKeyRef.internalValue = undefined;
      this._passcodeRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiKeyRef.internalValue = value.apiKeyRef;
      this._passcodeRef.internalValue = value.passcodeRef;
    }
  }

  // api_key_ref - computed: false, optional: false, required: true
  private _apiKeyRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRefOutputReference(this, "api_key_ref");
  public get apiKeyRef() {
    return this._apiKeyRef;
  }
  public putApiKeyRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef) {
    this._apiKeyRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyRefInput() {
    return this._apiKeyRef.internalValue;
  }

  // passcode_ref - computed: false, optional: false, required: true
  private _passcodeRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRefOutputReference(this, "passcode_ref");
  public get passcodeRef() {
    return this._passcodeRef;
  }
  public putPasscodeRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef) {
    this._passcodeRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get passcodeRefInput() {
    return this._passcodeRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbase {
  /**
  * APIHost use this to configure the host url for the API for selfhosted installation, default is https://public.onboardbase.com/api/v1/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#api_host DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#api_host}
  */
  readonly apiHost: string;
  /**
  * Auth configures how the Operator authenticates with the Onboardbase API
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth;
  /**
  * Environment is the name of an environmnent within a project to pull the secrets from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#environment DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#environment}
  */
  readonly environment: string;
  /**
  * Project is an onboardbase project that the secrets should be pulled from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#project DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#project}
  */
  readonly project: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbase | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_host: cdktf.stringToTerraform(struct!.apiHost),
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthToTerraform(struct!.auth),
    environment: cdktf.stringToTerraform(struct!.environment),
    project: cdktf.stringToTerraform(struct!.project),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbase | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_host: {
      value: cdktf.stringToHclTerraform(struct!.apiHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project: {
      value: cdktf.stringToHclTerraform(struct!.project),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbase | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiHost = this._apiHost;
    }
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._project !== undefined) {
      hasAnyValues = true;
      internalValueResult.project = this._project;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbase | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiHost = undefined;
      this._auth.internalValue = undefined;
      this._environment = undefined;
      this._project = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiHost = value.apiHost;
      this._auth.internalValue = value.auth;
      this._environment = value.environment;
      this._project = value.project;
    }
  }

  // api_host - computed: false, optional: false, required: true
  private _apiHost?: string; 
  public get apiHost() {
    return this.getStringAttribute('api_host');
  }
  public set apiHost(value: string) {
    this._apiHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiHostInput() {
    return this._apiHost;
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // environment - computed: false, optional: false, required: true
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // project - computed: false, optional: false, required: true
  private _project?: string; 
  public get project() {
    return this.getStringAttribute('project');
  }
  public set project(value: string) {
    this._project = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectInput() {
    return this._project;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef {
  /**
  * The ConnectToken is used for authentication to a 1Password Connect Server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#connect_token_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#connect_token_secret_ref}
  */
  readonly connectTokenSecretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_token_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRefToTerraform(struct!.connectTokenSecretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_token_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRefToHclTerraform(struct!.connectTokenSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTokenSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTokenSecretRef = this._connectTokenSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTokenSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTokenSecretRef.internalValue = value.connectTokenSecretRef;
    }
  }

  // connect_token_secret_ref - computed: false, optional: false, required: true
  private _connectTokenSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRefOutputReference(this, "connect_token_secret_ref");
  public get connectTokenSecretRef() {
    return this._connectTokenSecretRef;
  }
  public putConnectTokenSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef) {
    this._connectTokenSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTokenSecretRefInput() {
    return this._connectTokenSecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth {
  /**
  * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepassword {
  /**
  * Auth defines the information necessary to authenticate against OnePassword Connect Server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth;
  /**
  * ConnectHost defines the OnePassword Connect Server to connect to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#connect_host DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#connect_host}
  */
  readonly connectHost: string;
  /**
  * Vaults defines which OnePassword vaults to search in which order
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#vaults DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#vaults}
  */
  readonly vaults: { [key: string]: string };
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthToTerraform(struct!.auth),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    vaults: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.vaults),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vaults: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.vaults),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._vaults !== undefined) {
      hasAnyValues = true;
      internalValueResult.vaults = this._vaults;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectHost = undefined;
      this._vaults = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectHost = value.connectHost;
      this._vaults = value.vaults;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // vaults - computed: false, optional: false, required: true
  private _vaults?: { [key: string]: string }; 
  public get vaults() {
    return this.getStringMapAttribute('vaults');
  }
  public set vaults(value: { [key: string]: string }) {
    this._vaults = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vaultsInput() {
    return this._vaults;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprintToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprintToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprintOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekeyToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekeyToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef {
  /**
  * Fingerprint is the fingerprint of the API private key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#fingerprint DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#fingerprint}
  */
  readonly fingerprint: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint;
  /**
  * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#privatekey DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#privatekey}
  */
  readonly privatekey: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fingerprint: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprintToTerraform(struct!.fingerprint),
    privatekey: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekeyToTerraform(struct!.privatekey),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fingerprint: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprintToHclTerraform(struct!.fingerprint),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint",
    },
    privatekey: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekeyToHclTerraform(struct!.privatekey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fingerprint?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fingerprint = this._fingerprint?.internalValue;
    }
    if (this._privatekey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.privatekey = this._privatekey?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fingerprint.internalValue = undefined;
      this._privatekey.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fingerprint.internalValue = value.fingerprint;
      this._privatekey.internalValue = value.privatekey;
    }
  }

  // fingerprint - computed: false, optional: false, required: true
  private _fingerprint = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprintOutputReference(this, "fingerprint");
  public get fingerprint() {
    return this._fingerprint;
  }
  public putFingerprint(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint) {
    this._fingerprint.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fingerprintInput() {
    return this._fingerprint.internalValue;
  }

  // privatekey - computed: false, optional: false, required: true
  private _privatekey = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekeyOutputReference(this, "privatekey");
  public get privatekey() {
    return this._privatekey;
  }
  public putPrivatekey(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey) {
    this._privatekey.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get privatekeyInput() {
    return this._privatekey.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuth {
  /**
  * SecretRef to pass through sensitive information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef;
  /**
  * Tenancy is the tenancy OCID where user is located.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#tenancy DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#tenancy}
  */
  readonly tenancy: string;
  /**
  * User is an access OCID specific to the account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#user DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#user}
  */
  readonly user: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefToTerraform(struct!.secretRef),
    tenancy: cdktf.stringToTerraform(struct!.tenancy),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef",
    },
    tenancy: {
      value: cdktf.stringToHclTerraform(struct!.tenancy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._tenancy !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenancy = this._tenancy;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._tenancy = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._tenancy = value.tenancy;
      this._user = value.user;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // tenancy - computed: false, optional: false, required: true
  private _tenancy?: string; 
  public get tenancy() {
    return this.getStringAttribute('tenancy');
  }
  public set tenancy(value: string) {
    this._tenancy = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenancyInput() {
    return this._tenancy;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracle {
  /**
  * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuth;
  /**
  * Compartment is the vault compartment OCID. Required for PushSecret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#compartment DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#compartment}
  */
  readonly compartment?: string;
  /**
  * EncryptionKey is the OCID of the encryption key within the vault. Required for PushSecret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#encryption_key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#encryption_key}
  */
  readonly encryptionKey?: string;
  /**
  * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#principal_type DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#principal_type}
  */
  readonly principalType?: string;
  /**
  * Region is the region where vault is located.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#region DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#region}
  */
  readonly region: string;
  /**
  * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef;
  /**
  * Vault is the vault's OCID of the specific vault where secret is located.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#vault DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#vault}
  */
  readonly vault: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracle | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthToTerraform(struct!.auth),
    compartment: cdktf.stringToTerraform(struct!.compartment),
    encryption_key: cdktf.stringToTerraform(struct!.encryptionKey),
    principal_type: cdktf.stringToTerraform(struct!.principalType),
    region: cdktf.stringToTerraform(struct!.region),
    service_account_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRefToTerraform(struct!.serviceAccountRef),
    vault: cdktf.stringToTerraform(struct!.vault),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracle | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuth",
    },
    compartment: {
      value: cdktf.stringToHclTerraform(struct!.compartment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    encryption_key: {
      value: cdktf.stringToHclTerraform(struct!.encryptionKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    principal_type: {
      value: cdktf.stringToHclTerraform(struct!.principalType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef",
    },
    vault: {
      value: cdktf.stringToHclTerraform(struct!.vault),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracle | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._compartment !== undefined) {
      hasAnyValues = true;
      internalValueResult.compartment = this._compartment;
    }
    if (this._encryptionKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptionKey = this._encryptionKey;
    }
    if (this._principalType !== undefined) {
      hasAnyValues = true;
      internalValueResult.principalType = this._principalType;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    if (this._vault !== undefined) {
      hasAnyValues = true;
      internalValueResult.vault = this._vault;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracle | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._compartment = undefined;
      this._encryptionKey = undefined;
      this._principalType = undefined;
      this._region = undefined;
      this._serviceAccountRef.internalValue = undefined;
      this._vault = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._compartment = value.compartment;
      this._encryptionKey = value.encryptionKey;
      this._principalType = value.principalType;
      this._region = value.region;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
      this._vault = value.vault;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // compartment - computed: false, optional: true, required: false
  private _compartment?: string; 
  public get compartment() {
    return this.getStringAttribute('compartment');
  }
  public set compartment(value: string) {
    this._compartment = value;
  }
  public resetCompartment() {
    this._compartment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compartmentInput() {
    return this._compartment;
  }

  // encryption_key - computed: false, optional: true, required: false
  private _encryptionKey?: string; 
  public get encryptionKey() {
    return this.getStringAttribute('encryption_key');
  }
  public set encryptionKey(value: string) {
    this._encryptionKey = value;
  }
  public resetEncryptionKey() {
    this._encryptionKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionKeyInput() {
    return this._encryptionKey;
  }

  // principal_type - computed: false, optional: true, required: false
  private _principalType?: string; 
  public get principalType() {
    return this.getStringAttribute('principal_type');
  }
  public set principalType(value: string) {
    this._principalType = value;
  }
  public resetPrincipalType() {
    this._principalType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get principalTypeInput() {
    return this._principalType;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }

  // vault - computed: false, optional: false, required: true
  private _vault?: string; 
  public get vault() {
    return this.getStringAttribute('vault');
  }
  public set vault(value: string) {
    this._vault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vaultInput() {
    return this._vault;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuth {
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#password_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#password_secret_ref}
  */
  readonly passwordSecretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#private_key_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#private_key_secret_ref}
  */
  readonly privateKeySecretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRefToTerraform(struct!.passwordSecretRef),
    private_key_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRefToTerraform(struct!.privateKeySecretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRefToHclTerraform(struct!.passwordSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef",
    },
    private_key_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRefToHclTerraform(struct!.privateKeySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._passwordSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwordSecretRef = this._passwordSecretRef?.internalValue;
    }
    if (this._privateKeySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKeySecretRef = this._privateKeySecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._passwordSecretRef.internalValue = undefined;
      this._privateKeySecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._passwordSecretRef.internalValue = value.passwordSecretRef;
      this._privateKeySecretRef.internalValue = value.privateKeySecretRef;
    }
  }

  // password_secret_ref - computed: false, optional: false, required: true
  private _passwordSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRefOutputReference(this, "password_secret_ref");
  public get passwordSecretRef() {
    return this._passwordSecretRef;
  }
  public putPasswordSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef) {
    this._passwordSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordSecretRefInput() {
    return this._passwordSecretRef.internalValue;
  }

  // private_key_secret_ref - computed: false, optional: false, required: true
  private _privateKeySecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRefOutputReference(this, "private_key_secret_ref");
  public get privateKeySecretRef() {
    return this._privateKeySecretRef;
  }
  public putPrivateKeySecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef) {
    this._privateKeySecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeySecretRefInput() {
    return this._privateKeySecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassbolt {
  /**
  * Auth defines the information necessary to authenticate against Passbolt Server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuth;
  /**
  * Host defines the Passbolt Server to connect to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#host DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#host}
  */
  readonly host: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassbolt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthToTerraform(struct!.auth),
    host: cdktf.stringToTerraform(struct!.host),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassbolt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuth",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassbolt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassbolt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._host = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._host = value.host;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassboltAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentialsToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentialsToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef {
  /**
  * Username / Password is used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#credentials DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#credentials}
  */
  readonly credentials?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentialsToTerraform(struct!.credentials),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentials.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentials.internalValue = value.credentials;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepot {
  /**
  * Auth configures how secret-manager authenticates with a Password Depot instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth;
  /**
  * Database to use as source
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#database DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#database}
  */
  readonly database: string;
  /**
  * URL configures the Password Depot instance URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#host DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#host}
  */
  readonly host: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthToTerraform(struct!.auth),
    database: cdktf.stringToTerraform(struct!.database),
    host: cdktf.stringToTerraform(struct!.host),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._database = undefined;
      this._host = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._database = value.database;
      this._host = value.host;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessTokenToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessTokenToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef {
  /**
  * The AccessToken is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#access_token DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#access_token}
  */
  readonly accessToken: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessTokenToTerraform(struct!.accessToken),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessTokenToHclTerraform(struct!.accessToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = value.accessToken;
    }
  }

  // access_token - computed: false, optional: false, required: true
  private _accessToken = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessTokenOutputReference(this, "access_token");
  public get accessToken() {
    return this._accessToken;
  }
  public putAccessToken(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken) {
    this._accessToken.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuth {
  /**
  * PreviderAuthSecretRef holds secret references for Previder Vault credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPrevider {
  /**
  * PreviderAuth contains a secretRef for credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#base_uri DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#base_uri}
  */
  readonly baseUri?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPrevider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthToTerraform(struct!.auth),
    base_uri: cdktf.stringToTerraform(struct!.baseUri),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPrevider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuth",
    },
    base_uri: {
      value: cdktf.stringToHclTerraform(struct!.baseUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPrevider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._baseUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseUri = this._baseUri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPrevider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._baseUri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._baseUri = value.baseUri;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPreviderAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // base_uri - computed: false, optional: true, required: false
  private _baseUri?: string; 
  public get baseUri() {
    return this.getStringAttribute('base_uri');
  }
  public set baseUri(value: string) {
    this._baseUri = value;
  }
  public resetBaseUri() {
    this._baseUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseUriInput() {
    return this._baseUri;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken {
  /**
  * SecretRef is a reference to a secret containing the Pulumi API token.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumi {
  /**
  * AccessToken is the access tokens to sign in to the Pulumi Cloud Console.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#access_token DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#access_token}
  */
  readonly accessToken: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken;
  /**
  * APIURL is the URL of the Pulumi API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#api_url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#api_url}
  */
  readonly apiUrl?: string;
  /**
  * Environment are YAML documents composed of static key-value pairs, programmatic expressions, dynamically retrieved values from supported providers including all major clouds, and other Pulumi ESC environments. To create a new environment, visit https://www.pulumi.com/docs/esc/environments/ for more information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#environment DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#environment}
  */
  readonly environment: string;
  /**
  * Organization are a space to collaborate on shared projects and stacks. To create a new organization, visit https://app.pulumi.com/ and click 'New Organization'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#organization DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#organization}
  */
  readonly organization: string;
  /**
  * Project is the name of the Pulumi ESC project the environment belongs to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#project DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#project}
  */
  readonly project: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenToTerraform(struct!.accessToken),
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    environment: cdktf.stringToTerraform(struct!.environment),
    organization: cdktf.stringToTerraform(struct!.organization),
    project: cdktf.stringToTerraform(struct!.project),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenToHclTerraform(struct!.accessToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken",
    },
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    organization: {
      value: cdktf.stringToHclTerraform(struct!.organization),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project: {
      value: cdktf.stringToHclTerraform(struct!.project),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken?.internalValue;
    }
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._organization !== undefined) {
      hasAnyValues = true;
      internalValueResult.organization = this._organization;
    }
    if (this._project !== undefined) {
      hasAnyValues = true;
      internalValueResult.project = this._project;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = undefined;
      this._apiUrl = undefined;
      this._environment = undefined;
      this._organization = undefined;
      this._project = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = value.accessToken;
      this._apiUrl = value.apiUrl;
      this._environment = value.environment;
      this._organization = value.organization;
      this._project = value.project;
    }
  }

  // access_token - computed: false, optional: false, required: true
  private _accessToken = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenOutputReference(this, "access_token");
  public get accessToken() {
    return this._accessToken;
  }
  public putAccessToken(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken) {
    this._accessToken.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken.internalValue;
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // environment - computed: false, optional: false, required: true
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // organization - computed: false, optional: false, required: true
  private _organization?: string; 
  public get organization() {
    return this.getStringAttribute('organization');
  }
  public set organization(value: string) {
    this._organization = value;
  }
  // Temporarily expose input value. Use with caution.
  public get organizationInput() {
    return this._organization;
  }

  // project - computed: false, optional: false, required: true
  private _project?: string; 
  public get project() {
    return this.getStringAttribute('project');
  }
  public set project(value: string) {
    this._project = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectInput() {
    return this._project;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeyToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeyToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeyToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeyToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScaleway {
  /**
  * AccessKey is the non-secret part of the api key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#access_key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#access_key}
  */
  readonly accessKey: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey;
  /**
  * APIURL is the url of the api to use. Defaults to https://api.scaleway.com
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#api_url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#api_url}
  */
  readonly apiUrl?: string;
  /**
  * ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#project_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#project_id}
  */
  readonly projectId: string;
  /**
  * Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#region DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#region}
  */
  readonly region: string;
  /**
  * SecretKey is the non-secret part of the api key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_key}
  */
  readonly secretKey: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScaleway | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeyToTerraform(struct!.accessKey),
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    project_id: cdktf.stringToTerraform(struct!.projectId),
    region: cdktf.stringToTerraform(struct!.region),
    secret_key: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeyToTerraform(struct!.secretKey),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScaleway | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeyToHclTerraform(struct!.accessKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey",
    },
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_key: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeyToHclTerraform(struct!.secretKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScaleway | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKey = this._accessKey?.internalValue;
    }
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._secretKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKey = this._secretKey?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScaleway | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessKey.internalValue = undefined;
      this._apiUrl = undefined;
      this._projectId = undefined;
      this._region = undefined;
      this._secretKey.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessKey.internalValue = value.accessKey;
      this._apiUrl = value.apiUrl;
      this._projectId = value.projectId;
      this._region = value.region;
      this._secretKey.internalValue = value.secretKey;
    }
  }

  // access_key - computed: false, optional: false, required: true
  private _accessKey = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeyOutputReference(this, "access_key");
  public get accessKey() {
    return this._accessKey;
  }
  public putAccessKey(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey) {
    this._accessKey.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyInput() {
    return this._accessKey.internalValue;
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // project_id - computed: false, optional: false, required: true
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // secret_key - computed: false, optional: false, required: true
  private _secretKey = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeyOutputReference(this, "secret_key");
  public get secretKey() {
    return this._secretKey;
  }
  public putSecretKey(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey) {
    this._secretKey.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyInput() {
    return this._secretKey.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserver {
  /**
  * Password is the secret server account password.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#password DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#password}
  */
  readonly password: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword;
  /**
  * ServerURL URL to your secret server installation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#server_url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#server_url}
  */
  readonly serverUrl: string;
  /**
  * Username is the secret server account username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#username DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#username}
  */
  readonly username: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordToTerraform(struct!.password),
    server_url: cdktf.stringToTerraform(struct!.serverUrl),
    username: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameToTerraform(struct!.username),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordToHclTerraform(struct!.password),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword",
    },
    server_url: {
      value: cdktf.stringToHclTerraform(struct!.serverUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameToHclTerraform(struct!.username),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password?.internalValue;
    }
    if (this._serverUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverUrl = this._serverUrl;
    }
    if (this._username?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._password.internalValue = undefined;
      this._serverUrl = undefined;
      this._username.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._password.internalValue = value.password;
      this._serverUrl = value.serverUrl;
      this._username.internalValue = value.username;
    }
  }

  // password - computed: false, optional: false, required: true
  private _password = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordOutputReference(this, "password");
  public get password() {
    return this._password;
  }
  public putPassword(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword) {
    this._password.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password.internalValue;
  }

  // server_url - computed: false, optional: false, required: true
  private _serverUrl?: string; 
  public get serverUrl() {
    return this.getStringAttribute('server_url');
  }
  public set serverUrl(value: string) {
    this._serverUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serverUrlInput() {
    return this._serverUrl;
  }

  // username - computed: false, optional: false, required: true
  private _username = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameOutputReference(this, "username");
  public get username() {
    return this._username;
  }
  public putUsername(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername) {
    this._username.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_id}
  */
  readonly clientId: string;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_secret_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_secret_secret_ref}
  */
  readonly clientSecretSecretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRefToTerraform(struct!.clientSecretSecretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRefToHclTerraform(struct!.clientSecretSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecretSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecretSecretRef = this._clientSecretSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientId = undefined;
      this._clientSecretSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientId = value.clientId;
      this._clientSecretSecretRef.internalValue = value.clientSecretSecretRef;
    }
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret_secret_ref - computed: false, optional: false, required: true
  private _clientSecretSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRefOutputReference(this, "client_secret_secret_ref");
  public get clientSecretSecretRef() {
    return this._clientSecretSecretRef;
  }
  public putClientSecretSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef) {
    this._clientSecretSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretSecretRefInput() {
    return this._clientSecretSecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhasegura {
  /**
  * Auth defines parameters to authenticate in senhasegura
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth;
  /**
  * IgnoreSslCertificate defines if SSL certificate must be ignored
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#ignore_ssl_certificate DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#ignore_ssl_certificate}
  */
  readonly ignoreSslCertificate?: boolean | cdktf.IResolvable;
  /**
  * Module defines which senhasegura module should be used to get secrets
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#module DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#module}
  */
  readonly module: string;
  /**
  * URL of senhasegura
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#url DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#url}
  */
  readonly url: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhasegura | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthToTerraform(struct!.auth),
    ignore_ssl_certificate: cdktf.booleanToTerraform(struct!.ignoreSslCertificate),
    module: cdktf.stringToTerraform(struct!.module),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhasegura | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth",
    },
    ignore_ssl_certificate: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreSslCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    module: {
      value: cdktf.stringToHclTerraform(struct!.module),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhasegura | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._ignoreSslCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreSslCertificate = this._ignoreSslCertificate;
    }
    if (this._module !== undefined) {
      hasAnyValues = true;
      internalValueResult.module = this._module;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhasegura | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._ignoreSslCertificate = undefined;
      this._module = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._ignoreSslCertificate = value.ignoreSslCertificate;
      this._module = value.module;
      this._url = value.url;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // ignore_ssl_certificate - computed: false, optional: true, required: false
  private _ignoreSslCertificate?: boolean | cdktf.IResolvable; 
  public get ignoreSslCertificate() {
    return this.getBooleanAttribute('ignore_ssl_certificate');
  }
  public set ignoreSslCertificate(value: boolean | cdktf.IResolvable) {
    this._ignoreSslCertificate = value;
  }
  public resetIgnoreSslCertificate() {
    this._ignoreSslCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreSslCertificateInput() {
    return this._ignoreSslCertificate;
  }

  // module - computed: false, optional: false, required: true
  private _module?: string; 
  public get module() {
    return this.getStringAttribute('module');
  }
  public set module(value: string) {
    this._module = value;
  }
  // Temporarily expose input value. Use with caution.
  public get moduleInput() {
    return this._module;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole {
  /**
  * Path where the App Role authentication backend is mounted in Vault, e.g: 'approle'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#path DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#path}
  */
  readonly path: string;
  /**
  * RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#role_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#role_id}
  */
  readonly roleId?: string;
  /**
  * Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault. The 'key' field must be specified and denotes which entry within the Secret resource is used as the app role id.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#role_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#role_ref}
  */
  readonly roleRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef;
  /**
  * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The 'key' field must be specified and denotes which entry within the Secret resource is used as the app role secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    role_id: cdktf.stringToTerraform(struct!.roleId),
    role_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRefToTerraform(struct!.roleRef),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_id: {
      value: cdktf.stringToHclTerraform(struct!.roleId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRefToHclTerraform(struct!.roleRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._roleId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleId = this._roleId;
    }
    if (this._roleRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleRef = this._roleRef?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._roleId = undefined;
      this._roleRef.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._roleId = value.roleId;
      this._roleRef.internalValue = value.roleRef;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // role_id - computed: false, optional: true, required: false
  private _roleId?: string; 
  public get roleId() {
    return this.getStringAttribute('role_id');
  }
  public set roleId(value: string) {
    this._roleId = value;
  }
  public resetRoleId() {
    this._roleId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleIdInput() {
    return this._roleId;
  }

  // role_ref - computed: false, optional: true, required: false
  private _roleRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRefOutputReference(this, "role_ref");
  public get roleRef() {
    return this._roleRef;
  }
  public putRoleRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef) {
    this._roleRef.internalValue = value;
  }
  public resetRoleRef() {
    this._roleRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleRefInput() {
    return this._roleRef.internalValue;
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCertToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCertToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert {
  /**
  * ClientCert is a certificate to authenticate using the Cert Vault authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#client_cert DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#client_cert}
  */
  readonly clientCert?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert;
  /**
  * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_cert: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCertToTerraform(struct!.clientCert),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_cert: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCertToHclTerraform(struct!.clientCert),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientCert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCert = this._clientCert?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientCert.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientCert.internalValue = value.clientCert;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // client_cert - computed: false, optional: true, required: false
  private _clientCert = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCertOutputReference(this, "client_cert");
  public get clientCert() {
    return this._clientCert;
  }
  public putClientCert(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert) {
    this._clientCert.internalValue = value;
  }
  public resetClientCert() {
    this._clientCert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertInput() {
    return this._clientCert.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt {
  /**
  * A reference to a ServiceAccount resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    service_account_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRefToTerraform(struct!.serviceAccountRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    service_account_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._serviceAccountRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
    }
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef {
  /**
  * The AccessKeyID is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#access_key_id_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#access_key_id_secret_ref}
  */
  readonly accessKeyIdSecretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef;
  /**
  * The SecretAccessKey is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_access_key_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_access_key_secret_ref}
  */
  readonly secretAccessKeySecretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef;
  /**
  * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#session_token_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#session_token_secret_ref}
  */
  readonly sessionTokenSecretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key_id_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRefToTerraform(struct!.accessKeyIdSecretRef),
    secret_access_key_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRefToTerraform(struct!.secretAccessKeySecretRef),
    session_token_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRefToTerraform(struct!.sessionTokenSecretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key_id_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRefToHclTerraform(struct!.accessKeyIdSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef",
    },
    secret_access_key_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRefToHclTerraform(struct!.secretAccessKeySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef",
    },
    session_token_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRefToHclTerraform(struct!.sessionTokenSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKeyIdSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKeyIdSecretRef = this._accessKeyIdSecretRef?.internalValue;
    }
    if (this._secretAccessKeySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKeySecretRef = this._secretAccessKeySecretRef?.internalValue;
    }
    if (this._sessionTokenSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionTokenSecretRef = this._sessionTokenSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessKeyIdSecretRef.internalValue = undefined;
      this._secretAccessKeySecretRef.internalValue = undefined;
      this._sessionTokenSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessKeyIdSecretRef.internalValue = value.accessKeyIdSecretRef;
      this._secretAccessKeySecretRef.internalValue = value.secretAccessKeySecretRef;
      this._sessionTokenSecretRef.internalValue = value.sessionTokenSecretRef;
    }
  }

  // access_key_id_secret_ref - computed: false, optional: true, required: false
  private _accessKeyIdSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRefOutputReference(this, "access_key_id_secret_ref");
  public get accessKeyIdSecretRef() {
    return this._accessKeyIdSecretRef;
  }
  public putAccessKeyIdSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef) {
    this._accessKeyIdSecretRef.internalValue = value;
  }
  public resetAccessKeyIdSecretRef() {
    this._accessKeyIdSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyIdSecretRefInput() {
    return this._accessKeyIdSecretRef.internalValue;
  }

  // secret_access_key_secret_ref - computed: false, optional: true, required: false
  private _secretAccessKeySecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRefOutputReference(this, "secret_access_key_secret_ref");
  public get secretAccessKeySecretRef() {
    return this._secretAccessKeySecretRef;
  }
  public putSecretAccessKeySecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef) {
    this._secretAccessKeySecretRef.internalValue = value;
  }
  public resetSecretAccessKeySecretRef() {
    this._secretAccessKeySecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeySecretRefInput() {
    return this._secretAccessKeySecretRef.internalValue;
  }

  // session_token_secret_ref - computed: false, optional: true, required: false
  private _sessionTokenSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRefOutputReference(this, "session_token_secret_ref");
  public get sessionTokenSecretRef() {
    return this._sessionTokenSecretRef;
  }
  public putSessionTokenSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef) {
    this._sessionTokenSecretRef.internalValue = value;
  }
  public resetSessionTokenSecretRef() {
    this._sessionTokenSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTokenSecretRefInput() {
    return this._sessionTokenSecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam {
  /**
  * AWS External ID set on assumed IAM roles
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#external_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#external_id}
  */
  readonly externalId?: string;
  /**
  * Specify a service account with IRSA enabled
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#jwt DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#jwt}
  */
  readonly jwt?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt;
  /**
  * Path where the AWS auth method is enabled in Vault, e.g: 'aws'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#path DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#path}
  */
  readonly path?: string;
  /**
  * AWS region
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#region DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#region}
  */
  readonly region?: string;
  /**
  * This is the AWS role to be assumed before talking to vault
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#role DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#role}
  */
  readonly role?: string;
  /**
  * Specify credentials in a Secret object
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef;
  /**
  * X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: https://developer.hashicorp.com/vault/docs/auth/aws
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#vault_aws_iam_server_id DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#vault_aws_iam_server_id}
  */
  readonly vaultAwsIamServerId?: string;
  /**
  * Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#vault_role DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#vault_role}
  */
  readonly vaultRole: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_id: cdktf.stringToTerraform(struct!.externalId),
    jwt: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtToTerraform(struct!.jwt),
    path: cdktf.stringToTerraform(struct!.path),
    region: cdktf.stringToTerraform(struct!.region),
    role: cdktf.stringToTerraform(struct!.role),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefToTerraform(struct!.secretRef),
    vault_aws_iam_server_id: cdktf.stringToTerraform(struct!.vaultAwsIamServerId),
    vault_role: cdktf.stringToTerraform(struct!.vaultRole),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_id: {
      value: cdktf.stringToHclTerraform(struct!.externalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    jwt: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtToHclTerraform(struct!.jwt),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef",
    },
    vault_aws_iam_server_id: {
      value: cdktf.stringToHclTerraform(struct!.vaultAwsIamServerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vault_role: {
      value: cdktf.stringToHclTerraform(struct!.vaultRole),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalId = this._externalId;
    }
    if (this._jwt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwt = this._jwt?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._vaultAwsIamServerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.vaultAwsIamServerId = this._vaultAwsIamServerId;
    }
    if (this._vaultRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.vaultRole = this._vaultRole;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalId = undefined;
      this._jwt.internalValue = undefined;
      this._path = undefined;
      this._region = undefined;
      this._role = undefined;
      this._secretRef.internalValue = undefined;
      this._vaultAwsIamServerId = undefined;
      this._vaultRole = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalId = value.externalId;
      this._jwt.internalValue = value.jwt;
      this._path = value.path;
      this._region = value.region;
      this._role = value.role;
      this._secretRef.internalValue = value.secretRef;
      this._vaultAwsIamServerId = value.vaultAwsIamServerId;
      this._vaultRole = value.vaultRole;
    }
  }

  // external_id - computed: false, optional: true, required: false
  private _externalId?: string; 
  public get externalId() {
    return this.getStringAttribute('external_id');
  }
  public set externalId(value: string) {
    this._externalId = value;
  }
  public resetExternalId() {
    this._externalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalIdInput() {
    return this._externalId;
  }

  // jwt - computed: false, optional: true, required: false
  private _jwt = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtOutputReference(this, "jwt");
  public get jwt() {
    return this._jwt;
  }
  public putJwt(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt) {
    this._jwt.internalValue = value;
  }
  public resetJwt() {
    this._jwt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwtInput() {
    return this._jwt.internalValue;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // vault_aws_iam_server_id - computed: false, optional: true, required: false
  private _vaultAwsIamServerId?: string; 
  public get vaultAwsIamServerId() {
    return this.getStringAttribute('vault_aws_iam_server_id');
  }
  public set vaultAwsIamServerId(value: string) {
    this._vaultAwsIamServerId = value;
  }
  public resetVaultAwsIamServerId() {
    this._vaultAwsIamServerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vaultAwsIamServerIdInput() {
    return this._vaultAwsIamServerId;
  }

  // vault_role - computed: false, optional: false, required: true
  private _vaultRole?: string; 
  public get vaultRole() {
    return this.getStringAttribute('vault_role');
  }
  public set vaultRole(value: string) {
    this._vaultRole = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vaultRoleInput() {
    return this._vaultRole;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken {
  /**
  * Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by 'serviceAccountRef'. Defaults to a single audience 'vault' it not specified. Deprecated: use serviceAccountRef.Audiences instead
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by 'serviceAccountRef'. Deprecated: this will be removed in the future. Defaults to 10 minutes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#expiration_seconds DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#expiration_seconds}
  */
  readonly expirationSeconds?: number;
  /**
  * Service account field containing the name of a kubernetes ServiceAccount.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    expiration_seconds: cdktf.numberToTerraform(struct!.expirationSeconds),
    service_account_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRefToTerraform(struct!.serviceAccountRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    expiration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.expirationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._expirationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.expirationSeconds = this._expirationSeconds;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._expirationSeconds = undefined;
      this._serviceAccountRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._expirationSeconds = value.expirationSeconds;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // expiration_seconds - computed: false, optional: true, required: false
  private _expirationSeconds?: number; 
  public get expirationSeconds() {
    return this.getNumberAttribute('expiration_seconds');
  }
  public set expirationSeconds(value: number) {
    this._expirationSeconds = value;
  }
  public resetExpirationSeconds() {
    this._expirationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expirationSecondsInput() {
    return this._expirationSeconds;
  }

  // service_account_ref - computed: false, optional: false, required: true
  private _serviceAccountRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt {
  /**
  * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the 'TokenRequest' API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#kubernetes_service_account_token DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#kubernetes_service_account_token}
  */
  readonly kubernetesServiceAccountToken?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken;
  /**
  * Path where the JWT authentication backend is mounted in Vault, e.g: 'jwt'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#path DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#path}
  */
  readonly path: string;
  /**
  * Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#role DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#role}
  */
  readonly role?: string;
  /**
  * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    kubernetes_service_account_token: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenToTerraform(struct!.kubernetesServiceAccountToken),
    path: cdktf.stringToTerraform(struct!.path),
    role: cdktf.stringToTerraform(struct!.role),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    kubernetes_service_account_token: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenToHclTerraform(struct!.kubernetesServiceAccountToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._kubernetesServiceAccountToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesServiceAccountToken = this._kubernetesServiceAccountToken?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._kubernetesServiceAccountToken.internalValue = undefined;
      this._path = undefined;
      this._role = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._kubernetesServiceAccountToken.internalValue = value.kubernetesServiceAccountToken;
      this._path = value.path;
      this._role = value.role;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // kubernetes_service_account_token - computed: false, optional: true, required: false
  private _kubernetesServiceAccountToken = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenOutputReference(this, "kubernetes_service_account_token");
  public get kubernetesServiceAccountToken() {
    return this._kubernetesServiceAccountToken;
  }
  public putKubernetesServiceAccountToken(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken) {
    this._kubernetesServiceAccountToken.internalValue = value;
  }
  public resetKubernetesServiceAccountToken() {
    this._kubernetesServiceAccountToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesServiceAccountTokenInput() {
    return this._kubernetesServiceAccountToken.internalValue;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes {
  /**
  * Path where the Kubernetes authentication backend is mounted in Vault, e.g: 'kubernetes'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#mount_path DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#mount_path}
  */
  readonly mountPath: string;
  /**
  * A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#role DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#role}
  */
  readonly role: string;
  /**
  * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, 'token' is the default. If one is not specified, the one bound to the controller will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef;
  /**
  * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mount_path: cdktf.stringToTerraform(struct!.mountPath),
    role: cdktf.stringToTerraform(struct!.role),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRefToTerraform(struct!.secretRef),
    service_account_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRefToTerraform(struct!.serviceAccountRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mount_path: {
      value: cdktf.stringToHclTerraform(struct!.mountPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mountPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.mountPath = this._mountPath;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mountPath = undefined;
      this._role = undefined;
      this._secretRef.internalValue = undefined;
      this._serviceAccountRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mountPath = value.mountPath;
      this._role = value.role;
      this._secretRef.internalValue = value.secretRef;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
    }
  }

  // mount_path - computed: false, optional: false, required: true
  private _mountPath?: string; 
  public get mountPath() {
    return this.getStringAttribute('mount_path');
  }
  public set mountPath(value: string) {
    this._mountPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get mountPathInput() {
    return this._mountPath;
  }

  // role - computed: false, optional: false, required: true
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap {
  /**
  * Path where the LDAP authentication backend is mounted in Vault, e.g: 'ldap'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#path DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#path}
  */
  readonly path: string;
  /**
  * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef;
  /**
  * Username is a LDAP user name used to authenticate using the LDAP Vault authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#username DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#username}
  */
  readonly username: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRefToTerraform(struct!.secretRef),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secretRef.internalValue = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secretRef.internalValue = value.secretRef;
      this._username = value.username;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // username - computed: false, optional: false, required: true
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass {
  /**
  * Path where the UserPassword authentication backend is mounted in Vault, e.g: 'user'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#path DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#path}
  */
  readonly path: string;
  /**
  * SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef;
  /**
  * Username is a user name used to authenticate using the UserPass Vault authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#username DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#username}
  */
  readonly username: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRefToTerraform(struct!.secretRef),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secretRef.internalValue = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secretRef.internalValue = value.secretRef;
      this._username = value.username;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // username - computed: false, optional: false, required: true
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuth {
  /**
  * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#app_role DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#app_role}
  */
  readonly appRole?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole;
  /**
  * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#cert DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#cert}
  */
  readonly cert?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert;
  /**
  * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#iam DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#iam}
  */
  readonly iam?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam;
  /**
  * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#jwt DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#jwt}
  */
  readonly jwt?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt;
  /**
  * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#kubernetes DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#kubernetes}
  */
  readonly kubernetes?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes;
  /**
  * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#ldap DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#ldap}
  */
  readonly ldap?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap;
  /**
  * Name of the vault namespace to authenticate to. This can be different than the namespace your secret is in. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: 'ns1'. More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces This will default to Vault.Namespace field if set, or empty otherwise
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * TokenSecretRef authenticates with Vault by presenting a token.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#token_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#token_secret_ref}
  */
  readonly tokenSecretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef;
  /**
  * UserPass authenticates with Vault by passing username/password pair
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#user_pass DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#user_pass}
  */
  readonly userPass?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_role: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleToTerraform(struct!.appRole),
    cert: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertToTerraform(struct!.cert),
    iam: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamToTerraform(struct!.iam),
    jwt: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtToTerraform(struct!.jwt),
    kubernetes: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesToTerraform(struct!.kubernetes),
    ldap: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapToTerraform(struct!.ldap),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    token_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRefToTerraform(struct!.tokenSecretRef),
    user_pass: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassToTerraform(struct!.userPass),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_role: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleToHclTerraform(struct!.appRole),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole",
    },
    cert: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertToHclTerraform(struct!.cert),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert",
    },
    iam: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamToHclTerraform(struct!.iam),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam",
    },
    jwt: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtToHclTerraform(struct!.jwt),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt",
    },
    kubernetes: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesToHclTerraform(struct!.kubernetes),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes",
    },
    ldap: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapToHclTerraform(struct!.ldap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRefToHclTerraform(struct!.tokenSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef",
    },
    user_pass: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassToHclTerraform(struct!.userPass),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appRole?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.appRole = this._appRole?.internalValue;
    }
    if (this._cert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cert = this._cert?.internalValue;
    }
    if (this._iam?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.iam = this._iam?.internalValue;
    }
    if (this._jwt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwt = this._jwt?.internalValue;
    }
    if (this._kubernetes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetes = this._kubernetes?.internalValue;
    }
    if (this._ldap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ldap = this._ldap?.internalValue;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._tokenSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSecretRef = this._tokenSecretRef?.internalValue;
    }
    if (this._userPass?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.userPass = this._userPass?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appRole.internalValue = undefined;
      this._cert.internalValue = undefined;
      this._iam.internalValue = undefined;
      this._jwt.internalValue = undefined;
      this._kubernetes.internalValue = undefined;
      this._ldap.internalValue = undefined;
      this._namespace = undefined;
      this._tokenSecretRef.internalValue = undefined;
      this._userPass.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appRole.internalValue = value.appRole;
      this._cert.internalValue = value.cert;
      this._iam.internalValue = value.iam;
      this._jwt.internalValue = value.jwt;
      this._kubernetes.internalValue = value.kubernetes;
      this._ldap.internalValue = value.ldap;
      this._namespace = value.namespace;
      this._tokenSecretRef.internalValue = value.tokenSecretRef;
      this._userPass.internalValue = value.userPass;
    }
  }

  // app_role - computed: false, optional: true, required: false
  private _appRole = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleOutputReference(this, "app_role");
  public get appRole() {
    return this._appRole;
  }
  public putAppRole(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole) {
    this._appRole.internalValue = value;
  }
  public resetAppRole() {
    this._appRole.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appRoleInput() {
    return this._appRole.internalValue;
  }

  // cert - computed: false, optional: true, required: false
  private _cert = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertOutputReference(this, "cert");
  public get cert() {
    return this._cert;
  }
  public putCert(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert) {
    this._cert.internalValue = value;
  }
  public resetCert() {
    this._cert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certInput() {
    return this._cert.internalValue;
  }

  // iam - computed: false, optional: true, required: false
  private _iam = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamOutputReference(this, "iam");
  public get iam() {
    return this._iam;
  }
  public putIam(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam) {
    this._iam.internalValue = value;
  }
  public resetIam() {
    this._iam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iamInput() {
    return this._iam.internalValue;
  }

  // jwt - computed: false, optional: true, required: false
  private _jwt = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtOutputReference(this, "jwt");
  public get jwt() {
    return this._jwt;
  }
  public putJwt(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt) {
    this._jwt.internalValue = value;
  }
  public resetJwt() {
    this._jwt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwtInput() {
    return this._jwt.internalValue;
  }

  // kubernetes - computed: false, optional: true, required: false
  private _kubernetes = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesOutputReference(this, "kubernetes");
  public get kubernetes() {
    return this._kubernetes;
  }
  public putKubernetes(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes) {
    this._kubernetes.internalValue = value;
  }
  public resetKubernetes() {
    this._kubernetes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesInput() {
    return this._kubernetes.internalValue;
  }

  // ldap - computed: false, optional: true, required: false
  private _ldap = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapOutputReference(this, "ldap");
  public get ldap() {
    return this._ldap;
  }
  public putLdap(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap) {
    this._ldap.internalValue = value;
  }
  public resetLdap() {
    this._ldap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ldapInput() {
    return this._ldap.internalValue;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // token_secret_ref - computed: false, optional: true, required: false
  private _tokenSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRefOutputReference(this, "token_secret_ref");
  public get tokenSecretRef() {
    return this._tokenSecretRef;
  }
  public putTokenSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef) {
    this._tokenSecretRef.internalValue = value;
  }
  public resetTokenSecretRef() {
    this._tokenSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSecretRefInput() {
    return this._tokenSecretRef.internalValue;
  }

  // user_pass - computed: false, optional: true, required: false
  private _userPass = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassOutputReference(this, "user_pass");
  public get userPass() {
    return this._userPass;
  }
  public putUserPass(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass) {
    this._userPass.internalValue = value;
  }
  public resetUserPass() {
    this._userPass.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userPassInput() {
    return this._userPass.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider {
  /**
  * The key where the CA certificate can be found in the Secret or ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the object located at the provider type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * The type of provider to use such as 'Secret', or 'ConfigMap'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#type DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProviderToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProviderToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTls {
  /**
  * CertSecretRef is a certificate added to the transport layer when communicating with the Vault server. If no key for the Secret is specified, external-secret will default to 'tls.crt'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#cert_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#cert_secret_ref}
  */
  readonly certSecretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef;
  /**
  * KeySecretRef to a key in a Secret resource containing client private key added to the transport layer when communicating with the Vault server. If no key for the Secret is specified, external-secret will default to 'tls.key'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key_secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key_secret_ref}
  */
  readonly keySecretRef?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cert_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRefToTerraform(struct!.certSecretRef),
    key_secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRefToTerraform(struct!.keySecretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cert_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRefToHclTerraform(struct!.certSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef",
    },
    key_secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRefToHclTerraform(struct!.keySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certSecretRef = this._certSecretRef?.internalValue;
    }
    if (this._keySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keySecretRef = this._keySecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certSecretRef.internalValue = undefined;
      this._keySecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certSecretRef.internalValue = value.certSecretRef;
      this._keySecretRef.internalValue = value.keySecretRef;
    }
  }

  // cert_secret_ref - computed: false, optional: true, required: false
  private _certSecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRefOutputReference(this, "cert_secret_ref");
  public get certSecretRef() {
    return this._certSecretRef;
  }
  public putCertSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef) {
    this._certSecretRef.internalValue = value;
  }
  public resetCertSecretRef() {
    this._certSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certSecretRefInput() {
    return this._certSecretRef.internalValue;
  }

  // key_secret_ref - computed: false, optional: true, required: false
  private _keySecretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRefOutputReference(this, "key_secret_ref");
  public get keySecretRef() {
    return this._keySecretRef;
  }
  public putKeySecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef) {
    this._keySecretRef.internalValue = value;
  }
  public resetKeySecretRef() {
    this._keySecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keySecretRefInput() {
    return this._keySecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVault {
  /**
  * Auth configures how secret-manager authenticates with the Vault server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuth;
  /**
  * PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#ca_bundle DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * The provider for the CA bundle to use to validate Vault server certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#ca_provider DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#ca_provider}
  */
  readonly caProvider?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider;
  /**
  * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#forward_inconsistent DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#forward_inconsistent}
  */
  readonly forwardInconsistent?: boolean | cdktf.IResolvable;
  /**
  * Headers to be added in Vault request
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#headers DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#headers}
  */
  readonly headers?: { [key: string]: string };
  /**
  * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: 'ns1'. More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Path is the mount path of the Vault KV backend endpoint, e.g: 'secret'. The v2 KV secret engine version specific '/data' path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#path DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#path}
  */
  readonly path?: string;
  /**
  * ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#read_your_writes DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#read_your_writes}
  */
  readonly readYourWrites?: boolean | cdktf.IResolvable;
  /**
  * Server is the connection address for the Vault server, e.g: 'https://vault.example.com:8200'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#server DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#server}
  */
  readonly server: string;
  /**
  * The configuration used for client side related TLS communication, when the Vault server requires mutual authentication. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. It's worth noting this configuration is different from the 'TLS certificates auth method', which is available under the 'auth.cert' section.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#tls DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#tls}
  */
  readonly tls?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTls;
  /**
  * Version is the Vault KV secret engine version. This can be either 'v1' or 'v2'. Version defaults to 'v2'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#version DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#version}
  */
  readonly version?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVault | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthToTerraform(struct!.auth),
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    ca_provider: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProviderToTerraform(struct!.caProvider),
    forward_inconsistent: cdktf.booleanToTerraform(struct!.forwardInconsistent),
    headers: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.headers),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    path: cdktf.stringToTerraform(struct!.path),
    read_your_writes: cdktf.booleanToTerraform(struct!.readYourWrites),
    server: cdktf.stringToTerraform(struct!.server),
    tls: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsToTerraform(struct!.tls),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVault | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuth",
    },
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_provider: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProviderToHclTerraform(struct!.caProvider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider",
    },
    forward_inconsistent: {
      value: cdktf.booleanToHclTerraform(struct!.forwardInconsistent),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    headers: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.headers),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_your_writes: {
      value: cdktf.booleanToHclTerraform(struct!.readYourWrites),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server: {
      value: cdktf.stringToHclTerraform(struct!.server),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTls",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVault | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._caProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caProvider = this._caProvider?.internalValue;
    }
    if (this._forwardInconsistent !== undefined) {
      hasAnyValues = true;
      internalValueResult.forwardInconsistent = this._forwardInconsistent;
    }
    if (this._headers !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._readYourWrites !== undefined) {
      hasAnyValues = true;
      internalValueResult.readYourWrites = this._readYourWrites;
    }
    if (this._server !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVault | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._caBundle = undefined;
      this._caProvider.internalValue = undefined;
      this._forwardInconsistent = undefined;
      this._headers = undefined;
      this._namespace = undefined;
      this._path = undefined;
      this._readYourWrites = undefined;
      this._server = undefined;
      this._tls.internalValue = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._caBundle = value.caBundle;
      this._caProvider.internalValue = value.caProvider;
      this._forwardInconsistent = value.forwardInconsistent;
      this._headers = value.headers;
      this._namespace = value.namespace;
      this._path = value.path;
      this._readYourWrites = value.readYourWrites;
      this._server = value.server;
      this._tls.internalValue = value.tls;
      this._version = value.version;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // ca_provider - computed: false, optional: true, required: false
  private _caProvider = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProviderOutputReference(this, "ca_provider");
  public get caProvider() {
    return this._caProvider;
  }
  public putCaProvider(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider) {
    this._caProvider.internalValue = value;
  }
  public resetCaProvider() {
    this._caProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caProviderInput() {
    return this._caProvider.internalValue;
  }

  // forward_inconsistent - computed: false, optional: true, required: false
  private _forwardInconsistent?: boolean | cdktf.IResolvable; 
  public get forwardInconsistent() {
    return this.getBooleanAttribute('forward_inconsistent');
  }
  public set forwardInconsistent(value: boolean | cdktf.IResolvable) {
    this._forwardInconsistent = value;
  }
  public resetForwardInconsistent() {
    this._forwardInconsistent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forwardInconsistentInput() {
    return this._forwardInconsistent;
  }

  // headers - computed: false, optional: true, required: false
  private _headers?: { [key: string]: string }; 
  public get headers() {
    return this.getStringMapAttribute('headers');
  }
  public set headers(value: { [key: string]: string }) {
    this._headers = value;
  }
  public resetHeaders() {
    this._headers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // read_your_writes - computed: false, optional: true, required: false
  private _readYourWrites?: boolean | cdktf.IResolvable; 
  public get readYourWrites() {
    return this.getBooleanAttribute('read_your_writes');
  }
  public set readYourWrites(value: boolean | cdktf.IResolvable) {
    this._readYourWrites = value;
  }
  public resetReadYourWrites() {
    this._readYourWrites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readYourWritesInput() {
    return this._readYourWrites;
  }

  // server - computed: false, optional: false, required: true
  private _server?: string; 
  public get server() {
    return this.getStringAttribute('server');
  }
  public set server(value: string) {
    this._server = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderVaultTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookCaProvider {
  /**
  * The key the value inside of the provider type to use, only used with 'Secret' type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the object located at the provider type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * The namespace the Provider type is in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * The type of provider to use such as 'Secret', or 'ConfigMap'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#type DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookCaProviderToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookCaProviderToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookCaProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookCaProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookCaProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookResult {
  /**
  * Json path of return value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#json_path DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#json_path}
  */
  readonly jsonPath?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookResultToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookResult | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_path: cdktf.stringToTerraform(struct!.jsonPath),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookResultToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookResult | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_path: {
      value: cdktf.stringToHclTerraform(struct!.jsonPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookResultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookResult | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonPath = this._jsonPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookResult | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonPath = value.jsonPath;
    }
  }

  // json_path - computed: false, optional: true, required: false
  private _jsonPath?: string; 
  public get jsonPath() {
    return this.getStringAttribute('json_path');
  }
  public set jsonPath(value: string) {
    this._jsonPath = value;
  }
  public resetJsonPath() {
    this._jsonPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonPathInput() {
    return this._jsonPath;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRefToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecrets {
  /**
  * Name of this secret in templates
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Secret ref to fill in credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/external_secrets_io_cluster_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoClusterSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef;
}

export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsToTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    secret_ref: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsToHclTerraform(struct?: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}

export class DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsList extends cdktf.ComplexList {
  public internalValue? : DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsOutputReference {
    return new DataK8SExternalSecretsIoClusterSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
