// https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface AlertmanagerConfigConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#id AlertmanagerConfig#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The Organization ID. If not set, the Org ID defined in the provider block will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#org_id AlertmanagerConfig#org_id}
  */
  readonly orgId?: string;
  /**
  * A list of template names to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#templates AlertmanagerConfig#templates}
  */
  readonly templates?: string[];
  /**
  * A map of key values string, where the key is the template name and the value the content of the template.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#templates_files AlertmanagerConfig#templates_files}
  */
  readonly templatesFiles?: { [key: string]: string };
  /**
  * global block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#global AlertmanagerConfig#global}
  */
  readonly global?: AlertmanagerConfigGlobal;
  /**
  * inhibit_rule block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#inhibit_rule AlertmanagerConfig#inhibit_rule}
  */
  readonly inhibitRule?: AlertmanagerConfigInhibitRule[] | cdktf.IResolvable;
  /**
  * receiver block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#receiver AlertmanagerConfig#receiver}
  */
  readonly receiver: AlertmanagerConfigReceiver[] | cdktf.IResolvable;
  /**
  * route block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#route AlertmanagerConfig#route}
  */
  readonly route: AlertmanagerConfigRoute;
  /**
  * time_interval block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#time_interval AlertmanagerConfig#time_interval}
  */
  readonly timeInterval?: AlertmanagerConfigTimeInterval[] | cdktf.IResolvable;
}
export interface AlertmanagerConfigGlobalHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigGlobalHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigGlobalHttpConfigAuthorizationOutputReference | AlertmanagerConfigGlobalHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigGlobalHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigGlobalHttpConfigAuthorizationOutputReference | AlertmanagerConfigGlobalHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigGlobalHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigGlobalHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigGlobalHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigGlobalHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigGlobalHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigGlobalHttpConfigBasicAuthOutputReference | AlertmanagerConfigGlobalHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigGlobalHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigGlobalHttpConfigBasicAuthOutputReference | AlertmanagerConfigGlobalHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigGlobalHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigGlobalHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigGlobalHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigGlobalHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigGlobalHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigGlobalHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigGlobalHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigGlobalHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigGlobalHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigGlobalHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigGlobalHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigGlobalHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigGlobalHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigGlobalHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigGlobalHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigGlobalHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigGlobalHttpConfigOauth2OutputReference | AlertmanagerConfigGlobalHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigGlobalHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigGlobalHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigGlobalHttpConfigOauth2OutputReference | AlertmanagerConfigGlobalHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigGlobalHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigGlobalHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigGlobalHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigGlobalHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigGlobalHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigGlobalHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigGlobalHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigGlobalHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigGlobalHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigGlobalHttpConfigTlsConfigOutputReference | AlertmanagerConfigGlobalHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigGlobalHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigGlobalHttpConfigTlsConfigOutputReference | AlertmanagerConfigGlobalHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigGlobalHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigGlobalHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigGlobalHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigGlobalHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigGlobalHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigGlobalHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigGlobalHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigGlobalHttpConfigTlsConfig;
}

export function alertmanagerConfigGlobalHttpConfigToTerraform(struct?: AlertmanagerConfigGlobalHttpConfigOutputReference | AlertmanagerConfigGlobalHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigGlobalHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigGlobalHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigGlobalHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigGlobalHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigGlobalHttpConfigToHclTerraform(struct?: AlertmanagerConfigGlobalHttpConfigOutputReference | AlertmanagerConfigGlobalHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigGlobalHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigGlobalHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigGlobalHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigGlobalHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigGlobalHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigGlobalHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigGlobalHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigGlobalHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigGlobalHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigGlobalHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigGlobalHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigGlobalHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigGlobalHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigGlobalHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigGlobalHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigGlobalHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigGlobalHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigGlobalHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigGlobalHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigGlobal {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#opsgenie_api_key AlertmanagerConfig#opsgenie_api_key}
  */
  readonly opsgenieApiKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#opsgenie_api_url AlertmanagerConfig#opsgenie_api_url}
  */
  readonly opsgenieApiUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#pagerduty_url AlertmanagerConfig#pagerduty_url}
  */
  readonly pagerdutyUrl?: string;
  /**
  * The time after which an alert is declared resolved if it has not been updated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#resolve_timeout AlertmanagerConfig#resolve_timeout}
  */
  readonly resolveTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#slack_api_url AlertmanagerConfig#slack_api_url}
  */
  readonly slackApiUrl?: string;
  /**
  * SMTP Auth using PLAIN.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#smtp_auth_identity AlertmanagerConfig#smtp_auth_identity}
  */
  readonly smtpAuthIdentity?: string;
  /**
  * SMTP Auth using LOGIN and PLAIN.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#smtp_auth_password AlertmanagerConfig#smtp_auth_password}
  */
  readonly smtpAuthPassword?: string;
  /**
  * SMTP Auth using CRAM-MD5.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#smtp_auth_secret AlertmanagerConfig#smtp_auth_secret}
  */
  readonly smtpAuthSecret?: string;
  /**
  * SMTP Auth using CRAM-MD5, LOGIN and PLAIN. If empty, Alertmanager doesn't authenticate to the SMTP server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#smtp_auth_username AlertmanagerConfig#smtp_auth_username}
  */
  readonly smtpAuthUsername?: string;
  /**
  * The default SMTP From header field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#smtp_from AlertmanagerConfig#smtp_from}
  */
  readonly smtpFrom?: string;
  /**
  * The default hostname to identify to the SMTP server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#smtp_hello AlertmanagerConfig#smtp_hello}
  */
  readonly smtpHello?: string;
  /**
  * The default SMTP TLS requirement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#smtp_require_tls AlertmanagerConfig#smtp_require_tls}
  */
  readonly smtpRequireTls?: boolean | cdktf.IResolvable;
  /**
  * The default SMTP smarthost used for sending emails, including port number.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#smtp_smarthost AlertmanagerConfig#smtp_smarthost}
  */
  readonly smtpSmarthost?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#telegram_api_url AlertmanagerConfig#telegram_api_url}
  */
  readonly telegramApiUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#victorops_api_key AlertmanagerConfig#victorops_api_key}
  */
  readonly victoropsApiKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#victorops_api_url AlertmanagerConfig#victorops_api_url}
  */
  readonly victoropsApiUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#webex_api_url AlertmanagerConfig#webex_api_url}
  */
  readonly webexApiUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#wechat_api_corp_id AlertmanagerConfig#wechat_api_corp_id}
  */
  readonly wechatApiCorpId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#wechat_api_secret AlertmanagerConfig#wechat_api_secret}
  */
  readonly wechatApiSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#wechat_api_url AlertmanagerConfig#wechat_api_url}
  */
  readonly wechatApiUrl?: string;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigGlobalHttpConfig;
}

export function alertmanagerConfigGlobalToTerraform(struct?: AlertmanagerConfigGlobalOutputReference | AlertmanagerConfigGlobal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    opsgenie_api_key: cdktf.stringToTerraform(struct!.opsgenieApiKey),
    opsgenie_api_url: cdktf.stringToTerraform(struct!.opsgenieApiUrl),
    pagerduty_url: cdktf.stringToTerraform(struct!.pagerdutyUrl),
    resolve_timeout: cdktf.stringToTerraform(struct!.resolveTimeout),
    slack_api_url: cdktf.stringToTerraform(struct!.slackApiUrl),
    smtp_auth_identity: cdktf.stringToTerraform(struct!.smtpAuthIdentity),
    smtp_auth_password: cdktf.stringToTerraform(struct!.smtpAuthPassword),
    smtp_auth_secret: cdktf.stringToTerraform(struct!.smtpAuthSecret),
    smtp_auth_username: cdktf.stringToTerraform(struct!.smtpAuthUsername),
    smtp_from: cdktf.stringToTerraform(struct!.smtpFrom),
    smtp_hello: cdktf.stringToTerraform(struct!.smtpHello),
    smtp_require_tls: cdktf.booleanToTerraform(struct!.smtpRequireTls),
    smtp_smarthost: cdktf.stringToTerraform(struct!.smtpSmarthost),
    telegram_api_url: cdktf.stringToTerraform(struct!.telegramApiUrl),
    victorops_api_key: cdktf.stringToTerraform(struct!.victoropsApiKey),
    victorops_api_url: cdktf.stringToTerraform(struct!.victoropsApiUrl),
    webex_api_url: cdktf.stringToTerraform(struct!.webexApiUrl),
    wechat_api_corp_id: cdktf.stringToTerraform(struct!.wechatApiCorpId),
    wechat_api_secret: cdktf.stringToTerraform(struct!.wechatApiSecret),
    wechat_api_url: cdktf.stringToTerraform(struct!.wechatApiUrl),
    http_config: alertmanagerConfigGlobalHttpConfigToTerraform(struct!.httpConfig),
  }
}


export function alertmanagerConfigGlobalToHclTerraform(struct?: AlertmanagerConfigGlobalOutputReference | AlertmanagerConfigGlobal): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    opsgenie_api_key: {
      value: cdktf.stringToHclTerraform(struct!.opsgenieApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    opsgenie_api_url: {
      value: cdktf.stringToHclTerraform(struct!.opsgenieApiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pagerduty_url: {
      value: cdktf.stringToHclTerraform(struct!.pagerdutyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resolve_timeout: {
      value: cdktf.stringToHclTerraform(struct!.resolveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slack_api_url: {
      value: cdktf.stringToHclTerraform(struct!.slackApiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    smtp_auth_identity: {
      value: cdktf.stringToHclTerraform(struct!.smtpAuthIdentity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    smtp_auth_password: {
      value: cdktf.stringToHclTerraform(struct!.smtpAuthPassword),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    smtp_auth_secret: {
      value: cdktf.stringToHclTerraform(struct!.smtpAuthSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    smtp_auth_username: {
      value: cdktf.stringToHclTerraform(struct!.smtpAuthUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    smtp_from: {
      value: cdktf.stringToHclTerraform(struct!.smtpFrom),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    smtp_hello: {
      value: cdktf.stringToHclTerraform(struct!.smtpHello),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    smtp_require_tls: {
      value: cdktf.booleanToHclTerraform(struct!.smtpRequireTls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    smtp_smarthost: {
      value: cdktf.stringToHclTerraform(struct!.smtpSmarthost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    telegram_api_url: {
      value: cdktf.stringToHclTerraform(struct!.telegramApiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    victorops_api_key: {
      value: cdktf.stringToHclTerraform(struct!.victoropsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    victorops_api_url: {
      value: cdktf.stringToHclTerraform(struct!.victoropsApiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    webex_api_url: {
      value: cdktf.stringToHclTerraform(struct!.webexApiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    wechat_api_corp_id: {
      value: cdktf.stringToHclTerraform(struct!.wechatApiCorpId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    wechat_api_secret: {
      value: cdktf.stringToHclTerraform(struct!.wechatApiSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    wechat_api_url: {
      value: cdktf.stringToHclTerraform(struct!.wechatApiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_config: {
      value: alertmanagerConfigGlobalHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigGlobalHttpConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigGlobalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigGlobal | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._opsgenieApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.opsgenieApiKey = this._opsgenieApiKey;
    }
    if (this._opsgenieApiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.opsgenieApiUrl = this._opsgenieApiUrl;
    }
    if (this._pagerdutyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.pagerdutyUrl = this._pagerdutyUrl;
    }
    if (this._resolveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.resolveTimeout = this._resolveTimeout;
    }
    if (this._slackApiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.slackApiUrl = this._slackApiUrl;
    }
    if (this._smtpAuthIdentity !== undefined) {
      hasAnyValues = true;
      internalValueResult.smtpAuthIdentity = this._smtpAuthIdentity;
    }
    if (this._smtpAuthPassword !== undefined) {
      hasAnyValues = true;
      internalValueResult.smtpAuthPassword = this._smtpAuthPassword;
    }
    if (this._smtpAuthSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.smtpAuthSecret = this._smtpAuthSecret;
    }
    if (this._smtpAuthUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.smtpAuthUsername = this._smtpAuthUsername;
    }
    if (this._smtpFrom !== undefined) {
      hasAnyValues = true;
      internalValueResult.smtpFrom = this._smtpFrom;
    }
    if (this._smtpHello !== undefined) {
      hasAnyValues = true;
      internalValueResult.smtpHello = this._smtpHello;
    }
    if (this._smtpRequireTls !== undefined) {
      hasAnyValues = true;
      internalValueResult.smtpRequireTls = this._smtpRequireTls;
    }
    if (this._smtpSmarthost !== undefined) {
      hasAnyValues = true;
      internalValueResult.smtpSmarthost = this._smtpSmarthost;
    }
    if (this._telegramApiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.telegramApiUrl = this._telegramApiUrl;
    }
    if (this._victoropsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.victoropsApiKey = this._victoropsApiKey;
    }
    if (this._victoropsApiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.victoropsApiUrl = this._victoropsApiUrl;
    }
    if (this._webexApiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.webexApiUrl = this._webexApiUrl;
    }
    if (this._wechatApiCorpId !== undefined) {
      hasAnyValues = true;
      internalValueResult.wechatApiCorpId = this._wechatApiCorpId;
    }
    if (this._wechatApiSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.wechatApiSecret = this._wechatApiSecret;
    }
    if (this._wechatApiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.wechatApiUrl = this._wechatApiUrl;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigGlobal | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._opsgenieApiKey = undefined;
      this._opsgenieApiUrl = undefined;
      this._pagerdutyUrl = undefined;
      this._resolveTimeout = undefined;
      this._slackApiUrl = undefined;
      this._smtpAuthIdentity = undefined;
      this._smtpAuthPassword = undefined;
      this._smtpAuthSecret = undefined;
      this._smtpAuthUsername = undefined;
      this._smtpFrom = undefined;
      this._smtpHello = undefined;
      this._smtpRequireTls = undefined;
      this._smtpSmarthost = undefined;
      this._telegramApiUrl = undefined;
      this._victoropsApiKey = undefined;
      this._victoropsApiUrl = undefined;
      this._webexApiUrl = undefined;
      this._wechatApiCorpId = undefined;
      this._wechatApiSecret = undefined;
      this._wechatApiUrl = undefined;
      this._httpConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._opsgenieApiKey = value.opsgenieApiKey;
      this._opsgenieApiUrl = value.opsgenieApiUrl;
      this._pagerdutyUrl = value.pagerdutyUrl;
      this._resolveTimeout = value.resolveTimeout;
      this._slackApiUrl = value.slackApiUrl;
      this._smtpAuthIdentity = value.smtpAuthIdentity;
      this._smtpAuthPassword = value.smtpAuthPassword;
      this._smtpAuthSecret = value.smtpAuthSecret;
      this._smtpAuthUsername = value.smtpAuthUsername;
      this._smtpFrom = value.smtpFrom;
      this._smtpHello = value.smtpHello;
      this._smtpRequireTls = value.smtpRequireTls;
      this._smtpSmarthost = value.smtpSmarthost;
      this._telegramApiUrl = value.telegramApiUrl;
      this._victoropsApiKey = value.victoropsApiKey;
      this._victoropsApiUrl = value.victoropsApiUrl;
      this._webexApiUrl = value.webexApiUrl;
      this._wechatApiCorpId = value.wechatApiCorpId;
      this._wechatApiSecret = value.wechatApiSecret;
      this._wechatApiUrl = value.wechatApiUrl;
      this._httpConfig.internalValue = value.httpConfig;
    }
  }

  // opsgenie_api_key - computed: false, optional: true, required: false
  private _opsgenieApiKey?: string; 
  public get opsgenieApiKey() {
    return this.getStringAttribute('opsgenie_api_key');
  }
  public set opsgenieApiKey(value: string) {
    this._opsgenieApiKey = value;
  }
  public resetOpsgenieApiKey() {
    this._opsgenieApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opsgenieApiKeyInput() {
    return this._opsgenieApiKey;
  }

  // opsgenie_api_url - computed: false, optional: true, required: false
  private _opsgenieApiUrl?: string; 
  public get opsgenieApiUrl() {
    return this.getStringAttribute('opsgenie_api_url');
  }
  public set opsgenieApiUrl(value: string) {
    this._opsgenieApiUrl = value;
  }
  public resetOpsgenieApiUrl() {
    this._opsgenieApiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opsgenieApiUrlInput() {
    return this._opsgenieApiUrl;
  }

  // pagerduty_url - computed: false, optional: true, required: false
  private _pagerdutyUrl?: string; 
  public get pagerdutyUrl() {
    return this.getStringAttribute('pagerduty_url');
  }
  public set pagerdutyUrl(value: string) {
    this._pagerdutyUrl = value;
  }
  public resetPagerdutyUrl() {
    this._pagerdutyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pagerdutyUrlInput() {
    return this._pagerdutyUrl;
  }

  // resolve_timeout - computed: false, optional: true, required: false
  private _resolveTimeout?: string; 
  public get resolveTimeout() {
    return this.getStringAttribute('resolve_timeout');
  }
  public set resolveTimeout(value: string) {
    this._resolveTimeout = value;
  }
  public resetResolveTimeout() {
    this._resolveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resolveTimeoutInput() {
    return this._resolveTimeout;
  }

  // slack_api_url - computed: false, optional: true, required: false
  private _slackApiUrl?: string; 
  public get slackApiUrl() {
    return this.getStringAttribute('slack_api_url');
  }
  public set slackApiUrl(value: string) {
    this._slackApiUrl = value;
  }
  public resetSlackApiUrl() {
    this._slackApiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slackApiUrlInput() {
    return this._slackApiUrl;
  }

  // smtp_auth_identity - computed: false, optional: true, required: false
  private _smtpAuthIdentity?: string; 
  public get smtpAuthIdentity() {
    return this.getStringAttribute('smtp_auth_identity');
  }
  public set smtpAuthIdentity(value: string) {
    this._smtpAuthIdentity = value;
  }
  public resetSmtpAuthIdentity() {
    this._smtpAuthIdentity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smtpAuthIdentityInput() {
    return this._smtpAuthIdentity;
  }

  // smtp_auth_password - computed: false, optional: true, required: false
  private _smtpAuthPassword?: string; 
  public get smtpAuthPassword() {
    return this.getStringAttribute('smtp_auth_password');
  }
  public set smtpAuthPassword(value: string) {
    this._smtpAuthPassword = value;
  }
  public resetSmtpAuthPassword() {
    this._smtpAuthPassword = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smtpAuthPasswordInput() {
    return this._smtpAuthPassword;
  }

  // smtp_auth_secret - computed: false, optional: true, required: false
  private _smtpAuthSecret?: string; 
  public get smtpAuthSecret() {
    return this.getStringAttribute('smtp_auth_secret');
  }
  public set smtpAuthSecret(value: string) {
    this._smtpAuthSecret = value;
  }
  public resetSmtpAuthSecret() {
    this._smtpAuthSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smtpAuthSecretInput() {
    return this._smtpAuthSecret;
  }

  // smtp_auth_username - computed: false, optional: true, required: false
  private _smtpAuthUsername?: string; 
  public get smtpAuthUsername() {
    return this.getStringAttribute('smtp_auth_username');
  }
  public set smtpAuthUsername(value: string) {
    this._smtpAuthUsername = value;
  }
  public resetSmtpAuthUsername() {
    this._smtpAuthUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smtpAuthUsernameInput() {
    return this._smtpAuthUsername;
  }

  // smtp_from - computed: false, optional: true, required: false
  private _smtpFrom?: string; 
  public get smtpFrom() {
    return this.getStringAttribute('smtp_from');
  }
  public set smtpFrom(value: string) {
    this._smtpFrom = value;
  }
  public resetSmtpFrom() {
    this._smtpFrom = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smtpFromInput() {
    return this._smtpFrom;
  }

  // smtp_hello - computed: false, optional: true, required: false
  private _smtpHello?: string; 
  public get smtpHello() {
    return this.getStringAttribute('smtp_hello');
  }
  public set smtpHello(value: string) {
    this._smtpHello = value;
  }
  public resetSmtpHello() {
    this._smtpHello = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smtpHelloInput() {
    return this._smtpHello;
  }

  // smtp_require_tls - computed: false, optional: true, required: false
  private _smtpRequireTls?: boolean | cdktf.IResolvable; 
  public get smtpRequireTls() {
    return this.getBooleanAttribute('smtp_require_tls');
  }
  public set smtpRequireTls(value: boolean | cdktf.IResolvable) {
    this._smtpRequireTls = value;
  }
  public resetSmtpRequireTls() {
    this._smtpRequireTls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smtpRequireTlsInput() {
    return this._smtpRequireTls;
  }

  // smtp_smarthost - computed: false, optional: true, required: false
  private _smtpSmarthost?: string; 
  public get smtpSmarthost() {
    return this.getStringAttribute('smtp_smarthost');
  }
  public set smtpSmarthost(value: string) {
    this._smtpSmarthost = value;
  }
  public resetSmtpSmarthost() {
    this._smtpSmarthost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smtpSmarthostInput() {
    return this._smtpSmarthost;
  }

  // telegram_api_url - computed: false, optional: true, required: false
  private _telegramApiUrl?: string; 
  public get telegramApiUrl() {
    return this.getStringAttribute('telegram_api_url');
  }
  public set telegramApiUrl(value: string) {
    this._telegramApiUrl = value;
  }
  public resetTelegramApiUrl() {
    this._telegramApiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get telegramApiUrlInput() {
    return this._telegramApiUrl;
  }

  // victorops_api_key - computed: false, optional: true, required: false
  private _victoropsApiKey?: string; 
  public get victoropsApiKey() {
    return this.getStringAttribute('victorops_api_key');
  }
  public set victoropsApiKey(value: string) {
    this._victoropsApiKey = value;
  }
  public resetVictoropsApiKey() {
    this._victoropsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get victoropsApiKeyInput() {
    return this._victoropsApiKey;
  }

  // victorops_api_url - computed: false, optional: true, required: false
  private _victoropsApiUrl?: string; 
  public get victoropsApiUrl() {
    return this.getStringAttribute('victorops_api_url');
  }
  public set victoropsApiUrl(value: string) {
    this._victoropsApiUrl = value;
  }
  public resetVictoropsApiUrl() {
    this._victoropsApiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get victoropsApiUrlInput() {
    return this._victoropsApiUrl;
  }

  // webex_api_url - computed: false, optional: true, required: false
  private _webexApiUrl?: string; 
  public get webexApiUrl() {
    return this.getStringAttribute('webex_api_url');
  }
  public set webexApiUrl(value: string) {
    this._webexApiUrl = value;
  }
  public resetWebexApiUrl() {
    this._webexApiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webexApiUrlInput() {
    return this._webexApiUrl;
  }

  // wechat_api_corp_id - computed: false, optional: true, required: false
  private _wechatApiCorpId?: string; 
  public get wechatApiCorpId() {
    return this.getStringAttribute('wechat_api_corp_id');
  }
  public set wechatApiCorpId(value: string) {
    this._wechatApiCorpId = value;
  }
  public resetWechatApiCorpId() {
    this._wechatApiCorpId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wechatApiCorpIdInput() {
    return this._wechatApiCorpId;
  }

  // wechat_api_secret - computed: false, optional: true, required: false
  private _wechatApiSecret?: string; 
  public get wechatApiSecret() {
    return this.getStringAttribute('wechat_api_secret');
  }
  public set wechatApiSecret(value: string) {
    this._wechatApiSecret = value;
  }
  public resetWechatApiSecret() {
    this._wechatApiSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wechatApiSecretInput() {
    return this._wechatApiSecret;
  }

  // wechat_api_url - computed: false, optional: true, required: false
  private _wechatApiUrl?: string; 
  public get wechatApiUrl() {
    return this.getStringAttribute('wechat_api_url');
  }
  public set wechatApiUrl(value: string) {
    this._wechatApiUrl = value;
  }
  public resetWechatApiUrl() {
    this._wechatApiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wechatApiUrlInput() {
    return this._wechatApiUrl;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigGlobalHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigGlobalHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }
}
export interface AlertmanagerConfigInhibitRule {
  /**
  * Labels that must have an equal value in the source and target alert for the inhibition to take effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#equal AlertmanagerConfig#equal}
  */
  readonly equal?: string[];
  /**
  * A list of matchers for which one or more alerts have to exist for the inhibition to take effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#source_matchers AlertmanagerConfig#source_matchers}
  */
  readonly sourceMatchers?: string[];
  /**
  * A list of matchers that have to be fulfilled by the target alerts to be muted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#target_matchers AlertmanagerConfig#target_matchers}
  */
  readonly targetMatchers?: string[];
}

export function alertmanagerConfigInhibitRuleToTerraform(struct?: AlertmanagerConfigInhibitRule | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    equal: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.equal),
    source_matchers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sourceMatchers),
    target_matchers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.targetMatchers),
  }
}


export function alertmanagerConfigInhibitRuleToHclTerraform(struct?: AlertmanagerConfigInhibitRule | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    equal: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.equal),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    source_matchers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sourceMatchers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    target_matchers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.targetMatchers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigInhibitRuleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigInhibitRule | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._equal !== undefined) {
      hasAnyValues = true;
      internalValueResult.equal = this._equal;
    }
    if (this._sourceMatchers !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceMatchers = this._sourceMatchers;
    }
    if (this._targetMatchers !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetMatchers = this._targetMatchers;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigInhibitRule | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._equal = undefined;
      this._sourceMatchers = undefined;
      this._targetMatchers = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._equal = value.equal;
      this._sourceMatchers = value.sourceMatchers;
      this._targetMatchers = value.targetMatchers;
    }
  }

  // equal - computed: false, optional: true, required: false
  private _equal?: string[]; 
  public get equal() {
    return this.getListAttribute('equal');
  }
  public set equal(value: string[]) {
    this._equal = value;
  }
  public resetEqual() {
    this._equal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get equalInput() {
    return this._equal;
  }

  // source_matchers - computed: false, optional: true, required: false
  private _sourceMatchers?: string[]; 
  public get sourceMatchers() {
    return this.getListAttribute('source_matchers');
  }
  public set sourceMatchers(value: string[]) {
    this._sourceMatchers = value;
  }
  public resetSourceMatchers() {
    this._sourceMatchers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceMatchersInput() {
    return this._sourceMatchers;
  }

  // target_matchers - computed: false, optional: true, required: false
  private _targetMatchers?: string[]; 
  public get targetMatchers() {
    return this.getListAttribute('target_matchers');
  }
  public set targetMatchers(value: string[]) {
    this._targetMatchers = value;
  }
  public resetTargetMatchers() {
    this._targetMatchers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetMatchersInput() {
    return this._targetMatchers;
  }
}

export class AlertmanagerConfigInhibitRuleList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigInhibitRule[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigInhibitRuleOutputReference {
    return new AlertmanagerConfigInhibitRuleOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverDiscordConfigsHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfig;
}

export function alertmanagerConfigReceiverDiscordConfigsHttpConfigToTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverDiscordConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverDiscordConfigsHttpConfigToHclTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverDiscordConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverDiscordConfigsHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverDiscordConfigsHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverDiscordConfigsHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigReceiverDiscordConfigsHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigReceiverDiscordConfigsHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigReceiverDiscordConfigsHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverDiscordConfigsHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverDiscordConfigs {
  /**
  * Notification message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#message AlertmanagerConfig#message}
  */
  readonly message?: string;
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * Notification title.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#title AlertmanagerConfig#title}
  */
  readonly title?: string;
  /**
  * The webhook URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#webhook_url AlertmanagerConfig#webhook_url}
  */
  readonly webhookUrl?: string;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigReceiverDiscordConfigsHttpConfig;
}

export function alertmanagerConfigReceiverDiscordConfigsToTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    message: cdktf.stringToTerraform(struct!.message),
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    title: cdktf.stringToTerraform(struct!.title),
    webhook_url: cdktf.stringToTerraform(struct!.webhookUrl),
    http_config: alertmanagerConfigReceiverDiscordConfigsHttpConfigToTerraform(struct!.httpConfig),
  }
}


export function alertmanagerConfigReceiverDiscordConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverDiscordConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    title: {
      value: cdktf.stringToHclTerraform(struct!.title),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    webhook_url: {
      value: cdktf.stringToHclTerraform(struct!.webhookUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_config: {
      value: alertmanagerConfigReceiverDiscordConfigsHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverDiscordConfigsHttpConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverDiscordConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverDiscordConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._title !== undefined) {
      hasAnyValues = true;
      internalValueResult.title = this._title;
    }
    if (this._webhookUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.webhookUrl = this._webhookUrl;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverDiscordConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._message = undefined;
      this._sendResolved = undefined;
      this._title = undefined;
      this._webhookUrl = undefined;
      this._httpConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._message = value.message;
      this._sendResolved = value.sendResolved;
      this._title = value.title;
      this._webhookUrl = value.webhookUrl;
      this._httpConfig.internalValue = value.httpConfig;
    }
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // title - computed: false, optional: true, required: false
  private _title?: string; 
  public get title() {
    return this.getStringAttribute('title');
  }
  public set title(value: string) {
    this._title = value;
  }
  public resetTitle() {
    this._title = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get titleInput() {
    return this._title;
  }

  // webhook_url - computed: false, optional: true, required: false
  private _webhookUrl?: string; 
  public get webhookUrl() {
    return this.getStringAttribute('webhook_url');
  }
  public set webhookUrl(value: string) {
    this._webhookUrl = value;
  }
  public resetWebhookUrl() {
    this._webhookUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webhookUrlInput() {
    return this._webhookUrl;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigReceiverDiscordConfigsHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigReceiverDiscordConfigsHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }
}

export class AlertmanagerConfigReceiverDiscordConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverDiscordConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverDiscordConfigsOutputReference {
    return new AlertmanagerConfigReceiverDiscordConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverEmailConfigsTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverEmailConfigsTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverEmailConfigsTlsConfigOutputReference | AlertmanagerConfigReceiverEmailConfigsTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverEmailConfigsTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverEmailConfigsTlsConfigOutputReference | AlertmanagerConfigReceiverEmailConfigsTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverEmailConfigsTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverEmailConfigsTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverEmailConfigsTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverEmailConfigs {
  /**
  * SMTP authentication identity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#auth_identity AlertmanagerConfig#auth_identity}
  */
  readonly authIdentity?: string;
  /**
  * SMTP authentication password.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#auth_password AlertmanagerConfig#auth_password}
  */
  readonly authPassword?: string;
  /**
  * SMTP authentication secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#auth_secret AlertmanagerConfig#auth_secret}
  */
  readonly authSecret?: string;
  /**
  * SMTP authentication username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#auth_username AlertmanagerConfig#auth_username}
  */
  readonly authUsername?: string;
  /**
  * The sender's address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#from AlertmanagerConfig#from}
  */
  readonly from?: string;
  /**
  * Further headers email header key/value pairs. Overrides any headers previously set by the notification implementation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#headers AlertmanagerConfig#headers}
  */
  readonly headers?: { [key: string]: string };
  /**
  * The hostname to identify to the SMTP server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#hello AlertmanagerConfig#hello}
  */
  readonly hello?: string;
  /**
  * The HTML body of the email notification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#html AlertmanagerConfig#html}
  */
  readonly html?: string;
  /**
  * The SMTP TLS requirement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#require_tls AlertmanagerConfig#require_tls}
  */
  readonly requireTls?: boolean | cdktf.IResolvable;
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * The SMTP host through which emails are sent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#smarthost AlertmanagerConfig#smarthost}
  */
  readonly smarthost?: string;
  /**
  * The text body of the email notification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#text AlertmanagerConfig#text}
  */
  readonly text?: string;
  /**
  * The email address to send notifications to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#to AlertmanagerConfig#to}
  */
  readonly to?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverEmailConfigsTlsConfig;
}

export function alertmanagerConfigReceiverEmailConfigsToTerraform(struct?: AlertmanagerConfigReceiverEmailConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_identity: cdktf.stringToTerraform(struct!.authIdentity),
    auth_password: cdktf.stringToTerraform(struct!.authPassword),
    auth_secret: cdktf.stringToTerraform(struct!.authSecret),
    auth_username: cdktf.stringToTerraform(struct!.authUsername),
    from: cdktf.stringToTerraform(struct!.from),
    headers: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.headers),
    hello: cdktf.stringToTerraform(struct!.hello),
    html: cdktf.stringToTerraform(struct!.html),
    require_tls: cdktf.booleanToTerraform(struct!.requireTls),
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    smarthost: cdktf.stringToTerraform(struct!.smarthost),
    text: cdktf.stringToTerraform(struct!.text),
    to: cdktf.stringToTerraform(struct!.to),
    tls_config: alertmanagerConfigReceiverEmailConfigsTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverEmailConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverEmailConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_identity: {
      value: cdktf.stringToHclTerraform(struct!.authIdentity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_password: {
      value: cdktf.stringToHclTerraform(struct!.authPassword),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_secret: {
      value: cdktf.stringToHclTerraform(struct!.authSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_username: {
      value: cdktf.stringToHclTerraform(struct!.authUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    from: {
      value: cdktf.stringToHclTerraform(struct!.from),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.headers),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    hello: {
      value: cdktf.stringToHclTerraform(struct!.hello),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    html: {
      value: cdktf.stringToHclTerraform(struct!.html),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    require_tls: {
      value: cdktf.booleanToHclTerraform(struct!.requireTls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    smarthost: {
      value: cdktf.stringToHclTerraform(struct!.smarthost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    to: {
      value: cdktf.stringToHclTerraform(struct!.to),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverEmailConfigsTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverEmailConfigsTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverEmailConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverEmailConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authIdentity !== undefined) {
      hasAnyValues = true;
      internalValueResult.authIdentity = this._authIdentity;
    }
    if (this._authPassword !== undefined) {
      hasAnyValues = true;
      internalValueResult.authPassword = this._authPassword;
    }
    if (this._authSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.authSecret = this._authSecret;
    }
    if (this._authUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.authUsername = this._authUsername;
    }
    if (this._from !== undefined) {
      hasAnyValues = true;
      internalValueResult.from = this._from;
    }
    if (this._headers !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers;
    }
    if (this._hello !== undefined) {
      hasAnyValues = true;
      internalValueResult.hello = this._hello;
    }
    if (this._html !== undefined) {
      hasAnyValues = true;
      internalValueResult.html = this._html;
    }
    if (this._requireTls !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireTls = this._requireTls;
    }
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._smarthost !== undefined) {
      hasAnyValues = true;
      internalValueResult.smarthost = this._smarthost;
    }
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    if (this._to !== undefined) {
      hasAnyValues = true;
      internalValueResult.to = this._to;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverEmailConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authIdentity = undefined;
      this._authPassword = undefined;
      this._authSecret = undefined;
      this._authUsername = undefined;
      this._from = undefined;
      this._headers = undefined;
      this._hello = undefined;
      this._html = undefined;
      this._requireTls = undefined;
      this._sendResolved = undefined;
      this._smarthost = undefined;
      this._text = undefined;
      this._to = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authIdentity = value.authIdentity;
      this._authPassword = value.authPassword;
      this._authSecret = value.authSecret;
      this._authUsername = value.authUsername;
      this._from = value.from;
      this._headers = value.headers;
      this._hello = value.hello;
      this._html = value.html;
      this._requireTls = value.requireTls;
      this._sendResolved = value.sendResolved;
      this._smarthost = value.smarthost;
      this._text = value.text;
      this._to = value.to;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // auth_identity - computed: false, optional: true, required: false
  private _authIdentity?: string; 
  public get authIdentity() {
    return this.getStringAttribute('auth_identity');
  }
  public set authIdentity(value: string) {
    this._authIdentity = value;
  }
  public resetAuthIdentity() {
    this._authIdentity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authIdentityInput() {
    return this._authIdentity;
  }

  // auth_password - computed: false, optional: true, required: false
  private _authPassword?: string; 
  public get authPassword() {
    return this.getStringAttribute('auth_password');
  }
  public set authPassword(value: string) {
    this._authPassword = value;
  }
  public resetAuthPassword() {
    this._authPassword = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authPasswordInput() {
    return this._authPassword;
  }

  // auth_secret - computed: false, optional: true, required: false
  private _authSecret?: string; 
  public get authSecret() {
    return this.getStringAttribute('auth_secret');
  }
  public set authSecret(value: string) {
    this._authSecret = value;
  }
  public resetAuthSecret() {
    this._authSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authSecretInput() {
    return this._authSecret;
  }

  // auth_username - computed: false, optional: true, required: false
  private _authUsername?: string; 
  public get authUsername() {
    return this.getStringAttribute('auth_username');
  }
  public set authUsername(value: string) {
    this._authUsername = value;
  }
  public resetAuthUsername() {
    this._authUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authUsernameInput() {
    return this._authUsername;
  }

  // from - computed: false, optional: true, required: false
  private _from?: string; 
  public get from() {
    return this.getStringAttribute('from');
  }
  public set from(value: string) {
    this._from = value;
  }
  public resetFrom() {
    this._from = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromInput() {
    return this._from;
  }

  // headers - computed: false, optional: true, required: false
  private _headers?: { [key: string]: string }; 
  public get headers() {
    return this.getStringMapAttribute('headers');
  }
  public set headers(value: { [key: string]: string }) {
    this._headers = value;
  }
  public resetHeaders() {
    this._headers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers;
  }

  // hello - computed: false, optional: true, required: false
  private _hello?: string; 
  public get hello() {
    return this.getStringAttribute('hello');
  }
  public set hello(value: string) {
    this._hello = value;
  }
  public resetHello() {
    this._hello = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get helloInput() {
    return this._hello;
  }

  // html - computed: false, optional: true, required: false
  private _html?: string; 
  public get html() {
    return this.getStringAttribute('html');
  }
  public set html(value: string) {
    this._html = value;
  }
  public resetHtml() {
    this._html = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get htmlInput() {
    return this._html;
  }

  // require_tls - computed: false, optional: true, required: false
  private _requireTls?: boolean | cdktf.IResolvable; 
  public get requireTls() {
    return this.getBooleanAttribute('require_tls');
  }
  public set requireTls(value: boolean | cdktf.IResolvable) {
    this._requireTls = value;
  }
  public resetRequireTls() {
    this._requireTls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireTlsInput() {
    return this._requireTls;
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // smarthost - computed: false, optional: true, required: false
  private _smarthost?: string; 
  public get smarthost() {
    return this.getStringAttribute('smarthost');
  }
  public set smarthost(value: string) {
    this._smarthost = value;
  }
  public resetSmarthost() {
    this._smarthost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get smarthostInput() {
    return this._smarthost;
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }

  // to - computed: false, optional: true, required: false
  private _to?: string; 
  public get to() {
    return this.getStringAttribute('to');
  }
  public set to(value: string) {
    this._to = value;
  }
  public resetTo() {
    this._to = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toInput() {
    return this._to;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverEmailConfigsTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverEmailConfigsTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}

export class AlertmanagerConfigReceiverEmailConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverEmailConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverEmailConfigsOutputReference {
    return new AlertmanagerConfigReceiverEmailConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverMsteamsConfigsHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfig;
}

export function alertmanagerConfigReceiverMsteamsConfigsHttpConfigToTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverMsteamsConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverMsteamsConfigsHttpConfigToHclTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverMsteamsConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverMsteamsConfigsHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverMsteamsConfigsHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverMsteamsConfigsHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverMsteamsConfigs {
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * Message summary template.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#summary AlertmanagerConfig#summary}
  */
  readonly summary?: string;
  /**
  * Message body template.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#text AlertmanagerConfig#text}
  */
  readonly text?: string;
  /**
  * Message title template.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#title AlertmanagerConfig#title}
  */
  readonly title?: string;
  /**
  * The incoming webhook URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#webhook_url AlertmanagerConfig#webhook_url}
  */
  readonly webhookUrl?: string;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigReceiverMsteamsConfigsHttpConfig;
}

export function alertmanagerConfigReceiverMsteamsConfigsToTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    summary: cdktf.stringToTerraform(struct!.summary),
    text: cdktf.stringToTerraform(struct!.text),
    title: cdktf.stringToTerraform(struct!.title),
    webhook_url: cdktf.stringToTerraform(struct!.webhookUrl),
    http_config: alertmanagerConfigReceiverMsteamsConfigsHttpConfigToTerraform(struct!.httpConfig),
  }
}


export function alertmanagerConfigReceiverMsteamsConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverMsteamsConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    summary: {
      value: cdktf.stringToHclTerraform(struct!.summary),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    title: {
      value: cdktf.stringToHclTerraform(struct!.title),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    webhook_url: {
      value: cdktf.stringToHclTerraform(struct!.webhookUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_config: {
      value: alertmanagerConfigReceiverMsteamsConfigsHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverMsteamsConfigsHttpConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverMsteamsConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverMsteamsConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._summary !== undefined) {
      hasAnyValues = true;
      internalValueResult.summary = this._summary;
    }
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    if (this._title !== undefined) {
      hasAnyValues = true;
      internalValueResult.title = this._title;
    }
    if (this._webhookUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.webhookUrl = this._webhookUrl;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverMsteamsConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sendResolved = undefined;
      this._summary = undefined;
      this._text = undefined;
      this._title = undefined;
      this._webhookUrl = undefined;
      this._httpConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sendResolved = value.sendResolved;
      this._summary = value.summary;
      this._text = value.text;
      this._title = value.title;
      this._webhookUrl = value.webhookUrl;
      this._httpConfig.internalValue = value.httpConfig;
    }
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // summary - computed: false, optional: true, required: false
  private _summary?: string; 
  public get summary() {
    return this.getStringAttribute('summary');
  }
  public set summary(value: string) {
    this._summary = value;
  }
  public resetSummary() {
    this._summary = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get summaryInput() {
    return this._summary;
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }

  // title - computed: false, optional: true, required: false
  private _title?: string; 
  public get title() {
    return this.getStringAttribute('title');
  }
  public set title(value: string) {
    this._title = value;
  }
  public resetTitle() {
    this._title = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get titleInput() {
    return this._title;
  }

  // webhook_url - computed: false, optional: true, required: false
  private _webhookUrl?: string; 
  public get webhookUrl() {
    return this.getStringAttribute('webhook_url');
  }
  public set webhookUrl(value: string) {
    this._webhookUrl = value;
  }
  public resetWebhookUrl() {
    this._webhookUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webhookUrlInput() {
    return this._webhookUrl;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigReceiverMsteamsConfigsHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigReceiverMsteamsConfigsHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }
}

export class AlertmanagerConfigReceiverMsteamsConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverMsteamsConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverMsteamsConfigsOutputReference {
    return new AlertmanagerConfigReceiverMsteamsConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverOpsgenieConfigsHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfig;
}

export function alertmanagerConfigReceiverOpsgenieConfigsHttpConfigToTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverOpsgenieConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverOpsgenieConfigsHttpConfigToHclTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverOpsgenieConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverOpsgenieConfigsHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverOpsgenieConfigsResponders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#id AlertmanagerConfig#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#name AlertmanagerConfig#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverOpsgenieConfigsRespondersToTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsResponders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverOpsgenieConfigsRespondersToHclTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigsResponders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverOpsgenieConfigsRespondersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverOpsgenieConfigsResponders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverOpsgenieConfigsResponders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._name = undefined;
      this._type = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._name = value.name;
      this._type = value.type;
      this._username = value.username;
    }
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}

export class AlertmanagerConfigReceiverOpsgenieConfigsRespondersList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverOpsgenieConfigsResponders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverOpsgenieConfigsRespondersOutputReference {
    return new AlertmanagerConfigReceiverOpsgenieConfigsRespondersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverOpsgenieConfigs {
  /**
  * Comma separated list of actions that will be available for the alert.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#actions AlertmanagerConfig#actions}
  */
  readonly actions?: string;
  /**
  * The API key to use when talking to the OpsGenie API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#api_key AlertmanagerConfig#api_key}
  */
  readonly apiKey?: string;
  /**
  * The host to send OpsGenie API requests to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#api_url AlertmanagerConfig#api_url}
  */
  readonly apiUrl?: string;
  /**
  * A description of the alert.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#description AlertmanagerConfig#description}
  */
  readonly description?: string;
  /**
  * A set of arbitrary key/value pairs that provide further detail about the alert. All common labels are included as details by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#details AlertmanagerConfig#details}
  */
  readonly details?: { [key: string]: string };
  /**
  * Optional field that can be used to specify which domain alert is related to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#entity AlertmanagerConfig#entity}
  */
  readonly entity?: string;
  /**
  * Alert text limited to 130 characters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#message AlertmanagerConfig#message}
  */
  readonly message?: string;
  /**
  * Additional alert note.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#note AlertmanagerConfig#note}
  */
  readonly note?: string;
  /**
  * Priority level of alert. Possible values are P1, P2, P3, P4, and P5.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#priority AlertmanagerConfig#priority}
  */
  readonly priority?: string;
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * A backlink to the sender of the notification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#source AlertmanagerConfig#source}
  */
  readonly source?: string;
  /**
  * Comma separated list of tags attached to the notifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tags AlertmanagerConfig#tags}
  */
  readonly tags?: string;
  /**
  * Whether to update message and description of the alert in OpsGenie if it already exists. By default, the alert is never updated in OpsGenie, the new message only appears in activity log.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#update_alerts AlertmanagerConfig#update_alerts}
  */
  readonly updateAlerts?: boolean | cdktf.IResolvable;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfig;
  /**
  * responders block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#responders AlertmanagerConfig#responders}
  */
  readonly responders?: AlertmanagerConfigReceiverOpsgenieConfigsResponders[] | cdktf.IResolvable;
}

export function alertmanagerConfigReceiverOpsgenieConfigsToTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    actions: cdktf.stringToTerraform(struct!.actions),
    api_key: cdktf.stringToTerraform(struct!.apiKey),
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    description: cdktf.stringToTerraform(struct!.description),
    details: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.details),
    entity: cdktf.stringToTerraform(struct!.entity),
    message: cdktf.stringToTerraform(struct!.message),
    note: cdktf.stringToTerraform(struct!.note),
    priority: cdktf.stringToTerraform(struct!.priority),
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    source: cdktf.stringToTerraform(struct!.source),
    tags: cdktf.stringToTerraform(struct!.tags),
    update_alerts: cdktf.booleanToTerraform(struct!.updateAlerts),
    http_config: alertmanagerConfigReceiverOpsgenieConfigsHttpConfigToTerraform(struct!.httpConfig),
    responders: cdktf.listMapper(alertmanagerConfigReceiverOpsgenieConfigsRespondersToTerraform, true)(struct!.responders),
  }
}


export function alertmanagerConfigReceiverOpsgenieConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverOpsgenieConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    actions: {
      value: cdktf.stringToHclTerraform(struct!.actions),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_key: {
      value: cdktf.stringToHclTerraform(struct!.apiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    details: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.details),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    entity: {
      value: cdktf.stringToHclTerraform(struct!.entity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    note: {
      value: cdktf.stringToHclTerraform(struct!.note),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priority: {
      value: cdktf.stringToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.stringToHclTerraform(struct!.tags),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    update_alerts: {
      value: cdktf.booleanToHclTerraform(struct!.updateAlerts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    http_config: {
      value: alertmanagerConfigReceiverOpsgenieConfigsHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigList",
    },
    responders: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverOpsgenieConfigsRespondersToHclTerraform, true)(struct!.responders),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverOpsgenieConfigsRespondersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverOpsgenieConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverOpsgenieConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actions !== undefined) {
      hasAnyValues = true;
      internalValueResult.actions = this._actions;
    }
    if (this._apiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey;
    }
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._details !== undefined) {
      hasAnyValues = true;
      internalValueResult.details = this._details;
    }
    if (this._entity !== undefined) {
      hasAnyValues = true;
      internalValueResult.entity = this._entity;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._note !== undefined) {
      hasAnyValues = true;
      internalValueResult.note = this._note;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._updateAlerts !== undefined) {
      hasAnyValues = true;
      internalValueResult.updateAlerts = this._updateAlerts;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    if (this._responders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responders = this._responders?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverOpsgenieConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actions = undefined;
      this._apiKey = undefined;
      this._apiUrl = undefined;
      this._description = undefined;
      this._details = undefined;
      this._entity = undefined;
      this._message = undefined;
      this._note = undefined;
      this._priority = undefined;
      this._sendResolved = undefined;
      this._source = undefined;
      this._tags = undefined;
      this._updateAlerts = undefined;
      this._httpConfig.internalValue = undefined;
      this._responders.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actions = value.actions;
      this._apiKey = value.apiKey;
      this._apiUrl = value.apiUrl;
      this._description = value.description;
      this._details = value.details;
      this._entity = value.entity;
      this._message = value.message;
      this._note = value.note;
      this._priority = value.priority;
      this._sendResolved = value.sendResolved;
      this._source = value.source;
      this._tags = value.tags;
      this._updateAlerts = value.updateAlerts;
      this._httpConfig.internalValue = value.httpConfig;
      this._responders.internalValue = value.responders;
    }
  }

  // actions - computed: false, optional: true, required: false
  private _actions?: string; 
  public get actions() {
    return this.getStringAttribute('actions');
  }
  public set actions(value: string) {
    this._actions = value;
  }
  public resetActions() {
    this._actions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionsInput() {
    return this._actions;
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey?: string; 
  public get apiKey() {
    return this.getStringAttribute('api_key');
  }
  public set apiKey(value: string) {
    this._apiKey = value;
  }
  public resetApiKey() {
    this._apiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey;
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // details - computed: false, optional: true, required: false
  private _details?: { [key: string]: string }; 
  public get details() {
    return this.getStringMapAttribute('details');
  }
  public set details(value: { [key: string]: string }) {
    this._details = value;
  }
  public resetDetails() {
    this._details = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailsInput() {
    return this._details;
  }

  // entity - computed: false, optional: true, required: false
  private _entity?: string; 
  public get entity() {
    return this.getStringAttribute('entity');
  }
  public set entity(value: string) {
    this._entity = value;
  }
  public resetEntity() {
    this._entity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entityInput() {
    return this._entity;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // note - computed: false, optional: true, required: false
  private _note?: string; 
  public get note() {
    return this.getStringAttribute('note');
  }
  public set note(value: string) {
    this._note = value;
  }
  public resetNote() {
    this._note = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noteInput() {
    return this._note;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: string; 
  public get priority() {
    return this.getStringAttribute('priority');
  }
  public set priority(value: string) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // source - computed: false, optional: true, required: false
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  public resetSource() {
    this._source = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: string; 
  public get tags() {
    return this.getStringAttribute('tags');
  }
  public set tags(value: string) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // update_alerts - computed: false, optional: true, required: false
  private _updateAlerts?: boolean | cdktf.IResolvable; 
  public get updateAlerts() {
    return this.getBooleanAttribute('update_alerts');
  }
  public set updateAlerts(value: boolean | cdktf.IResolvable) {
    this._updateAlerts = value;
  }
  public resetUpdateAlerts() {
    this._updateAlerts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateAlertsInput() {
    return this._updateAlerts;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigReceiverOpsgenieConfigsHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigReceiverOpsgenieConfigsHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }

  // responders - computed: false, optional: true, required: false
  private _responders = new AlertmanagerConfigReceiverOpsgenieConfigsRespondersList(this, "responders", false);
  public get responders() {
    return this._responders;
  }
  public putResponders(value: AlertmanagerConfigReceiverOpsgenieConfigsResponders[] | cdktf.IResolvable) {
    this._responders.internalValue = value;
  }
  public resetResponders() {
    this._responders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get respondersInput() {
    return this._responders.internalValue;
  }
}

export class AlertmanagerConfigReceiverOpsgenieConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverOpsgenieConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverOpsgenieConfigsOutputReference {
    return new AlertmanagerConfigReceiverOpsgenieConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverPagerdutyConfigsHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfig;
}

export function alertmanagerConfigReceiverPagerdutyConfigsHttpConfigToTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverPagerdutyConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverPagerdutyConfigsHttpConfigToHclTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverPagerdutyConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverPagerdutyConfigsHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverPagerdutyConfigsImages {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#alt AlertmanagerConfig#alt}
  */
  readonly alt?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#href AlertmanagerConfig#href}
  */
  readonly href?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#src AlertmanagerConfig#src}
  */
  readonly src?: string;
}

export function alertmanagerConfigReceiverPagerdutyConfigsImagesToTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsImages | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    alt: cdktf.stringToTerraform(struct!.alt),
    href: cdktf.stringToTerraform(struct!.href),
    src: cdktf.stringToTerraform(struct!.src),
  }
}


export function alertmanagerConfigReceiverPagerdutyConfigsImagesToHclTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsImages | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    alt: {
      value: cdktf.stringToHclTerraform(struct!.alt),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    href: {
      value: cdktf.stringToHclTerraform(struct!.href),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    src: {
      value: cdktf.stringToHclTerraform(struct!.src),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPagerdutyConfigsImagesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverPagerdutyConfigsImages | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._alt !== undefined) {
      hasAnyValues = true;
      internalValueResult.alt = this._alt;
    }
    if (this._href !== undefined) {
      hasAnyValues = true;
      internalValueResult.href = this._href;
    }
    if (this._src !== undefined) {
      hasAnyValues = true;
      internalValueResult.src = this._src;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPagerdutyConfigsImages | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._alt = undefined;
      this._href = undefined;
      this._src = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._alt = value.alt;
      this._href = value.href;
      this._src = value.src;
    }
  }

  // alt - computed: false, optional: true, required: false
  private _alt?: string; 
  public get alt() {
    return this.getStringAttribute('alt');
  }
  public set alt(value: string) {
    this._alt = value;
  }
  public resetAlt() {
    this._alt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get altInput() {
    return this._alt;
  }

  // href - computed: false, optional: true, required: false
  private _href?: string; 
  public get href() {
    return this.getStringAttribute('href');
  }
  public set href(value: string) {
    this._href = value;
  }
  public resetHref() {
    this._href = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hrefInput() {
    return this._href;
  }

  // src - computed: false, optional: true, required: false
  private _src?: string; 
  public get src() {
    return this.getStringAttribute('src');
  }
  public set src(value: string) {
    this._src = value;
  }
  public resetSrc() {
    this._src = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get srcInput() {
    return this._src;
  }
}

export class AlertmanagerConfigReceiverPagerdutyConfigsImagesList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverPagerdutyConfigsImages[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverPagerdutyConfigsImagesOutputReference {
    return new AlertmanagerConfigReceiverPagerdutyConfigsImagesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverPagerdutyConfigsLinks {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#href AlertmanagerConfig#href}
  */
  readonly href?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#text AlertmanagerConfig#text}
  */
  readonly text?: string;
}

export function alertmanagerConfigReceiverPagerdutyConfigsLinksToTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsLinks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    href: cdktf.stringToTerraform(struct!.href),
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function alertmanagerConfigReceiverPagerdutyConfigsLinksToHclTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigsLinks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    href: {
      value: cdktf.stringToHclTerraform(struct!.href),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPagerdutyConfigsLinksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverPagerdutyConfigsLinks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._href !== undefined) {
      hasAnyValues = true;
      internalValueResult.href = this._href;
    }
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPagerdutyConfigsLinks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._href = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._href = value.href;
      this._text = value.text;
    }
  }

  // href - computed: false, optional: true, required: false
  private _href?: string; 
  public get href() {
    return this.getStringAttribute('href');
  }
  public set href(value: string) {
    this._href = value;
  }
  public resetHref() {
    this._href = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hrefInput() {
    return this._href;
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}

export class AlertmanagerConfigReceiverPagerdutyConfigsLinksList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverPagerdutyConfigsLinks[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverPagerdutyConfigsLinksOutputReference {
    return new AlertmanagerConfigReceiverPagerdutyConfigsLinksOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverPagerdutyConfigs {
  /**
  * The class/type of the event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#class AlertmanagerConfig#class}
  */
  readonly class?: string;
  /**
  * The client identification of the Alertmanager.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client AlertmanagerConfig#client}
  */
  readonly client?: string;
  /**
  * A backlink to the sender of the notification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_url AlertmanagerConfig#client_url}
  */
  readonly clientUrl?: string;
  /**
  * The part or component of the affected system that is broken.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#component AlertmanagerConfig#component}
  */
  readonly component?: string;
  /**
  * A description of the incident.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#description AlertmanagerConfig#description}
  */
  readonly description?: string;
  /**
  * A set of arbitrary key/value pairs that provide further detail about the incident.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#details AlertmanagerConfig#details}
  */
  readonly details?: { [key: string]: string };
  /**
  * A cluster or grouping of sources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group AlertmanagerConfig#group}
  */
  readonly group?: string;
  /**
  * The PagerDuty integration key (when using PagerDuty integration type `Events API v2`).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#routing_key AlertmanagerConfig#routing_key}
  */
  readonly routingKey?: string;
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * The PagerDuty integration key (when using PagerDuty integration type `Prometheus`).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#service_key AlertmanagerConfig#service_key}
  */
  readonly serviceKey?: string;
  /**
  * Severity of the incident.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#severity AlertmanagerConfig#severity}
  */
  readonly severity?: string;
  /**
  * The URL to send API requests to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#url AlertmanagerConfig#url}
  */
  readonly url?: string;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfig;
  /**
  * images block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#images AlertmanagerConfig#images}
  */
  readonly images?: AlertmanagerConfigReceiverPagerdutyConfigsImages[] | cdktf.IResolvable;
  /**
  * links block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#links AlertmanagerConfig#links}
  */
  readonly links?: AlertmanagerConfigReceiverPagerdutyConfigsLinks[] | cdktf.IResolvable;
}

export function alertmanagerConfigReceiverPagerdutyConfigsToTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    class: cdktf.stringToTerraform(struct!.class),
    client: cdktf.stringToTerraform(struct!.client),
    client_url: cdktf.stringToTerraform(struct!.clientUrl),
    component: cdktf.stringToTerraform(struct!.component),
    description: cdktf.stringToTerraform(struct!.description),
    details: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.details),
    group: cdktf.stringToTerraform(struct!.group),
    routing_key: cdktf.stringToTerraform(struct!.routingKey),
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    service_key: cdktf.stringToTerraform(struct!.serviceKey),
    severity: cdktf.stringToTerraform(struct!.severity),
    url: cdktf.stringToTerraform(struct!.url),
    http_config: alertmanagerConfigReceiverPagerdutyConfigsHttpConfigToTerraform(struct!.httpConfig),
    images: cdktf.listMapper(alertmanagerConfigReceiverPagerdutyConfigsImagesToTerraform, true)(struct!.images),
    links: cdktf.listMapper(alertmanagerConfigReceiverPagerdutyConfigsLinksToTerraform, true)(struct!.links),
  }
}


export function alertmanagerConfigReceiverPagerdutyConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverPagerdutyConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    class: {
      value: cdktf.stringToHclTerraform(struct!.class),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client: {
      value: cdktf.stringToHclTerraform(struct!.client),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_url: {
      value: cdktf.stringToHclTerraform(struct!.clientUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    component: {
      value: cdktf.stringToHclTerraform(struct!.component),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    details: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.details),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    routing_key: {
      value: cdktf.stringToHclTerraform(struct!.routingKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    service_key: {
      value: cdktf.stringToHclTerraform(struct!.serviceKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    severity: {
      value: cdktf.stringToHclTerraform(struct!.severity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_config: {
      value: alertmanagerConfigReceiverPagerdutyConfigsHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigList",
    },
    images: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverPagerdutyConfigsImagesToHclTerraform, true)(struct!.images),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPagerdutyConfigsImagesList",
    },
    links: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverPagerdutyConfigsLinksToHclTerraform, true)(struct!.links),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPagerdutyConfigsLinksList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPagerdutyConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverPagerdutyConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._class !== undefined) {
      hasAnyValues = true;
      internalValueResult.class = this._class;
    }
    if (this._client !== undefined) {
      hasAnyValues = true;
      internalValueResult.client = this._client;
    }
    if (this._clientUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientUrl = this._clientUrl;
    }
    if (this._component !== undefined) {
      hasAnyValues = true;
      internalValueResult.component = this._component;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._details !== undefined) {
      hasAnyValues = true;
      internalValueResult.details = this._details;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._routingKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.routingKey = this._routingKey;
    }
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._serviceKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceKey = this._serviceKey;
    }
    if (this._severity !== undefined) {
      hasAnyValues = true;
      internalValueResult.severity = this._severity;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    if (this._images?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.images = this._images?.internalValue;
    }
    if (this._links?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.links = this._links?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPagerdutyConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._class = undefined;
      this._client = undefined;
      this._clientUrl = undefined;
      this._component = undefined;
      this._description = undefined;
      this._details = undefined;
      this._group = undefined;
      this._routingKey = undefined;
      this._sendResolved = undefined;
      this._serviceKey = undefined;
      this._severity = undefined;
      this._url = undefined;
      this._httpConfig.internalValue = undefined;
      this._images.internalValue = undefined;
      this._links.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._class = value.class;
      this._client = value.client;
      this._clientUrl = value.clientUrl;
      this._component = value.component;
      this._description = value.description;
      this._details = value.details;
      this._group = value.group;
      this._routingKey = value.routingKey;
      this._sendResolved = value.sendResolved;
      this._serviceKey = value.serviceKey;
      this._severity = value.severity;
      this._url = value.url;
      this._httpConfig.internalValue = value.httpConfig;
      this._images.internalValue = value.images;
      this._links.internalValue = value.links;
    }
  }

  // class - computed: false, optional: true, required: false
  private _class?: string; 
  public get class() {
    return this.getStringAttribute('class');
  }
  public set class(value: string) {
    this._class = value;
  }
  public resetClass() {
    this._class = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get classInput() {
    return this._class;
  }

  // client - computed: false, optional: true, required: false
  private _client?: string; 
  public get client() {
    return this.getStringAttribute('client');
  }
  public set client(value: string) {
    this._client = value;
  }
  public resetClient() {
    this._client = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientInput() {
    return this._client;
  }

  // client_url - computed: false, optional: true, required: false
  private _clientUrl?: string; 
  public get clientUrl() {
    return this.getStringAttribute('client_url');
  }
  public set clientUrl(value: string) {
    this._clientUrl = value;
  }
  public resetClientUrl() {
    this._clientUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientUrlInput() {
    return this._clientUrl;
  }

  // component - computed: false, optional: true, required: false
  private _component?: string; 
  public get component() {
    return this.getStringAttribute('component');
  }
  public set component(value: string) {
    this._component = value;
  }
  public resetComponent() {
    this._component = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get componentInput() {
    return this._component;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // details - computed: false, optional: true, required: false
  private _details?: { [key: string]: string }; 
  public get details() {
    return this.getStringMapAttribute('details');
  }
  public set details(value: { [key: string]: string }) {
    this._details = value;
  }
  public resetDetails() {
    this._details = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailsInput() {
    return this._details;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // routing_key - computed: false, optional: true, required: false
  private _routingKey?: string; 
  public get routingKey() {
    return this.getStringAttribute('routing_key');
  }
  public set routingKey(value: string) {
    this._routingKey = value;
  }
  public resetRoutingKey() {
    this._routingKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routingKeyInput() {
    return this._routingKey;
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // service_key - computed: false, optional: true, required: false
  private _serviceKey?: string; 
  public get serviceKey() {
    return this.getStringAttribute('service_key');
  }
  public set serviceKey(value: string) {
    this._serviceKey = value;
  }
  public resetServiceKey() {
    this._serviceKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceKeyInput() {
    return this._serviceKey;
  }

  // severity - computed: false, optional: true, required: false
  private _severity?: string; 
  public get severity() {
    return this.getStringAttribute('severity');
  }
  public set severity(value: string) {
    this._severity = value;
  }
  public resetSeverity() {
    this._severity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityInput() {
    return this._severity;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigReceiverPagerdutyConfigsHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigReceiverPagerdutyConfigsHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }

  // images - computed: false, optional: true, required: false
  private _images = new AlertmanagerConfigReceiverPagerdutyConfigsImagesList(this, "images", false);
  public get images() {
    return this._images;
  }
  public putImages(value: AlertmanagerConfigReceiverPagerdutyConfigsImages[] | cdktf.IResolvable) {
    this._images.internalValue = value;
  }
  public resetImages() {
    this._images.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagesInput() {
    return this._images.internalValue;
  }

  // links - computed: false, optional: true, required: false
  private _links = new AlertmanagerConfigReceiverPagerdutyConfigsLinksList(this, "links", false);
  public get links() {
    return this._links;
  }
  public putLinks(value: AlertmanagerConfigReceiverPagerdutyConfigsLinks[] | cdktf.IResolvable) {
    this._links.internalValue = value;
  }
  public resetLinks() {
    this._links.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get linksInput() {
    return this._links.internalValue;
  }
}

export class AlertmanagerConfigReceiverPagerdutyConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverPagerdutyConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverPagerdutyConfigsOutputReference {
    return new AlertmanagerConfigReceiverPagerdutyConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverPushoverConfigsHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfig;
}

export function alertmanagerConfigReceiverPushoverConfigsHttpConfigToTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverPushoverConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverPushoverConfigsHttpConfigToHclTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverPushoverConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPushoverConfigsHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverPushoverConfigsHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPushoverConfigsHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigReceiverPushoverConfigsHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigReceiverPushoverConfigsHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigReceiverPushoverConfigsHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverPushoverConfigsHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverPushoverConfigs {
  /**
  * How long your notification will continue to be retried for, unless the user acknowledges the notification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#expire AlertmanagerConfig#expire}
  */
  readonly expire?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#html AlertmanagerConfig#html}
  */
  readonly html?: boolean | cdktf.IResolvable;
  /**
  * Notification message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#message AlertmanagerConfig#message}
  */
  readonly message?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#priority AlertmanagerConfig#priority}
  */
  readonly priority?: string;
  /**
  * How often the Pushover servers will send the same notification to the user.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#retry AlertmanagerConfig#retry}
  */
  readonly retry?: string;
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#sound AlertmanagerConfig#sound}
  */
  readonly sound?: string;
  /**
  * Notification title.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#title AlertmanagerConfig#title}
  */
  readonly title?: string;
  /**
  * The registered application's API token.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token AlertmanagerConfig#token}
  */
  readonly token?: string;
  /**
  *  A supplementary URL shown alongside the message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#url AlertmanagerConfig#url}
  */
  readonly url?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#url_title AlertmanagerConfig#url_title}
  */
  readonly urlTitle?: string;
  /**
  * The recipient user's user key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#user_key AlertmanagerConfig#user_key}
  */
  readonly userKey?: string;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigReceiverPushoverConfigsHttpConfig;
}

export function alertmanagerConfigReceiverPushoverConfigsToTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expire: cdktf.stringToTerraform(struct!.expire),
    html: cdktf.booleanToTerraform(struct!.html),
    message: cdktf.stringToTerraform(struct!.message),
    priority: cdktf.stringToTerraform(struct!.priority),
    retry: cdktf.stringToTerraform(struct!.retry),
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    sound: cdktf.stringToTerraform(struct!.sound),
    title: cdktf.stringToTerraform(struct!.title),
    token: cdktf.stringToTerraform(struct!.token),
    url: cdktf.stringToTerraform(struct!.url),
    url_title: cdktf.stringToTerraform(struct!.urlTitle),
    user_key: cdktf.stringToTerraform(struct!.userKey),
    http_config: alertmanagerConfigReceiverPushoverConfigsHttpConfigToTerraform(struct!.httpConfig),
  }
}


export function alertmanagerConfigReceiverPushoverConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverPushoverConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expire: {
      value: cdktf.stringToHclTerraform(struct!.expire),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    html: {
      value: cdktf.booleanToHclTerraform(struct!.html),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priority: {
      value: cdktf.stringToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    retry: {
      value: cdktf.stringToHclTerraform(struct!.retry),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sound: {
      value: cdktf.stringToHclTerraform(struct!.sound),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    title: {
      value: cdktf.stringToHclTerraform(struct!.title),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url_title: {
      value: cdktf.stringToHclTerraform(struct!.urlTitle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_key: {
      value: cdktf.stringToHclTerraform(struct!.userKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_config: {
      value: alertmanagerConfigReceiverPushoverConfigsHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPushoverConfigsHttpConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverPushoverConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverPushoverConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expire !== undefined) {
      hasAnyValues = true;
      internalValueResult.expire = this._expire;
    }
    if (this._html !== undefined) {
      hasAnyValues = true;
      internalValueResult.html = this._html;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._retry !== undefined) {
      hasAnyValues = true;
      internalValueResult.retry = this._retry;
    }
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._sound !== undefined) {
      hasAnyValues = true;
      internalValueResult.sound = this._sound;
    }
    if (this._title !== undefined) {
      hasAnyValues = true;
      internalValueResult.title = this._title;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._urlTitle !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlTitle = this._urlTitle;
    }
    if (this._userKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.userKey = this._userKey;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverPushoverConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expire = undefined;
      this._html = undefined;
      this._message = undefined;
      this._priority = undefined;
      this._retry = undefined;
      this._sendResolved = undefined;
      this._sound = undefined;
      this._title = undefined;
      this._token = undefined;
      this._url = undefined;
      this._urlTitle = undefined;
      this._userKey = undefined;
      this._httpConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expire = value.expire;
      this._html = value.html;
      this._message = value.message;
      this._priority = value.priority;
      this._retry = value.retry;
      this._sendResolved = value.sendResolved;
      this._sound = value.sound;
      this._title = value.title;
      this._token = value.token;
      this._url = value.url;
      this._urlTitle = value.urlTitle;
      this._userKey = value.userKey;
      this._httpConfig.internalValue = value.httpConfig;
    }
  }

  // expire - computed: false, optional: true, required: false
  private _expire?: string; 
  public get expire() {
    return this.getStringAttribute('expire');
  }
  public set expire(value: string) {
    this._expire = value;
  }
  public resetExpire() {
    this._expire = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expireInput() {
    return this._expire;
  }

  // html - computed: false, optional: true, required: false
  private _html?: boolean | cdktf.IResolvable; 
  public get html() {
    return this.getBooleanAttribute('html');
  }
  public set html(value: boolean | cdktf.IResolvable) {
    this._html = value;
  }
  public resetHtml() {
    this._html = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get htmlInput() {
    return this._html;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: string; 
  public get priority() {
    return this.getStringAttribute('priority');
  }
  public set priority(value: string) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // retry - computed: false, optional: true, required: false
  private _retry?: string; 
  public get retry() {
    return this.getStringAttribute('retry');
  }
  public set retry(value: string) {
    this._retry = value;
  }
  public resetRetry() {
    this._retry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryInput() {
    return this._retry;
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // sound - computed: false, optional: true, required: false
  private _sound?: string; 
  public get sound() {
    return this.getStringAttribute('sound');
  }
  public set sound(value: string) {
    this._sound = value;
  }
  public resetSound() {
    this._sound = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get soundInput() {
    return this._sound;
  }

  // title - computed: false, optional: true, required: false
  private _title?: string; 
  public get title() {
    return this.getStringAttribute('title');
  }
  public set title(value: string) {
    this._title = value;
  }
  public resetTitle() {
    this._title = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get titleInput() {
    return this._title;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // url_title - computed: false, optional: true, required: false
  private _urlTitle?: string; 
  public get urlTitle() {
    return this.getStringAttribute('url_title');
  }
  public set urlTitle(value: string) {
    this._urlTitle = value;
  }
  public resetUrlTitle() {
    this._urlTitle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlTitleInput() {
    return this._urlTitle;
  }

  // user_key - computed: false, optional: true, required: false
  private _userKey?: string; 
  public get userKey() {
    return this.getStringAttribute('user_key');
  }
  public set userKey(value: string) {
    this._userKey = value;
  }
  public resetUserKey() {
    this._userKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userKeyInput() {
    return this._userKey;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigReceiverPushoverConfigsHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigReceiverPushoverConfigsHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }
}

export class AlertmanagerConfigReceiverPushoverConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverPushoverConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverPushoverConfigsOutputReference {
    return new AlertmanagerConfigReceiverPushoverConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverSlackConfigsActionsConfirm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#dismiss_text AlertmanagerConfig#dismiss_text}
  */
  readonly dismissText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#ok_text AlertmanagerConfig#ok_text}
  */
  readonly okText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#text AlertmanagerConfig#text}
  */
  readonly text?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#title AlertmanagerConfig#title}
  */
  readonly title?: string;
}

export function alertmanagerConfigReceiverSlackConfigsActionsConfirmToTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsActionsConfirmOutputReference | AlertmanagerConfigReceiverSlackConfigsActionsConfirm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dismiss_text: cdktf.stringToTerraform(struct!.dismissText),
    ok_text: cdktf.stringToTerraform(struct!.okText),
    text: cdktf.stringToTerraform(struct!.text),
    title: cdktf.stringToTerraform(struct!.title),
  }
}


export function alertmanagerConfigReceiverSlackConfigsActionsConfirmToHclTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsActionsConfirmOutputReference | AlertmanagerConfigReceiverSlackConfigsActionsConfirm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dismiss_text: {
      value: cdktf.stringToHclTerraform(struct!.dismissText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ok_text: {
      value: cdktf.stringToHclTerraform(struct!.okText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    title: {
      value: cdktf.stringToHclTerraform(struct!.title),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSlackConfigsActionsConfirmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSlackConfigsActionsConfirm | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dismissText !== undefined) {
      hasAnyValues = true;
      internalValueResult.dismissText = this._dismissText;
    }
    if (this._okText !== undefined) {
      hasAnyValues = true;
      internalValueResult.okText = this._okText;
    }
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    if (this._title !== undefined) {
      hasAnyValues = true;
      internalValueResult.title = this._title;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSlackConfigsActionsConfirm | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._dismissText = undefined;
      this._okText = undefined;
      this._text = undefined;
      this._title = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._dismissText = value.dismissText;
      this._okText = value.okText;
      this._text = value.text;
      this._title = value.title;
    }
  }

  // dismiss_text - computed: false, optional: true, required: false
  private _dismissText?: string; 
  public get dismissText() {
    return this.getStringAttribute('dismiss_text');
  }
  public set dismissText(value: string) {
    this._dismissText = value;
  }
  public resetDismissText() {
    this._dismissText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dismissTextInput() {
    return this._dismissText;
  }

  // ok_text - computed: false, optional: true, required: false
  private _okText?: string; 
  public get okText() {
    return this.getStringAttribute('ok_text');
  }
  public set okText(value: string) {
    this._okText = value;
  }
  public resetOkText() {
    this._okText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get okTextInput() {
    return this._okText;
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }

  // title - computed: false, optional: true, required: false
  private _title?: string; 
  public get title() {
    return this.getStringAttribute('title');
  }
  public set title(value: string) {
    this._title = value;
  }
  public resetTitle() {
    this._title = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get titleInput() {
    return this._title;
  }
}
export interface AlertmanagerConfigReceiverSlackConfigsActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#name AlertmanagerConfig#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#style AlertmanagerConfig#style}
  */
  readonly style?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#text AlertmanagerConfig#text}
  */
  readonly text?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#url AlertmanagerConfig#url}
  */
  readonly url?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#value AlertmanagerConfig#value}
  */
  readonly value?: string;
  /**
  * confirm block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#confirm AlertmanagerConfig#confirm}
  */
  readonly confirm?: AlertmanagerConfigReceiverSlackConfigsActionsConfirm;
}

export function alertmanagerConfigReceiverSlackConfigsActionsToTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    style: cdktf.stringToTerraform(struct!.style),
    text: cdktf.stringToTerraform(struct!.text),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    value: cdktf.stringToTerraform(struct!.value),
    confirm: alertmanagerConfigReceiverSlackConfigsActionsConfirmToTerraform(struct!.confirm),
  }
}


export function alertmanagerConfigReceiverSlackConfigsActionsToHclTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    style: {
      value: cdktf.stringToHclTerraform(struct!.style),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    confirm: {
      value: alertmanagerConfigReceiverSlackConfigsActionsConfirmToHclTerraform(struct!.confirm),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSlackConfigsActionsConfirmList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSlackConfigsActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverSlackConfigsActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._style !== undefined) {
      hasAnyValues = true;
      internalValueResult.style = this._style;
    }
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._confirm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.confirm = this._confirm?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSlackConfigsActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._style = undefined;
      this._text = undefined;
      this._type = undefined;
      this._url = undefined;
      this._value = undefined;
      this._confirm.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._style = value.style;
      this._text = value.text;
      this._type = value.type;
      this._url = value.url;
      this._value = value.value;
      this._confirm.internalValue = value.confirm;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // style - computed: false, optional: true, required: false
  private _style?: string; 
  public get style() {
    return this.getStringAttribute('style');
  }
  public set style(value: string) {
    this._style = value;
  }
  public resetStyle() {
    this._style = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get styleInput() {
    return this._style;
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // confirm - computed: false, optional: true, required: false
  private _confirm = new AlertmanagerConfigReceiverSlackConfigsActionsConfirmOutputReference(this, "confirm");
  public get confirm() {
    return this._confirm;
  }
  public putConfirm(value: AlertmanagerConfigReceiverSlackConfigsActionsConfirm) {
    this._confirm.internalValue = value;
  }
  public resetConfirm() {
    this._confirm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get confirmInput() {
    return this._confirm.internalValue;
  }
}

export class AlertmanagerConfigReceiverSlackConfigsActionsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverSlackConfigsActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverSlackConfigsActionsOutputReference {
    return new AlertmanagerConfigReceiverSlackConfigsActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverSlackConfigsFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#short AlertmanagerConfig#short}
  */
  readonly short?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#title AlertmanagerConfig#title}
  */
  readonly title?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#value AlertmanagerConfig#value}
  */
  readonly value?: string;
}

export function alertmanagerConfigReceiverSlackConfigsFieldsToTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    short: cdktf.booleanToTerraform(struct!.short),
    title: cdktf.stringToTerraform(struct!.title),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function alertmanagerConfigReceiverSlackConfigsFieldsToHclTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    short: {
      value: cdktf.booleanToHclTerraform(struct!.short),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    title: {
      value: cdktf.stringToHclTerraform(struct!.title),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSlackConfigsFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverSlackConfigsFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._short !== undefined) {
      hasAnyValues = true;
      internalValueResult.short = this._short;
    }
    if (this._title !== undefined) {
      hasAnyValues = true;
      internalValueResult.title = this._title;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSlackConfigsFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._short = undefined;
      this._title = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._short = value.short;
      this._title = value.title;
      this._value = value.value;
    }
  }

  // short - computed: false, optional: true, required: false
  private _short?: boolean | cdktf.IResolvable; 
  public get short() {
    return this.getBooleanAttribute('short');
  }
  public set short(value: boolean | cdktf.IResolvable) {
    this._short = value;
  }
  public resetShort() {
    this._short = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shortInput() {
    return this._short;
  }

  // title - computed: false, optional: true, required: false
  private _title?: string; 
  public get title() {
    return this.getStringAttribute('title');
  }
  public set title(value: string) {
    this._title = value;
  }
  public resetTitle() {
    this._title = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get titleInput() {
    return this._title;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class AlertmanagerConfigReceiverSlackConfigsFieldsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverSlackConfigsFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverSlackConfigsFieldsOutputReference {
    return new AlertmanagerConfigReceiverSlackConfigsFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverSlackConfigsHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigReceiverSlackConfigsHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverSlackConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigReceiverSlackConfigsHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverSlackConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSlackConfigsHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSlackConfigsHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSlackConfigsHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigReceiverSlackConfigsHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverSlackConfigsHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverSlackConfigsHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigReceiverSlackConfigsHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfig;
}

export function alertmanagerConfigReceiverSlackConfigsHttpConfigToTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverSlackConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigReceiverSlackConfigsHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigReceiverSlackConfigsHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverSlackConfigsHttpConfigToHclTerraform(struct?: AlertmanagerConfigReceiverSlackConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverSlackConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigReceiverSlackConfigsHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSlackConfigsHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigReceiverSlackConfigsHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSlackConfigsHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSlackConfigsHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSlackConfigsHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigReceiverSlackConfigsHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigReceiverSlackConfigsHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigReceiverSlackConfigsHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigReceiverSlackConfigsHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverSlackConfigsHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverSlackConfigs {
  /**
  * The Slack webhook URL. Defaults to global settings if none are set here.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#api_url AlertmanagerConfig#api_url}
  */
  readonly apiUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#callback_id AlertmanagerConfig#callback_id}
  */
  readonly callbackId?: string;
  /**
  * The channel or user to send notifications to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#channel AlertmanagerConfig#channel}
  */
  readonly channel?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#color AlertmanagerConfig#color}
  */
  readonly color?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#fallback AlertmanagerConfig#fallback}
  */
  readonly fallback?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#footer AlertmanagerConfig#footer}
  */
  readonly footer?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#icon_emoji AlertmanagerConfig#icon_emoji}
  */
  readonly iconEmoji?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#icon_url AlertmanagerConfig#icon_url}
  */
  readonly iconUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#image_url AlertmanagerConfig#image_url}
  */
  readonly imageUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#link_names AlertmanagerConfig#link_names}
  */
  readonly linkNames?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#mrkdwn_in AlertmanagerConfig#mrkdwn_in}
  */
  readonly mrkdwnIn?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#pretext AlertmanagerConfig#pretext}
  */
  readonly pretext?: string;
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#short_fields AlertmanagerConfig#short_fields}
  */
  readonly shortFields?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#text AlertmanagerConfig#text}
  */
  readonly text?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#thumb_url AlertmanagerConfig#thumb_url}
  */
  readonly thumbUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#title AlertmanagerConfig#title}
  */
  readonly title?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#title_link AlertmanagerConfig#title_link}
  */
  readonly titleLink?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
  /**
  * actions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#actions AlertmanagerConfig#actions}
  */
  readonly actions?: AlertmanagerConfigReceiverSlackConfigsActions[] | cdktf.IResolvable;
  /**
  * fields block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#fields AlertmanagerConfig#fields}
  */
  readonly fields?: AlertmanagerConfigReceiverSlackConfigsFields[] | cdktf.IResolvable;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigReceiverSlackConfigsHttpConfig;
}

export function alertmanagerConfigReceiverSlackConfigsToTerraform(struct?: AlertmanagerConfigReceiverSlackConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    callback_id: cdktf.stringToTerraform(struct!.callbackId),
    channel: cdktf.stringToTerraform(struct!.channel),
    color: cdktf.stringToTerraform(struct!.color),
    fallback: cdktf.stringToTerraform(struct!.fallback),
    footer: cdktf.stringToTerraform(struct!.footer),
    icon_emoji: cdktf.stringToTerraform(struct!.iconEmoji),
    icon_url: cdktf.stringToTerraform(struct!.iconUrl),
    image_url: cdktf.stringToTerraform(struct!.imageUrl),
    link_names: cdktf.booleanToTerraform(struct!.linkNames),
    mrkdwn_in: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.mrkdwnIn),
    pretext: cdktf.stringToTerraform(struct!.pretext),
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    short_fields: cdktf.booleanToTerraform(struct!.shortFields),
    text: cdktf.stringToTerraform(struct!.text),
    thumb_url: cdktf.stringToTerraform(struct!.thumbUrl),
    title: cdktf.stringToTerraform(struct!.title),
    title_link: cdktf.stringToTerraform(struct!.titleLink),
    username: cdktf.stringToTerraform(struct!.username),
    actions: cdktf.listMapper(alertmanagerConfigReceiverSlackConfigsActionsToTerraform, true)(struct!.actions),
    fields: cdktf.listMapper(alertmanagerConfigReceiverSlackConfigsFieldsToTerraform, true)(struct!.fields),
    http_config: alertmanagerConfigReceiverSlackConfigsHttpConfigToTerraform(struct!.httpConfig),
  }
}


export function alertmanagerConfigReceiverSlackConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverSlackConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    callback_id: {
      value: cdktf.stringToHclTerraform(struct!.callbackId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    fallback: {
      value: cdktf.stringToHclTerraform(struct!.fallback),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    footer: {
      value: cdktf.stringToHclTerraform(struct!.footer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    icon_emoji: {
      value: cdktf.stringToHclTerraform(struct!.iconEmoji),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    icon_url: {
      value: cdktf.stringToHclTerraform(struct!.iconUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_url: {
      value: cdktf.stringToHclTerraform(struct!.imageUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    link_names: {
      value: cdktf.booleanToHclTerraform(struct!.linkNames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mrkdwn_in: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.mrkdwnIn),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    pretext: {
      value: cdktf.stringToHclTerraform(struct!.pretext),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    short_fields: {
      value: cdktf.booleanToHclTerraform(struct!.shortFields),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    thumb_url: {
      value: cdktf.stringToHclTerraform(struct!.thumbUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    title: {
      value: cdktf.stringToHclTerraform(struct!.title),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    title_link: {
      value: cdktf.stringToHclTerraform(struct!.titleLink),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    actions: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverSlackConfigsActionsToHclTerraform, true)(struct!.actions),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSlackConfigsActionsList",
    },
    fields: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverSlackConfigsFieldsToHclTerraform, true)(struct!.fields),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSlackConfigsFieldsList",
    },
    http_config: {
      value: alertmanagerConfigReceiverSlackConfigsHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSlackConfigsHttpConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSlackConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverSlackConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._callbackId !== undefined) {
      hasAnyValues = true;
      internalValueResult.callbackId = this._callbackId;
    }
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._fallback !== undefined) {
      hasAnyValues = true;
      internalValueResult.fallback = this._fallback;
    }
    if (this._footer !== undefined) {
      hasAnyValues = true;
      internalValueResult.footer = this._footer;
    }
    if (this._iconEmoji !== undefined) {
      hasAnyValues = true;
      internalValueResult.iconEmoji = this._iconEmoji;
    }
    if (this._iconUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.iconUrl = this._iconUrl;
    }
    if (this._imageUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageUrl = this._imageUrl;
    }
    if (this._linkNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.linkNames = this._linkNames;
    }
    if (this._mrkdwnIn !== undefined) {
      hasAnyValues = true;
      internalValueResult.mrkdwnIn = this._mrkdwnIn;
    }
    if (this._pretext !== undefined) {
      hasAnyValues = true;
      internalValueResult.pretext = this._pretext;
    }
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._shortFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.shortFields = this._shortFields;
    }
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    if (this._thumbUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.thumbUrl = this._thumbUrl;
    }
    if (this._title !== undefined) {
      hasAnyValues = true;
      internalValueResult.title = this._title;
    }
    if (this._titleLink !== undefined) {
      hasAnyValues = true;
      internalValueResult.titleLink = this._titleLink;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    if (this._actions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.actions = this._actions?.internalValue;
    }
    if (this._fields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields?.internalValue;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSlackConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiUrl = undefined;
      this._callbackId = undefined;
      this._channel = undefined;
      this._color = undefined;
      this._fallback = undefined;
      this._footer = undefined;
      this._iconEmoji = undefined;
      this._iconUrl = undefined;
      this._imageUrl = undefined;
      this._linkNames = undefined;
      this._mrkdwnIn = undefined;
      this._pretext = undefined;
      this._sendResolved = undefined;
      this._shortFields = undefined;
      this._text = undefined;
      this._thumbUrl = undefined;
      this._title = undefined;
      this._titleLink = undefined;
      this._username = undefined;
      this._actions.internalValue = undefined;
      this._fields.internalValue = undefined;
      this._httpConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiUrl = value.apiUrl;
      this._callbackId = value.callbackId;
      this._channel = value.channel;
      this._color = value.color;
      this._fallback = value.fallback;
      this._footer = value.footer;
      this._iconEmoji = value.iconEmoji;
      this._iconUrl = value.iconUrl;
      this._imageUrl = value.imageUrl;
      this._linkNames = value.linkNames;
      this._mrkdwnIn = value.mrkdwnIn;
      this._pretext = value.pretext;
      this._sendResolved = value.sendResolved;
      this._shortFields = value.shortFields;
      this._text = value.text;
      this._thumbUrl = value.thumbUrl;
      this._title = value.title;
      this._titleLink = value.titleLink;
      this._username = value.username;
      this._actions.internalValue = value.actions;
      this._fields.internalValue = value.fields;
      this._httpConfig.internalValue = value.httpConfig;
    }
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // callback_id - computed: false, optional: true, required: false
  private _callbackId?: string; 
  public get callbackId() {
    return this.getStringAttribute('callback_id');
  }
  public set callbackId(value: string) {
    this._callbackId = value;
  }
  public resetCallbackId() {
    this._callbackId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get callbackIdInput() {
    return this._callbackId;
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // fallback - computed: false, optional: true, required: false
  private _fallback?: string; 
  public get fallback() {
    return this.getStringAttribute('fallback');
  }
  public set fallback(value: string) {
    this._fallback = value;
  }
  public resetFallback() {
    this._fallback = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fallbackInput() {
    return this._fallback;
  }

  // footer - computed: false, optional: true, required: false
  private _footer?: string; 
  public get footer() {
    return this.getStringAttribute('footer');
  }
  public set footer(value: string) {
    this._footer = value;
  }
  public resetFooter() {
    this._footer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get footerInput() {
    return this._footer;
  }

  // icon_emoji - computed: false, optional: true, required: false
  private _iconEmoji?: string; 
  public get iconEmoji() {
    return this.getStringAttribute('icon_emoji');
  }
  public set iconEmoji(value: string) {
    this._iconEmoji = value;
  }
  public resetIconEmoji() {
    this._iconEmoji = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iconEmojiInput() {
    return this._iconEmoji;
  }

  // icon_url - computed: false, optional: true, required: false
  private _iconUrl?: string; 
  public get iconUrl() {
    return this.getStringAttribute('icon_url');
  }
  public set iconUrl(value: string) {
    this._iconUrl = value;
  }
  public resetIconUrl() {
    this._iconUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iconUrlInput() {
    return this._iconUrl;
  }

  // image_url - computed: false, optional: true, required: false
  private _imageUrl?: string; 
  public get imageUrl() {
    return this.getStringAttribute('image_url');
  }
  public set imageUrl(value: string) {
    this._imageUrl = value;
  }
  public resetImageUrl() {
    this._imageUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageUrlInput() {
    return this._imageUrl;
  }

  // link_names - computed: false, optional: true, required: false
  private _linkNames?: boolean | cdktf.IResolvable; 
  public get linkNames() {
    return this.getBooleanAttribute('link_names');
  }
  public set linkNames(value: boolean | cdktf.IResolvable) {
    this._linkNames = value;
  }
  public resetLinkNames() {
    this._linkNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get linkNamesInput() {
    return this._linkNames;
  }

  // mrkdwn_in - computed: false, optional: true, required: false
  private _mrkdwnIn?: string[]; 
  public get mrkdwnIn() {
    return this.getListAttribute('mrkdwn_in');
  }
  public set mrkdwnIn(value: string[]) {
    this._mrkdwnIn = value;
  }
  public resetMrkdwnIn() {
    this._mrkdwnIn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mrkdwnInInput() {
    return this._mrkdwnIn;
  }

  // pretext - computed: false, optional: true, required: false
  private _pretext?: string; 
  public get pretext() {
    return this.getStringAttribute('pretext');
  }
  public set pretext(value: string) {
    this._pretext = value;
  }
  public resetPretext() {
    this._pretext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pretextInput() {
    return this._pretext;
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // short_fields - computed: false, optional: true, required: false
  private _shortFields?: boolean | cdktf.IResolvable; 
  public get shortFields() {
    return this.getBooleanAttribute('short_fields');
  }
  public set shortFields(value: boolean | cdktf.IResolvable) {
    this._shortFields = value;
  }
  public resetShortFields() {
    this._shortFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shortFieldsInput() {
    return this._shortFields;
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }

  // thumb_url - computed: false, optional: true, required: false
  private _thumbUrl?: string; 
  public get thumbUrl() {
    return this.getStringAttribute('thumb_url');
  }
  public set thumbUrl(value: string) {
    this._thumbUrl = value;
  }
  public resetThumbUrl() {
    this._thumbUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thumbUrlInput() {
    return this._thumbUrl;
  }

  // title - computed: false, optional: true, required: false
  private _title?: string; 
  public get title() {
    return this.getStringAttribute('title');
  }
  public set title(value: string) {
    this._title = value;
  }
  public resetTitle() {
    this._title = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get titleInput() {
    return this._title;
  }

  // title_link - computed: false, optional: true, required: false
  private _titleLink?: string; 
  public get titleLink() {
    return this.getStringAttribute('title_link');
  }
  public set titleLink(value: string) {
    this._titleLink = value;
  }
  public resetTitleLink() {
    this._titleLink = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get titleLinkInput() {
    return this._titleLink;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }

  // actions - computed: false, optional: true, required: false
  private _actions = new AlertmanagerConfigReceiverSlackConfigsActionsList(this, "actions", false);
  public get actions() {
    return this._actions;
  }
  public putActions(value: AlertmanagerConfigReceiverSlackConfigsActions[] | cdktf.IResolvable) {
    this._actions.internalValue = value;
  }
  public resetActions() {
    this._actions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionsInput() {
    return this._actions.internalValue;
  }

  // fields - computed: false, optional: true, required: false
  private _fields = new AlertmanagerConfigReceiverSlackConfigsFieldsList(this, "fields", false);
  public get fields() {
    return this._fields;
  }
  public putFields(value: AlertmanagerConfigReceiverSlackConfigsFields[] | cdktf.IResolvable) {
    this._fields.internalValue = value;
  }
  public resetFields() {
    this._fields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields.internalValue;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigReceiverSlackConfigsHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigReceiverSlackConfigsHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }
}

export class AlertmanagerConfigReceiverSlackConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverSlackConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverSlackConfigsOutputReference {
    return new AlertmanagerConfigReceiverSlackConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverSnsConfigsHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigReceiverSnsConfigsHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverSnsConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigReceiverSnsConfigsHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverSnsConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSnsConfigsHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSnsConfigsHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSnsConfigsHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigReceiverSnsConfigsHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverSnsConfigsHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverSnsConfigsHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigReceiverSnsConfigsHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfig;
}

export function alertmanagerConfigReceiverSnsConfigsHttpConfigToTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverSnsConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigReceiverSnsConfigsHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigReceiverSnsConfigsHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverSnsConfigsHttpConfigToHclTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverSnsConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigReceiverSnsConfigsHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSnsConfigsHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigReceiverSnsConfigsHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSnsConfigsHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSnsConfigsHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSnsConfigsHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigReceiverSnsConfigsHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigReceiverSnsConfigsHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigReceiverSnsConfigsHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigReceiverSnsConfigsHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverSnsConfigsHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverSnsConfigsSigv4 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#access_key AlertmanagerConfig#access_key}
  */
  readonly accessKey?: string;
  /**
  * Named AWS profile used to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#profile AlertmanagerConfig#profile}
  */
  readonly profile?: string;
  /**
  * The AWS region. If blank, the region from the default credentials chain is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#region AlertmanagerConfig#region}
  */
  readonly region?: string;
  /**
  * AWS Role ARN, an alternative to using AWS API keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#role_arn AlertmanagerConfig#role_arn}
  */
  readonly roleArn?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#secret_key AlertmanagerConfig#secret_key}
  */
  readonly secretKey?: string;
}

export function alertmanagerConfigReceiverSnsConfigsSigv4ToTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsSigv4OutputReference | AlertmanagerConfigReceiverSnsConfigsSigv4): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key: cdktf.stringToTerraform(struct!.accessKey),
    profile: cdktf.stringToTerraform(struct!.profile),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    secret_key: cdktf.stringToTerraform(struct!.secretKey),
  }
}


export function alertmanagerConfigReceiverSnsConfigsSigv4ToHclTerraform(struct?: AlertmanagerConfigReceiverSnsConfigsSigv4OutputReference | AlertmanagerConfigReceiverSnsConfigsSigv4): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key: {
      value: cdktf.stringToHclTerraform(struct!.accessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_key: {
      value: cdktf.stringToHclTerraform(struct!.secretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSnsConfigsSigv4OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverSnsConfigsSigv4 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKey = this._accessKey;
    }
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._secretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKey = this._secretKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSnsConfigsSigv4 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._accessKey = undefined;
      this._profile = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._secretKey = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._accessKey = value.accessKey;
      this._profile = value.profile;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._secretKey = value.secretKey;
    }
  }

  // access_key - computed: false, optional: true, required: false
  private _accessKey?: string; 
  public get accessKey() {
    return this.getStringAttribute('access_key');
  }
  public set accessKey(value: string) {
    this._accessKey = value;
  }
  public resetAccessKey() {
    this._accessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyInput() {
    return this._accessKey;
  }

  // profile - computed: false, optional: true, required: false
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  public resetProfile() {
    this._profile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // secret_key - computed: false, optional: true, required: false
  private _secretKey?: string; 
  public get secretKey() {
    return this.getStringAttribute('secret_key');
  }
  public set secretKey(value: string) {
    this._secretKey = value;
  }
  public resetSecretKey() {
    this._secretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyInput() {
    return this._secretKey;
  }
}
export interface AlertmanagerConfigReceiverSnsConfigs {
  /**
  * The SNS API URL. If not specified, the SNS API URL from the SNS SDK will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#api_url AlertmanagerConfig#api_url}
  */
  readonly apiUrl?: string;
  /**
  * SNS message attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#attributes AlertmanagerConfig#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * The message content of the SNS notification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#message AlertmanagerConfig#message}
  */
  readonly message?: string;
  /**
  * Phone number if message is delivered via SMS in E.164 format.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#phone_number AlertmanagerConfig#phone_number}
  */
  readonly phoneNumber?: string;
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * Subject line when the message is delivered to email endpoints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#subject AlertmanagerConfig#subject}
  */
  readonly subject?: string;
  /**
  * The mobile platform endpoint ARN if message is delivered via mobile notifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#target_arn AlertmanagerConfig#target_arn}
  */
  readonly targetArn?: string;
  /**
  * SNS topic ARN. If not set, a value for the phone_number or target_arn should be set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#topic_arn AlertmanagerConfig#topic_arn}
  */
  readonly topicArn?: string;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigReceiverSnsConfigsHttpConfig;
  /**
  * sigv4 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#sigv4 AlertmanagerConfig#sigv4}
  */
  readonly sigv4?: AlertmanagerConfigReceiverSnsConfigsSigv4;
}

export function alertmanagerConfigReceiverSnsConfigsToTerraform(struct?: AlertmanagerConfigReceiverSnsConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    message: cdktf.stringToTerraform(struct!.message),
    phone_number: cdktf.stringToTerraform(struct!.phoneNumber),
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    subject: cdktf.stringToTerraform(struct!.subject),
    target_arn: cdktf.stringToTerraform(struct!.targetArn),
    topic_arn: cdktf.stringToTerraform(struct!.topicArn),
    http_config: alertmanagerConfigReceiverSnsConfigsHttpConfigToTerraform(struct!.httpConfig),
    sigv4: alertmanagerConfigReceiverSnsConfigsSigv4ToTerraform(struct!.sigv4),
  }
}


export function alertmanagerConfigReceiverSnsConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverSnsConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    phone_number: {
      value: cdktf.stringToHclTerraform(struct!.phoneNumber),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    subject: {
      value: cdktf.stringToHclTerraform(struct!.subject),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_arn: {
      value: cdktf.stringToHclTerraform(struct!.targetArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    topic_arn: {
      value: cdktf.stringToHclTerraform(struct!.topicArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_config: {
      value: alertmanagerConfigReceiverSnsConfigsHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSnsConfigsHttpConfigList",
    },
    sigv4: {
      value: alertmanagerConfigReceiverSnsConfigsSigv4ToHclTerraform(struct!.sigv4),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSnsConfigsSigv4List",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverSnsConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverSnsConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._phoneNumber !== undefined) {
      hasAnyValues = true;
      internalValueResult.phoneNumber = this._phoneNumber;
    }
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._subject !== undefined) {
      hasAnyValues = true;
      internalValueResult.subject = this._subject;
    }
    if (this._targetArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetArn = this._targetArn;
    }
    if (this._topicArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.topicArn = this._topicArn;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    if (this._sigv4?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigv4 = this._sigv4?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverSnsConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiUrl = undefined;
      this._attributes = undefined;
      this._message = undefined;
      this._phoneNumber = undefined;
      this._sendResolved = undefined;
      this._subject = undefined;
      this._targetArn = undefined;
      this._topicArn = undefined;
      this._httpConfig.internalValue = undefined;
      this._sigv4.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiUrl = value.apiUrl;
      this._attributes = value.attributes;
      this._message = value.message;
      this._phoneNumber = value.phoneNumber;
      this._sendResolved = value.sendResolved;
      this._subject = value.subject;
      this._targetArn = value.targetArn;
      this._topicArn = value.topicArn;
      this._httpConfig.internalValue = value.httpConfig;
      this._sigv4.internalValue = value.sigv4;
    }
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // phone_number - computed: false, optional: true, required: false
  private _phoneNumber?: string; 
  public get phoneNumber() {
    return this.getStringAttribute('phone_number');
  }
  public set phoneNumber(value: string) {
    this._phoneNumber = value;
  }
  public resetPhoneNumber() {
    this._phoneNumber = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get phoneNumberInput() {
    return this._phoneNumber;
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // subject - computed: false, optional: true, required: false
  private _subject?: string; 
  public get subject() {
    return this.getStringAttribute('subject');
  }
  public set subject(value: string) {
    this._subject = value;
  }
  public resetSubject() {
    this._subject = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectInput() {
    return this._subject;
  }

  // target_arn - computed: false, optional: true, required: false
  private _targetArn?: string; 
  public get targetArn() {
    return this.getStringAttribute('target_arn');
  }
  public set targetArn(value: string) {
    this._targetArn = value;
  }
  public resetTargetArn() {
    this._targetArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetArnInput() {
    return this._targetArn;
  }

  // topic_arn - computed: false, optional: true, required: false
  private _topicArn?: string; 
  public get topicArn() {
    return this.getStringAttribute('topic_arn');
  }
  public set topicArn(value: string) {
    this._topicArn = value;
  }
  public resetTopicArn() {
    this._topicArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicArnInput() {
    return this._topicArn;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigReceiverSnsConfigsHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigReceiverSnsConfigsHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }

  // sigv4 - computed: false, optional: true, required: false
  private _sigv4 = new AlertmanagerConfigReceiverSnsConfigsSigv4OutputReference(this, "sigv4");
  public get sigv4() {
    return this._sigv4;
  }
  public putSigv4(value: AlertmanagerConfigReceiverSnsConfigsSigv4) {
    this._sigv4.internalValue = value;
  }
  public resetSigv4() {
    this._sigv4.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigv4Input() {
    return this._sigv4.internalValue;
  }
}

export class AlertmanagerConfigReceiverSnsConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverSnsConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverSnsConfigsOutputReference {
    return new AlertmanagerConfigReceiverSnsConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverTelegramConfigsHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfig;
}

export function alertmanagerConfigReceiverTelegramConfigsHttpConfigToTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverTelegramConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverTelegramConfigsHttpConfigToHclTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverTelegramConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverTelegramConfigsHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverTelegramConfigsHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverTelegramConfigsHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigReceiverTelegramConfigsHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigReceiverTelegramConfigsHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigReceiverTelegramConfigsHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverTelegramConfigsHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverTelegramConfigs {
  /**
  * The Telegram API URL. If not specified, default API URL will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#api_url AlertmanagerConfig#api_url}
  */
  readonly apiUrl?: string;
  /**
  * Telegram bot token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bot_token AlertmanagerConfig#bot_token}
  */
  readonly botToken?: string;
  /**
  * ID of the chat where to send the messages.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#chat_id AlertmanagerConfig#chat_id}
  */
  readonly chatId?: number;
  /**
  * Disable telegram notifications
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#disable_notifications AlertmanagerConfig#disable_notifications}
  */
  readonly disableNotifications?: boolean | cdktf.IResolvable;
  /**
  * Message template
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#message AlertmanagerConfig#message}
  */
  readonly message?: string;
  /**
  * Parse mode for telegram message, supported values are MarkdownV2, Markdown, HTML and empty string for plain text.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#parse_mode AlertmanagerConfig#parse_mode}
  */
  readonly parseMode?: string;
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigReceiverTelegramConfigsHttpConfig;
}

export function alertmanagerConfigReceiverTelegramConfigsToTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    bot_token: cdktf.stringToTerraform(struct!.botToken),
    chat_id: cdktf.numberToTerraform(struct!.chatId),
    disable_notifications: cdktf.booleanToTerraform(struct!.disableNotifications),
    message: cdktf.stringToTerraform(struct!.message),
    parse_mode: cdktf.stringToTerraform(struct!.parseMode),
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    http_config: alertmanagerConfigReceiverTelegramConfigsHttpConfigToTerraform(struct!.httpConfig),
  }
}


export function alertmanagerConfigReceiverTelegramConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverTelegramConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bot_token: {
      value: cdktf.stringToHclTerraform(struct!.botToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    chat_id: {
      value: cdktf.numberToHclTerraform(struct!.chatId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disable_notifications: {
      value: cdktf.booleanToHclTerraform(struct!.disableNotifications),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parse_mode: {
      value: cdktf.stringToHclTerraform(struct!.parseMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    http_config: {
      value: alertmanagerConfigReceiverTelegramConfigsHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverTelegramConfigsHttpConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverTelegramConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverTelegramConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._botToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.botToken = this._botToken;
    }
    if (this._chatId !== undefined) {
      hasAnyValues = true;
      internalValueResult.chatId = this._chatId;
    }
    if (this._disableNotifications !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableNotifications = this._disableNotifications;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._parseMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseMode = this._parseMode;
    }
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverTelegramConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiUrl = undefined;
      this._botToken = undefined;
      this._chatId = undefined;
      this._disableNotifications = undefined;
      this._message = undefined;
      this._parseMode = undefined;
      this._sendResolved = undefined;
      this._httpConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiUrl = value.apiUrl;
      this._botToken = value.botToken;
      this._chatId = value.chatId;
      this._disableNotifications = value.disableNotifications;
      this._message = value.message;
      this._parseMode = value.parseMode;
      this._sendResolved = value.sendResolved;
      this._httpConfig.internalValue = value.httpConfig;
    }
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // bot_token - computed: false, optional: true, required: false
  private _botToken?: string; 
  public get botToken() {
    return this.getStringAttribute('bot_token');
  }
  public set botToken(value: string) {
    this._botToken = value;
  }
  public resetBotToken() {
    this._botToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get botTokenInput() {
    return this._botToken;
  }

  // chat_id - computed: false, optional: true, required: false
  private _chatId?: number; 
  public get chatId() {
    return this.getNumberAttribute('chat_id');
  }
  public set chatId(value: number) {
    this._chatId = value;
  }
  public resetChatId() {
    this._chatId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chatIdInput() {
    return this._chatId;
  }

  // disable_notifications - computed: false, optional: true, required: false
  private _disableNotifications?: boolean | cdktf.IResolvable; 
  public get disableNotifications() {
    return this.getBooleanAttribute('disable_notifications');
  }
  public set disableNotifications(value: boolean | cdktf.IResolvable) {
    this._disableNotifications = value;
  }
  public resetDisableNotifications() {
    this._disableNotifications = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableNotificationsInput() {
    return this._disableNotifications;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // parse_mode - computed: false, optional: true, required: false
  private _parseMode?: string; 
  public get parseMode() {
    return this.getStringAttribute('parse_mode');
  }
  public set parseMode(value: string) {
    this._parseMode = value;
  }
  public resetParseMode() {
    this._parseMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseModeInput() {
    return this._parseMode;
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigReceiverTelegramConfigsHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigReceiverTelegramConfigsHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }
}

export class AlertmanagerConfigReceiverTelegramConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverTelegramConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverTelegramConfigsOutputReference {
    return new AlertmanagerConfigReceiverTelegramConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverVictoropsConfigsHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfig;
}

export function alertmanagerConfigReceiverVictoropsConfigsHttpConfigToTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverVictoropsConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverVictoropsConfigsHttpConfigToHclTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverVictoropsConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverVictoropsConfigsHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverVictoropsConfigsHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverVictoropsConfigsHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverVictoropsConfigs {
  /**
  * The API key to use when talking to the VictorOps API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#api_key AlertmanagerConfig#api_key}
  */
  readonly apiKey?: string;
  /**
  * The VictorOps API URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#api_url AlertmanagerConfig#api_url}
  */
  readonly apiUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#custom_fields AlertmanagerConfig#custom_fields}
  */
  readonly customFields?: { [key: string]: string };
  /**
  * Contains summary of the alerted problem.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#entity_display_name AlertmanagerConfig#entity_display_name}
  */
  readonly entityDisplayName?: string;
  /**
  * Describes the behavior of the alert (CRITICAL, WARNING, INFO).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#message_type AlertmanagerConfig#message_type}
  */
  readonly messageType?: string;
  /**
  * The monitoring tool the state message is from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#monitoring_tool AlertmanagerConfig#monitoring_tool}
  */
  readonly monitoringTool?: string;
  /**
  * A key used to map the alert to a team.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#routing_key AlertmanagerConfig#routing_key}
  */
  readonly routingKey?: string;
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * Contains long explanation of the alerted problem.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#state_message AlertmanagerConfig#state_message}
  */
  readonly stateMessage?: string;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigReceiverVictoropsConfigsHttpConfig;
}

export function alertmanagerConfigReceiverVictoropsConfigsToTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_key: cdktf.stringToTerraform(struct!.apiKey),
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    custom_fields: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.customFields),
    entity_display_name: cdktf.stringToTerraform(struct!.entityDisplayName),
    message_type: cdktf.stringToTerraform(struct!.messageType),
    monitoring_tool: cdktf.stringToTerraform(struct!.monitoringTool),
    routing_key: cdktf.stringToTerraform(struct!.routingKey),
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    state_message: cdktf.stringToTerraform(struct!.stateMessage),
    http_config: alertmanagerConfigReceiverVictoropsConfigsHttpConfigToTerraform(struct!.httpConfig),
  }
}


export function alertmanagerConfigReceiverVictoropsConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverVictoropsConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_key: {
      value: cdktf.stringToHclTerraform(struct!.apiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_fields: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.customFields),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    entity_display_name: {
      value: cdktf.stringToHclTerraform(struct!.entityDisplayName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_type: {
      value: cdktf.stringToHclTerraform(struct!.messageType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    monitoring_tool: {
      value: cdktf.stringToHclTerraform(struct!.monitoringTool),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    routing_key: {
      value: cdktf.stringToHclTerraform(struct!.routingKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    state_message: {
      value: cdktf.stringToHclTerraform(struct!.stateMessage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_config: {
      value: alertmanagerConfigReceiverVictoropsConfigsHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverVictoropsConfigsHttpConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverVictoropsConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverVictoropsConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey;
    }
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._customFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.customFields = this._customFields;
    }
    if (this._entityDisplayName !== undefined) {
      hasAnyValues = true;
      internalValueResult.entityDisplayName = this._entityDisplayName;
    }
    if (this._messageType !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageType = this._messageType;
    }
    if (this._monitoringTool !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringTool = this._monitoringTool;
    }
    if (this._routingKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.routingKey = this._routingKey;
    }
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._stateMessage !== undefined) {
      hasAnyValues = true;
      internalValueResult.stateMessage = this._stateMessage;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverVictoropsConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiKey = undefined;
      this._apiUrl = undefined;
      this._customFields = undefined;
      this._entityDisplayName = undefined;
      this._messageType = undefined;
      this._monitoringTool = undefined;
      this._routingKey = undefined;
      this._sendResolved = undefined;
      this._stateMessage = undefined;
      this._httpConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiKey = value.apiKey;
      this._apiUrl = value.apiUrl;
      this._customFields = value.customFields;
      this._entityDisplayName = value.entityDisplayName;
      this._messageType = value.messageType;
      this._monitoringTool = value.monitoringTool;
      this._routingKey = value.routingKey;
      this._sendResolved = value.sendResolved;
      this._stateMessage = value.stateMessage;
      this._httpConfig.internalValue = value.httpConfig;
    }
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey?: string; 
  public get apiKey() {
    return this.getStringAttribute('api_key');
  }
  public set apiKey(value: string) {
    this._apiKey = value;
  }
  public resetApiKey() {
    this._apiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey;
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // custom_fields - computed: false, optional: true, required: false
  private _customFields?: { [key: string]: string }; 
  public get customFields() {
    return this.getStringMapAttribute('custom_fields');
  }
  public set customFields(value: { [key: string]: string }) {
    this._customFields = value;
  }
  public resetCustomFields() {
    this._customFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customFieldsInput() {
    return this._customFields;
  }

  // entity_display_name - computed: false, optional: true, required: false
  private _entityDisplayName?: string; 
  public get entityDisplayName() {
    return this.getStringAttribute('entity_display_name');
  }
  public set entityDisplayName(value: string) {
    this._entityDisplayName = value;
  }
  public resetEntityDisplayName() {
    this._entityDisplayName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entityDisplayNameInput() {
    return this._entityDisplayName;
  }

  // message_type - computed: false, optional: true, required: false
  private _messageType?: string; 
  public get messageType() {
    return this.getStringAttribute('message_type');
  }
  public set messageType(value: string) {
    this._messageType = value;
  }
  public resetMessageType() {
    this._messageType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageTypeInput() {
    return this._messageType;
  }

  // monitoring_tool - computed: false, optional: true, required: false
  private _monitoringTool?: string; 
  public get monitoringTool() {
    return this.getStringAttribute('monitoring_tool');
  }
  public set monitoringTool(value: string) {
    this._monitoringTool = value;
  }
  public resetMonitoringTool() {
    this._monitoringTool = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringToolInput() {
    return this._monitoringTool;
  }

  // routing_key - computed: false, optional: true, required: false
  private _routingKey?: string; 
  public get routingKey() {
    return this.getStringAttribute('routing_key');
  }
  public set routingKey(value: string) {
    this._routingKey = value;
  }
  public resetRoutingKey() {
    this._routingKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routingKeyInput() {
    return this._routingKey;
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // state_message - computed: false, optional: true, required: false
  private _stateMessage?: string; 
  public get stateMessage() {
    return this.getStringAttribute('state_message');
  }
  public set stateMessage(value: string) {
    this._stateMessage = value;
  }
  public resetStateMessage() {
    this._stateMessage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stateMessageInput() {
    return this._stateMessage;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigReceiverVictoropsConfigsHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigReceiverVictoropsConfigsHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }
}

export class AlertmanagerConfigReceiverVictoropsConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverVictoropsConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverVictoropsConfigsOutputReference {
    return new AlertmanagerConfigReceiverVictoropsConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverWebexConfigsHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigReceiverWebexConfigsHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigReceiverWebexConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverWebexConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigReceiverWebexConfigsHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigReceiverWebexConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverWebexConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebexConfigsHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebexConfigsHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebexConfigsHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigReceiverWebexConfigsHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverWebexConfigsHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverWebexConfigsHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigReceiverWebexConfigsHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfig;
}

export function alertmanagerConfigReceiverWebexConfigsHttpConfigToTerraform(struct?: AlertmanagerConfigReceiverWebexConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverWebexConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigReceiverWebexConfigsHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigReceiverWebexConfigsHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverWebexConfigsHttpConfigToHclTerraform(struct?: AlertmanagerConfigReceiverWebexConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverWebexConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigReceiverWebexConfigsHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebexConfigsHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigReceiverWebexConfigsHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebexConfigsHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebexConfigsHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebexConfigsHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigReceiverWebexConfigsHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigReceiverWebexConfigsHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigReceiverWebexConfigsHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigReceiverWebexConfigsHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverWebexConfigsHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverWebexConfigs {
  /**
  * The Webex Teams API URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#api_url AlertmanagerConfig#api_url}
  */
  readonly apiUrl?: string;
  /**
  * Message template.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#message AlertmanagerConfig#message}
  */
  readonly message?: string;
  /**
  * ID of the Webex Teams room where to send the messages.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#room_id AlertmanagerConfig#room_id}
  */
  readonly roomId?: string;
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigReceiverWebexConfigsHttpConfig;
}

export function alertmanagerConfigReceiverWebexConfigsToTerraform(struct?: AlertmanagerConfigReceiverWebexConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    message: cdktf.stringToTerraform(struct!.message),
    room_id: cdktf.stringToTerraform(struct!.roomId),
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    http_config: alertmanagerConfigReceiverWebexConfigsHttpConfigToTerraform(struct!.httpConfig),
  }
}


export function alertmanagerConfigReceiverWebexConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverWebexConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    room_id: {
      value: cdktf.stringToHclTerraform(struct!.roomId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    http_config: {
      value: alertmanagerConfigReceiverWebexConfigsHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebexConfigsHttpConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebexConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebexConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._roomId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roomId = this._roomId;
    }
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebexConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiUrl = undefined;
      this._message = undefined;
      this._roomId = undefined;
      this._sendResolved = undefined;
      this._httpConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiUrl = value.apiUrl;
      this._message = value.message;
      this._roomId = value.roomId;
      this._sendResolved = value.sendResolved;
      this._httpConfig.internalValue = value.httpConfig;
    }
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // room_id - computed: false, optional: true, required: false
  private _roomId?: string; 
  public get roomId() {
    return this.getStringAttribute('room_id');
  }
  public set roomId(value: string) {
    this._roomId = value;
  }
  public resetRoomId() {
    this._roomId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roomIdInput() {
    return this._roomId;
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigReceiverWebexConfigsHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigReceiverWebexConfigsHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }
}

export class AlertmanagerConfigReceiverWebexConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverWebexConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverWebexConfigsOutputReference {
    return new AlertmanagerConfigReceiverWebexConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverWebhookConfigsHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfig;
}

export function alertmanagerConfigReceiverWebhookConfigsHttpConfigToTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverWebhookConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverWebhookConfigsHttpConfigToHclTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverWebhookConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebhookConfigsHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebhookConfigsHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebhookConfigsHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigReceiverWebhookConfigsHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigReceiverWebhookConfigsHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigReceiverWebhookConfigsHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverWebhookConfigsHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverWebhookConfigs {
  /**
  * The maximum number of alerts to include in a single webhook message. Alerts above this threshold are truncated. When leaving this at its default value of 0, all alerts are included.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_alerts AlertmanagerConfig#max_alerts}
  */
  readonly maxAlerts?: number;
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * The endpoint to send HTTP POST requests to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#url AlertmanagerConfig#url}
  */
  readonly url?: string;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigReceiverWebhookConfigsHttpConfig;
}

export function alertmanagerConfigReceiverWebhookConfigsToTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_alerts: cdktf.numberToTerraform(struct!.maxAlerts),
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    url: cdktf.stringToTerraform(struct!.url),
    http_config: alertmanagerConfigReceiverWebhookConfigsHttpConfigToTerraform(struct!.httpConfig),
  }
}


export function alertmanagerConfigReceiverWebhookConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverWebhookConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_alerts: {
      value: cdktf.numberToHclTerraform(struct!.maxAlerts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_config: {
      value: alertmanagerConfigReceiverWebhookConfigsHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebhookConfigsHttpConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWebhookConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverWebhookConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxAlerts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxAlerts = this._maxAlerts;
    }
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWebhookConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxAlerts = undefined;
      this._sendResolved = undefined;
      this._url = undefined;
      this._httpConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxAlerts = value.maxAlerts;
      this._sendResolved = value.sendResolved;
      this._url = value.url;
      this._httpConfig.internalValue = value.httpConfig;
    }
  }

  // max_alerts - computed: false, optional: true, required: false
  private _maxAlerts?: number; 
  public get maxAlerts() {
    return this.getNumberAttribute('max_alerts');
  }
  public set maxAlerts(value: number) {
    this._maxAlerts = value;
  }
  public resetMaxAlerts() {
    this._maxAlerts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxAlertsInput() {
    return this._maxAlerts;
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigReceiverWebhookConfigsHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigReceiverWebhookConfigsHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }
}

export class AlertmanagerConfigReceiverWebhookConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverWebhookConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverWebhookConfigsOutputReference {
    return new AlertmanagerConfigReceiverWebhookConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiverWechatConfigsHttpConfigAuthorization {
  /**
  * Sets the credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#credentials AlertmanagerConfig#credentials}
  */
  readonly credentials?: string;
  /**
  * Sets the authentication type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#type AlertmanagerConfig#type}
  */
  readonly type?: string;
}

export function alertmanagerConfigReceiverWechatConfigsHttpConfigAuthorizationToTerraform(struct?: AlertmanagerConfigReceiverWechatConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverWechatConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: cdktf.stringToTerraform(struct!.credentials),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function alertmanagerConfigReceiverWechatConfigsHttpConfigAuthorizationToHclTerraform(struct?: AlertmanagerConfigReceiverWechatConfigsHttpConfigAuthorizationOutputReference | AlertmanagerConfigReceiverWechatConfigsHttpConfigAuthorization): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: cdktf.stringToHclTerraform(struct!.credentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWechatConfigsHttpConfigAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWechatConfigsHttpConfigAuthorization | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWechatConfigsHttpConfigAuthorization | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._credentials = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._credentials = value.credentials;
      this._type = value.type;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials?: string; 
  public get credentials() {
    return this.getStringAttribute('credentials');
  }
  public set credentials(value: string) {
    this._credentials = value;
  }
  public resetCredentials() {
    this._credentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface AlertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#password AlertmanagerConfig#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#username AlertmanagerConfig#username}
  */
  readonly username?: string;
}

export function alertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuthToTerraform(struct?: AlertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function alertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuthToHclTerraform(struct?: AlertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuthOutputReference | AlertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._password = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfigToTerraform(struct?: AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfigOutputReference | AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_id AlertmanagerConfig#client_id}
  */
  readonly clientId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#client_secret AlertmanagerConfig#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Parameters to append to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#endpoint_params AlertmanagerConfig#endpoint_params}
  */
  readonly endpointParams?: { [key: string]: string };
  /**
  * Scopes for the token request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#scopes AlertmanagerConfig#scopes}
  */
  readonly scopes?: string[];
  /**
  * The URL to fetch the token from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#token_url AlertmanagerConfig#token_url}
  */
  readonly tokenUrl?: string;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfig;
}

export function alertmanagerConfigReceiverWechatConfigsHttpConfigOauth2ToTerraform(struct?: AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    endpoint_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.endpointParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
    tls_config: alertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverWechatConfigsHttpConfigOauth2ToHclTerraform(struct?: AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2OutputReference | AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.endpointParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_config: {
      value: alertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._endpointParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._endpointParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._endpointParams = value.endpointParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams?: { [key: string]: string }; 
  public get endpointParams() {
    return this.getStringMapAttribute('endpoint_params');
  }
  public set endpointParams(value: { [key: string]: string }) {
    this._endpointParams = value;
  }
  public resetEndpointParams() {
    this._endpointParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: true, required: false
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  public resetTokenUrl() {
    this._tokenUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2TlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfig {
  /**
  * Disable validation of the server certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#insecure_skip_verify AlertmanagerConfig#insecure_skip_verify}
  */
  readonly insecureSkipVerify?: boolean | cdktf.IResolvable;
  /**
  * Maximum acceptable TLS version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#max_version AlertmanagerConfig#max_version}
  */
  readonly maxVersion?: string;
  /**
  * Minimum acceptable TLS version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#min_version AlertmanagerConfig#min_version}
  */
  readonly minVersion?: string;
  /**
  * ServerName extension to indicate the name of the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#server_name AlertmanagerConfig#server_name}
  */
  readonly serverName?: string;
}

export function alertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfigToTerraform(struct?: AlertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    insecure_skip_verify: cdktf.booleanToTerraform(struct!.insecureSkipVerify),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    server_name: cdktf.stringToTerraform(struct!.serverName),
  }
}


export function alertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfigToHclTerraform(struct?: AlertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfigOutputReference | AlertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    insecure_skip_verify: {
      value: cdktf.booleanToHclTerraform(struct!.insecureSkipVerify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._insecureSkipVerify !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecureSkipVerify = this._insecureSkipVerify;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._insecureSkipVerify = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._serverName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._insecureSkipVerify = value.insecureSkipVerify;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._serverName = value.serverName;
    }
  }

  // insecure_skip_verify - computed: false, optional: true, required: false
  private _insecureSkipVerify?: boolean | cdktf.IResolvable; 
  public get insecureSkipVerify() {
    return this.getBooleanAttribute('insecure_skip_verify');
  }
  public set insecureSkipVerify(value: boolean | cdktf.IResolvable) {
    this._insecureSkipVerify = value;
  }
  public resetInsecureSkipVerify() {
    this._insecureSkipVerify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureSkipVerifyInput() {
    return this._insecureSkipVerify;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }
}
export interface AlertmanagerConfigReceiverWechatConfigsHttpConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#bearer_token AlertmanagerConfig#bearer_token}
  */
  readonly bearerToken?: string;
  /**
  * Whether to enable HTTP2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#enable_http2 AlertmanagerConfig#enable_http2}
  */
  readonly enableHttp2?: boolean | cdktf.IResolvable;
  /**
  * Configure whether HTTP requests follow HTTP 3xx redirects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#follow_redirects AlertmanagerConfig#follow_redirects}
  */
  readonly followRedirects?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#proxy_url AlertmanagerConfig#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * authorization block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#authorization AlertmanagerConfig#authorization}
  */
  readonly authorization?: AlertmanagerConfigReceiverWechatConfigsHttpConfigAuthorization;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#basic_auth AlertmanagerConfig#basic_auth}
  */
  readonly basicAuth?: AlertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuth;
  /**
  * oauth2 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#oauth2 AlertmanagerConfig#oauth2}
  */
  readonly oauth2?: AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2;
  /**
  * tls_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#tls_config AlertmanagerConfig#tls_config}
  */
  readonly tlsConfig?: AlertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfig;
}

export function alertmanagerConfigReceiverWechatConfigsHttpConfigToTerraform(struct?: AlertmanagerConfigReceiverWechatConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverWechatConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: cdktf.stringToTerraform(struct!.bearerToken),
    enable_http2: cdktf.booleanToTerraform(struct!.enableHttp2),
    follow_redirects: cdktf.booleanToTerraform(struct!.followRedirects),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    authorization: alertmanagerConfigReceiverWechatConfigsHttpConfigAuthorizationToTerraform(struct!.authorization),
    basic_auth: alertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuthToTerraform(struct!.basicAuth),
    oauth2: alertmanagerConfigReceiverWechatConfigsHttpConfigOauth2ToTerraform(struct!.oauth2),
    tls_config: alertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfigToTerraform(struct!.tlsConfig),
  }
}


export function alertmanagerConfigReceiverWechatConfigsHttpConfigToHclTerraform(struct?: AlertmanagerConfigReceiverWechatConfigsHttpConfigOutputReference | AlertmanagerConfigReceiverWechatConfigsHttpConfig): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: cdktf.stringToHclTerraform(struct!.bearerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_http2: {
      value: cdktf.booleanToHclTerraform(struct!.enableHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    follow_redirects: {
      value: cdktf.booleanToHclTerraform(struct!.followRedirects),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization: {
      value: alertmanagerConfigReceiverWechatConfigsHttpConfigAuthorizationToHclTerraform(struct!.authorization),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWechatConfigsHttpConfigAuthorizationList",
    },
    basic_auth: {
      value: alertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuthList",
    },
    oauth2: {
      value: alertmanagerConfigReceiverWechatConfigsHttpConfigOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2List",
    },
    tls_config: {
      value: alertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfigToHclTerraform(struct!.tlsConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWechatConfigsHttpConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigReceiverWechatConfigsHttpConfig | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken;
    }
    if (this._enableHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHttp2 = this._enableHttp2;
    }
    if (this._followRedirects !== undefined) {
      hasAnyValues = true;
      internalValueResult.followRedirects = this._followRedirects;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._authorization?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorization = this._authorization?.internalValue;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._tlsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsConfig = this._tlsConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWechatConfigsHttpConfig | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bearerToken = undefined;
      this._enableHttp2 = undefined;
      this._followRedirects = undefined;
      this._proxyUrl = undefined;
      this._authorization.internalValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth2.internalValue = undefined;
      this._tlsConfig.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bearerToken = value.bearerToken;
      this._enableHttp2 = value.enableHttp2;
      this._followRedirects = value.followRedirects;
      this._proxyUrl = value.proxyUrl;
      this._authorization.internalValue = value.authorization;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth2.internalValue = value.oauth2;
      this._tlsConfig.internalValue = value.tlsConfig;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken?: string; 
  public get bearerToken() {
    return this.getStringAttribute('bearer_token');
  }
  public set bearerToken(value: string) {
    this._bearerToken = value;
  }
  public resetBearerToken() {
    this._bearerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken;
  }

  // enable_http2 - computed: false, optional: true, required: false
  private _enableHttp2?: boolean | cdktf.IResolvable; 
  public get enableHttp2() {
    return this.getBooleanAttribute('enable_http2');
  }
  public set enableHttp2(value: boolean | cdktf.IResolvable) {
    this._enableHttp2 = value;
  }
  public resetEnableHttp2() {
    this._enableHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHttp2Input() {
    return this._enableHttp2;
  }

  // follow_redirects - computed: false, optional: true, required: false
  private _followRedirects?: boolean | cdktf.IResolvable; 
  public get followRedirects() {
    return this.getBooleanAttribute('follow_redirects');
  }
  public set followRedirects(value: boolean | cdktf.IResolvable) {
    this._followRedirects = value;
  }
  public resetFollowRedirects() {
    this._followRedirects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get followRedirectsInput() {
    return this._followRedirects;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // authorization - computed: false, optional: true, required: false
  private _authorization = new AlertmanagerConfigReceiverWechatConfigsHttpConfigAuthorizationOutputReference(this, "authorization");
  public get authorization() {
    return this._authorization;
  }
  public putAuthorization(value: AlertmanagerConfigReceiverWechatConfigsHttpConfigAuthorization) {
    this._authorization.internalValue = value;
  }
  public resetAuthorization() {
    this._authorization.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationInput() {
    return this._authorization.internalValue;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new AlertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: AlertmanagerConfigReceiverWechatConfigsHttpConfigBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: AlertmanagerConfigReceiverWechatConfigsHttpConfigOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // tls_config - computed: false, optional: true, required: false
  private _tlsConfig = new AlertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfigOutputReference(this, "tls_config");
  public get tlsConfig() {
    return this._tlsConfig;
  }
  public putTlsConfig(value: AlertmanagerConfigReceiverWechatConfigsHttpConfigTlsConfig) {
    this._tlsConfig.internalValue = value;
  }
  public resetTlsConfig() {
    this._tlsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsConfigInput() {
    return this._tlsConfig.internalValue;
  }
}
export interface AlertmanagerConfigReceiverWechatConfigs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#agent_id AlertmanagerConfig#agent_id}
  */
  readonly agentId?: string;
  /**
  * The API key to use when talking to the WeChat API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#api_secret AlertmanagerConfig#api_secret}
  */
  readonly apiSecret?: string;
  /**
  * The WeChat API URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#api_url AlertmanagerConfig#api_url}
  */
  readonly apiUrl?: string;
  /**
  * The corp id for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#corp_id AlertmanagerConfig#corp_id}
  */
  readonly corpId?: string;
  /**
  * API request data as defined by the WeChat API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#message AlertmanagerConfig#message}
  */
  readonly message?: string;
  /**
  * Type of the message type, supported values are `text` and `markdown`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#message_type AlertmanagerConfig#message_type}
  */
  readonly messageType?: string;
  /**
  * Whether to notify about resolved alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#send_resolved AlertmanagerConfig#send_resolved}
  */
  readonly sendResolved?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#to_party AlertmanagerConfig#to_party}
  */
  readonly toParty?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#to_tag AlertmanagerConfig#to_tag}
  */
  readonly toTag?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#to_user AlertmanagerConfig#to_user}
  */
  readonly toUser?: string;
  /**
  * http_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#http_config AlertmanagerConfig#http_config}
  */
  readonly httpConfig?: AlertmanagerConfigReceiverWechatConfigsHttpConfig;
}

export function alertmanagerConfigReceiverWechatConfigsToTerraform(struct?: AlertmanagerConfigReceiverWechatConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    agent_id: cdktf.stringToTerraform(struct!.agentId),
    api_secret: cdktf.stringToTerraform(struct!.apiSecret),
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    corp_id: cdktf.stringToTerraform(struct!.corpId),
    message: cdktf.stringToTerraform(struct!.message),
    message_type: cdktf.stringToTerraform(struct!.messageType),
    send_resolved: cdktf.booleanToTerraform(struct!.sendResolved),
    to_party: cdktf.stringToTerraform(struct!.toParty),
    to_tag: cdktf.stringToTerraform(struct!.toTag),
    to_user: cdktf.stringToTerraform(struct!.toUser),
    http_config: alertmanagerConfigReceiverWechatConfigsHttpConfigToTerraform(struct!.httpConfig),
  }
}


export function alertmanagerConfigReceiverWechatConfigsToHclTerraform(struct?: AlertmanagerConfigReceiverWechatConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    agent_id: {
      value: cdktf.stringToHclTerraform(struct!.agentId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_secret: {
      value: cdktf.stringToHclTerraform(struct!.apiSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    corp_id: {
      value: cdktf.stringToHclTerraform(struct!.corpId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_type: {
      value: cdktf.stringToHclTerraform(struct!.messageType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_resolved: {
      value: cdktf.booleanToHclTerraform(struct!.sendResolved),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    to_party: {
      value: cdktf.stringToHclTerraform(struct!.toParty),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    to_tag: {
      value: cdktf.stringToHclTerraform(struct!.toTag),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    to_user: {
      value: cdktf.stringToHclTerraform(struct!.toUser),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_config: {
      value: alertmanagerConfigReceiverWechatConfigsHttpConfigToHclTerraform(struct!.httpConfig),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWechatConfigsHttpConfigList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverWechatConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiverWechatConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._agentId !== undefined) {
      hasAnyValues = true;
      internalValueResult.agentId = this._agentId;
    }
    if (this._apiSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiSecret = this._apiSecret;
    }
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._corpId !== undefined) {
      hasAnyValues = true;
      internalValueResult.corpId = this._corpId;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._messageType !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageType = this._messageType;
    }
    if (this._sendResolved !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendResolved = this._sendResolved;
    }
    if (this._toParty !== undefined) {
      hasAnyValues = true;
      internalValueResult.toParty = this._toParty;
    }
    if (this._toTag !== undefined) {
      hasAnyValues = true;
      internalValueResult.toTag = this._toTag;
    }
    if (this._toUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.toUser = this._toUser;
    }
    if (this._httpConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConfig = this._httpConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiverWechatConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._agentId = undefined;
      this._apiSecret = undefined;
      this._apiUrl = undefined;
      this._corpId = undefined;
      this._message = undefined;
      this._messageType = undefined;
      this._sendResolved = undefined;
      this._toParty = undefined;
      this._toTag = undefined;
      this._toUser = undefined;
      this._httpConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._agentId = value.agentId;
      this._apiSecret = value.apiSecret;
      this._apiUrl = value.apiUrl;
      this._corpId = value.corpId;
      this._message = value.message;
      this._messageType = value.messageType;
      this._sendResolved = value.sendResolved;
      this._toParty = value.toParty;
      this._toTag = value.toTag;
      this._toUser = value.toUser;
      this._httpConfig.internalValue = value.httpConfig;
    }
  }

  // agent_id - computed: false, optional: true, required: false
  private _agentId?: string; 
  public get agentId() {
    return this.getStringAttribute('agent_id');
  }
  public set agentId(value: string) {
    this._agentId = value;
  }
  public resetAgentId() {
    this._agentId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get agentIdInput() {
    return this._agentId;
  }

  // api_secret - computed: false, optional: true, required: false
  private _apiSecret?: string; 
  public get apiSecret() {
    return this.getStringAttribute('api_secret');
  }
  public set apiSecret(value: string) {
    this._apiSecret = value;
  }
  public resetApiSecret() {
    this._apiSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiSecretInput() {
    return this._apiSecret;
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // corp_id - computed: false, optional: true, required: false
  private _corpId?: string; 
  public get corpId() {
    return this.getStringAttribute('corp_id');
  }
  public set corpId(value: string) {
    this._corpId = value;
  }
  public resetCorpId() {
    this._corpId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get corpIdInput() {
    return this._corpId;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // message_type - computed: false, optional: true, required: false
  private _messageType?: string; 
  public get messageType() {
    return this.getStringAttribute('message_type');
  }
  public set messageType(value: string) {
    this._messageType = value;
  }
  public resetMessageType() {
    this._messageType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageTypeInput() {
    return this._messageType;
  }

  // send_resolved - computed: false, optional: true, required: false
  private _sendResolved?: boolean | cdktf.IResolvable; 
  public get sendResolved() {
    return this.getBooleanAttribute('send_resolved');
  }
  public set sendResolved(value: boolean | cdktf.IResolvable) {
    this._sendResolved = value;
  }
  public resetSendResolved() {
    this._sendResolved = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendResolvedInput() {
    return this._sendResolved;
  }

  // to_party - computed: false, optional: true, required: false
  private _toParty?: string; 
  public get toParty() {
    return this.getStringAttribute('to_party');
  }
  public set toParty(value: string) {
    this._toParty = value;
  }
  public resetToParty() {
    this._toParty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toPartyInput() {
    return this._toParty;
  }

  // to_tag - computed: false, optional: true, required: false
  private _toTag?: string; 
  public get toTag() {
    return this.getStringAttribute('to_tag');
  }
  public set toTag(value: string) {
    this._toTag = value;
  }
  public resetToTag() {
    this._toTag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toTagInput() {
    return this._toTag;
  }

  // to_user - computed: false, optional: true, required: false
  private _toUser?: string; 
  public get toUser() {
    return this.getStringAttribute('to_user');
  }
  public set toUser(value: string) {
    this._toUser = value;
  }
  public resetToUser() {
    this._toUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toUserInput() {
    return this._toUser;
  }

  // http_config - computed: false, optional: true, required: false
  private _httpConfig = new AlertmanagerConfigReceiverWechatConfigsHttpConfigOutputReference(this, "http_config");
  public get httpConfig() {
    return this._httpConfig;
  }
  public putHttpConfig(value: AlertmanagerConfigReceiverWechatConfigsHttpConfig) {
    this._httpConfig.internalValue = value;
  }
  public resetHttpConfig() {
    this._httpConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConfigInput() {
    return this._httpConfig.internalValue;
  }
}

export class AlertmanagerConfigReceiverWechatConfigsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiverWechatConfigs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverWechatConfigsOutputReference {
    return new AlertmanagerConfigReceiverWechatConfigsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigReceiver {
  /**
  * The time after which an alert is declared resolved if it has not been updated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#name AlertmanagerConfig#name}
  */
  readonly name: string;
  /**
  * discord_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#discord_configs AlertmanagerConfig#discord_configs}
  */
  readonly discordConfigs?: AlertmanagerConfigReceiverDiscordConfigs[] | cdktf.IResolvable;
  /**
  * email_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#email_configs AlertmanagerConfig#email_configs}
  */
  readonly emailConfigs?: AlertmanagerConfigReceiverEmailConfigs[] | cdktf.IResolvable;
  /**
  * msteams_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#msteams_configs AlertmanagerConfig#msteams_configs}
  */
  readonly msteamsConfigs?: AlertmanagerConfigReceiverMsteamsConfigs[] | cdktf.IResolvable;
  /**
  * opsgenie_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#opsgenie_configs AlertmanagerConfig#opsgenie_configs}
  */
  readonly opsgenieConfigs?: AlertmanagerConfigReceiverOpsgenieConfigs[] | cdktf.IResolvable;
  /**
  * pagerduty_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#pagerduty_configs AlertmanagerConfig#pagerduty_configs}
  */
  readonly pagerdutyConfigs?: AlertmanagerConfigReceiverPagerdutyConfigs[] | cdktf.IResolvable;
  /**
  * pushover_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#pushover_configs AlertmanagerConfig#pushover_configs}
  */
  readonly pushoverConfigs?: AlertmanagerConfigReceiverPushoverConfigs[] | cdktf.IResolvable;
  /**
  * slack_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#slack_configs AlertmanagerConfig#slack_configs}
  */
  readonly slackConfigs?: AlertmanagerConfigReceiverSlackConfigs[] | cdktf.IResolvable;
  /**
  * sns_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#sns_configs AlertmanagerConfig#sns_configs}
  */
  readonly snsConfigs?: AlertmanagerConfigReceiverSnsConfigs[] | cdktf.IResolvable;
  /**
  * telegram_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#telegram_configs AlertmanagerConfig#telegram_configs}
  */
  readonly telegramConfigs?: AlertmanagerConfigReceiverTelegramConfigs[] | cdktf.IResolvable;
  /**
  * victorops_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#victorops_configs AlertmanagerConfig#victorops_configs}
  */
  readonly victoropsConfigs?: AlertmanagerConfigReceiverVictoropsConfigs[] | cdktf.IResolvable;
  /**
  * webex_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#webex_configs AlertmanagerConfig#webex_configs}
  */
  readonly webexConfigs?: AlertmanagerConfigReceiverWebexConfigs[] | cdktf.IResolvable;
  /**
  * webhook_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#webhook_configs AlertmanagerConfig#webhook_configs}
  */
  readonly webhookConfigs?: AlertmanagerConfigReceiverWebhookConfigs[] | cdktf.IResolvable;
  /**
  * wechat_configs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#wechat_configs AlertmanagerConfig#wechat_configs}
  */
  readonly wechatConfigs?: AlertmanagerConfigReceiverWechatConfigs[] | cdktf.IResolvable;
}

export function alertmanagerConfigReceiverToTerraform(struct?: AlertmanagerConfigReceiver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    discord_configs: cdktf.listMapper(alertmanagerConfigReceiverDiscordConfigsToTerraform, true)(struct!.discordConfigs),
    email_configs: cdktf.listMapper(alertmanagerConfigReceiverEmailConfigsToTerraform, true)(struct!.emailConfigs),
    msteams_configs: cdktf.listMapper(alertmanagerConfigReceiverMsteamsConfigsToTerraform, true)(struct!.msteamsConfigs),
    opsgenie_configs: cdktf.listMapper(alertmanagerConfigReceiverOpsgenieConfigsToTerraform, true)(struct!.opsgenieConfigs),
    pagerduty_configs: cdktf.listMapper(alertmanagerConfigReceiverPagerdutyConfigsToTerraform, true)(struct!.pagerdutyConfigs),
    pushover_configs: cdktf.listMapper(alertmanagerConfigReceiverPushoverConfigsToTerraform, true)(struct!.pushoverConfigs),
    slack_configs: cdktf.listMapper(alertmanagerConfigReceiverSlackConfigsToTerraform, true)(struct!.slackConfigs),
    sns_configs: cdktf.listMapper(alertmanagerConfigReceiverSnsConfigsToTerraform, true)(struct!.snsConfigs),
    telegram_configs: cdktf.listMapper(alertmanagerConfigReceiverTelegramConfigsToTerraform, true)(struct!.telegramConfigs),
    victorops_configs: cdktf.listMapper(alertmanagerConfigReceiverVictoropsConfigsToTerraform, true)(struct!.victoropsConfigs),
    webex_configs: cdktf.listMapper(alertmanagerConfigReceiverWebexConfigsToTerraform, true)(struct!.webexConfigs),
    webhook_configs: cdktf.listMapper(alertmanagerConfigReceiverWebhookConfigsToTerraform, true)(struct!.webhookConfigs),
    wechat_configs: cdktf.listMapper(alertmanagerConfigReceiverWechatConfigsToTerraform, true)(struct!.wechatConfigs),
  }
}


export function alertmanagerConfigReceiverToHclTerraform(struct?: AlertmanagerConfigReceiver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discord_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverDiscordConfigsToHclTerraform, true)(struct!.discordConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverDiscordConfigsList",
    },
    email_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverEmailConfigsToHclTerraform, true)(struct!.emailConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverEmailConfigsList",
    },
    msteams_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverMsteamsConfigsToHclTerraform, true)(struct!.msteamsConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverMsteamsConfigsList",
    },
    opsgenie_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverOpsgenieConfigsToHclTerraform, true)(struct!.opsgenieConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverOpsgenieConfigsList",
    },
    pagerduty_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverPagerdutyConfigsToHclTerraform, true)(struct!.pagerdutyConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPagerdutyConfigsList",
    },
    pushover_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverPushoverConfigsToHclTerraform, true)(struct!.pushoverConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverPushoverConfigsList",
    },
    slack_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverSlackConfigsToHclTerraform, true)(struct!.slackConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSlackConfigsList",
    },
    sns_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverSnsConfigsToHclTerraform, true)(struct!.snsConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverSnsConfigsList",
    },
    telegram_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverTelegramConfigsToHclTerraform, true)(struct!.telegramConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverTelegramConfigsList",
    },
    victorops_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverVictoropsConfigsToHclTerraform, true)(struct!.victoropsConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverVictoropsConfigsList",
    },
    webex_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverWebexConfigsToHclTerraform, true)(struct!.webexConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebexConfigsList",
    },
    webhook_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverWebhookConfigsToHclTerraform, true)(struct!.webhookConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWebhookConfigsList",
    },
    wechat_configs: {
      value: cdktf.listMapperHcl(alertmanagerConfigReceiverWechatConfigsToHclTerraform, true)(struct!.wechatConfigs),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigReceiverWechatConfigsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigReceiverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigReceiver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._discordConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.discordConfigs = this._discordConfigs?.internalValue;
    }
    if (this._emailConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.emailConfigs = this._emailConfigs?.internalValue;
    }
    if (this._msteamsConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.msteamsConfigs = this._msteamsConfigs?.internalValue;
    }
    if (this._opsgenieConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.opsgenieConfigs = this._opsgenieConfigs?.internalValue;
    }
    if (this._pagerdutyConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pagerdutyConfigs = this._pagerdutyConfigs?.internalValue;
    }
    if (this._pushoverConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pushoverConfigs = this._pushoverConfigs?.internalValue;
    }
    if (this._slackConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slackConfigs = this._slackConfigs?.internalValue;
    }
    if (this._snsConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.snsConfigs = this._snsConfigs?.internalValue;
    }
    if (this._telegramConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.telegramConfigs = this._telegramConfigs?.internalValue;
    }
    if (this._victoropsConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.victoropsConfigs = this._victoropsConfigs?.internalValue;
    }
    if (this._webexConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.webexConfigs = this._webexConfigs?.internalValue;
    }
    if (this._webhookConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.webhookConfigs = this._webhookConfigs?.internalValue;
    }
    if (this._wechatConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wechatConfigs = this._wechatConfigs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigReceiver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._discordConfigs.internalValue = undefined;
      this._emailConfigs.internalValue = undefined;
      this._msteamsConfigs.internalValue = undefined;
      this._opsgenieConfigs.internalValue = undefined;
      this._pagerdutyConfigs.internalValue = undefined;
      this._pushoverConfigs.internalValue = undefined;
      this._slackConfigs.internalValue = undefined;
      this._snsConfigs.internalValue = undefined;
      this._telegramConfigs.internalValue = undefined;
      this._victoropsConfigs.internalValue = undefined;
      this._webexConfigs.internalValue = undefined;
      this._webhookConfigs.internalValue = undefined;
      this._wechatConfigs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._discordConfigs.internalValue = value.discordConfigs;
      this._emailConfigs.internalValue = value.emailConfigs;
      this._msteamsConfigs.internalValue = value.msteamsConfigs;
      this._opsgenieConfigs.internalValue = value.opsgenieConfigs;
      this._pagerdutyConfigs.internalValue = value.pagerdutyConfigs;
      this._pushoverConfigs.internalValue = value.pushoverConfigs;
      this._slackConfigs.internalValue = value.slackConfigs;
      this._snsConfigs.internalValue = value.snsConfigs;
      this._telegramConfigs.internalValue = value.telegramConfigs;
      this._victoropsConfigs.internalValue = value.victoropsConfigs;
      this._webexConfigs.internalValue = value.webexConfigs;
      this._webhookConfigs.internalValue = value.webhookConfigs;
      this._wechatConfigs.internalValue = value.wechatConfigs;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // discord_configs - computed: false, optional: true, required: false
  private _discordConfigs = new AlertmanagerConfigReceiverDiscordConfigsList(this, "discord_configs", false);
  public get discordConfigs() {
    return this._discordConfigs;
  }
  public putDiscordConfigs(value: AlertmanagerConfigReceiverDiscordConfigs[] | cdktf.IResolvable) {
    this._discordConfigs.internalValue = value;
  }
  public resetDiscordConfigs() {
    this._discordConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discordConfigsInput() {
    return this._discordConfigs.internalValue;
  }

  // email_configs - computed: false, optional: true, required: false
  private _emailConfigs = new AlertmanagerConfigReceiverEmailConfigsList(this, "email_configs", false);
  public get emailConfigs() {
    return this._emailConfigs;
  }
  public putEmailConfigs(value: AlertmanagerConfigReceiverEmailConfigs[] | cdktf.IResolvable) {
    this._emailConfigs.internalValue = value;
  }
  public resetEmailConfigs() {
    this._emailConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emailConfigsInput() {
    return this._emailConfigs.internalValue;
  }

  // msteams_configs - computed: false, optional: true, required: false
  private _msteamsConfigs = new AlertmanagerConfigReceiverMsteamsConfigsList(this, "msteams_configs", false);
  public get msteamsConfigs() {
    return this._msteamsConfigs;
  }
  public putMsteamsConfigs(value: AlertmanagerConfigReceiverMsteamsConfigs[] | cdktf.IResolvable) {
    this._msteamsConfigs.internalValue = value;
  }
  public resetMsteamsConfigs() {
    this._msteamsConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get msteamsConfigsInput() {
    return this._msteamsConfigs.internalValue;
  }

  // opsgenie_configs - computed: false, optional: true, required: false
  private _opsgenieConfigs = new AlertmanagerConfigReceiverOpsgenieConfigsList(this, "opsgenie_configs", false);
  public get opsgenieConfigs() {
    return this._opsgenieConfigs;
  }
  public putOpsgenieConfigs(value: AlertmanagerConfigReceiverOpsgenieConfigs[] | cdktf.IResolvable) {
    this._opsgenieConfigs.internalValue = value;
  }
  public resetOpsgenieConfigs() {
    this._opsgenieConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opsgenieConfigsInput() {
    return this._opsgenieConfigs.internalValue;
  }

  // pagerduty_configs - computed: false, optional: true, required: false
  private _pagerdutyConfigs = new AlertmanagerConfigReceiverPagerdutyConfigsList(this, "pagerduty_configs", false);
  public get pagerdutyConfigs() {
    return this._pagerdutyConfigs;
  }
  public putPagerdutyConfigs(value: AlertmanagerConfigReceiverPagerdutyConfigs[] | cdktf.IResolvable) {
    this._pagerdutyConfigs.internalValue = value;
  }
  public resetPagerdutyConfigs() {
    this._pagerdutyConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pagerdutyConfigsInput() {
    return this._pagerdutyConfigs.internalValue;
  }

  // pushover_configs - computed: false, optional: true, required: false
  private _pushoverConfigs = new AlertmanagerConfigReceiverPushoverConfigsList(this, "pushover_configs", false);
  public get pushoverConfigs() {
    return this._pushoverConfigs;
  }
  public putPushoverConfigs(value: AlertmanagerConfigReceiverPushoverConfigs[] | cdktf.IResolvable) {
    this._pushoverConfigs.internalValue = value;
  }
  public resetPushoverConfigs() {
    this._pushoverConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pushoverConfigsInput() {
    return this._pushoverConfigs.internalValue;
  }

  // slack_configs - computed: false, optional: true, required: false
  private _slackConfigs = new AlertmanagerConfigReceiverSlackConfigsList(this, "slack_configs", false);
  public get slackConfigs() {
    return this._slackConfigs;
  }
  public putSlackConfigs(value: AlertmanagerConfigReceiverSlackConfigs[] | cdktf.IResolvable) {
    this._slackConfigs.internalValue = value;
  }
  public resetSlackConfigs() {
    this._slackConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slackConfigsInput() {
    return this._slackConfigs.internalValue;
  }

  // sns_configs - computed: false, optional: true, required: false
  private _snsConfigs = new AlertmanagerConfigReceiverSnsConfigsList(this, "sns_configs", false);
  public get snsConfigs() {
    return this._snsConfigs;
  }
  public putSnsConfigs(value: AlertmanagerConfigReceiverSnsConfigs[] | cdktf.IResolvable) {
    this._snsConfigs.internalValue = value;
  }
  public resetSnsConfigs() {
    this._snsConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snsConfigsInput() {
    return this._snsConfigs.internalValue;
  }

  // telegram_configs - computed: false, optional: true, required: false
  private _telegramConfigs = new AlertmanagerConfigReceiverTelegramConfigsList(this, "telegram_configs", false);
  public get telegramConfigs() {
    return this._telegramConfigs;
  }
  public putTelegramConfigs(value: AlertmanagerConfigReceiverTelegramConfigs[] | cdktf.IResolvable) {
    this._telegramConfigs.internalValue = value;
  }
  public resetTelegramConfigs() {
    this._telegramConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get telegramConfigsInput() {
    return this._telegramConfigs.internalValue;
  }

  // victorops_configs - computed: false, optional: true, required: false
  private _victoropsConfigs = new AlertmanagerConfigReceiverVictoropsConfigsList(this, "victorops_configs", false);
  public get victoropsConfigs() {
    return this._victoropsConfigs;
  }
  public putVictoropsConfigs(value: AlertmanagerConfigReceiverVictoropsConfigs[] | cdktf.IResolvable) {
    this._victoropsConfigs.internalValue = value;
  }
  public resetVictoropsConfigs() {
    this._victoropsConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get victoropsConfigsInput() {
    return this._victoropsConfigs.internalValue;
  }

  // webex_configs - computed: false, optional: true, required: false
  private _webexConfigs = new AlertmanagerConfigReceiverWebexConfigsList(this, "webex_configs", false);
  public get webexConfigs() {
    return this._webexConfigs;
  }
  public putWebexConfigs(value: AlertmanagerConfigReceiverWebexConfigs[] | cdktf.IResolvable) {
    this._webexConfigs.internalValue = value;
  }
  public resetWebexConfigs() {
    this._webexConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webexConfigsInput() {
    return this._webexConfigs.internalValue;
  }

  // webhook_configs - computed: false, optional: true, required: false
  private _webhookConfigs = new AlertmanagerConfigReceiverWebhookConfigsList(this, "webhook_configs", false);
  public get webhookConfigs() {
    return this._webhookConfigs;
  }
  public putWebhookConfigs(value: AlertmanagerConfigReceiverWebhookConfigs[] | cdktf.IResolvable) {
    this._webhookConfigs.internalValue = value;
  }
  public resetWebhookConfigs() {
    this._webhookConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webhookConfigsInput() {
    return this._webhookConfigs.internalValue;
  }

  // wechat_configs - computed: false, optional: true, required: false
  private _wechatConfigs = new AlertmanagerConfigReceiverWechatConfigsList(this, "wechat_configs", false);
  public get wechatConfigs() {
    return this._wechatConfigs;
  }
  public putWechatConfigs(value: AlertmanagerConfigReceiverWechatConfigs[] | cdktf.IResolvable) {
    this._wechatConfigs.internalValue = value;
  }
  public resetWechatConfigs() {
    this._wechatConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wechatConfigsInput() {
    return this._wechatConfigs.internalValue;
  }
}

export class AlertmanagerConfigReceiverList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigReceiver[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigReceiverOutputReference {
    return new AlertmanagerConfigReceiverOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigRouteChildRouteChildRouteChildRoute {
  /**
  * Times when the route should be active. These must match the name of a mute time interval defined in the time_interval block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#active_time_intervals AlertmanagerConfig#active_time_intervals}
  */
  readonly activeTimeIntervals?: string[];
  /**
  * Whether an alert should continue matching subsequent sibling nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#continue AlertmanagerConfig#continue}
  */
  readonly continue?: boolean | cdktf.IResolvable;
  /**
  * The labels by which incoming alerts are grouped together.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group_by AlertmanagerConfig#group_by}
  */
  readonly groupBy?: string[];
  /**
  * How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group_interval AlertmanagerConfig#group_interval}
  */
  readonly groupInterval?: string;
  /**
  * How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group_wait AlertmanagerConfig#group_wait}
  */
  readonly groupWait?: string;
  /**
  * A list of matchers that an alert has to fulfill to match the node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#matchers AlertmanagerConfig#matchers}
  */
  readonly matchers?: string[];
  /**
  * Times when the route should be muted. These must match the name of a mute time interval defined in the time_interval block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#mute_time_intervals AlertmanagerConfig#mute_time_intervals}
  */
  readonly muteTimeIntervals?: string[];
  /**
  * Name of the receiver to send the notification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#receiver AlertmanagerConfig#receiver}
  */
  readonly receiver?: string;
  /**
  * How long to wait before sending a notification again if it has already been sent successfully for an alert.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#repeat_interval AlertmanagerConfig#repeat_interval}
  */
  readonly repeatInterval?: string;
}

export function alertmanagerConfigRouteChildRouteChildRouteChildRouteToTerraform(struct?: AlertmanagerConfigRouteChildRouteChildRouteChildRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    active_time_intervals: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.activeTimeIntervals),
    continue: cdktf.booleanToTerraform(struct!.continue),
    group_by: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupBy),
    group_interval: cdktf.stringToTerraform(struct!.groupInterval),
    group_wait: cdktf.stringToTerraform(struct!.groupWait),
    matchers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matchers),
    mute_time_intervals: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.muteTimeIntervals),
    receiver: cdktf.stringToTerraform(struct!.receiver),
    repeat_interval: cdktf.stringToTerraform(struct!.repeatInterval),
  }
}


export function alertmanagerConfigRouteChildRouteChildRouteChildRouteToHclTerraform(struct?: AlertmanagerConfigRouteChildRouteChildRouteChildRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    active_time_intervals: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.activeTimeIntervals),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    continue: {
      value: cdktf.booleanToHclTerraform(struct!.continue),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    group_by: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupBy),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    group_interval: {
      value: cdktf.stringToHclTerraform(struct!.groupInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_wait: {
      value: cdktf.stringToHclTerraform(struct!.groupWait),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    matchers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matchers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mute_time_intervals: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.muteTimeIntervals),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    receiver: {
      value: cdktf.stringToHclTerraform(struct!.receiver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    repeat_interval: {
      value: cdktf.stringToHclTerraform(struct!.repeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigRouteChildRouteChildRouteChildRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigRouteChildRouteChildRouteChildRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activeTimeIntervals !== undefined) {
      hasAnyValues = true;
      internalValueResult.activeTimeIntervals = this._activeTimeIntervals;
    }
    if (this._continue !== undefined) {
      hasAnyValues = true;
      internalValueResult.continue = this._continue;
    }
    if (this._groupBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupBy = this._groupBy;
    }
    if (this._groupInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupInterval = this._groupInterval;
    }
    if (this._groupWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupWait = this._groupWait;
    }
    if (this._matchers !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchers = this._matchers;
    }
    if (this._muteTimeIntervals !== undefined) {
      hasAnyValues = true;
      internalValueResult.muteTimeIntervals = this._muteTimeIntervals;
    }
    if (this._receiver !== undefined) {
      hasAnyValues = true;
      internalValueResult.receiver = this._receiver;
    }
    if (this._repeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.repeatInterval = this._repeatInterval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigRouteChildRouteChildRouteChildRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activeTimeIntervals = undefined;
      this._continue = undefined;
      this._groupBy = undefined;
      this._groupInterval = undefined;
      this._groupWait = undefined;
      this._matchers = undefined;
      this._muteTimeIntervals = undefined;
      this._receiver = undefined;
      this._repeatInterval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activeTimeIntervals = value.activeTimeIntervals;
      this._continue = value.continue;
      this._groupBy = value.groupBy;
      this._groupInterval = value.groupInterval;
      this._groupWait = value.groupWait;
      this._matchers = value.matchers;
      this._muteTimeIntervals = value.muteTimeIntervals;
      this._receiver = value.receiver;
      this._repeatInterval = value.repeatInterval;
    }
  }

  // active_time_intervals - computed: false, optional: true, required: false
  private _activeTimeIntervals?: string[]; 
  public get activeTimeIntervals() {
    return this.getListAttribute('active_time_intervals');
  }
  public set activeTimeIntervals(value: string[]) {
    this._activeTimeIntervals = value;
  }
  public resetActiveTimeIntervals() {
    this._activeTimeIntervals = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activeTimeIntervalsInput() {
    return this._activeTimeIntervals;
  }

  // continue - computed: false, optional: true, required: false
  private _continue?: boolean | cdktf.IResolvable; 
  public get continue() {
    return this.getBooleanAttribute('continue');
  }
  public set continue(value: boolean | cdktf.IResolvable) {
    this._continue = value;
  }
  public resetContinue() {
    this._continue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get continueInput() {
    return this._continue;
  }

  // group_by - computed: false, optional: true, required: false
  private _groupBy?: string[]; 
  public get groupBy() {
    return this.getListAttribute('group_by');
  }
  public set groupBy(value: string[]) {
    this._groupBy = value;
  }
  public resetGroupBy() {
    this._groupBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupByInput() {
    return this._groupBy;
  }

  // group_interval - computed: false, optional: true, required: false
  private _groupInterval?: string; 
  public get groupInterval() {
    return this.getStringAttribute('group_interval');
  }
  public set groupInterval(value: string) {
    this._groupInterval = value;
  }
  public resetGroupInterval() {
    this._groupInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupIntervalInput() {
    return this._groupInterval;
  }

  // group_wait - computed: false, optional: true, required: false
  private _groupWait?: string; 
  public get groupWait() {
    return this.getStringAttribute('group_wait');
  }
  public set groupWait(value: string) {
    this._groupWait = value;
  }
  public resetGroupWait() {
    this._groupWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupWaitInput() {
    return this._groupWait;
  }

  // matchers - computed: false, optional: true, required: false
  private _matchers?: string[]; 
  public get matchers() {
    return this.getListAttribute('matchers');
  }
  public set matchers(value: string[]) {
    this._matchers = value;
  }
  public resetMatchers() {
    this._matchers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchersInput() {
    return this._matchers;
  }

  // mute_time_intervals - computed: false, optional: true, required: false
  private _muteTimeIntervals?: string[]; 
  public get muteTimeIntervals() {
    return this.getListAttribute('mute_time_intervals');
  }
  public set muteTimeIntervals(value: string[]) {
    this._muteTimeIntervals = value;
  }
  public resetMuteTimeIntervals() {
    this._muteTimeIntervals = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get muteTimeIntervalsInput() {
    return this._muteTimeIntervals;
  }

  // receiver - computed: false, optional: true, required: false
  private _receiver?: string; 
  public get receiver() {
    return this.getStringAttribute('receiver');
  }
  public set receiver(value: string) {
    this._receiver = value;
  }
  public resetReceiver() {
    this._receiver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get receiverInput() {
    return this._receiver;
  }

  // repeat_interval - computed: false, optional: true, required: false
  private _repeatInterval?: string; 
  public get repeatInterval() {
    return this.getStringAttribute('repeat_interval');
  }
  public set repeatInterval(value: string) {
    this._repeatInterval = value;
  }
  public resetRepeatInterval() {
    this._repeatInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get repeatIntervalInput() {
    return this._repeatInterval;
  }
}

export class AlertmanagerConfigRouteChildRouteChildRouteChildRouteList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigRouteChildRouteChildRouteChildRoute[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigRouteChildRouteChildRouteChildRouteOutputReference {
    return new AlertmanagerConfigRouteChildRouteChildRouteChildRouteOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigRouteChildRouteChildRoute {
  /**
  * Times when the route should be active. These must match the name of a mute time interval defined in the time_interval block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#active_time_intervals AlertmanagerConfig#active_time_intervals}
  */
  readonly activeTimeIntervals?: string[];
  /**
  * Whether an alert should continue matching subsequent sibling nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#continue AlertmanagerConfig#continue}
  */
  readonly continue?: boolean | cdktf.IResolvable;
  /**
  * The labels by which incoming alerts are grouped together.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group_by AlertmanagerConfig#group_by}
  */
  readonly groupBy?: string[];
  /**
  * How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group_interval AlertmanagerConfig#group_interval}
  */
  readonly groupInterval?: string;
  /**
  * How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group_wait AlertmanagerConfig#group_wait}
  */
  readonly groupWait?: string;
  /**
  * A list of matchers that an alert has to fulfill to match the node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#matchers AlertmanagerConfig#matchers}
  */
  readonly matchers?: string[];
  /**
  * Times when the route should be muted. These must match the name of a mute time interval defined in the time_interval block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#mute_time_intervals AlertmanagerConfig#mute_time_intervals}
  */
  readonly muteTimeIntervals?: string[];
  /**
  * Name of the receiver to send the notification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#receiver AlertmanagerConfig#receiver}
  */
  readonly receiver?: string;
  /**
  * How long to wait before sending a notification again if it has already been sent successfully for an alert.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#repeat_interval AlertmanagerConfig#repeat_interval}
  */
  readonly repeatInterval?: string;
  /**
  * child_route block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#child_route AlertmanagerConfig#child_route}
  */
  readonly childRoute?: AlertmanagerConfigRouteChildRouteChildRouteChildRoute[] | cdktf.IResolvable;
}

export function alertmanagerConfigRouteChildRouteChildRouteToTerraform(struct?: AlertmanagerConfigRouteChildRouteChildRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    active_time_intervals: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.activeTimeIntervals),
    continue: cdktf.booleanToTerraform(struct!.continue),
    group_by: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupBy),
    group_interval: cdktf.stringToTerraform(struct!.groupInterval),
    group_wait: cdktf.stringToTerraform(struct!.groupWait),
    matchers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matchers),
    mute_time_intervals: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.muteTimeIntervals),
    receiver: cdktf.stringToTerraform(struct!.receiver),
    repeat_interval: cdktf.stringToTerraform(struct!.repeatInterval),
    child_route: cdktf.listMapper(alertmanagerConfigRouteChildRouteChildRouteChildRouteToTerraform, true)(struct!.childRoute),
  }
}


export function alertmanagerConfigRouteChildRouteChildRouteToHclTerraform(struct?: AlertmanagerConfigRouteChildRouteChildRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    active_time_intervals: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.activeTimeIntervals),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    continue: {
      value: cdktf.booleanToHclTerraform(struct!.continue),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    group_by: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupBy),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    group_interval: {
      value: cdktf.stringToHclTerraform(struct!.groupInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_wait: {
      value: cdktf.stringToHclTerraform(struct!.groupWait),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    matchers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matchers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mute_time_intervals: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.muteTimeIntervals),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    receiver: {
      value: cdktf.stringToHclTerraform(struct!.receiver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    repeat_interval: {
      value: cdktf.stringToHclTerraform(struct!.repeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    child_route: {
      value: cdktf.listMapperHcl(alertmanagerConfigRouteChildRouteChildRouteChildRouteToHclTerraform, true)(struct!.childRoute),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigRouteChildRouteChildRouteChildRouteList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigRouteChildRouteChildRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigRouteChildRouteChildRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activeTimeIntervals !== undefined) {
      hasAnyValues = true;
      internalValueResult.activeTimeIntervals = this._activeTimeIntervals;
    }
    if (this._continue !== undefined) {
      hasAnyValues = true;
      internalValueResult.continue = this._continue;
    }
    if (this._groupBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupBy = this._groupBy;
    }
    if (this._groupInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupInterval = this._groupInterval;
    }
    if (this._groupWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupWait = this._groupWait;
    }
    if (this._matchers !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchers = this._matchers;
    }
    if (this._muteTimeIntervals !== undefined) {
      hasAnyValues = true;
      internalValueResult.muteTimeIntervals = this._muteTimeIntervals;
    }
    if (this._receiver !== undefined) {
      hasAnyValues = true;
      internalValueResult.receiver = this._receiver;
    }
    if (this._repeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.repeatInterval = this._repeatInterval;
    }
    if (this._childRoute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.childRoute = this._childRoute?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigRouteChildRouteChildRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activeTimeIntervals = undefined;
      this._continue = undefined;
      this._groupBy = undefined;
      this._groupInterval = undefined;
      this._groupWait = undefined;
      this._matchers = undefined;
      this._muteTimeIntervals = undefined;
      this._receiver = undefined;
      this._repeatInterval = undefined;
      this._childRoute.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activeTimeIntervals = value.activeTimeIntervals;
      this._continue = value.continue;
      this._groupBy = value.groupBy;
      this._groupInterval = value.groupInterval;
      this._groupWait = value.groupWait;
      this._matchers = value.matchers;
      this._muteTimeIntervals = value.muteTimeIntervals;
      this._receiver = value.receiver;
      this._repeatInterval = value.repeatInterval;
      this._childRoute.internalValue = value.childRoute;
    }
  }

  // active_time_intervals - computed: false, optional: true, required: false
  private _activeTimeIntervals?: string[]; 
  public get activeTimeIntervals() {
    return this.getListAttribute('active_time_intervals');
  }
  public set activeTimeIntervals(value: string[]) {
    this._activeTimeIntervals = value;
  }
  public resetActiveTimeIntervals() {
    this._activeTimeIntervals = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activeTimeIntervalsInput() {
    return this._activeTimeIntervals;
  }

  // continue - computed: false, optional: true, required: false
  private _continue?: boolean | cdktf.IResolvable; 
  public get continue() {
    return this.getBooleanAttribute('continue');
  }
  public set continue(value: boolean | cdktf.IResolvable) {
    this._continue = value;
  }
  public resetContinue() {
    this._continue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get continueInput() {
    return this._continue;
  }

  // group_by - computed: false, optional: true, required: false
  private _groupBy?: string[]; 
  public get groupBy() {
    return this.getListAttribute('group_by');
  }
  public set groupBy(value: string[]) {
    this._groupBy = value;
  }
  public resetGroupBy() {
    this._groupBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupByInput() {
    return this._groupBy;
  }

  // group_interval - computed: false, optional: true, required: false
  private _groupInterval?: string; 
  public get groupInterval() {
    return this.getStringAttribute('group_interval');
  }
  public set groupInterval(value: string) {
    this._groupInterval = value;
  }
  public resetGroupInterval() {
    this._groupInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupIntervalInput() {
    return this._groupInterval;
  }

  // group_wait - computed: false, optional: true, required: false
  private _groupWait?: string; 
  public get groupWait() {
    return this.getStringAttribute('group_wait');
  }
  public set groupWait(value: string) {
    this._groupWait = value;
  }
  public resetGroupWait() {
    this._groupWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupWaitInput() {
    return this._groupWait;
  }

  // matchers - computed: false, optional: true, required: false
  private _matchers?: string[]; 
  public get matchers() {
    return this.getListAttribute('matchers');
  }
  public set matchers(value: string[]) {
    this._matchers = value;
  }
  public resetMatchers() {
    this._matchers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchersInput() {
    return this._matchers;
  }

  // mute_time_intervals - computed: false, optional: true, required: false
  private _muteTimeIntervals?: string[]; 
  public get muteTimeIntervals() {
    return this.getListAttribute('mute_time_intervals');
  }
  public set muteTimeIntervals(value: string[]) {
    this._muteTimeIntervals = value;
  }
  public resetMuteTimeIntervals() {
    this._muteTimeIntervals = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get muteTimeIntervalsInput() {
    return this._muteTimeIntervals;
  }

  // receiver - computed: false, optional: true, required: false
  private _receiver?: string; 
  public get receiver() {
    return this.getStringAttribute('receiver');
  }
  public set receiver(value: string) {
    this._receiver = value;
  }
  public resetReceiver() {
    this._receiver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get receiverInput() {
    return this._receiver;
  }

  // repeat_interval - computed: false, optional: true, required: false
  private _repeatInterval?: string; 
  public get repeatInterval() {
    return this.getStringAttribute('repeat_interval');
  }
  public set repeatInterval(value: string) {
    this._repeatInterval = value;
  }
  public resetRepeatInterval() {
    this._repeatInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get repeatIntervalInput() {
    return this._repeatInterval;
  }

  // child_route - computed: false, optional: true, required: false
  private _childRoute = new AlertmanagerConfigRouteChildRouteChildRouteChildRouteList(this, "child_route", false);
  public get childRoute() {
    return this._childRoute;
  }
  public putChildRoute(value: AlertmanagerConfigRouteChildRouteChildRouteChildRoute[] | cdktf.IResolvable) {
    this._childRoute.internalValue = value;
  }
  public resetChildRoute() {
    this._childRoute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get childRouteInput() {
    return this._childRoute.internalValue;
  }
}

export class AlertmanagerConfigRouteChildRouteChildRouteList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigRouteChildRouteChildRoute[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigRouteChildRouteChildRouteOutputReference {
    return new AlertmanagerConfigRouteChildRouteChildRouteOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigRouteChildRoute {
  /**
  * Times when the route should be active. These must match the name of a mute time interval defined in the time_interval block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#active_time_intervals AlertmanagerConfig#active_time_intervals}
  */
  readonly activeTimeIntervals?: string[];
  /**
  * Whether an alert should continue matching subsequent sibling nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#continue AlertmanagerConfig#continue}
  */
  readonly continue?: boolean | cdktf.IResolvable;
  /**
  * The labels by which incoming alerts are grouped together.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group_by AlertmanagerConfig#group_by}
  */
  readonly groupBy?: string[];
  /**
  * How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group_interval AlertmanagerConfig#group_interval}
  */
  readonly groupInterval?: string;
  /**
  * How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group_wait AlertmanagerConfig#group_wait}
  */
  readonly groupWait?: string;
  /**
  * A list of matchers that an alert has to fulfill to match the node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#matchers AlertmanagerConfig#matchers}
  */
  readonly matchers?: string[];
  /**
  * Times when the route should be muted. These must match the name of a mute time interval defined in the time_interval block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#mute_time_intervals AlertmanagerConfig#mute_time_intervals}
  */
  readonly muteTimeIntervals?: string[];
  /**
  * Name of the receiver to send the notification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#receiver AlertmanagerConfig#receiver}
  */
  readonly receiver?: string;
  /**
  * How long to wait before sending a notification again if it has already been sent successfully for an alert.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#repeat_interval AlertmanagerConfig#repeat_interval}
  */
  readonly repeatInterval?: string;
  /**
  * child_route block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#child_route AlertmanagerConfig#child_route}
  */
  readonly childRoute?: AlertmanagerConfigRouteChildRouteChildRoute[] | cdktf.IResolvable;
}

export function alertmanagerConfigRouteChildRouteToTerraform(struct?: AlertmanagerConfigRouteChildRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    active_time_intervals: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.activeTimeIntervals),
    continue: cdktf.booleanToTerraform(struct!.continue),
    group_by: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupBy),
    group_interval: cdktf.stringToTerraform(struct!.groupInterval),
    group_wait: cdktf.stringToTerraform(struct!.groupWait),
    matchers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matchers),
    mute_time_intervals: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.muteTimeIntervals),
    receiver: cdktf.stringToTerraform(struct!.receiver),
    repeat_interval: cdktf.stringToTerraform(struct!.repeatInterval),
    child_route: cdktf.listMapper(alertmanagerConfigRouteChildRouteChildRouteToTerraform, true)(struct!.childRoute),
  }
}


export function alertmanagerConfigRouteChildRouteToHclTerraform(struct?: AlertmanagerConfigRouteChildRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    active_time_intervals: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.activeTimeIntervals),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    continue: {
      value: cdktf.booleanToHclTerraform(struct!.continue),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    group_by: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupBy),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    group_interval: {
      value: cdktf.stringToHclTerraform(struct!.groupInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_wait: {
      value: cdktf.stringToHclTerraform(struct!.groupWait),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    matchers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matchers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mute_time_intervals: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.muteTimeIntervals),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    receiver: {
      value: cdktf.stringToHclTerraform(struct!.receiver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    repeat_interval: {
      value: cdktf.stringToHclTerraform(struct!.repeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    child_route: {
      value: cdktf.listMapperHcl(alertmanagerConfigRouteChildRouteChildRouteToHclTerraform, true)(struct!.childRoute),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigRouteChildRouteChildRouteList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigRouteChildRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigRouteChildRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activeTimeIntervals !== undefined) {
      hasAnyValues = true;
      internalValueResult.activeTimeIntervals = this._activeTimeIntervals;
    }
    if (this._continue !== undefined) {
      hasAnyValues = true;
      internalValueResult.continue = this._continue;
    }
    if (this._groupBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupBy = this._groupBy;
    }
    if (this._groupInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupInterval = this._groupInterval;
    }
    if (this._groupWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupWait = this._groupWait;
    }
    if (this._matchers !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchers = this._matchers;
    }
    if (this._muteTimeIntervals !== undefined) {
      hasAnyValues = true;
      internalValueResult.muteTimeIntervals = this._muteTimeIntervals;
    }
    if (this._receiver !== undefined) {
      hasAnyValues = true;
      internalValueResult.receiver = this._receiver;
    }
    if (this._repeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.repeatInterval = this._repeatInterval;
    }
    if (this._childRoute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.childRoute = this._childRoute?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigRouteChildRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activeTimeIntervals = undefined;
      this._continue = undefined;
      this._groupBy = undefined;
      this._groupInterval = undefined;
      this._groupWait = undefined;
      this._matchers = undefined;
      this._muteTimeIntervals = undefined;
      this._receiver = undefined;
      this._repeatInterval = undefined;
      this._childRoute.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activeTimeIntervals = value.activeTimeIntervals;
      this._continue = value.continue;
      this._groupBy = value.groupBy;
      this._groupInterval = value.groupInterval;
      this._groupWait = value.groupWait;
      this._matchers = value.matchers;
      this._muteTimeIntervals = value.muteTimeIntervals;
      this._receiver = value.receiver;
      this._repeatInterval = value.repeatInterval;
      this._childRoute.internalValue = value.childRoute;
    }
  }

  // active_time_intervals - computed: false, optional: true, required: false
  private _activeTimeIntervals?: string[]; 
  public get activeTimeIntervals() {
    return this.getListAttribute('active_time_intervals');
  }
  public set activeTimeIntervals(value: string[]) {
    this._activeTimeIntervals = value;
  }
  public resetActiveTimeIntervals() {
    this._activeTimeIntervals = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activeTimeIntervalsInput() {
    return this._activeTimeIntervals;
  }

  // continue - computed: false, optional: true, required: false
  private _continue?: boolean | cdktf.IResolvable; 
  public get continue() {
    return this.getBooleanAttribute('continue');
  }
  public set continue(value: boolean | cdktf.IResolvable) {
    this._continue = value;
  }
  public resetContinue() {
    this._continue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get continueInput() {
    return this._continue;
  }

  // group_by - computed: false, optional: true, required: false
  private _groupBy?: string[]; 
  public get groupBy() {
    return this.getListAttribute('group_by');
  }
  public set groupBy(value: string[]) {
    this._groupBy = value;
  }
  public resetGroupBy() {
    this._groupBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupByInput() {
    return this._groupBy;
  }

  // group_interval - computed: false, optional: true, required: false
  private _groupInterval?: string; 
  public get groupInterval() {
    return this.getStringAttribute('group_interval');
  }
  public set groupInterval(value: string) {
    this._groupInterval = value;
  }
  public resetGroupInterval() {
    this._groupInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupIntervalInput() {
    return this._groupInterval;
  }

  // group_wait - computed: false, optional: true, required: false
  private _groupWait?: string; 
  public get groupWait() {
    return this.getStringAttribute('group_wait');
  }
  public set groupWait(value: string) {
    this._groupWait = value;
  }
  public resetGroupWait() {
    this._groupWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupWaitInput() {
    return this._groupWait;
  }

  // matchers - computed: false, optional: true, required: false
  private _matchers?: string[]; 
  public get matchers() {
    return this.getListAttribute('matchers');
  }
  public set matchers(value: string[]) {
    this._matchers = value;
  }
  public resetMatchers() {
    this._matchers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchersInput() {
    return this._matchers;
  }

  // mute_time_intervals - computed: false, optional: true, required: false
  private _muteTimeIntervals?: string[]; 
  public get muteTimeIntervals() {
    return this.getListAttribute('mute_time_intervals');
  }
  public set muteTimeIntervals(value: string[]) {
    this._muteTimeIntervals = value;
  }
  public resetMuteTimeIntervals() {
    this._muteTimeIntervals = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get muteTimeIntervalsInput() {
    return this._muteTimeIntervals;
  }

  // receiver - computed: false, optional: true, required: false
  private _receiver?: string; 
  public get receiver() {
    return this.getStringAttribute('receiver');
  }
  public set receiver(value: string) {
    this._receiver = value;
  }
  public resetReceiver() {
    this._receiver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get receiverInput() {
    return this._receiver;
  }

  // repeat_interval - computed: false, optional: true, required: false
  private _repeatInterval?: string; 
  public get repeatInterval() {
    return this.getStringAttribute('repeat_interval');
  }
  public set repeatInterval(value: string) {
    this._repeatInterval = value;
  }
  public resetRepeatInterval() {
    this._repeatInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get repeatIntervalInput() {
    return this._repeatInterval;
  }

  // child_route - computed: false, optional: true, required: false
  private _childRoute = new AlertmanagerConfigRouteChildRouteChildRouteList(this, "child_route", false);
  public get childRoute() {
    return this._childRoute;
  }
  public putChildRoute(value: AlertmanagerConfigRouteChildRouteChildRoute[] | cdktf.IResolvable) {
    this._childRoute.internalValue = value;
  }
  public resetChildRoute() {
    this._childRoute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get childRouteInput() {
    return this._childRoute.internalValue;
  }
}

export class AlertmanagerConfigRouteChildRouteList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigRouteChildRoute[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigRouteChildRouteOutputReference {
    return new AlertmanagerConfigRouteChildRouteOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigRoute {
  /**
  * The labels by which incoming alerts are grouped together.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group_by AlertmanagerConfig#group_by}
  */
  readonly groupBy?: string[];
  /**
  * How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group_interval AlertmanagerConfig#group_interval}
  */
  readonly groupInterval: string;
  /**
  * How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#group_wait AlertmanagerConfig#group_wait}
  */
  readonly groupWait: string;
  /**
  * Name of the receiver to send the notification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#receiver AlertmanagerConfig#receiver}
  */
  readonly receiver: string;
  /**
  * How long to wait before sending a notification again if it has already been sent successfully for an alert.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#repeat_interval AlertmanagerConfig#repeat_interval}
  */
  readonly repeatInterval: string;
  /**
  * child_route block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#child_route AlertmanagerConfig#child_route}
  */
  readonly childRoute?: AlertmanagerConfigRouteChildRoute[] | cdktf.IResolvable;
}

export function alertmanagerConfigRouteToTerraform(struct?: AlertmanagerConfigRouteOutputReference | AlertmanagerConfigRoute): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group_by: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupBy),
    group_interval: cdktf.stringToTerraform(struct!.groupInterval),
    group_wait: cdktf.stringToTerraform(struct!.groupWait),
    receiver: cdktf.stringToTerraform(struct!.receiver),
    repeat_interval: cdktf.stringToTerraform(struct!.repeatInterval),
    child_route: cdktf.listMapper(alertmanagerConfigRouteChildRouteToTerraform, true)(struct!.childRoute),
  }
}


export function alertmanagerConfigRouteToHclTerraform(struct?: AlertmanagerConfigRouteOutputReference | AlertmanagerConfigRoute): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group_by: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupBy),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    group_interval: {
      value: cdktf.stringToHclTerraform(struct!.groupInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_wait: {
      value: cdktf.stringToHclTerraform(struct!.groupWait),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    receiver: {
      value: cdktf.stringToHclTerraform(struct!.receiver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    repeat_interval: {
      value: cdktf.stringToHclTerraform(struct!.repeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    child_route: {
      value: cdktf.listMapperHcl(alertmanagerConfigRouteChildRouteToHclTerraform, true)(struct!.childRoute),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigRouteChildRouteList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): AlertmanagerConfigRoute | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groupBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupBy = this._groupBy;
    }
    if (this._groupInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupInterval = this._groupInterval;
    }
    if (this._groupWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupWait = this._groupWait;
    }
    if (this._receiver !== undefined) {
      hasAnyValues = true;
      internalValueResult.receiver = this._receiver;
    }
    if (this._repeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.repeatInterval = this._repeatInterval;
    }
    if (this._childRoute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.childRoute = this._childRoute?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigRoute | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._groupBy = undefined;
      this._groupInterval = undefined;
      this._groupWait = undefined;
      this._receiver = undefined;
      this._repeatInterval = undefined;
      this._childRoute.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._groupBy = value.groupBy;
      this._groupInterval = value.groupInterval;
      this._groupWait = value.groupWait;
      this._receiver = value.receiver;
      this._repeatInterval = value.repeatInterval;
      this._childRoute.internalValue = value.childRoute;
    }
  }

  // group_by - computed: false, optional: true, required: false
  private _groupBy?: string[]; 
  public get groupBy() {
    return this.getListAttribute('group_by');
  }
  public set groupBy(value: string[]) {
    this._groupBy = value;
  }
  public resetGroupBy() {
    this._groupBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupByInput() {
    return this._groupBy;
  }

  // group_interval - computed: false, optional: false, required: true
  private _groupInterval?: string; 
  public get groupInterval() {
    return this.getStringAttribute('group_interval');
  }
  public set groupInterval(value: string) {
    this._groupInterval = value;
  }
  // Temporarily expose input value. Use with caution.
  public get groupIntervalInput() {
    return this._groupInterval;
  }

  // group_wait - computed: false, optional: false, required: true
  private _groupWait?: string; 
  public get groupWait() {
    return this.getStringAttribute('group_wait');
  }
  public set groupWait(value: string) {
    this._groupWait = value;
  }
  // Temporarily expose input value. Use with caution.
  public get groupWaitInput() {
    return this._groupWait;
  }

  // receiver - computed: false, optional: false, required: true
  private _receiver?: string; 
  public get receiver() {
    return this.getStringAttribute('receiver');
  }
  public set receiver(value: string) {
    this._receiver = value;
  }
  // Temporarily expose input value. Use with caution.
  public get receiverInput() {
    return this._receiver;
  }

  // repeat_interval - computed: false, optional: false, required: true
  private _repeatInterval?: string; 
  public get repeatInterval() {
    return this.getStringAttribute('repeat_interval');
  }
  public set repeatInterval(value: string) {
    this._repeatInterval = value;
  }
  // Temporarily expose input value. Use with caution.
  public get repeatIntervalInput() {
    return this._repeatInterval;
  }

  // child_route - computed: false, optional: true, required: false
  private _childRoute = new AlertmanagerConfigRouteChildRouteList(this, "child_route", false);
  public get childRoute() {
    return this._childRoute;
  }
  public putChildRoute(value: AlertmanagerConfigRouteChildRoute[] | cdktf.IResolvable) {
    this._childRoute.internalValue = value;
  }
  public resetChildRoute() {
    this._childRoute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get childRouteInput() {
    return this._childRoute.internalValue;
  }
}
export interface AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#begin AlertmanagerConfig#begin}
  */
  readonly begin?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#end AlertmanagerConfig#end}
  */
  readonly end?: number;
}

export function alertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonthToTerraform(struct?: AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    begin: cdktf.numberToTerraform(struct!.begin),
    end: cdktf.numberToTerraform(struct!.end),
  }
}


export function alertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonthToHclTerraform(struct?: AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    begin: {
      value: cdktf.numberToHclTerraform(struct!.begin),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._begin !== undefined) {
      hasAnyValues = true;
      internalValueResult.begin = this._begin;
    }
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._begin = undefined;
      this._end = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._begin = value.begin;
      this._end = value.end;
    }
  }

  // begin - computed: false, optional: true, required: false
  private _begin?: number; 
  public get begin() {
    return this.getNumberAttribute('begin');
  }
  public set begin(value: number) {
    this._begin = value;
  }
  public resetBegin() {
    this._begin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get beginInput() {
    return this._begin;
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }
}

export class AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonthList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonth[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonthOutputReference {
    return new AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonthOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigTimeIntervalTimeIntervalsMonths {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#begin AlertmanagerConfig#begin}
  */
  readonly begin?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#end AlertmanagerConfig#end}
  */
  readonly end?: number;
}

export function alertmanagerConfigTimeIntervalTimeIntervalsMonthsToTerraform(struct?: AlertmanagerConfigTimeIntervalTimeIntervalsMonths | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    begin: cdktf.numberToTerraform(struct!.begin),
    end: cdktf.numberToTerraform(struct!.end),
  }
}


export function alertmanagerConfigTimeIntervalTimeIntervalsMonthsToHclTerraform(struct?: AlertmanagerConfigTimeIntervalTimeIntervalsMonths | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    begin: {
      value: cdktf.numberToHclTerraform(struct!.begin),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigTimeIntervalTimeIntervalsMonthsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigTimeIntervalTimeIntervalsMonths | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._begin !== undefined) {
      hasAnyValues = true;
      internalValueResult.begin = this._begin;
    }
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigTimeIntervalTimeIntervalsMonths | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._begin = undefined;
      this._end = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._begin = value.begin;
      this._end = value.end;
    }
  }

  // begin - computed: false, optional: true, required: false
  private _begin?: number; 
  public get begin() {
    return this.getNumberAttribute('begin');
  }
  public set begin(value: number) {
    this._begin = value;
  }
  public resetBegin() {
    this._begin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get beginInput() {
    return this._begin;
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }
}

export class AlertmanagerConfigTimeIntervalTimeIntervalsMonthsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigTimeIntervalTimeIntervalsMonths[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigTimeIntervalTimeIntervalsMonthsOutputReference {
    return new AlertmanagerConfigTimeIntervalTimeIntervalsMonthsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigTimeIntervalTimeIntervalsTimes {
  /**
  * End time in HH:MM format.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#end_time AlertmanagerConfig#end_time}
  */
  readonly endTime?: string;
  /**
  * Start time in HH:MM format.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#start_time AlertmanagerConfig#start_time}
  */
  readonly startTime?: string;
}

export function alertmanagerConfigTimeIntervalTimeIntervalsTimesToTerraform(struct?: AlertmanagerConfigTimeIntervalTimeIntervalsTimes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end_time: cdktf.stringToTerraform(struct!.endTime),
    start_time: cdktf.stringToTerraform(struct!.startTime),
  }
}


export function alertmanagerConfigTimeIntervalTimeIntervalsTimesToHclTerraform(struct?: AlertmanagerConfigTimeIntervalTimeIntervalsTimes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end_time: {
      value: cdktf.stringToHclTerraform(struct!.endTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start_time: {
      value: cdktf.stringToHclTerraform(struct!.startTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigTimeIntervalTimeIntervalsTimesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigTimeIntervalTimeIntervalsTimes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.endTime = this._endTime;
    }
    if (this._startTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.startTime = this._startTime;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigTimeIntervalTimeIntervalsTimes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endTime = undefined;
      this._startTime = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endTime = value.endTime;
      this._startTime = value.startTime;
    }
  }

  // end_time - computed: false, optional: true, required: false
  private _endTime?: string; 
  public get endTime() {
    return this.getStringAttribute('end_time');
  }
  public set endTime(value: string) {
    this._endTime = value;
  }
  public resetEndTime() {
    this._endTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endTimeInput() {
    return this._endTime;
  }

  // start_time - computed: false, optional: true, required: false
  private _startTime?: string; 
  public get startTime() {
    return this.getStringAttribute('start_time');
  }
  public set startTime(value: string) {
    this._startTime = value;
  }
  public resetStartTime() {
    this._startTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startTimeInput() {
    return this._startTime;
  }
}

export class AlertmanagerConfigTimeIntervalTimeIntervalsTimesList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigTimeIntervalTimeIntervalsTimes[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigTimeIntervalTimeIntervalsTimesOutputReference {
    return new AlertmanagerConfigTimeIntervalTimeIntervalsTimesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigTimeIntervalTimeIntervalsWeekdays {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#begin AlertmanagerConfig#begin}
  */
  readonly begin?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#end AlertmanagerConfig#end}
  */
  readonly end?: number;
}

export function alertmanagerConfigTimeIntervalTimeIntervalsWeekdaysToTerraform(struct?: AlertmanagerConfigTimeIntervalTimeIntervalsWeekdays | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    begin: cdktf.numberToTerraform(struct!.begin),
    end: cdktf.numberToTerraform(struct!.end),
  }
}


export function alertmanagerConfigTimeIntervalTimeIntervalsWeekdaysToHclTerraform(struct?: AlertmanagerConfigTimeIntervalTimeIntervalsWeekdays | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    begin: {
      value: cdktf.numberToHclTerraform(struct!.begin),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigTimeIntervalTimeIntervalsWeekdaysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigTimeIntervalTimeIntervalsWeekdays | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._begin !== undefined) {
      hasAnyValues = true;
      internalValueResult.begin = this._begin;
    }
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigTimeIntervalTimeIntervalsWeekdays | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._begin = undefined;
      this._end = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._begin = value.begin;
      this._end = value.end;
    }
  }

  // begin - computed: false, optional: true, required: false
  private _begin?: number; 
  public get begin() {
    return this.getNumberAttribute('begin');
  }
  public set begin(value: number) {
    this._begin = value;
  }
  public resetBegin() {
    this._begin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get beginInput() {
    return this._begin;
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }
}

export class AlertmanagerConfigTimeIntervalTimeIntervalsWeekdaysList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigTimeIntervalTimeIntervalsWeekdays[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigTimeIntervalTimeIntervalsWeekdaysOutputReference {
    return new AlertmanagerConfigTimeIntervalTimeIntervalsWeekdaysOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigTimeIntervalTimeIntervalsYears {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#begin AlertmanagerConfig#begin}
  */
  readonly begin?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#end AlertmanagerConfig#end}
  */
  readonly end?: number;
}

export function alertmanagerConfigTimeIntervalTimeIntervalsYearsToTerraform(struct?: AlertmanagerConfigTimeIntervalTimeIntervalsYears | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    begin: cdktf.numberToTerraform(struct!.begin),
    end: cdktf.numberToTerraform(struct!.end),
  }
}


export function alertmanagerConfigTimeIntervalTimeIntervalsYearsToHclTerraform(struct?: AlertmanagerConfigTimeIntervalTimeIntervalsYears | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    begin: {
      value: cdktf.numberToHclTerraform(struct!.begin),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigTimeIntervalTimeIntervalsYearsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigTimeIntervalTimeIntervalsYears | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._begin !== undefined) {
      hasAnyValues = true;
      internalValueResult.begin = this._begin;
    }
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigTimeIntervalTimeIntervalsYears | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._begin = undefined;
      this._end = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._begin = value.begin;
      this._end = value.end;
    }
  }

  // begin - computed: false, optional: true, required: false
  private _begin?: number; 
  public get begin() {
    return this.getNumberAttribute('begin');
  }
  public set begin(value: number) {
    this._begin = value;
  }
  public resetBegin() {
    this._begin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get beginInput() {
    return this._begin;
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }
}

export class AlertmanagerConfigTimeIntervalTimeIntervalsYearsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigTimeIntervalTimeIntervalsYears[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigTimeIntervalTimeIntervalsYearsOutputReference {
    return new AlertmanagerConfigTimeIntervalTimeIntervalsYearsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigTimeIntervalTimeIntervals {
  /**
  * A string that matches a location in the IANA time zone database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#location AlertmanagerConfig#location}
  */
  readonly location?: string;
  /**
  * days_of_month block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#days_of_month AlertmanagerConfig#days_of_month}
  */
  readonly daysOfMonth?: AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonth[] | cdktf.IResolvable;
  /**
  * months block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#months AlertmanagerConfig#months}
  */
  readonly months?: AlertmanagerConfigTimeIntervalTimeIntervalsMonths[] | cdktf.IResolvable;
  /**
  * times block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#times AlertmanagerConfig#times}
  */
  readonly times?: AlertmanagerConfigTimeIntervalTimeIntervalsTimes[] | cdktf.IResolvable;
  /**
  * weekdays block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#weekdays AlertmanagerConfig#weekdays}
  */
  readonly weekdays?: AlertmanagerConfigTimeIntervalTimeIntervalsWeekdays[] | cdktf.IResolvable;
  /**
  * years block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#years AlertmanagerConfig#years}
  */
  readonly years?: AlertmanagerConfigTimeIntervalTimeIntervalsYears[] | cdktf.IResolvable;
}

export function alertmanagerConfigTimeIntervalTimeIntervalsToTerraform(struct?: AlertmanagerConfigTimeIntervalTimeIntervals | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    location: cdktf.stringToTerraform(struct!.location),
    days_of_month: cdktf.listMapper(alertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonthToTerraform, true)(struct!.daysOfMonth),
    months: cdktf.listMapper(alertmanagerConfigTimeIntervalTimeIntervalsMonthsToTerraform, true)(struct!.months),
    times: cdktf.listMapper(alertmanagerConfigTimeIntervalTimeIntervalsTimesToTerraform, true)(struct!.times),
    weekdays: cdktf.listMapper(alertmanagerConfigTimeIntervalTimeIntervalsWeekdaysToTerraform, true)(struct!.weekdays),
    years: cdktf.listMapper(alertmanagerConfigTimeIntervalTimeIntervalsYearsToTerraform, true)(struct!.years),
  }
}


export function alertmanagerConfigTimeIntervalTimeIntervalsToHclTerraform(struct?: AlertmanagerConfigTimeIntervalTimeIntervals | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    location: {
      value: cdktf.stringToHclTerraform(struct!.location),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    days_of_month: {
      value: cdktf.listMapperHcl(alertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonthToHclTerraform, true)(struct!.daysOfMonth),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonthList",
    },
    months: {
      value: cdktf.listMapperHcl(alertmanagerConfigTimeIntervalTimeIntervalsMonthsToHclTerraform, true)(struct!.months),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigTimeIntervalTimeIntervalsMonthsList",
    },
    times: {
      value: cdktf.listMapperHcl(alertmanagerConfigTimeIntervalTimeIntervalsTimesToHclTerraform, true)(struct!.times),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigTimeIntervalTimeIntervalsTimesList",
    },
    weekdays: {
      value: cdktf.listMapperHcl(alertmanagerConfigTimeIntervalTimeIntervalsWeekdaysToHclTerraform, true)(struct!.weekdays),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigTimeIntervalTimeIntervalsWeekdaysList",
    },
    years: {
      value: cdktf.listMapperHcl(alertmanagerConfigTimeIntervalTimeIntervalsYearsToHclTerraform, true)(struct!.years),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigTimeIntervalTimeIntervalsYearsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigTimeIntervalTimeIntervalsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigTimeIntervalTimeIntervals | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._location !== undefined) {
      hasAnyValues = true;
      internalValueResult.location = this._location;
    }
    if (this._daysOfMonth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.daysOfMonth = this._daysOfMonth?.internalValue;
    }
    if (this._months?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.months = this._months?.internalValue;
    }
    if (this._times?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.times = this._times?.internalValue;
    }
    if (this._weekdays?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.weekdays = this._weekdays?.internalValue;
    }
    if (this._years?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.years = this._years?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigTimeIntervalTimeIntervals | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._location = undefined;
      this._daysOfMonth.internalValue = undefined;
      this._months.internalValue = undefined;
      this._times.internalValue = undefined;
      this._weekdays.internalValue = undefined;
      this._years.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._location = value.location;
      this._daysOfMonth.internalValue = value.daysOfMonth;
      this._months.internalValue = value.months;
      this._times.internalValue = value.times;
      this._weekdays.internalValue = value.weekdays;
      this._years.internalValue = value.years;
    }
  }

  // location - computed: false, optional: true, required: false
  private _location?: string; 
  public get location() {
    return this.getStringAttribute('location');
  }
  public set location(value: string) {
    this._location = value;
  }
  public resetLocation() {
    this._location = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationInput() {
    return this._location;
  }

  // days_of_month - computed: false, optional: true, required: false
  private _daysOfMonth = new AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonthList(this, "days_of_month", false);
  public get daysOfMonth() {
    return this._daysOfMonth;
  }
  public putDaysOfMonth(value: AlertmanagerConfigTimeIntervalTimeIntervalsDaysOfMonth[] | cdktf.IResolvable) {
    this._daysOfMonth.internalValue = value;
  }
  public resetDaysOfMonth() {
    this._daysOfMonth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get daysOfMonthInput() {
    return this._daysOfMonth.internalValue;
  }

  // months - computed: false, optional: true, required: false
  private _months = new AlertmanagerConfigTimeIntervalTimeIntervalsMonthsList(this, "months", false);
  public get months() {
    return this._months;
  }
  public putMonths(value: AlertmanagerConfigTimeIntervalTimeIntervalsMonths[] | cdktf.IResolvable) {
    this._months.internalValue = value;
  }
  public resetMonths() {
    this._months.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monthsInput() {
    return this._months.internalValue;
  }

  // times - computed: false, optional: true, required: false
  private _times = new AlertmanagerConfigTimeIntervalTimeIntervalsTimesList(this, "times", false);
  public get times() {
    return this._times;
  }
  public putTimes(value: AlertmanagerConfigTimeIntervalTimeIntervalsTimes[] | cdktf.IResolvable) {
    this._times.internalValue = value;
  }
  public resetTimes() {
    this._times.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timesInput() {
    return this._times.internalValue;
  }

  // weekdays - computed: false, optional: true, required: false
  private _weekdays = new AlertmanagerConfigTimeIntervalTimeIntervalsWeekdaysList(this, "weekdays", false);
  public get weekdays() {
    return this._weekdays;
  }
  public putWeekdays(value: AlertmanagerConfigTimeIntervalTimeIntervalsWeekdays[] | cdktf.IResolvable) {
    this._weekdays.internalValue = value;
  }
  public resetWeekdays() {
    this._weekdays.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weekdaysInput() {
    return this._weekdays.internalValue;
  }

  // years - computed: false, optional: true, required: false
  private _years = new AlertmanagerConfigTimeIntervalTimeIntervalsYearsList(this, "years", false);
  public get years() {
    return this._years;
  }
  public putYears(value: AlertmanagerConfigTimeIntervalTimeIntervalsYears[] | cdktf.IResolvable) {
    this._years.internalValue = value;
  }
  public resetYears() {
    this._years.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get yearsInput() {
    return this._years.internalValue;
  }
}

export class AlertmanagerConfigTimeIntervalTimeIntervalsList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigTimeIntervalTimeIntervals[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigTimeIntervalTimeIntervalsOutputReference {
    return new AlertmanagerConfigTimeIntervalTimeIntervalsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface AlertmanagerConfigTimeInterval {
  /**
  * Name interval of time that may be referenced in the routing tree to mute/activate particular routes for particular times of the day.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#name AlertmanagerConfig#name}
  */
  readonly name?: string;
  /**
  * time_intervals block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#time_intervals AlertmanagerConfig#time_intervals}
  */
  readonly timeIntervals?: AlertmanagerConfigTimeIntervalTimeIntervals[] | cdktf.IResolvable;
}

export function alertmanagerConfigTimeIntervalToTerraform(struct?: AlertmanagerConfigTimeInterval | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    time_intervals: cdktf.listMapper(alertmanagerConfigTimeIntervalTimeIntervalsToTerraform, true)(struct!.timeIntervals),
  }
}


export function alertmanagerConfigTimeIntervalToHclTerraform(struct?: AlertmanagerConfigTimeInterval | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_intervals: {
      value: cdktf.listMapperHcl(alertmanagerConfigTimeIntervalTimeIntervalsToHclTerraform, true)(struct!.timeIntervals),
      isBlock: true,
      type: "list",
      storageClassType: "AlertmanagerConfigTimeIntervalTimeIntervalsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class AlertmanagerConfigTimeIntervalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): AlertmanagerConfigTimeInterval | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._timeIntervals?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeIntervals = this._timeIntervals?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: AlertmanagerConfigTimeInterval | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._timeIntervals.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._timeIntervals.internalValue = value.timeIntervals;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // time_intervals - computed: false, optional: true, required: false
  private _timeIntervals = new AlertmanagerConfigTimeIntervalTimeIntervalsList(this, "time_intervals", false);
  public get timeIntervals() {
    return this._timeIntervals;
  }
  public putTimeIntervals(value: AlertmanagerConfigTimeIntervalTimeIntervals[] | cdktf.IResolvable) {
    this._timeIntervals.internalValue = value;
  }
  public resetTimeIntervals() {
    this._timeIntervals.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeIntervalsInput() {
    return this._timeIntervals.internalValue;
  }
}

export class AlertmanagerConfigTimeIntervalList extends cdktf.ComplexList {
  public internalValue? : AlertmanagerConfigTimeInterval[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): AlertmanagerConfigTimeIntervalOutputReference {
    return new AlertmanagerConfigTimeIntervalOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config mimir_alertmanager_config}
*/
export class AlertmanagerConfig extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "mimir_alertmanager_config";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a AlertmanagerConfig resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the AlertmanagerConfig to import
  * @param importFromId The id of the existing AlertmanagerConfig that should be imported. Refer to the {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the AlertmanagerConfig to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "mimir_alertmanager_config", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/fgouteroux/mimir/1.0.9/docs/resources/alertmanager_config mimir_alertmanager_config} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options AlertmanagerConfigConfig
  */
  public constructor(scope: Construct, id: string, config: AlertmanagerConfigConfig) {
    super(scope, id, {
      terraformResourceType: 'mimir_alertmanager_config',
      terraformGeneratorMetadata: {
        providerName: 'mimir',
        providerVersion: '1.0.9'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._id = config.id;
    this._orgId = config.orgId;
    this._templates = config.templates;
    this._templatesFiles = config.templatesFiles;
    this._global.internalValue = config.global;
    this._inhibitRule.internalValue = config.inhibitRule;
    this._receiver.internalValue = config.receiver;
    this._route.internalValue = config.route;
    this._timeInterval.internalValue = config.timeInterval;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // org_id - computed: false, optional: true, required: false
  private _orgId?: string; 
  public get orgId() {
    return this.getStringAttribute('org_id');
  }
  public set orgId(value: string) {
    this._orgId = value;
  }
  public resetOrgId() {
    this._orgId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orgIdInput() {
    return this._orgId;
  }

  // templates - computed: false, optional: true, required: false
  private _templates?: string[]; 
  public get templates() {
    return this.getListAttribute('templates');
  }
  public set templates(value: string[]) {
    this._templates = value;
  }
  public resetTemplates() {
    this._templates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templatesInput() {
    return this._templates;
  }

  // templates_files - computed: false, optional: true, required: false
  private _templatesFiles?: { [key: string]: string }; 
  public get templatesFiles() {
    return this.getStringMapAttribute('templates_files');
  }
  public set templatesFiles(value: { [key: string]: string }) {
    this._templatesFiles = value;
  }
  public resetTemplatesFiles() {
    this._templatesFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templatesFilesInput() {
    return this._templatesFiles;
  }

  // global - computed: false, optional: true, required: false
  private _global = new AlertmanagerConfigGlobalOutputReference(this, "global");
  public get global() {
    return this._global;
  }
  public putGlobal(value: AlertmanagerConfigGlobal) {
    this._global.internalValue = value;
  }
  public resetGlobal() {
    this._global.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalInput() {
    return this._global.internalValue;
  }

  // inhibit_rule - computed: false, optional: true, required: false
  private _inhibitRule = new AlertmanagerConfigInhibitRuleList(this, "inhibit_rule", false);
  public get inhibitRule() {
    return this._inhibitRule;
  }
  public putInhibitRule(value: AlertmanagerConfigInhibitRule[] | cdktf.IResolvable) {
    this._inhibitRule.internalValue = value;
  }
  public resetInhibitRule() {
    this._inhibitRule.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inhibitRuleInput() {
    return this._inhibitRule.internalValue;
  }

  // receiver - computed: false, optional: false, required: true
  private _receiver = new AlertmanagerConfigReceiverList(this, "receiver", false);
  public get receiver() {
    return this._receiver;
  }
  public putReceiver(value: AlertmanagerConfigReceiver[] | cdktf.IResolvable) {
    this._receiver.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get receiverInput() {
    return this._receiver.internalValue;
  }

  // route - computed: false, optional: false, required: true
  private _route = new AlertmanagerConfigRouteOutputReference(this, "route");
  public get route() {
    return this._route;
  }
  public putRoute(value: AlertmanagerConfigRoute) {
    this._route.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get routeInput() {
    return this._route.internalValue;
  }

  // time_interval - computed: false, optional: true, required: false
  private _timeInterval = new AlertmanagerConfigTimeIntervalList(this, "time_interval", false);
  public get timeInterval() {
    return this._timeInterval;
  }
  public putTimeInterval(value: AlertmanagerConfigTimeInterval[] | cdktf.IResolvable) {
    this._timeInterval.internalValue = value;
  }
  public resetTimeInterval() {
    this._timeInterval.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeIntervalInput() {
    return this._timeInterval.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      id: cdktf.stringToTerraform(this._id),
      org_id: cdktf.stringToTerraform(this._orgId),
      templates: cdktf.listMapper(cdktf.stringToTerraform, false)(this._templates),
      templates_files: cdktf.hashMapper(cdktf.stringToTerraform)(this._templatesFiles),
      global: alertmanagerConfigGlobalToTerraform(this._global.internalValue),
      inhibit_rule: cdktf.listMapper(alertmanagerConfigInhibitRuleToTerraform, true)(this._inhibitRule.internalValue),
      receiver: cdktf.listMapper(alertmanagerConfigReceiverToTerraform, true)(this._receiver.internalValue),
      route: alertmanagerConfigRouteToTerraform(this._route.internalValue),
      time_interval: cdktf.listMapper(alertmanagerConfigTimeIntervalToTerraform, true)(this._timeInterval.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      id: {
        value: cdktf.stringToHclTerraform(this._id),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      org_id: {
        value: cdktf.stringToHclTerraform(this._orgId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      templates: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._templates),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      templates_files: {
        value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(this._templatesFiles),
        isBlock: false,
        type: "map",
        storageClassType: "stringMap",
      },
      global: {
        value: alertmanagerConfigGlobalToHclTerraform(this._global.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "AlertmanagerConfigGlobalList",
      },
      inhibit_rule: {
        value: cdktf.listMapperHcl(alertmanagerConfigInhibitRuleToHclTerraform, true)(this._inhibitRule.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "AlertmanagerConfigInhibitRuleList",
      },
      receiver: {
        value: cdktf.listMapperHcl(alertmanagerConfigReceiverToHclTerraform, true)(this._receiver.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "AlertmanagerConfigReceiverList",
      },
      route: {
        value: alertmanagerConfigRouteToHclTerraform(this._route.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "AlertmanagerConfigRouteList",
      },
      time_interval: {
        value: cdktf.listMapperHcl(alertmanagerConfigTimeIntervalToHclTerraform, true)(this._timeInterval.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "AlertmanagerConfigTimeIntervalList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
