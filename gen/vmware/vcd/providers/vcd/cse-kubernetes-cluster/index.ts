// https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface CseKubernetesClusterConfig extends cdktf.TerraformMetaArguments {
  /**
  * A file generated by 'vcd_api_token' resource, that stores the API token used to create and manage the cluster, owned by the user specified in 'owner'. Be careful about this file, as it contains sensitive information
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#api_token_file CseKubernetesCluster#api_token_file}
  */
  readonly apiTokenFile?: string;
  /**
  * If errors occur before the Kubernetes cluster becomes available, and this argument is 'true', CSE Server will automatically attempt to repair the cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#auto_repair_on_errors CseKubernetesCluster#auto_repair_on_errors}
  */
  readonly autoRepairOnErrors?: boolean | cdktf.IResolvable;
  /**
  * The CSE version to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#cse_version CseKubernetesCluster#cse_version}
  */
  readonly cseVersion: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#id CseKubernetesCluster#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The ID of the vApp Template that corresponds to a Kubernetes template OVA
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#kubernetes_template_id CseKubernetesCluster#kubernetes_template_id}
  */
  readonly kubernetesTemplateId: string;
  /**
  * The name of the Kubernetes cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#name CseKubernetesCluster#name}
  */
  readonly name: string;
  /**
  * The ID of the network that the Kubernetes cluster will use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#network_id CseKubernetesCluster#network_id}
  */
  readonly networkId: string;
  /**
  * After the Kubernetes cluster becomes available, nodes that become unhealthy will be remediated according to unhealthy node conditions and remediation rules
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#node_health_check CseKubernetesCluster#node_health_check}
  */
  readonly nodeHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * The time, in minutes, to wait for the cluster operations to be successfully completed. For example, during cluster creation, it should be in `provisioned`state before the timeout is reached, otherwise the operation will return an error. For cluster deletion, this timeoutspecifies the time to wait until the cluster is completely deleted. Setting this argument to `0` means to wait indefinitely
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#operations_timeout_minutes CseKubernetesCluster#operations_timeout_minutes}
  */
  readonly operationsTimeoutMinutes?: number;
  /**
  * The name of organization that will own this Kubernetes cluster, optional if defined at provider level. Useful when connected as sysadmin working across different organizations
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#org CseKubernetesCluster#org}
  */
  readonly org?: string;
  /**
  * The user that creates the cluster and owns the API token specified in 'api_token'. It must have the 'Kubernetes Cluster Author' role. If not specified, it assumes it's the user from the provider configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#owner CseKubernetesCluster#owner}
  */
  readonly owner?: string;
  /**
  * CIDR that the Kubernetes pods will use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#pods_cidr CseKubernetesCluster#pods_cidr}
  */
  readonly podsCidr?: string;
  /**
  * The Kubernetes runtime for the cluster. Only 'tkg' (Tanzu Kubernetes Grid) is supported
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#runtime CseKubernetesCluster#runtime}
  */
  readonly runtime?: string;
  /**
  * CIDR that the Kubernetes services will use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#services_cidr CseKubernetesCluster#services_cidr}
  */
  readonly servicesCidr?: string;
  /**
  * The SSH public key used to login into the cluster nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#ssh_public_key CseKubernetesCluster#ssh_public_key}
  */
  readonly sshPublicKey?: string;
  /**
  * The ID of the VDC that hosts the Kubernetes cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#vdc_id CseKubernetesCluster#vdc_id}
  */
  readonly vdcId: string;
  /**
  * Virtual IP subnet for the cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#virtual_ip_subnet CseKubernetesCluster#virtual_ip_subnet}
  */
  readonly virtualIpSubnet?: string;
  /**
  * control_plane block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#control_plane CseKubernetesCluster#control_plane}
  */
  readonly controlPlane: CseKubernetesClusterControlPlane;
  /**
  * default_storage_class block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#default_storage_class CseKubernetesCluster#default_storage_class}
  */
  readonly defaultStorageClass?: CseKubernetesClusterDefaultStorageClass;
  /**
  * worker_pool block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#worker_pool CseKubernetesCluster#worker_pool}
  */
  readonly workerPool: CseKubernetesClusterWorkerPool[] | cdktf.IResolvable;
}
export interface CseKubernetesClusterEvents {
}

export function cseKubernetesClusterEventsToTerraform(struct?: CseKubernetesClusterEvents): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function cseKubernetesClusterEventsToHclTerraform(struct?: CseKubernetesClusterEvents): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class CseKubernetesClusterEventsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): CseKubernetesClusterEvents | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: CseKubernetesClusterEvents | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // details - computed: true, optional: false, required: false
  public get details() {
    return this.getStringAttribute('details');
  }

  // name - computed: true, optional: false, required: false
  public get name() {
    return this.getStringAttribute('name');
  }

  // occurred_at - computed: true, optional: false, required: false
  public get occurredAt() {
    return this.getStringAttribute('occurred_at');
  }

  // resource_id - computed: true, optional: false, required: false
  public get resourceId() {
    return this.getStringAttribute('resource_id');
  }

  // type - computed: true, optional: false, required: false
  public get type() {
    return this.getStringAttribute('type');
  }
}

export class CseKubernetesClusterEventsList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): CseKubernetesClusterEventsOutputReference {
    return new CseKubernetesClusterEventsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface CseKubernetesClusterControlPlane {
  /**
  * Disk size, in Gibibytes (Gi), for the control plane nodes. Must be at least 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#disk_size_gi CseKubernetesCluster#disk_size_gi}
  */
  readonly diskSizeGi?: number;
  /**
  * IP for the control plane. It will be automatically assigned during cluster creation if left empty
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#ip CseKubernetesCluster#ip}
  */
  readonly ip?: string;
  /**
  * The number of nodes that the control plane has. Must be an odd number and higher than 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#machine_count CseKubernetesCluster#machine_count}
  */
  readonly machineCount?: number;
  /**
  * VM Placement policy for the control plane nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#placement_policy_id CseKubernetesCluster#placement_policy_id}
  */
  readonly placementPolicyId?: string;
  /**
  * VM Sizing policy for the control plane nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#sizing_policy_id CseKubernetesCluster#sizing_policy_id}
  */
  readonly sizingPolicyId?: string;
  /**
  * Storage profile for the control plane nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#storage_profile_id CseKubernetesCluster#storage_profile_id}
  */
  readonly storageProfileId?: string;
}

export function cseKubernetesClusterControlPlaneToTerraform(struct?: CseKubernetesClusterControlPlaneOutputReference | CseKubernetesClusterControlPlane): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disk_size_gi: cdktf.numberToTerraform(struct!.diskSizeGi),
    ip: cdktf.stringToTerraform(struct!.ip),
    machine_count: cdktf.numberToTerraform(struct!.machineCount),
    placement_policy_id: cdktf.stringToTerraform(struct!.placementPolicyId),
    sizing_policy_id: cdktf.stringToTerraform(struct!.sizingPolicyId),
    storage_profile_id: cdktf.stringToTerraform(struct!.storageProfileId),
  }
}


export function cseKubernetesClusterControlPlaneToHclTerraform(struct?: CseKubernetesClusterControlPlaneOutputReference | CseKubernetesClusterControlPlane): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disk_size_gi: {
      value: cdktf.numberToHclTerraform(struct!.diskSizeGi),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    machine_count: {
      value: cdktf.numberToHclTerraform(struct!.machineCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    placement_policy_id: {
      value: cdktf.stringToHclTerraform(struct!.placementPolicyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sizing_policy_id: {
      value: cdktf.stringToHclTerraform(struct!.sizingPolicyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_profile_id: {
      value: cdktf.stringToHclTerraform(struct!.storageProfileId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class CseKubernetesClusterControlPlaneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): CseKubernetesClusterControlPlane | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._diskSizeGi !== undefined) {
      hasAnyValues = true;
      internalValueResult.diskSizeGi = this._diskSizeGi;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    if (this._machineCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.machineCount = this._machineCount;
    }
    if (this._placementPolicyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.placementPolicyId = this._placementPolicyId;
    }
    if (this._sizingPolicyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.sizingPolicyId = this._sizingPolicyId;
    }
    if (this._storageProfileId !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageProfileId = this._storageProfileId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: CseKubernetesClusterControlPlane | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._diskSizeGi = undefined;
      this._ip = undefined;
      this._machineCount = undefined;
      this._placementPolicyId = undefined;
      this._sizingPolicyId = undefined;
      this._storageProfileId = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._diskSizeGi = value.diskSizeGi;
      this._ip = value.ip;
      this._machineCount = value.machineCount;
      this._placementPolicyId = value.placementPolicyId;
      this._sizingPolicyId = value.sizingPolicyId;
      this._storageProfileId = value.storageProfileId;
    }
  }

  // disk_size_gi - computed: false, optional: true, required: false
  private _diskSizeGi?: number; 
  public get diskSizeGi() {
    return this.getNumberAttribute('disk_size_gi');
  }
  public set diskSizeGi(value: number) {
    this._diskSizeGi = value;
  }
  public resetDiskSizeGi() {
    this._diskSizeGi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskSizeGiInput() {
    return this._diskSizeGi;
  }

  // ip - computed: true, optional: true, required: false
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  public resetIp() {
    this._ip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }

  // machine_count - computed: false, optional: true, required: false
  private _machineCount?: number; 
  public get machineCount() {
    return this.getNumberAttribute('machine_count');
  }
  public set machineCount(value: number) {
    this._machineCount = value;
  }
  public resetMachineCount() {
    this._machineCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get machineCountInput() {
    return this._machineCount;
  }

  // placement_policy_id - computed: false, optional: true, required: false
  private _placementPolicyId?: string; 
  public get placementPolicyId() {
    return this.getStringAttribute('placement_policy_id');
  }
  public set placementPolicyId(value: string) {
    this._placementPolicyId = value;
  }
  public resetPlacementPolicyId() {
    this._placementPolicyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get placementPolicyIdInput() {
    return this._placementPolicyId;
  }

  // sizing_policy_id - computed: false, optional: true, required: false
  private _sizingPolicyId?: string; 
  public get sizingPolicyId() {
    return this.getStringAttribute('sizing_policy_id');
  }
  public set sizingPolicyId(value: string) {
    this._sizingPolicyId = value;
  }
  public resetSizingPolicyId() {
    this._sizingPolicyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizingPolicyIdInput() {
    return this._sizingPolicyId;
  }

  // storage_profile_id - computed: false, optional: true, required: false
  private _storageProfileId?: string; 
  public get storageProfileId() {
    return this.getStringAttribute('storage_profile_id');
  }
  public set storageProfileId(value: string) {
    this._storageProfileId = value;
  }
  public resetStorageProfileId() {
    this._storageProfileId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageProfileIdInput() {
    return this._storageProfileId;
  }
}
export interface CseKubernetesClusterDefaultStorageClass {
  /**
  * Filesystem of the storage class, can be either 'ext4' or 'xfs'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#filesystem CseKubernetesCluster#filesystem}
  */
  readonly filesystem: string;
  /**
  * Name to give to this storage class
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#name CseKubernetesCluster#name}
  */
  readonly name: string;
  /**
  * Reclaim policy. Possible values are: `delete` deletes the volume when the `PersistentVolumeClaim` is deleted; `retain` does not delete, and the volume can be manually reclaimed
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#reclaim_policy CseKubernetesCluster#reclaim_policy}
  */
  readonly reclaimPolicy: string;
  /**
  * ID of the storage profile to use for the storage class
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#storage_profile_id CseKubernetesCluster#storage_profile_id}
  */
  readonly storageProfileId: string;
}

export function cseKubernetesClusterDefaultStorageClassToTerraform(struct?: CseKubernetesClusterDefaultStorageClassOutputReference | CseKubernetesClusterDefaultStorageClass): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filesystem: cdktf.stringToTerraform(struct!.filesystem),
    name: cdktf.stringToTerraform(struct!.name),
    reclaim_policy: cdktf.stringToTerraform(struct!.reclaimPolicy),
    storage_profile_id: cdktf.stringToTerraform(struct!.storageProfileId),
  }
}


export function cseKubernetesClusterDefaultStorageClassToHclTerraform(struct?: CseKubernetesClusterDefaultStorageClassOutputReference | CseKubernetesClusterDefaultStorageClass): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filesystem: {
      value: cdktf.stringToHclTerraform(struct!.filesystem),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reclaim_policy: {
      value: cdktf.stringToHclTerraform(struct!.reclaimPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_profile_id: {
      value: cdktf.stringToHclTerraform(struct!.storageProfileId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class CseKubernetesClusterDefaultStorageClassOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): CseKubernetesClusterDefaultStorageClass | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filesystem !== undefined) {
      hasAnyValues = true;
      internalValueResult.filesystem = this._filesystem;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._reclaimPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.reclaimPolicy = this._reclaimPolicy;
    }
    if (this._storageProfileId !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageProfileId = this._storageProfileId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: CseKubernetesClusterDefaultStorageClass | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._filesystem = undefined;
      this._name = undefined;
      this._reclaimPolicy = undefined;
      this._storageProfileId = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._filesystem = value.filesystem;
      this._name = value.name;
      this._reclaimPolicy = value.reclaimPolicy;
      this._storageProfileId = value.storageProfileId;
    }
  }

  // filesystem - computed: false, optional: false, required: true
  private _filesystem?: string; 
  public get filesystem() {
    return this.getStringAttribute('filesystem');
  }
  public set filesystem(value: string) {
    this._filesystem = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filesystemInput() {
    return this._filesystem;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // reclaim_policy - computed: false, optional: false, required: true
  private _reclaimPolicy?: string; 
  public get reclaimPolicy() {
    return this.getStringAttribute('reclaim_policy');
  }
  public set reclaimPolicy(value: string) {
    this._reclaimPolicy = value;
  }
  // Temporarily expose input value. Use with caution.
  public get reclaimPolicyInput() {
    return this._reclaimPolicy;
  }

  // storage_profile_id - computed: false, optional: false, required: true
  private _storageProfileId?: string; 
  public get storageProfileId() {
    return this.getStringAttribute('storage_profile_id');
  }
  public set storageProfileId(value: string) {
    this._storageProfileId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get storageProfileIdInput() {
    return this._storageProfileId;
  }
}
export interface CseKubernetesClusterWorkerPool {
  /**
  * Maximum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_min_replicas'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#autoscaler_max_replicas CseKubernetesCluster#autoscaler_max_replicas}
  */
  readonly autoscalerMaxReplicas?: number;
  /**
  * Minimum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_max_replicas'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#autoscaler_min_replicas CseKubernetesCluster#autoscaler_min_replicas}
  */
  readonly autoscalerMinReplicas?: number;
  /**
  * Disk size, in Gibibytes (Gi), for this worker pool
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#disk_size_gi CseKubernetesCluster#disk_size_gi}
  */
  readonly diskSizeGi?: number;
  /**
  * The number of nodes that this worker pool has. Must be higher than or equal to 0. Ignored if 'autoscaler_max_replicas' and 'autoscaler_min_replicas' are set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#machine_count CseKubernetesCluster#machine_count}
  */
  readonly machineCount?: number;
  /**
  * The name of this worker pool. Must be unique
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#name CseKubernetesCluster#name}
  */
  readonly name: string;
  /**
  * VM Placement policy for this worker pool
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#placement_policy_id CseKubernetesCluster#placement_policy_id}
  */
  readonly placementPolicyId?: string;
  /**
  * VM Sizing policy for this worker pool
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#sizing_policy_id CseKubernetesCluster#sizing_policy_id}
  */
  readonly sizingPolicyId?: string;
  /**
  * Storage profile for this worker pool
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#storage_profile_id CseKubernetesCluster#storage_profile_id}
  */
  readonly storageProfileId?: string;
  /**
  * vGPU policy for this worker pool
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#vgpu_policy_id CseKubernetesCluster#vgpu_policy_id}
  */
  readonly vgpuPolicyId?: string;
}

export function cseKubernetesClusterWorkerPoolToTerraform(struct?: CseKubernetesClusterWorkerPool | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    autoscaler_max_replicas: cdktf.numberToTerraform(struct!.autoscalerMaxReplicas),
    autoscaler_min_replicas: cdktf.numberToTerraform(struct!.autoscalerMinReplicas),
    disk_size_gi: cdktf.numberToTerraform(struct!.diskSizeGi),
    machine_count: cdktf.numberToTerraform(struct!.machineCount),
    name: cdktf.stringToTerraform(struct!.name),
    placement_policy_id: cdktf.stringToTerraform(struct!.placementPolicyId),
    sizing_policy_id: cdktf.stringToTerraform(struct!.sizingPolicyId),
    storage_profile_id: cdktf.stringToTerraform(struct!.storageProfileId),
    vgpu_policy_id: cdktf.stringToTerraform(struct!.vgpuPolicyId),
  }
}


export function cseKubernetesClusterWorkerPoolToHclTerraform(struct?: CseKubernetesClusterWorkerPool | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    autoscaler_max_replicas: {
      value: cdktf.numberToHclTerraform(struct!.autoscalerMaxReplicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    autoscaler_min_replicas: {
      value: cdktf.numberToHclTerraform(struct!.autoscalerMinReplicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disk_size_gi: {
      value: cdktf.numberToHclTerraform(struct!.diskSizeGi),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    machine_count: {
      value: cdktf.numberToHclTerraform(struct!.machineCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    placement_policy_id: {
      value: cdktf.stringToHclTerraform(struct!.placementPolicyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sizing_policy_id: {
      value: cdktf.stringToHclTerraform(struct!.sizingPolicyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_profile_id: {
      value: cdktf.stringToHclTerraform(struct!.storageProfileId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vgpu_policy_id: {
      value: cdktf.stringToHclTerraform(struct!.vgpuPolicyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class CseKubernetesClusterWorkerPoolOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): CseKubernetesClusterWorkerPool | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoscalerMaxReplicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoscalerMaxReplicas = this._autoscalerMaxReplicas;
    }
    if (this._autoscalerMinReplicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoscalerMinReplicas = this._autoscalerMinReplicas;
    }
    if (this._diskSizeGi !== undefined) {
      hasAnyValues = true;
      internalValueResult.diskSizeGi = this._diskSizeGi;
    }
    if (this._machineCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.machineCount = this._machineCount;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._placementPolicyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.placementPolicyId = this._placementPolicyId;
    }
    if (this._sizingPolicyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.sizingPolicyId = this._sizingPolicyId;
    }
    if (this._storageProfileId !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageProfileId = this._storageProfileId;
    }
    if (this._vgpuPolicyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.vgpuPolicyId = this._vgpuPolicyId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: CseKubernetesClusterWorkerPool | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoscalerMaxReplicas = undefined;
      this._autoscalerMinReplicas = undefined;
      this._diskSizeGi = undefined;
      this._machineCount = undefined;
      this._name = undefined;
      this._placementPolicyId = undefined;
      this._sizingPolicyId = undefined;
      this._storageProfileId = undefined;
      this._vgpuPolicyId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoscalerMaxReplicas = value.autoscalerMaxReplicas;
      this._autoscalerMinReplicas = value.autoscalerMinReplicas;
      this._diskSizeGi = value.diskSizeGi;
      this._machineCount = value.machineCount;
      this._name = value.name;
      this._placementPolicyId = value.placementPolicyId;
      this._sizingPolicyId = value.sizingPolicyId;
      this._storageProfileId = value.storageProfileId;
      this._vgpuPolicyId = value.vgpuPolicyId;
    }
  }

  // autoscaler_max_replicas - computed: false, optional: true, required: false
  private _autoscalerMaxReplicas?: number; 
  public get autoscalerMaxReplicas() {
    return this.getNumberAttribute('autoscaler_max_replicas');
  }
  public set autoscalerMaxReplicas(value: number) {
    this._autoscalerMaxReplicas = value;
  }
  public resetAutoscalerMaxReplicas() {
    this._autoscalerMaxReplicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoscalerMaxReplicasInput() {
    return this._autoscalerMaxReplicas;
  }

  // autoscaler_min_replicas - computed: false, optional: true, required: false
  private _autoscalerMinReplicas?: number; 
  public get autoscalerMinReplicas() {
    return this.getNumberAttribute('autoscaler_min_replicas');
  }
  public set autoscalerMinReplicas(value: number) {
    this._autoscalerMinReplicas = value;
  }
  public resetAutoscalerMinReplicas() {
    this._autoscalerMinReplicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoscalerMinReplicasInput() {
    return this._autoscalerMinReplicas;
  }

  // disk_size_gi - computed: false, optional: true, required: false
  private _diskSizeGi?: number; 
  public get diskSizeGi() {
    return this.getNumberAttribute('disk_size_gi');
  }
  public set diskSizeGi(value: number) {
    this._diskSizeGi = value;
  }
  public resetDiskSizeGi() {
    this._diskSizeGi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskSizeGiInput() {
    return this._diskSizeGi;
  }

  // machine_count - computed: false, optional: true, required: false
  private _machineCount?: number; 
  public get machineCount() {
    return this.getNumberAttribute('machine_count');
  }
  public set machineCount(value: number) {
    this._machineCount = value;
  }
  public resetMachineCount() {
    this._machineCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get machineCountInput() {
    return this._machineCount;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // placement_policy_id - computed: false, optional: true, required: false
  private _placementPolicyId?: string; 
  public get placementPolicyId() {
    return this.getStringAttribute('placement_policy_id');
  }
  public set placementPolicyId(value: string) {
    this._placementPolicyId = value;
  }
  public resetPlacementPolicyId() {
    this._placementPolicyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get placementPolicyIdInput() {
    return this._placementPolicyId;
  }

  // sizing_policy_id - computed: false, optional: true, required: false
  private _sizingPolicyId?: string; 
  public get sizingPolicyId() {
    return this.getStringAttribute('sizing_policy_id');
  }
  public set sizingPolicyId(value: string) {
    this._sizingPolicyId = value;
  }
  public resetSizingPolicyId() {
    this._sizingPolicyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizingPolicyIdInput() {
    return this._sizingPolicyId;
  }

  // storage_profile_id - computed: false, optional: true, required: false
  private _storageProfileId?: string; 
  public get storageProfileId() {
    return this.getStringAttribute('storage_profile_id');
  }
  public set storageProfileId(value: string) {
    this._storageProfileId = value;
  }
  public resetStorageProfileId() {
    this._storageProfileId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageProfileIdInput() {
    return this._storageProfileId;
  }

  // vgpu_policy_id - computed: false, optional: true, required: false
  private _vgpuPolicyId?: string; 
  public get vgpuPolicyId() {
    return this.getStringAttribute('vgpu_policy_id');
  }
  public set vgpuPolicyId(value: string) {
    this._vgpuPolicyId = value;
  }
  public resetVgpuPolicyId() {
    this._vgpuPolicyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vgpuPolicyIdInput() {
    return this._vgpuPolicyId;
  }
}

export class CseKubernetesClusterWorkerPoolList extends cdktf.ComplexList {
  public internalValue? : CseKubernetesClusterWorkerPool[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): CseKubernetesClusterWorkerPoolOutputReference {
    return new CseKubernetesClusterWorkerPoolOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster vcd_cse_kubernetes_cluster}
*/
export class CseKubernetesCluster extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "vcd_cse_kubernetes_cluster";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a CseKubernetesCluster resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the CseKubernetesCluster to import
  * @param importFromId The id of the existing CseKubernetesCluster that should be imported. Refer to the {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the CseKubernetesCluster to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "vcd_cse_kubernetes_cluster", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/vmware/vcd/3.14.1/docs/resources/cse_kubernetes_cluster vcd_cse_kubernetes_cluster} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options CseKubernetesClusterConfig
  */
  public constructor(scope: Construct, id: string, config: CseKubernetesClusterConfig) {
    super(scope, id, {
      terraformResourceType: 'vcd_cse_kubernetes_cluster',
      terraformGeneratorMetadata: {
        providerName: 'vcd',
        providerVersion: '3.14.1'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._apiTokenFile = config.apiTokenFile;
    this._autoRepairOnErrors = config.autoRepairOnErrors;
    this._cseVersion = config.cseVersion;
    this._id = config.id;
    this._kubernetesTemplateId = config.kubernetesTemplateId;
    this._name = config.name;
    this._networkId = config.networkId;
    this._nodeHealthCheck = config.nodeHealthCheck;
    this._operationsTimeoutMinutes = config.operationsTimeoutMinutes;
    this._org = config.org;
    this._owner = config.owner;
    this._podsCidr = config.podsCidr;
    this._runtime = config.runtime;
    this._servicesCidr = config.servicesCidr;
    this._sshPublicKey = config.sshPublicKey;
    this._vdcId = config.vdcId;
    this._virtualIpSubnet = config.virtualIpSubnet;
    this._controlPlane.internalValue = config.controlPlane;
    this._defaultStorageClass.internalValue = config.defaultStorageClass;
    this._workerPool.internalValue = config.workerPool;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // api_token_file - computed: false, optional: true, required: false
  private _apiTokenFile?: string; 
  public get apiTokenFile() {
    return this.getStringAttribute('api_token_file');
  }
  public set apiTokenFile(value: string) {
    this._apiTokenFile = value;
  }
  public resetApiTokenFile() {
    this._apiTokenFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiTokenFileInput() {
    return this._apiTokenFile;
  }

  // auto_repair_on_errors - computed: true, optional: true, required: false
  private _autoRepairOnErrors?: boolean | cdktf.IResolvable; 
  public get autoRepairOnErrors() {
    return this.getBooleanAttribute('auto_repair_on_errors');
  }
  public set autoRepairOnErrors(value: boolean | cdktf.IResolvable) {
    this._autoRepairOnErrors = value;
  }
  public resetAutoRepairOnErrors() {
    this._autoRepairOnErrors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoRepairOnErrorsInput() {
    return this._autoRepairOnErrors;
  }

  // capvcd_version - computed: true, optional: false, required: false
  public get capvcdVersion() {
    return this.getStringAttribute('capvcd_version');
  }

  // cluster_resource_set_bindings - computed: true, optional: false, required: false
  public get clusterResourceSetBindings() {
    return cdktf.Fn.tolist(this.getListAttribute('cluster_resource_set_bindings'));
  }

  // cpi_version - computed: true, optional: false, required: false
  public get cpiVersion() {
    return this.getStringAttribute('cpi_version');
  }

  // cse_version - computed: false, optional: false, required: true
  private _cseVersion?: string; 
  public get cseVersion() {
    return this.getStringAttribute('cse_version');
  }
  public set cseVersion(value: string) {
    this._cseVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cseVersionInput() {
    return this._cseVersion;
  }

  // csi_version - computed: true, optional: false, required: false
  public get csiVersion() {
    return this.getStringAttribute('csi_version');
  }

  // events - computed: true, optional: false, required: false
  private _events = new CseKubernetesClusterEventsList(this, "events", false);
  public get events() {
    return this._events;
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // kubeconfig - computed: true, optional: false, required: false
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }

  // kubernetes_template_id - computed: false, optional: false, required: true
  private _kubernetesTemplateId?: string; 
  public get kubernetesTemplateId() {
    return this.getStringAttribute('kubernetes_template_id');
  }
  public set kubernetesTemplateId(value: string) {
    this._kubernetesTemplateId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesTemplateIdInput() {
    return this._kubernetesTemplateId;
  }

  // kubernetes_version - computed: true, optional: false, required: false
  public get kubernetesVersion() {
    return this.getStringAttribute('kubernetes_version');
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // network_id - computed: false, optional: false, required: true
  private _networkId?: string; 
  public get networkId() {
    return this.getStringAttribute('network_id');
  }
  public set networkId(value: string) {
    this._networkId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get networkIdInput() {
    return this._networkId;
  }

  // node_health_check - computed: false, optional: true, required: false
  private _nodeHealthCheck?: boolean | cdktf.IResolvable; 
  public get nodeHealthCheck() {
    return this.getBooleanAttribute('node_health_check');
  }
  public set nodeHealthCheck(value: boolean | cdktf.IResolvable) {
    this._nodeHealthCheck = value;
  }
  public resetNodeHealthCheck() {
    this._nodeHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeHealthCheckInput() {
    return this._nodeHealthCheck;
  }

  // operations_timeout_minutes - computed: false, optional: true, required: false
  private _operationsTimeoutMinutes?: number; 
  public get operationsTimeoutMinutes() {
    return this.getNumberAttribute('operations_timeout_minutes');
  }
  public set operationsTimeoutMinutes(value: number) {
    this._operationsTimeoutMinutes = value;
  }
  public resetOperationsTimeoutMinutes() {
    this._operationsTimeoutMinutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationsTimeoutMinutesInput() {
    return this._operationsTimeoutMinutes;
  }

  // org - computed: false, optional: true, required: false
  private _org?: string; 
  public get org() {
    return this.getStringAttribute('org');
  }
  public set org(value: string) {
    this._org = value;
  }
  public resetOrg() {
    this._org = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orgInput() {
    return this._org;
  }

  // owner - computed: false, optional: true, required: false
  private _owner?: string; 
  public get owner() {
    return this.getStringAttribute('owner');
  }
  public set owner(value: string) {
    this._owner = value;
  }
  public resetOwner() {
    this._owner = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ownerInput() {
    return this._owner;
  }

  // pods_cidr - computed: false, optional: true, required: false
  private _podsCidr?: string; 
  public get podsCidr() {
    return this.getStringAttribute('pods_cidr');
  }
  public set podsCidr(value: string) {
    this._podsCidr = value;
  }
  public resetPodsCidr() {
    this._podsCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podsCidrInput() {
    return this._podsCidr;
  }

  // runtime - computed: false, optional: true, required: false
  private _runtime?: string; 
  public get runtime() {
    return this.getStringAttribute('runtime');
  }
  public set runtime(value: string) {
    this._runtime = value;
  }
  public resetRuntime() {
    this._runtime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeInput() {
    return this._runtime;
  }

  // services_cidr - computed: false, optional: true, required: false
  private _servicesCidr?: string; 
  public get servicesCidr() {
    return this.getStringAttribute('services_cidr');
  }
  public set servicesCidr(value: string) {
    this._servicesCidr = value;
  }
  public resetServicesCidr() {
    this._servicesCidr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesCidrInput() {
    return this._servicesCidr;
  }

  // ssh_public_key - computed: false, optional: true, required: false
  private _sshPublicKey?: string; 
  public get sshPublicKey() {
    return this.getStringAttribute('ssh_public_key');
  }
  public set sshPublicKey(value: string) {
    this._sshPublicKey = value;
  }
  public resetSshPublicKey() {
    this._sshPublicKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshPublicKeyInput() {
    return this._sshPublicKey;
  }

  // state - computed: true, optional: false, required: false
  public get state() {
    return this.getStringAttribute('state');
  }

  // supported_upgrades - computed: true, optional: false, required: false
  public get supportedUpgrades() {
    return cdktf.Fn.tolist(this.getListAttribute('supported_upgrades'));
  }

  // tkg_product_version - computed: true, optional: false, required: false
  public get tkgProductVersion() {
    return this.getStringAttribute('tkg_product_version');
  }

  // vdc_id - computed: false, optional: false, required: true
  private _vdcId?: string; 
  public get vdcId() {
    return this.getStringAttribute('vdc_id');
  }
  public set vdcId(value: string) {
    this._vdcId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vdcIdInput() {
    return this._vdcId;
  }

  // virtual_ip_subnet - computed: false, optional: true, required: false
  private _virtualIpSubnet?: string; 
  public get virtualIpSubnet() {
    return this.getStringAttribute('virtual_ip_subnet');
  }
  public set virtualIpSubnet(value: string) {
    this._virtualIpSubnet = value;
  }
  public resetVirtualIpSubnet() {
    this._virtualIpSubnet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualIpSubnetInput() {
    return this._virtualIpSubnet;
  }

  // control_plane - computed: false, optional: false, required: true
  private _controlPlane = new CseKubernetesClusterControlPlaneOutputReference(this, "control_plane");
  public get controlPlane() {
    return this._controlPlane;
  }
  public putControlPlane(value: CseKubernetesClusterControlPlane) {
    this._controlPlane.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get controlPlaneInput() {
    return this._controlPlane.internalValue;
  }

  // default_storage_class - computed: false, optional: true, required: false
  private _defaultStorageClass = new CseKubernetesClusterDefaultStorageClassOutputReference(this, "default_storage_class");
  public get defaultStorageClass() {
    return this._defaultStorageClass;
  }
  public putDefaultStorageClass(value: CseKubernetesClusterDefaultStorageClass) {
    this._defaultStorageClass.internalValue = value;
  }
  public resetDefaultStorageClass() {
    this._defaultStorageClass.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultStorageClassInput() {
    return this._defaultStorageClass.internalValue;
  }

  // worker_pool - computed: false, optional: false, required: true
  private _workerPool = new CseKubernetesClusterWorkerPoolList(this, "worker_pool", false);
  public get workerPool() {
    return this._workerPool;
  }
  public putWorkerPool(value: CseKubernetesClusterWorkerPool[] | cdktf.IResolvable) {
    this._workerPool.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get workerPoolInput() {
    return this._workerPool.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      api_token_file: cdktf.stringToTerraform(this._apiTokenFile),
      auto_repair_on_errors: cdktf.booleanToTerraform(this._autoRepairOnErrors),
      cse_version: cdktf.stringToTerraform(this._cseVersion),
      id: cdktf.stringToTerraform(this._id),
      kubernetes_template_id: cdktf.stringToTerraform(this._kubernetesTemplateId),
      name: cdktf.stringToTerraform(this._name),
      network_id: cdktf.stringToTerraform(this._networkId),
      node_health_check: cdktf.booleanToTerraform(this._nodeHealthCheck),
      operations_timeout_minutes: cdktf.numberToTerraform(this._operationsTimeoutMinutes),
      org: cdktf.stringToTerraform(this._org),
      owner: cdktf.stringToTerraform(this._owner),
      pods_cidr: cdktf.stringToTerraform(this._podsCidr),
      runtime: cdktf.stringToTerraform(this._runtime),
      services_cidr: cdktf.stringToTerraform(this._servicesCidr),
      ssh_public_key: cdktf.stringToTerraform(this._sshPublicKey),
      vdc_id: cdktf.stringToTerraform(this._vdcId),
      virtual_ip_subnet: cdktf.stringToTerraform(this._virtualIpSubnet),
      control_plane: cseKubernetesClusterControlPlaneToTerraform(this._controlPlane.internalValue),
      default_storage_class: cseKubernetesClusterDefaultStorageClassToTerraform(this._defaultStorageClass.internalValue),
      worker_pool: cdktf.listMapper(cseKubernetesClusterWorkerPoolToTerraform, true)(this._workerPool.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      api_token_file: {
        value: cdktf.stringToHclTerraform(this._apiTokenFile),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      auto_repair_on_errors: {
        value: cdktf.booleanToHclTerraform(this._autoRepairOnErrors),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      cse_version: {
        value: cdktf.stringToHclTerraform(this._cseVersion),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      id: {
        value: cdktf.stringToHclTerraform(this._id),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      kubernetes_template_id: {
        value: cdktf.stringToHclTerraform(this._kubernetesTemplateId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      name: {
        value: cdktf.stringToHclTerraform(this._name),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      network_id: {
        value: cdktf.stringToHclTerraform(this._networkId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      node_health_check: {
        value: cdktf.booleanToHclTerraform(this._nodeHealthCheck),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      operations_timeout_minutes: {
        value: cdktf.numberToHclTerraform(this._operationsTimeoutMinutes),
        isBlock: false,
        type: "simple",
        storageClassType: "number",
      },
      org: {
        value: cdktf.stringToHclTerraform(this._org),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      owner: {
        value: cdktf.stringToHclTerraform(this._owner),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      pods_cidr: {
        value: cdktf.stringToHclTerraform(this._podsCidr),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      runtime: {
        value: cdktf.stringToHclTerraform(this._runtime),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      services_cidr: {
        value: cdktf.stringToHclTerraform(this._servicesCidr),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      ssh_public_key: {
        value: cdktf.stringToHclTerraform(this._sshPublicKey),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      vdc_id: {
        value: cdktf.stringToHclTerraform(this._vdcId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      virtual_ip_subnet: {
        value: cdktf.stringToHclTerraform(this._virtualIpSubnet),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      control_plane: {
        value: cseKubernetesClusterControlPlaneToHclTerraform(this._controlPlane.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "CseKubernetesClusterControlPlaneList",
      },
      default_storage_class: {
        value: cseKubernetesClusterDefaultStorageClassToHclTerraform(this._defaultStorageClass.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "CseKubernetesClusterDefaultStorageClassList",
      },
      worker_pool: {
        value: cdktf.listMapperHcl(cseKubernetesClusterWorkerPoolToHclTerraform, true)(this._workerPool.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "CseKubernetesClusterWorkerPoolList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
