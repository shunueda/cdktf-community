import * as cdktf from 'cdktf';
export interface DashboardAnnotationsSourceLogsLabelFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardAnnotationsSourceLogsLabelFieldsToTerraform(struct?: DashboardAnnotationsSourceLogsLabelFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardAnnotationsSourceLogsLabelFieldsToHclTerraform(struct?: DashboardAnnotationsSourceLogsLabelFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceLogsLabelFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardAnnotationsSourceLogsLabelFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceLogsLabelFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}

export class DashboardAnnotationsSourceLogsLabelFieldsList extends cdktf.ComplexList {
  public internalValue? : DashboardAnnotationsSourceLogsLabelFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardAnnotationsSourceLogsLabelFieldsOutputReference {
    return new DashboardAnnotationsSourceLogsLabelFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardAnnotationsSourceLogsStrategyDurationDurationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardAnnotationsSourceLogsStrategyDurationDurationFieldToTerraform(struct?: DashboardAnnotationsSourceLogsStrategyDurationDurationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardAnnotationsSourceLogsStrategyDurationDurationFieldToHclTerraform(struct?: DashboardAnnotationsSourceLogsStrategyDurationDurationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceLogsStrategyDurationDurationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceLogsStrategyDurationDurationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceLogsStrategyDurationDurationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardAnnotationsSourceLogsStrategyDurationStartTimestampField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardAnnotationsSourceLogsStrategyDurationStartTimestampFieldToTerraform(struct?: DashboardAnnotationsSourceLogsStrategyDurationStartTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardAnnotationsSourceLogsStrategyDurationStartTimestampFieldToHclTerraform(struct?: DashboardAnnotationsSourceLogsStrategyDurationStartTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceLogsStrategyDurationStartTimestampFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceLogsStrategyDurationStartTimestampField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceLogsStrategyDurationStartTimestampField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardAnnotationsSourceLogsStrategyDuration {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration_field Dashboard#duration_field}
  */
  readonly durationField: DashboardAnnotationsSourceLogsStrategyDurationDurationField;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start_timestamp_field Dashboard#start_timestamp_field}
  */
  readonly startTimestampField: DashboardAnnotationsSourceLogsStrategyDurationStartTimestampField;
}

export function dashboardAnnotationsSourceLogsStrategyDurationToTerraform(struct?: DashboardAnnotationsSourceLogsStrategyDuration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration_field: dashboardAnnotationsSourceLogsStrategyDurationDurationFieldToTerraform(struct!.durationField),
    start_timestamp_field: dashboardAnnotationsSourceLogsStrategyDurationStartTimestampFieldToTerraform(struct!.startTimestampField),
  }
}


export function dashboardAnnotationsSourceLogsStrategyDurationToHclTerraform(struct?: DashboardAnnotationsSourceLogsStrategyDuration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration_field: {
      value: dashboardAnnotationsSourceLogsStrategyDurationDurationFieldToHclTerraform(struct!.durationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceLogsStrategyDurationDurationField",
    },
    start_timestamp_field: {
      value: dashboardAnnotationsSourceLogsStrategyDurationStartTimestampFieldToHclTerraform(struct!.startTimestampField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceLogsStrategyDurationStartTimestampField",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceLogsStrategyDurationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceLogsStrategyDuration | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._durationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationField = this._durationField?.internalValue;
    }
    if (this._startTimestampField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.startTimestampField = this._startTimestampField?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceLogsStrategyDuration | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._durationField.internalValue = undefined;
      this._startTimestampField.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._durationField.internalValue = value.durationField;
      this._startTimestampField.internalValue = value.startTimestampField;
    }
  }

  // duration_field - computed: false, optional: false, required: true
  private _durationField = new DashboardAnnotationsSourceLogsStrategyDurationDurationFieldOutputReference(this, "duration_field");
  public get durationField() {
    return this._durationField;
  }
  public putDurationField(value: DashboardAnnotationsSourceLogsStrategyDurationDurationField) {
    this._durationField.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationFieldInput() {
    return this._durationField.internalValue;
  }

  // start_timestamp_field - computed: false, optional: false, required: true
  private _startTimestampField = new DashboardAnnotationsSourceLogsStrategyDurationStartTimestampFieldOutputReference(this, "start_timestamp_field");
  public get startTimestampField() {
    return this._startTimestampField;
  }
  public putStartTimestampField(value: DashboardAnnotationsSourceLogsStrategyDurationStartTimestampField) {
    this._startTimestampField.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startTimestampFieldInput() {
    return this._startTimestampField.internalValue;
  }
}
export interface DashboardAnnotationsSourceLogsStrategyInstantTimestampField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardAnnotationsSourceLogsStrategyInstantTimestampFieldToTerraform(struct?: DashboardAnnotationsSourceLogsStrategyInstantTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardAnnotationsSourceLogsStrategyInstantTimestampFieldToHclTerraform(struct?: DashboardAnnotationsSourceLogsStrategyInstantTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceLogsStrategyInstantTimestampFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceLogsStrategyInstantTimestampField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceLogsStrategyInstantTimestampField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardAnnotationsSourceLogsStrategyInstant {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#timestamp_field Dashboard#timestamp_field}
  */
  readonly timestampField: DashboardAnnotationsSourceLogsStrategyInstantTimestampField;
}

export function dashboardAnnotationsSourceLogsStrategyInstantToTerraform(struct?: DashboardAnnotationsSourceLogsStrategyInstant | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    timestamp_field: dashboardAnnotationsSourceLogsStrategyInstantTimestampFieldToTerraform(struct!.timestampField),
  }
}


export function dashboardAnnotationsSourceLogsStrategyInstantToHclTerraform(struct?: DashboardAnnotationsSourceLogsStrategyInstant | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    timestamp_field: {
      value: dashboardAnnotationsSourceLogsStrategyInstantTimestampFieldToHclTerraform(struct!.timestampField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceLogsStrategyInstantTimestampField",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceLogsStrategyInstantOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceLogsStrategyInstant | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._timestampField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampField = this._timestampField?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceLogsStrategyInstant | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._timestampField.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._timestampField.internalValue = value.timestampField;
    }
  }

  // timestamp_field - computed: false, optional: false, required: true
  private _timestampField = new DashboardAnnotationsSourceLogsStrategyInstantTimestampFieldOutputReference(this, "timestamp_field");
  public get timestampField() {
    return this._timestampField;
  }
  public putTimestampField(value: DashboardAnnotationsSourceLogsStrategyInstantTimestampField) {
    this._timestampField.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampFieldInput() {
    return this._timestampField.internalValue;
  }
}
export interface DashboardAnnotationsSourceLogsStrategyRangeEndTimestampField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardAnnotationsSourceLogsStrategyRangeEndTimestampFieldToTerraform(struct?: DashboardAnnotationsSourceLogsStrategyRangeEndTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardAnnotationsSourceLogsStrategyRangeEndTimestampFieldToHclTerraform(struct?: DashboardAnnotationsSourceLogsStrategyRangeEndTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceLogsStrategyRangeEndTimestampFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceLogsStrategyRangeEndTimestampField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceLogsStrategyRangeEndTimestampField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardAnnotationsSourceLogsStrategyRangeStartTimestampField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardAnnotationsSourceLogsStrategyRangeStartTimestampFieldToTerraform(struct?: DashboardAnnotationsSourceLogsStrategyRangeStartTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardAnnotationsSourceLogsStrategyRangeStartTimestampFieldToHclTerraform(struct?: DashboardAnnotationsSourceLogsStrategyRangeStartTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceLogsStrategyRangeStartTimestampFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceLogsStrategyRangeStartTimestampField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceLogsStrategyRangeStartTimestampField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardAnnotationsSourceLogsStrategyRange {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end_timestamp_field Dashboard#end_timestamp_field}
  */
  readonly endTimestampField: DashboardAnnotationsSourceLogsStrategyRangeEndTimestampField;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start_timestamp_field Dashboard#start_timestamp_field}
  */
  readonly startTimestampField: DashboardAnnotationsSourceLogsStrategyRangeStartTimestampField;
}

export function dashboardAnnotationsSourceLogsStrategyRangeToTerraform(struct?: DashboardAnnotationsSourceLogsStrategyRange | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end_timestamp_field: dashboardAnnotationsSourceLogsStrategyRangeEndTimestampFieldToTerraform(struct!.endTimestampField),
    start_timestamp_field: dashboardAnnotationsSourceLogsStrategyRangeStartTimestampFieldToTerraform(struct!.startTimestampField),
  }
}


export function dashboardAnnotationsSourceLogsStrategyRangeToHclTerraform(struct?: DashboardAnnotationsSourceLogsStrategyRange | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end_timestamp_field: {
      value: dashboardAnnotationsSourceLogsStrategyRangeEndTimestampFieldToHclTerraform(struct!.endTimestampField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceLogsStrategyRangeEndTimestampField",
    },
    start_timestamp_field: {
      value: dashboardAnnotationsSourceLogsStrategyRangeStartTimestampFieldToHclTerraform(struct!.startTimestampField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceLogsStrategyRangeStartTimestampField",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceLogsStrategyRangeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceLogsStrategyRange | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endTimestampField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endTimestampField = this._endTimestampField?.internalValue;
    }
    if (this._startTimestampField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.startTimestampField = this._startTimestampField?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceLogsStrategyRange | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endTimestampField.internalValue = undefined;
      this._startTimestampField.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endTimestampField.internalValue = value.endTimestampField;
      this._startTimestampField.internalValue = value.startTimestampField;
    }
  }

  // end_timestamp_field - computed: false, optional: false, required: true
  private _endTimestampField = new DashboardAnnotationsSourceLogsStrategyRangeEndTimestampFieldOutputReference(this, "end_timestamp_field");
  public get endTimestampField() {
    return this._endTimestampField;
  }
  public putEndTimestampField(value: DashboardAnnotationsSourceLogsStrategyRangeEndTimestampField) {
    this._endTimestampField.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endTimestampFieldInput() {
    return this._endTimestampField.internalValue;
  }

  // start_timestamp_field - computed: false, optional: false, required: true
  private _startTimestampField = new DashboardAnnotationsSourceLogsStrategyRangeStartTimestampFieldOutputReference(this, "start_timestamp_field");
  public get startTimestampField() {
    return this._startTimestampField;
  }
  public putStartTimestampField(value: DashboardAnnotationsSourceLogsStrategyRangeStartTimestampField) {
    this._startTimestampField.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startTimestampFieldInput() {
    return this._startTimestampField.internalValue;
  }
}
export interface DashboardAnnotationsSourceLogsStrategy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration?: DashboardAnnotationsSourceLogsStrategyDuration;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#instant Dashboard#instant}
  */
  readonly instant?: DashboardAnnotationsSourceLogsStrategyInstant;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#range Dashboard#range}
  */
  readonly range?: DashboardAnnotationsSourceLogsStrategyRange;
}

export function dashboardAnnotationsSourceLogsStrategyToTerraform(struct?: DashboardAnnotationsSourceLogsStrategy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: dashboardAnnotationsSourceLogsStrategyDurationToTerraform(struct!.duration),
    instant: dashboardAnnotationsSourceLogsStrategyInstantToTerraform(struct!.instant),
    range: dashboardAnnotationsSourceLogsStrategyRangeToTerraform(struct!.range),
  }
}


export function dashboardAnnotationsSourceLogsStrategyToHclTerraform(struct?: DashboardAnnotationsSourceLogsStrategy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: dashboardAnnotationsSourceLogsStrategyDurationToHclTerraform(struct!.duration),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceLogsStrategyDuration",
    },
    instant: {
      value: dashboardAnnotationsSourceLogsStrategyInstantToHclTerraform(struct!.instant),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceLogsStrategyInstant",
    },
    range: {
      value: dashboardAnnotationsSourceLogsStrategyRangeToHclTerraform(struct!.range),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceLogsStrategyRange",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceLogsStrategyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceLogsStrategy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration?.internalValue;
    }
    if (this._instant?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.instant = this._instant?.internalValue;
    }
    if (this._range?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.range = this._range?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceLogsStrategy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration.internalValue = undefined;
      this._instant.internalValue = undefined;
      this._range.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration.internalValue = value.duration;
      this._instant.internalValue = value.instant;
      this._range.internalValue = value.range;
    }
  }

  // duration - computed: false, optional: true, required: false
  private _duration = new DashboardAnnotationsSourceLogsStrategyDurationOutputReference(this, "duration");
  public get duration() {
    return this._duration;
  }
  public putDuration(value: DashboardAnnotationsSourceLogsStrategyDuration) {
    this._duration.internalValue = value;
  }
  public resetDuration() {
    this._duration.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration.internalValue;
  }

  // instant - computed: false, optional: true, required: false
  private _instant = new DashboardAnnotationsSourceLogsStrategyInstantOutputReference(this, "instant");
  public get instant() {
    return this._instant;
  }
  public putInstant(value: DashboardAnnotationsSourceLogsStrategyInstant) {
    this._instant.internalValue = value;
  }
  public resetInstant() {
    this._instant.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get instantInput() {
    return this._instant.internalValue;
  }

  // range - computed: false, optional: true, required: false
  private _range = new DashboardAnnotationsSourceLogsStrategyRangeOutputReference(this, "range");
  public get range() {
    return this._range;
  }
  public putRange(value: DashboardAnnotationsSourceLogsStrategyRange) {
    this._range.internalValue = value;
  }
  public resetRange() {
    this._range.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rangeInput() {
    return this._range.internalValue;
  }
}
export interface DashboardAnnotationsSourceLogs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#label_fields Dashboard#label_fields}
  */
  readonly labelFields?: DashboardAnnotationsSourceLogsLabelFields[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#lucene_query Dashboard#lucene_query}
  */
  readonly luceneQuery?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#message_template Dashboard#message_template}
  */
  readonly messageTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#strategy Dashboard#strategy}
  */
  readonly strategy: DashboardAnnotationsSourceLogsStrategy;
}

export function dashboardAnnotationsSourceLogsToTerraform(struct?: DashboardAnnotationsSourceLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_fields: cdktf.listMapper(dashboardAnnotationsSourceLogsLabelFieldsToTerraform, false)(struct!.labelFields),
    lucene_query: cdktf.stringToTerraform(struct!.luceneQuery),
    message_template: cdktf.stringToTerraform(struct!.messageTemplate),
    strategy: dashboardAnnotationsSourceLogsStrategyToTerraform(struct!.strategy),
  }
}


export function dashboardAnnotationsSourceLogsToHclTerraform(struct?: DashboardAnnotationsSourceLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_fields: {
      value: cdktf.listMapperHcl(dashboardAnnotationsSourceLogsLabelFieldsToHclTerraform, false)(struct!.labelFields),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardAnnotationsSourceLogsLabelFieldsList",
    },
    lucene_query: {
      value: cdktf.stringToHclTerraform(struct!.luceneQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_template: {
      value: cdktf.stringToHclTerraform(struct!.messageTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    strategy: {
      value: dashboardAnnotationsSourceLogsStrategyToHclTerraform(struct!.strategy),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceLogsStrategy",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelFields = this._labelFields?.internalValue;
    }
    if (this._luceneQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.luceneQuery = this._luceneQuery;
    }
    if (this._messageTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageTemplate = this._messageTemplate;
    }
    if (this._strategy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.strategy = this._strategy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelFields.internalValue = undefined;
      this._luceneQuery = undefined;
      this._messageTemplate = undefined;
      this._strategy.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelFields.internalValue = value.labelFields;
      this._luceneQuery = value.luceneQuery;
      this._messageTemplate = value.messageTemplate;
      this._strategy.internalValue = value.strategy;
    }
  }

  // label_fields - computed: false, optional: true, required: false
  private _labelFields = new DashboardAnnotationsSourceLogsLabelFieldsList(this, "label_fields", false);
  public get labelFields() {
    return this._labelFields;
  }
  public putLabelFields(value: DashboardAnnotationsSourceLogsLabelFields[] | cdktf.IResolvable) {
    this._labelFields.internalValue = value;
  }
  public resetLabelFields() {
    this._labelFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelFieldsInput() {
    return this._labelFields.internalValue;
  }

  // lucene_query - computed: false, optional: true, required: false
  private _luceneQuery?: string; 
  public get luceneQuery() {
    return this.getStringAttribute('lucene_query');
  }
  public set luceneQuery(value: string) {
    this._luceneQuery = value;
  }
  public resetLuceneQuery() {
    this._luceneQuery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get luceneQueryInput() {
    return this._luceneQuery;
  }

  // message_template - computed: false, optional: true, required: false
  private _messageTemplate?: string; 
  public get messageTemplate() {
    return this.getStringAttribute('message_template');
  }
  public set messageTemplate(value: string) {
    this._messageTemplate = value;
  }
  public resetMessageTemplate() {
    this._messageTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageTemplateInput() {
    return this._messageTemplate;
  }

  // strategy - computed: false, optional: false, required: true
  private _strategy = new DashboardAnnotationsSourceLogsStrategyOutputReference(this, "strategy");
  public get strategy() {
    return this._strategy;
  }
  public putStrategy(value: DashboardAnnotationsSourceLogsStrategy) {
    this._strategy.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get strategyInput() {
    return this._strategy.internalValue;
  }
}
export interface DashboardAnnotationsSourceMetricsStrategyStartTime {
}

export function dashboardAnnotationsSourceMetricsStrategyStartTimeToTerraform(struct?: DashboardAnnotationsSourceMetricsStrategyStartTime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dashboardAnnotationsSourceMetricsStrategyStartTimeToHclTerraform(struct?: DashboardAnnotationsSourceMetricsStrategyStartTime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DashboardAnnotationsSourceMetricsStrategyStartTimeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceMetricsStrategyStartTime | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceMetricsStrategyStartTime | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DashboardAnnotationsSourceMetricsStrategy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start_time Dashboard#start_time}
  */
  readonly startTime: DashboardAnnotationsSourceMetricsStrategyStartTime;
}

export function dashboardAnnotationsSourceMetricsStrategyToTerraform(struct?: DashboardAnnotationsSourceMetricsStrategy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    start_time: dashboardAnnotationsSourceMetricsStrategyStartTimeToTerraform(struct!.startTime),
  }
}


export function dashboardAnnotationsSourceMetricsStrategyToHclTerraform(struct?: DashboardAnnotationsSourceMetricsStrategy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    start_time: {
      value: dashboardAnnotationsSourceMetricsStrategyStartTimeToHclTerraform(struct!.startTime),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceMetricsStrategyStartTime",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceMetricsStrategyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceMetricsStrategy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._startTime?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.startTime = this._startTime?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceMetricsStrategy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._startTime.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._startTime.internalValue = value.startTime;
    }
  }

  // start_time - computed: false, optional: false, required: true
  private _startTime = new DashboardAnnotationsSourceMetricsStrategyStartTimeOutputReference(this, "start_time");
  public get startTime() {
    return this._startTime;
  }
  public putStartTime(value: DashboardAnnotationsSourceMetricsStrategyStartTime) {
    this._startTime.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startTimeInput() {
    return this._startTime.internalValue;
  }
}
export interface DashboardAnnotationsSourceMetrics {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#labels Dashboard#labels}
  */
  readonly labels?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#message_template Dashboard#message_template}
  */
  readonly messageTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#promql_query Dashboard#promql_query}
  */
  readonly promqlQuery: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#strategy Dashboard#strategy}
  */
  readonly strategy: DashboardAnnotationsSourceMetricsStrategy;
}

export function dashboardAnnotationsSourceMetricsToTerraform(struct?: DashboardAnnotationsSourceMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.labels),
    message_template: cdktf.stringToTerraform(struct!.messageTemplate),
    promql_query: cdktf.stringToTerraform(struct!.promqlQuery),
    strategy: dashboardAnnotationsSourceMetricsStrategyToTerraform(struct!.strategy),
  }
}


export function dashboardAnnotationsSourceMetricsToHclTerraform(struct?: DashboardAnnotationsSourceMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.labels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    message_template: {
      value: cdktf.stringToHclTerraform(struct!.messageTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    promql_query: {
      value: cdktf.stringToHclTerraform(struct!.promqlQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    strategy: {
      value: dashboardAnnotationsSourceMetricsStrategyToHclTerraform(struct!.strategy),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceMetricsStrategy",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._messageTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageTemplate = this._messageTemplate;
    }
    if (this._promqlQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.promqlQuery = this._promqlQuery;
    }
    if (this._strategy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.strategy = this._strategy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labels = undefined;
      this._messageTemplate = undefined;
      this._promqlQuery = undefined;
      this._strategy.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labels = value.labels;
      this._messageTemplate = value.messageTemplate;
      this._promqlQuery = value.promqlQuery;
      this._strategy.internalValue = value.strategy;
    }
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string[]; 
  public get labels() {
    return this.getListAttribute('labels');
  }
  public set labels(value: string[]) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // message_template - computed: false, optional: true, required: false
  private _messageTemplate?: string; 
  public get messageTemplate() {
    return this.getStringAttribute('message_template');
  }
  public set messageTemplate(value: string) {
    this._messageTemplate = value;
  }
  public resetMessageTemplate() {
    this._messageTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageTemplateInput() {
    return this._messageTemplate;
  }

  // promql_query - computed: false, optional: false, required: true
  private _promqlQuery?: string; 
  public get promqlQuery() {
    return this.getStringAttribute('promql_query');
  }
  public set promqlQuery(value: string) {
    this._promqlQuery = value;
  }
  // Temporarily expose input value. Use with caution.
  public get promqlQueryInput() {
    return this._promqlQuery;
  }

  // strategy - computed: false, optional: false, required: true
  private _strategy = new DashboardAnnotationsSourceMetricsStrategyOutputReference(this, "strategy");
  public get strategy() {
    return this._strategy;
  }
  public putStrategy(value: DashboardAnnotationsSourceMetricsStrategy) {
    this._strategy.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get strategyInput() {
    return this._strategy.internalValue;
  }
}
export interface DashboardAnnotationsSourceSpansLabelFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardAnnotationsSourceSpansLabelFieldsToTerraform(struct?: DashboardAnnotationsSourceSpansLabelFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardAnnotationsSourceSpansLabelFieldsToHclTerraform(struct?: DashboardAnnotationsSourceSpansLabelFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceSpansLabelFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardAnnotationsSourceSpansLabelFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceSpansLabelFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}

export class DashboardAnnotationsSourceSpansLabelFieldsList extends cdktf.ComplexList {
  public internalValue? : DashboardAnnotationsSourceSpansLabelFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardAnnotationsSourceSpansLabelFieldsOutputReference {
    return new DashboardAnnotationsSourceSpansLabelFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardAnnotationsSourceSpansStrategyDurationDurationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardAnnotationsSourceSpansStrategyDurationDurationFieldToTerraform(struct?: DashboardAnnotationsSourceSpansStrategyDurationDurationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardAnnotationsSourceSpansStrategyDurationDurationFieldToHclTerraform(struct?: DashboardAnnotationsSourceSpansStrategyDurationDurationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceSpansStrategyDurationDurationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceSpansStrategyDurationDurationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceSpansStrategyDurationDurationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardAnnotationsSourceSpansStrategyDurationStartTimestampField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardAnnotationsSourceSpansStrategyDurationStartTimestampFieldToTerraform(struct?: DashboardAnnotationsSourceSpansStrategyDurationStartTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardAnnotationsSourceSpansStrategyDurationStartTimestampFieldToHclTerraform(struct?: DashboardAnnotationsSourceSpansStrategyDurationStartTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceSpansStrategyDurationStartTimestampFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceSpansStrategyDurationStartTimestampField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceSpansStrategyDurationStartTimestampField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardAnnotationsSourceSpansStrategyDuration {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration_field Dashboard#duration_field}
  */
  readonly durationField: DashboardAnnotationsSourceSpansStrategyDurationDurationField;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start_timestamp_field Dashboard#start_timestamp_field}
  */
  readonly startTimestampField: DashboardAnnotationsSourceSpansStrategyDurationStartTimestampField;
}

export function dashboardAnnotationsSourceSpansStrategyDurationToTerraform(struct?: DashboardAnnotationsSourceSpansStrategyDuration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration_field: dashboardAnnotationsSourceSpansStrategyDurationDurationFieldToTerraform(struct!.durationField),
    start_timestamp_field: dashboardAnnotationsSourceSpansStrategyDurationStartTimestampFieldToTerraform(struct!.startTimestampField),
  }
}


export function dashboardAnnotationsSourceSpansStrategyDurationToHclTerraform(struct?: DashboardAnnotationsSourceSpansStrategyDuration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration_field: {
      value: dashboardAnnotationsSourceSpansStrategyDurationDurationFieldToHclTerraform(struct!.durationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceSpansStrategyDurationDurationField",
    },
    start_timestamp_field: {
      value: dashboardAnnotationsSourceSpansStrategyDurationStartTimestampFieldToHclTerraform(struct!.startTimestampField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceSpansStrategyDurationStartTimestampField",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceSpansStrategyDurationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceSpansStrategyDuration | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._durationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationField = this._durationField?.internalValue;
    }
    if (this._startTimestampField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.startTimestampField = this._startTimestampField?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceSpansStrategyDuration | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._durationField.internalValue = undefined;
      this._startTimestampField.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._durationField.internalValue = value.durationField;
      this._startTimestampField.internalValue = value.startTimestampField;
    }
  }

  // duration_field - computed: false, optional: false, required: true
  private _durationField = new DashboardAnnotationsSourceSpansStrategyDurationDurationFieldOutputReference(this, "duration_field");
  public get durationField() {
    return this._durationField;
  }
  public putDurationField(value: DashboardAnnotationsSourceSpansStrategyDurationDurationField) {
    this._durationField.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationFieldInput() {
    return this._durationField.internalValue;
  }

  // start_timestamp_field - computed: false, optional: false, required: true
  private _startTimestampField = new DashboardAnnotationsSourceSpansStrategyDurationStartTimestampFieldOutputReference(this, "start_timestamp_field");
  public get startTimestampField() {
    return this._startTimestampField;
  }
  public putStartTimestampField(value: DashboardAnnotationsSourceSpansStrategyDurationStartTimestampField) {
    this._startTimestampField.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startTimestampFieldInput() {
    return this._startTimestampField.internalValue;
  }
}
export interface DashboardAnnotationsSourceSpansStrategyInstantTimestampField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardAnnotationsSourceSpansStrategyInstantTimestampFieldToTerraform(struct?: DashboardAnnotationsSourceSpansStrategyInstantTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardAnnotationsSourceSpansStrategyInstantTimestampFieldToHclTerraform(struct?: DashboardAnnotationsSourceSpansStrategyInstantTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceSpansStrategyInstantTimestampFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceSpansStrategyInstantTimestampField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceSpansStrategyInstantTimestampField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardAnnotationsSourceSpansStrategyInstant {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#timestamp_field Dashboard#timestamp_field}
  */
  readonly timestampField: DashboardAnnotationsSourceSpansStrategyInstantTimestampField;
}

export function dashboardAnnotationsSourceSpansStrategyInstantToTerraform(struct?: DashboardAnnotationsSourceSpansStrategyInstant | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    timestamp_field: dashboardAnnotationsSourceSpansStrategyInstantTimestampFieldToTerraform(struct!.timestampField),
  }
}


export function dashboardAnnotationsSourceSpansStrategyInstantToHclTerraform(struct?: DashboardAnnotationsSourceSpansStrategyInstant | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    timestamp_field: {
      value: dashboardAnnotationsSourceSpansStrategyInstantTimestampFieldToHclTerraform(struct!.timestampField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceSpansStrategyInstantTimestampField",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceSpansStrategyInstantOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceSpansStrategyInstant | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._timestampField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampField = this._timestampField?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceSpansStrategyInstant | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._timestampField.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._timestampField.internalValue = value.timestampField;
    }
  }

  // timestamp_field - computed: false, optional: false, required: true
  private _timestampField = new DashboardAnnotationsSourceSpansStrategyInstantTimestampFieldOutputReference(this, "timestamp_field");
  public get timestampField() {
    return this._timestampField;
  }
  public putTimestampField(value: DashboardAnnotationsSourceSpansStrategyInstantTimestampField) {
    this._timestampField.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampFieldInput() {
    return this._timestampField.internalValue;
  }
}
export interface DashboardAnnotationsSourceSpansStrategyRangeEndTimestampField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardAnnotationsSourceSpansStrategyRangeEndTimestampFieldToTerraform(struct?: DashboardAnnotationsSourceSpansStrategyRangeEndTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardAnnotationsSourceSpansStrategyRangeEndTimestampFieldToHclTerraform(struct?: DashboardAnnotationsSourceSpansStrategyRangeEndTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceSpansStrategyRangeEndTimestampFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceSpansStrategyRangeEndTimestampField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceSpansStrategyRangeEndTimestampField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardAnnotationsSourceSpansStrategyRangeStartTimestampField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardAnnotationsSourceSpansStrategyRangeStartTimestampFieldToTerraform(struct?: DashboardAnnotationsSourceSpansStrategyRangeStartTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardAnnotationsSourceSpansStrategyRangeStartTimestampFieldToHclTerraform(struct?: DashboardAnnotationsSourceSpansStrategyRangeStartTimestampField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceSpansStrategyRangeStartTimestampFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceSpansStrategyRangeStartTimestampField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceSpansStrategyRangeStartTimestampField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardAnnotationsSourceSpansStrategyRange {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end_timestamp_field Dashboard#end_timestamp_field}
  */
  readonly endTimestampField: DashboardAnnotationsSourceSpansStrategyRangeEndTimestampField;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start_timestamp_field Dashboard#start_timestamp_field}
  */
  readonly startTimestampField: DashboardAnnotationsSourceSpansStrategyRangeStartTimestampField;
}

export function dashboardAnnotationsSourceSpansStrategyRangeToTerraform(struct?: DashboardAnnotationsSourceSpansStrategyRange | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end_timestamp_field: dashboardAnnotationsSourceSpansStrategyRangeEndTimestampFieldToTerraform(struct!.endTimestampField),
    start_timestamp_field: dashboardAnnotationsSourceSpansStrategyRangeStartTimestampFieldToTerraform(struct!.startTimestampField),
  }
}


export function dashboardAnnotationsSourceSpansStrategyRangeToHclTerraform(struct?: DashboardAnnotationsSourceSpansStrategyRange | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end_timestamp_field: {
      value: dashboardAnnotationsSourceSpansStrategyRangeEndTimestampFieldToHclTerraform(struct!.endTimestampField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceSpansStrategyRangeEndTimestampField",
    },
    start_timestamp_field: {
      value: dashboardAnnotationsSourceSpansStrategyRangeStartTimestampFieldToHclTerraform(struct!.startTimestampField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceSpansStrategyRangeStartTimestampField",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceSpansStrategyRangeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceSpansStrategyRange | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endTimestampField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endTimestampField = this._endTimestampField?.internalValue;
    }
    if (this._startTimestampField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.startTimestampField = this._startTimestampField?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceSpansStrategyRange | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endTimestampField.internalValue = undefined;
      this._startTimestampField.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endTimestampField.internalValue = value.endTimestampField;
      this._startTimestampField.internalValue = value.startTimestampField;
    }
  }

  // end_timestamp_field - computed: false, optional: false, required: true
  private _endTimestampField = new DashboardAnnotationsSourceSpansStrategyRangeEndTimestampFieldOutputReference(this, "end_timestamp_field");
  public get endTimestampField() {
    return this._endTimestampField;
  }
  public putEndTimestampField(value: DashboardAnnotationsSourceSpansStrategyRangeEndTimestampField) {
    this._endTimestampField.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endTimestampFieldInput() {
    return this._endTimestampField.internalValue;
  }

  // start_timestamp_field - computed: false, optional: false, required: true
  private _startTimestampField = new DashboardAnnotationsSourceSpansStrategyRangeStartTimestampFieldOutputReference(this, "start_timestamp_field");
  public get startTimestampField() {
    return this._startTimestampField;
  }
  public putStartTimestampField(value: DashboardAnnotationsSourceSpansStrategyRangeStartTimestampField) {
    this._startTimestampField.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startTimestampFieldInput() {
    return this._startTimestampField.internalValue;
  }
}
export interface DashboardAnnotationsSourceSpansStrategy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration?: DashboardAnnotationsSourceSpansStrategyDuration;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#instant Dashboard#instant}
  */
  readonly instant?: DashboardAnnotationsSourceSpansStrategyInstant;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#range Dashboard#range}
  */
  readonly range?: DashboardAnnotationsSourceSpansStrategyRange;
}

export function dashboardAnnotationsSourceSpansStrategyToTerraform(struct?: DashboardAnnotationsSourceSpansStrategy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: dashboardAnnotationsSourceSpansStrategyDurationToTerraform(struct!.duration),
    instant: dashboardAnnotationsSourceSpansStrategyInstantToTerraform(struct!.instant),
    range: dashboardAnnotationsSourceSpansStrategyRangeToTerraform(struct!.range),
  }
}


export function dashboardAnnotationsSourceSpansStrategyToHclTerraform(struct?: DashboardAnnotationsSourceSpansStrategy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: dashboardAnnotationsSourceSpansStrategyDurationToHclTerraform(struct!.duration),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceSpansStrategyDuration",
    },
    instant: {
      value: dashboardAnnotationsSourceSpansStrategyInstantToHclTerraform(struct!.instant),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceSpansStrategyInstant",
    },
    range: {
      value: dashboardAnnotationsSourceSpansStrategyRangeToHclTerraform(struct!.range),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceSpansStrategyRange",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceSpansStrategyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceSpansStrategy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration?.internalValue;
    }
    if (this._instant?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.instant = this._instant?.internalValue;
    }
    if (this._range?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.range = this._range?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceSpansStrategy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration.internalValue = undefined;
      this._instant.internalValue = undefined;
      this._range.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration.internalValue = value.duration;
      this._instant.internalValue = value.instant;
      this._range.internalValue = value.range;
    }
  }

  // duration - computed: false, optional: true, required: false
  private _duration = new DashboardAnnotationsSourceSpansStrategyDurationOutputReference(this, "duration");
  public get duration() {
    return this._duration;
  }
  public putDuration(value: DashboardAnnotationsSourceSpansStrategyDuration) {
    this._duration.internalValue = value;
  }
  public resetDuration() {
    this._duration.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration.internalValue;
  }

  // instant - computed: false, optional: true, required: false
  private _instant = new DashboardAnnotationsSourceSpansStrategyInstantOutputReference(this, "instant");
  public get instant() {
    return this._instant;
  }
  public putInstant(value: DashboardAnnotationsSourceSpansStrategyInstant) {
    this._instant.internalValue = value;
  }
  public resetInstant() {
    this._instant.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get instantInput() {
    return this._instant.internalValue;
  }

  // range - computed: false, optional: true, required: false
  private _range = new DashboardAnnotationsSourceSpansStrategyRangeOutputReference(this, "range");
  public get range() {
    return this._range;
  }
  public putRange(value: DashboardAnnotationsSourceSpansStrategyRange) {
    this._range.internalValue = value;
  }
  public resetRange() {
    this._range.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rangeInput() {
    return this._range.internalValue;
  }
}
export interface DashboardAnnotationsSourceSpans {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#label_fields Dashboard#label_fields}
  */
  readonly labelFields?: DashboardAnnotationsSourceSpansLabelFields[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#lucene_query Dashboard#lucene_query}
  */
  readonly luceneQuery?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#message_template Dashboard#message_template}
  */
  readonly messageTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#strategy Dashboard#strategy}
  */
  readonly strategy: DashboardAnnotationsSourceSpansStrategy;
}

export function dashboardAnnotationsSourceSpansToTerraform(struct?: DashboardAnnotationsSourceSpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_fields: cdktf.listMapper(dashboardAnnotationsSourceSpansLabelFieldsToTerraform, false)(struct!.labelFields),
    lucene_query: cdktf.stringToTerraform(struct!.luceneQuery),
    message_template: cdktf.stringToTerraform(struct!.messageTemplate),
    strategy: dashboardAnnotationsSourceSpansStrategyToTerraform(struct!.strategy),
  }
}


export function dashboardAnnotationsSourceSpansToHclTerraform(struct?: DashboardAnnotationsSourceSpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_fields: {
      value: cdktf.listMapperHcl(dashboardAnnotationsSourceSpansLabelFieldsToHclTerraform, false)(struct!.labelFields),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardAnnotationsSourceSpansLabelFieldsList",
    },
    lucene_query: {
      value: cdktf.stringToHclTerraform(struct!.luceneQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_template: {
      value: cdktf.stringToHclTerraform(struct!.messageTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    strategy: {
      value: dashboardAnnotationsSourceSpansStrategyToHclTerraform(struct!.strategy),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceSpansStrategy",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceSpansOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSourceSpans | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelFields = this._labelFields?.internalValue;
    }
    if (this._luceneQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.luceneQuery = this._luceneQuery;
    }
    if (this._messageTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageTemplate = this._messageTemplate;
    }
    if (this._strategy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.strategy = this._strategy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSourceSpans | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelFields.internalValue = undefined;
      this._luceneQuery = undefined;
      this._messageTemplate = undefined;
      this._strategy.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelFields.internalValue = value.labelFields;
      this._luceneQuery = value.luceneQuery;
      this._messageTemplate = value.messageTemplate;
      this._strategy.internalValue = value.strategy;
    }
  }

  // label_fields - computed: false, optional: true, required: false
  private _labelFields = new DashboardAnnotationsSourceSpansLabelFieldsList(this, "label_fields", false);
  public get labelFields() {
    return this._labelFields;
  }
  public putLabelFields(value: DashboardAnnotationsSourceSpansLabelFields[] | cdktf.IResolvable) {
    this._labelFields.internalValue = value;
  }
  public resetLabelFields() {
    this._labelFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelFieldsInput() {
    return this._labelFields.internalValue;
  }

  // lucene_query - computed: false, optional: true, required: false
  private _luceneQuery?: string; 
  public get luceneQuery() {
    return this.getStringAttribute('lucene_query');
  }
  public set luceneQuery(value: string) {
    this._luceneQuery = value;
  }
  public resetLuceneQuery() {
    this._luceneQuery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get luceneQueryInput() {
    return this._luceneQuery;
  }

  // message_template - computed: false, optional: true, required: false
  private _messageTemplate?: string; 
  public get messageTemplate() {
    return this.getStringAttribute('message_template');
  }
  public set messageTemplate(value: string) {
    this._messageTemplate = value;
  }
  public resetMessageTemplate() {
    this._messageTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageTemplateInput() {
    return this._messageTemplate;
  }

  // strategy - computed: false, optional: false, required: true
  private _strategy = new DashboardAnnotationsSourceSpansStrategyOutputReference(this, "strategy");
  public get strategy() {
    return this._strategy;
  }
  public putStrategy(value: DashboardAnnotationsSourceSpansStrategy) {
    this._strategy.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get strategyInput() {
    return this._strategy.internalValue;
  }
}
export interface DashboardAnnotationsSource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#logs Dashboard#logs}
  */
  readonly logs?: DashboardAnnotationsSourceLogs;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metrics Dashboard#metrics}
  */
  readonly metrics?: DashboardAnnotationsSourceMetrics;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#spans Dashboard#spans}
  */
  readonly spans?: DashboardAnnotationsSourceSpans;
}

export function dashboardAnnotationsSourceToTerraform(struct?: DashboardAnnotationsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    logs: dashboardAnnotationsSourceLogsToTerraform(struct!.logs),
    metrics: dashboardAnnotationsSourceMetricsToTerraform(struct!.metrics),
    spans: dashboardAnnotationsSourceSpansToTerraform(struct!.spans),
  }
}


export function dashboardAnnotationsSourceToHclTerraform(struct?: DashboardAnnotationsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    logs: {
      value: dashboardAnnotationsSourceLogsToHclTerraform(struct!.logs),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceLogs",
    },
    metrics: {
      value: dashboardAnnotationsSourceMetricsToHclTerraform(struct!.metrics),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceMetrics",
    },
    spans: {
      value: dashboardAnnotationsSourceSpansToHclTerraform(struct!.spans),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSourceSpans",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAnnotationsSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._logs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logs = this._logs?.internalValue;
    }
    if (this._metrics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics?.internalValue;
    }
    if (this._spans?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spans = this._spans?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotationsSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._logs.internalValue = undefined;
      this._metrics.internalValue = undefined;
      this._spans.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._logs.internalValue = value.logs;
      this._metrics.internalValue = value.metrics;
      this._spans.internalValue = value.spans;
    }
  }

  // logs - computed: false, optional: true, required: false
  private _logs = new DashboardAnnotationsSourceLogsOutputReference(this, "logs");
  public get logs() {
    return this._logs;
  }
  public putLogs(value: DashboardAnnotationsSourceLogs) {
    this._logs.internalValue = value;
  }
  public resetLogs() {
    this._logs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logsInput() {
    return this._logs.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics = new DashboardAnnotationsSourceMetricsOutputReference(this, "metrics");
  public get metrics() {
    return this._metrics;
  }
  public putMetrics(value: DashboardAnnotationsSourceMetrics) {
    this._metrics.internalValue = value;
  }
  public resetMetrics() {
    this._metrics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics.internalValue;
  }

  // spans - computed: false, optional: true, required: false
  private _spans = new DashboardAnnotationsSourceSpansOutputReference(this, "spans");
  public get spans() {
    return this._spans;
  }
  public putSpans(value: DashboardAnnotationsSourceSpans) {
    this._spans.internalValue = value;
  }
  public resetSpans() {
    this._spans.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spansInput() {
    return this._spans.internalValue;
  }
}
export interface DashboardAnnotations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#enabled Dashboard#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#id Dashboard#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#name Dashboard#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#source Dashboard#source}
  */
  readonly source: DashboardAnnotationsSource;
}

export function dashboardAnnotationsToTerraform(struct?: DashboardAnnotations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    id: cdktf.stringToTerraform(struct!.id),
    name: cdktf.stringToTerraform(struct!.name),
    source: dashboardAnnotationsSourceToTerraform(struct!.source),
  }
}


export function dashboardAnnotationsToHclTerraform(struct?: DashboardAnnotations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: dashboardAnnotationsSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardAnnotationsSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAnnotationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardAnnotations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAnnotations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._id = undefined;
      this._name = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._id = value.id;
      this._name = value.name;
      this._source.internalValue = value.source;
    }
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // source - computed: false, optional: false, required: true
  private _source = new DashboardAnnotationsSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DashboardAnnotationsSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}

export class DashboardAnnotationsList extends cdktf.ComplexList {
  public internalValue? : DashboardAnnotations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardAnnotationsOutputReference {
    return new DashboardAnnotationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardAutoRefresh {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type?: string;
}

export function dashboardAutoRefreshToTerraform(struct?: DashboardAutoRefresh | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardAutoRefreshToHclTerraform(struct?: DashboardAutoRefresh | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardAutoRefreshOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardAutoRefresh | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardAutoRefresh | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
    }
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardFiltersSourceLogsObservationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardFiltersSourceLogsObservationFieldToTerraform(struct?: DashboardFiltersSourceLogsObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardFiltersSourceLogsObservationFieldToHclTerraform(struct?: DashboardFiltersSourceLogsObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardFiltersSourceLogsObservationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardFiltersSourceLogsObservationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardFiltersSourceLogsObservationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardFiltersSourceLogsOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardFiltersSourceLogsOperatorToTerraform(struct?: DashboardFiltersSourceLogsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardFiltersSourceLogsOperatorToHclTerraform(struct?: DashboardFiltersSourceLogsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardFiltersSourceLogsOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardFiltersSourceLogsOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardFiltersSourceLogsOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardFiltersSourceLogs {
  /**
  * Field in the logs to apply the filter on.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#observation_field Dashboard#observation_field}
  */
  readonly observationField?: DashboardFiltersSourceLogsObservationField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardFiltersSourceLogsOperator;
}

export function dashboardFiltersSourceLogsToTerraform(struct?: DashboardFiltersSourceLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    observation_field: dashboardFiltersSourceLogsObservationFieldToTerraform(struct!.observationField),
    operator: dashboardFiltersSourceLogsOperatorToTerraform(struct!.operator),
  }
}


export function dashboardFiltersSourceLogsToHclTerraform(struct?: DashboardFiltersSourceLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    observation_field: {
      value: dashboardFiltersSourceLogsObservationFieldToHclTerraform(struct!.observationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardFiltersSourceLogsObservationField",
    },
    operator: {
      value: dashboardFiltersSourceLogsOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardFiltersSourceLogsOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardFiltersSourceLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardFiltersSourceLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._observationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.observationField = this._observationField?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardFiltersSourceLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._observationField.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._observationField.internalValue = value.observationField;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // observation_field - computed: false, optional: true, required: false
  private _observationField = new DashboardFiltersSourceLogsObservationFieldOutputReference(this, "observation_field");
  public get observationField() {
    return this._observationField;
  }
  public putObservationField(value: DashboardFiltersSourceLogsObservationField) {
    this._observationField.internalValue = value;
  }
  public resetObservationField() {
    this._observationField.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get observationFieldInput() {
    return this._observationField.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardFiltersSourceLogsOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardFiltersSourceLogsOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardFiltersSourceMetricsOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardFiltersSourceMetricsOperatorToTerraform(struct?: DashboardFiltersSourceMetricsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardFiltersSourceMetricsOperatorToHclTerraform(struct?: DashboardFiltersSourceMetricsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardFiltersSourceMetricsOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardFiltersSourceMetricsOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardFiltersSourceMetricsOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardFiltersSourceMetrics {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#label Dashboard#label}
  */
  readonly label?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metric_name Dashboard#metric_name}
  */
  readonly metricName?: string;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardFiltersSourceMetricsOperator;
}

export function dashboardFiltersSourceMetricsToTerraform(struct?: DashboardFiltersSourceMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    metric_name: cdktf.stringToTerraform(struct!.metricName),
    operator: dashboardFiltersSourceMetricsOperatorToTerraform(struct!.operator),
  }
}


export function dashboardFiltersSourceMetricsToHclTerraform(struct?: DashboardFiltersSourceMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric_name: {
      value: cdktf.stringToHclTerraform(struct!.metricName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: dashboardFiltersSourceMetricsOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardFiltersSourceMetricsOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardFiltersSourceMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardFiltersSourceMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._metricName !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricName = this._metricName;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardFiltersSourceMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._metricName = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._metricName = value.metricName;
      this._operator.internalValue = value.operator;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // metric_name - computed: false, optional: true, required: false
  private _metricName?: string; 
  public get metricName() {
    return this.getStringAttribute('metric_name');
  }
  public set metricName(value: string) {
    this._metricName = value;
  }
  public resetMetricName() {
    this._metricName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricNameInput() {
    return this._metricName;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardFiltersSourceMetricsOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardFiltersSourceMetricsOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardFiltersSourceSpansField {
  /**
  * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
  /**
  * The value of the field. When the field type is `metadata`, can be one of ["application_name" "operation_name" "service_name" "subsystem_name" "unspecified"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#value Dashboard#value}
  */
  readonly value: string;
}

export function dashboardFiltersSourceSpansFieldToTerraform(struct?: DashboardFiltersSourceSpansField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dashboardFiltersSourceSpansFieldToHclTerraform(struct?: DashboardFiltersSourceSpansField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardFiltersSourceSpansFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardFiltersSourceSpansField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardFiltersSourceSpansField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DashboardFiltersSourceSpansOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardFiltersSourceSpansOperatorToTerraform(struct?: DashboardFiltersSourceSpansOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardFiltersSourceSpansOperatorToHclTerraform(struct?: DashboardFiltersSourceSpansOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardFiltersSourceSpansOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardFiltersSourceSpansOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardFiltersSourceSpansOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardFiltersSourceSpans {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: DashboardFiltersSourceSpansField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardFiltersSourceSpansOperator;
}

export function dashboardFiltersSourceSpansToTerraform(struct?: DashboardFiltersSourceSpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: dashboardFiltersSourceSpansFieldToTerraform(struct!.field),
    operator: dashboardFiltersSourceSpansOperatorToTerraform(struct!.operator),
  }
}


export function dashboardFiltersSourceSpansToHclTerraform(struct?: DashboardFiltersSourceSpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: dashboardFiltersSourceSpansFieldToHclTerraform(struct!.field),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardFiltersSourceSpansField",
    },
    operator: {
      value: dashboardFiltersSourceSpansOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardFiltersSourceSpansOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardFiltersSourceSpansOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardFiltersSourceSpans | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardFiltersSourceSpans | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field.internalValue = value.field;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field = new DashboardFiltersSourceSpansFieldOutputReference(this, "field");
  public get field() {
    return this._field;
  }
  public putField(value: DashboardFiltersSourceSpansField) {
    this._field.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardFiltersSourceSpansOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardFiltersSourceSpansOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardFiltersSource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#logs Dashboard#logs}
  */
  readonly logs?: DashboardFiltersSourceLogs;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metrics Dashboard#metrics}
  */
  readonly metrics?: DashboardFiltersSourceMetrics;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#spans Dashboard#spans}
  */
  readonly spans?: DashboardFiltersSourceSpans;
}

export function dashboardFiltersSourceToTerraform(struct?: DashboardFiltersSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    logs: dashboardFiltersSourceLogsToTerraform(struct!.logs),
    metrics: dashboardFiltersSourceMetricsToTerraform(struct!.metrics),
    spans: dashboardFiltersSourceSpansToTerraform(struct!.spans),
  }
}


export function dashboardFiltersSourceToHclTerraform(struct?: DashboardFiltersSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    logs: {
      value: dashboardFiltersSourceLogsToHclTerraform(struct!.logs),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardFiltersSourceLogs",
    },
    metrics: {
      value: dashboardFiltersSourceMetricsToHclTerraform(struct!.metrics),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardFiltersSourceMetrics",
    },
    spans: {
      value: dashboardFiltersSourceSpansToHclTerraform(struct!.spans),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardFiltersSourceSpans",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardFiltersSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardFiltersSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._logs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logs = this._logs?.internalValue;
    }
    if (this._metrics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics?.internalValue;
    }
    if (this._spans?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spans = this._spans?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardFiltersSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._logs.internalValue = undefined;
      this._metrics.internalValue = undefined;
      this._spans.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._logs.internalValue = value.logs;
      this._metrics.internalValue = value.metrics;
      this._spans.internalValue = value.spans;
    }
  }

  // logs - computed: false, optional: true, required: false
  private _logs = new DashboardFiltersSourceLogsOutputReference(this, "logs");
  public get logs() {
    return this._logs;
  }
  public putLogs(value: DashboardFiltersSourceLogs) {
    this._logs.internalValue = value;
  }
  public resetLogs() {
    this._logs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logsInput() {
    return this._logs.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics = new DashboardFiltersSourceMetricsOutputReference(this, "metrics");
  public get metrics() {
    return this._metrics;
  }
  public putMetrics(value: DashboardFiltersSourceMetrics) {
    this._metrics.internalValue = value;
  }
  public resetMetrics() {
    this._metrics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics.internalValue;
  }

  // spans - computed: false, optional: true, required: false
  private _spans = new DashboardFiltersSourceSpansOutputReference(this, "spans");
  public get spans() {
    return this._spans;
  }
  public putSpans(value: DashboardFiltersSourceSpans) {
    this._spans.internalValue = value;
  }
  public resetSpans() {
    this._spans.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spansInput() {
    return this._spans.internalValue;
  }
}
export interface DashboardFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#collapsed Dashboard#collapsed}
  */
  readonly collapsed?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#enabled Dashboard#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#source Dashboard#source}
  */
  readonly source: DashboardFiltersSource;
}

export function dashboardFiltersToTerraform(struct?: DashboardFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collapsed: cdktf.booleanToTerraform(struct!.collapsed),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    source: dashboardFiltersSourceToTerraform(struct!.source),
  }
}


export function dashboardFiltersToHclTerraform(struct?: DashboardFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collapsed: {
      value: cdktf.booleanToHclTerraform(struct!.collapsed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source: {
      value: dashboardFiltersSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardFiltersSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collapsed !== undefined) {
      hasAnyValues = true;
      internalValueResult.collapsed = this._collapsed;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collapsed = undefined;
      this._enabled = undefined;
      this._source.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collapsed = value.collapsed;
      this._enabled = value.enabled;
      this._source.internalValue = value.source;
    }
  }

  // collapsed - computed: true, optional: true, required: false
  private _collapsed?: boolean | cdktf.IResolvable; 
  public get collapsed() {
    return this.getBooleanAttribute('collapsed');
  }
  public set collapsed(value: boolean | cdktf.IResolvable) {
    this._collapsed = value;
  }
  public resetCollapsed() {
    this._collapsed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collapsedInput() {
    return this._collapsed;
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // source - computed: false, optional: false, required: true
  private _source = new DashboardFiltersSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DashboardFiltersSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }
}

export class DashboardFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardFiltersOutputReference {
    return new DashboardFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardFolder {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#id Dashboard#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#path Dashboard#path}
  */
  readonly path?: string;
}

export function dashboardFolderToTerraform(struct?: DashboardFolder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dashboardFolderToHclTerraform(struct?: DashboardFolder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardFolderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardFolder | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardFolder | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._path = value.path;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DashboardLayoutSectionsOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#collapsed Dashboard#collapsed}
  */
  readonly collapsed?: boolean | cdktf.IResolvable;
  /**
  * Section color, valid values: [cyan green blue purple magenta pink orange]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#color Dashboard#color}
  */
  readonly color?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#description Dashboard#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#name Dashboard#name}
  */
  readonly name: string;
}

export function dashboardLayoutSectionsOptionsToTerraform(struct?: DashboardLayoutSectionsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collapsed: cdktf.booleanToTerraform(struct!.collapsed),
    color: cdktf.stringToTerraform(struct!.color),
    description: cdktf.stringToTerraform(struct!.description),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dashboardLayoutSectionsOptionsToHclTerraform(struct?: DashboardLayoutSectionsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collapsed: {
      value: cdktf.booleanToHclTerraform(struct!.collapsed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collapsed !== undefined) {
      hasAnyValues = true;
      internalValueResult.collapsed = this._collapsed;
    }
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collapsed = undefined;
      this._color = undefined;
      this._description = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collapsed = value.collapsed;
      this._color = value.color;
      this._description = value.description;
      this._name = value.name;
    }
  }

  // collapsed - computed: false, optional: true, required: false
  private _collapsed?: boolean | cdktf.IResolvable; 
  public get collapsed() {
    return this.getBooleanAttribute('collapsed');
  }
  public set collapsed(value: boolean | cdktf.IResolvable) {
    this._collapsed = value;
  }
  public resetCollapsed() {
    this._collapsed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collapsedInput() {
    return this._collapsed;
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogs {
  /**
  * Field in the logs to apply the filter on.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#observation_field Dashboard#observation_field}
  */
  readonly observationField?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    observation_field: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationFieldToTerraform(struct!.observationField),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    observation_field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationFieldToHclTerraform(struct!.observationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._observationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.observationField = this._observationField?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._observationField.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._observationField.internalValue = value.observationField;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // observation_field - computed: false, optional: true, required: false
  private _observationField = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationFieldOutputReference(this, "observation_field");
  public get observationField() {
    return this._observationField;
  }
  public putObservationField(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsObservationField) {
    this._observationField.internalValue = value;
  }
  public resetObservationField() {
    this._observationField.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get observationFieldInput() {
    return this._observationField.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetrics {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#label Dashboard#label}
  */
  readonly label?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metric_name Dashboard#metric_name}
  */
  readonly metricName?: string;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    metric_name: cdktf.stringToTerraform(struct!.metricName),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric_name: {
      value: cdktf.stringToHclTerraform(struct!.metricName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._metricName !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricName = this._metricName;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._metricName = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._metricName = value.metricName;
      this._operator.internalValue = value.operator;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // metric_name - computed: false, optional: true, required: false
  private _metricName?: string; 
  public get metricName() {
    return this.getStringAttribute('metric_name');
  }
  public set metricName(value: string) {
    this._metricName = value;
  }
  public resetMetricName() {
    this._metricName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricNameInput() {
    return this._metricName;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansField {
  /**
  * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
  /**
  * The value of the field. When the field type is `metadata`, can be one of ["application_name" "operation_name" "service_name" "subsystem_name" "unspecified"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#value Dashboard#value}
  */
  readonly value: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpans {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansFieldToTerraform(struct!.field),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansFieldToHclTerraform(struct!.field),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpans | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpans | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field.internalValue = value.field;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansFieldOutputReference(this, "field");
  public get field() {
    return this._field;
  }
  public putField(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansField) {
    this._field.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#logs Dashboard#logs}
  */
  readonly logs?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogs;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metrics Dashboard#metrics}
  */
  readonly metrics?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetrics;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#spans Dashboard#spans}
  */
  readonly spans?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpans;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    logs: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsToTerraform(struct!.logs),
    metrics: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsToTerraform(struct!.metrics),
    spans: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansToTerraform(struct!.spans),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    logs: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsToHclTerraform(struct!.logs),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogs",
    },
    metrics: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsToHclTerraform(struct!.metrics),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetrics",
    },
    spans: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansToHclTerraform(struct!.spans),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpans",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._logs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logs = this._logs?.internalValue;
    }
    if (this._metrics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics?.internalValue;
    }
    if (this._spans?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spans = this._spans?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._logs.internalValue = undefined;
      this._metrics.internalValue = undefined;
      this._spans.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._logs.internalValue = value.logs;
      this._metrics.internalValue = value.metrics;
      this._spans.internalValue = value.spans;
    }
  }

  // logs - computed: false, optional: true, required: false
  private _logs = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogsOutputReference(this, "logs");
  public get logs() {
    return this._logs;
  }
  public putLogs(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersLogs) {
    this._logs.internalValue = value;
  }
  public resetLogs() {
    this._logs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logsInput() {
    return this._logs.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetricsOutputReference(this, "metrics");
  public get metrics() {
    return this._metrics;
  }
  public putMetrics(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersMetrics) {
    this._metrics.internalValue = value;
  }
  public resetMetrics() {
    this._metrics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics.internalValue;
  }

  // spans - computed: false, optional: true, required: false
  private _spans = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpansOutputReference(this, "spans");
  public get spans() {
    return this._spans;
  }
  public putSpans(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersSpans) {
    this._spans.internalValue = value;
  }
  public resetSpans() {
    this._spans.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spansInput() {
    return this._spans.internalValue;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsolute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end Dashboard#end}
  */
  readonly end: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start Dashboard#start}
  */
  readonly start: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsoluteToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.stringToTerraform(struct!.end),
    start: cdktf.stringToTerraform(struct!.start),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsoluteToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.stringToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.stringToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsoluteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsolute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsolute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: false, required: true
  private _end?: string; 
  public get end() {
    return this.getStringAttribute('end');
  }
  public set end(value: string) {
    this._end = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: false, required: true
  private _start?: string; 
  public get start() {
    return this.getStringAttribute('start');
  }
  public set start(value: string) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelative {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelativeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelativeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelativeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelative | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelative | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrame {
  /**
  * Absolute time frame specifying a fixed start and end time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#absolute Dashboard#absolute}
  */
  readonly absolute?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsolute;
  /**
  * Relative time frame specifying a duration from the current time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#relative Dashboard#relative}
  */
  readonly relative?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelative;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    absolute: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsoluteToTerraform(struct!.absolute),
    relative: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelativeToTerraform(struct!.relative),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    absolute: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsoluteToHclTerraform(struct!.absolute),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsolute",
    },
    relative: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelativeToHclTerraform(struct!.relative),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelative",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrame | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._absolute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.absolute = this._absolute?.internalValue;
    }
    if (this._relative?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relative = this._relative?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrame | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._absolute.internalValue = undefined;
      this._relative.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._absolute.internalValue = value.absolute;
      this._relative.internalValue = value.relative;
    }
  }

  // absolute - computed: false, optional: true, required: false
  private _absolute = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsoluteOutputReference(this, "absolute");
  public get absolute() {
    return this._absolute;
  }
  public putAbsolute(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameAbsolute) {
    this._absolute.internalValue = value;
  }
  public resetAbsolute() {
    this._absolute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get absoluteInput() {
    return this._absolute.internalValue;
  }

  // relative - computed: false, optional: true, required: false
  private _relative = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelativeOutputReference(this, "relative");
  public get relative() {
    return this._relative;
  }
  public putRelative(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameRelative) {
    this._relative.internalValue = value;
  }
  public resetRelative() {
    this._relative.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relativeInput() {
    return this._relative.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrime {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#filters Dashboard#filters}
  */
  readonly filters?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#group_names Dashboard#group_names}
  */
  readonly groupNames?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#query Dashboard#query}
  */
  readonly query: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#stacked_group_name Dashboard#stacked_group_name}
  */
  readonly stackedGroupName?: string;
  /**
  * Specifies the time frame. Can be either absolute or relative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time_frame Dashboard#time_frame}
  */
  readonly timeFrame?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrame;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filters: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersToTerraform, false)(struct!.filters),
    group_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupNames),
    query: cdktf.stringToTerraform(struct!.query),
    stacked_group_name: cdktf.stringToTerraform(struct!.stackedGroupName),
    time_frame: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameToTerraform(struct!.timeFrame),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filters: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersList",
    },
    group_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    query: {
      value: cdktf.stringToHclTerraform(struct!.query),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stacked_group_name: {
      value: cdktf.stringToHclTerraform(struct!.stackedGroupName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_frame: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameToHclTerraform(struct!.timeFrame),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrame",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrime | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._groupNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupNames = this._groupNames;
    }
    if (this._query !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query;
    }
    if (this._stackedGroupName !== undefined) {
      hasAnyValues = true;
      internalValueResult.stackedGroupName = this._stackedGroupName;
    }
    if (this._timeFrame?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeFrame = this._timeFrame?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrime | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filters.internalValue = undefined;
      this._groupNames = undefined;
      this._query = undefined;
      this._stackedGroupName = undefined;
      this._timeFrame.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filters.internalValue = value.filters;
      this._groupNames = value.groupNames;
      this._query = value.query;
      this._stackedGroupName = value.stackedGroupName;
      this._timeFrame.internalValue = value.timeFrame;
    }
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // group_names - computed: false, optional: true, required: false
  private _groupNames?: string[]; 
  public get groupNames() {
    return this.getListAttribute('group_names');
  }
  public set groupNames(value: string[]) {
    this._groupNames = value;
  }
  public resetGroupNames() {
    this._groupNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupNamesInput() {
    return this._groupNames;
  }

  // query - computed: false, optional: false, required: true
  private _query?: string; 
  public get query() {
    return this.getStringAttribute('query');
  }
  public set query(value: string) {
    this._query = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query;
  }

  // stacked_group_name - computed: false, optional: true, required: false
  private _stackedGroupName?: string; 
  public get stackedGroupName() {
    return this.getStringAttribute('stacked_group_name');
  }
  public set stackedGroupName(value: string) {
    this._stackedGroupName = value;
  }
  public resetStackedGroupName() {
    this._stackedGroupName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stackedGroupNameInput() {
    return this._stackedGroupName;
  }

  // time_frame - computed: false, optional: true, required: false
  private _timeFrame = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrameOutputReference(this, "time_frame");
  public get timeFrame() {
    return this._timeFrame;
  }
  public putTimeFrame(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeTimeFrame) {
    this._timeFrame.internalValue = value;
  }
  public resetTimeFrame() {
    this._timeFrame.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeFrameInput() {
    return this._timeFrame.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#observation_field Dashboard#observation_field}
  */
  readonly observationField?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationField;
  /**
  * The percentage of the aggregation to return. required when type is `percentile`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#percent Dashboard#percent}
  */
  readonly percent?: number;
  /**
  * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    observation_field: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationFieldToTerraform(struct!.observationField),
    percent: cdktf.numberToTerraform(struct!.percent),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    observation_field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationFieldToHclTerraform(struct!.observationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationField",
    },
    percent: {
      value: cdktf.numberToHclTerraform(struct!.percent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._observationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.observationField = this._observationField?.internalValue;
    }
    if (this._percent !== undefined) {
      hasAnyValues = true;
      internalValueResult.percent = this._percent;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._observationField.internalValue = undefined;
      this._percent = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._observationField.internalValue = value.observationField;
      this._percent = value.percent;
      this._type = value.type;
    }
  }

  // field - computed: false, optional: true, required: false
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  public resetField() {
    this._field = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // observation_field - computed: false, optional: true, required: false
  private _observationField = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationFieldOutputReference(this, "observation_field");
  public get observationField() {
    return this._observationField;
  }
  public putObservationField(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationObservationField) {
    this._observationField.internalValue = value;
  }
  public resetObservationField() {
    this._observationField.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get observationFieldInput() {
    return this._observationField.internalValue;
  }

  // percent - computed: false, optional: true, required: false
  private _percent?: number; 
  public get percent() {
    return this.getNumberAttribute('percent');
  }
  public set percent(value: number) {
    this._percent = value;
  }
  public resetPercent() {
    this._percent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentInput() {
    return this._percent;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#observation_field Dashboard#observation_field}
  */
  readonly observationField?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    observation_field: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationFieldToTerraform(struct!.observationField),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    observation_field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationFieldToHclTerraform(struct!.observationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._observationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.observationField = this._observationField?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._observationField.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._observationField.internalValue = value.observationField;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // observation_field - computed: false, optional: true, required: false
  private _observationField = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationFieldOutputReference(this, "observation_field");
  public get observationField() {
    return this._observationField;
  }
  public putObservationField(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersObservationField) {
    this._observationField.internalValue = value;
  }
  public resetObservationField() {
    this._observationField.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get observationFieldInput() {
    return this._observationField.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFieldsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFieldsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFieldsList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFieldsOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsolute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end Dashboard#end}
  */
  readonly end: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start Dashboard#start}
  */
  readonly start: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsoluteToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.stringToTerraform(struct!.end),
    start: cdktf.stringToTerraform(struct!.start),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsoluteToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.stringToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.stringToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsoluteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsolute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsolute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: false, required: true
  private _end?: string; 
  public get end() {
    return this.getStringAttribute('end');
  }
  public set end(value: string) {
    this._end = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: false, required: true
  private _start?: string; 
  public get start() {
    return this.getStringAttribute('start');
  }
  public set start(value: string) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelative {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelativeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelativeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelativeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelative | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelative | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrame {
  /**
  * Absolute time frame specifying a fixed start and end time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#absolute Dashboard#absolute}
  */
  readonly absolute?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsolute;
  /**
  * Relative time frame specifying a duration from the current time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#relative Dashboard#relative}
  */
  readonly relative?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelative;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    absolute: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsoluteToTerraform(struct!.absolute),
    relative: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelativeToTerraform(struct!.relative),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    absolute: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsoluteToHclTerraform(struct!.absolute),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsolute",
    },
    relative: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelativeToHclTerraform(struct!.relative),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelative",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrame | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._absolute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.absolute = this._absolute?.internalValue;
    }
    if (this._relative?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relative = this._relative?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrame | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._absolute.internalValue = undefined;
      this._relative.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._absolute.internalValue = value.absolute;
      this._relative.internalValue = value.relative;
    }
  }

  // absolute - computed: false, optional: true, required: false
  private _absolute = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsoluteOutputReference(this, "absolute");
  public get absolute() {
    return this._absolute;
  }
  public putAbsolute(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameAbsolute) {
    this._absolute.internalValue = value;
  }
  public resetAbsolute() {
    this._absolute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get absoluteInput() {
    return this._absolute.internalValue;
  }

  // relative - computed: false, optional: true, required: false
  private _relative = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelativeOutputReference(this, "relative");
  public get relative() {
    return this._relative;
  }
  public putRelative(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameRelative) {
    this._relative.internalValue = value;
  }
  public resetRelative() {
    this._relative.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relativeInput() {
    return this._relative.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#aggregation Dashboard#aggregation}
  */
  readonly aggregation: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregation;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#filters Dashboard#filters}
  */
  readonly filters?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#group_names Dashboard#group_names}
  */
  readonly groupNames?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#group_names_fields Dashboard#group_names_fields}
  */
  readonly groupNamesFields?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFields[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#lucene_query Dashboard#lucene_query}
  */
  readonly luceneQuery?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#stacked_group_name Dashboard#stacked_group_name}
  */
  readonly stackedGroupName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#stacked_group_name_field Dashboard#stacked_group_name_field}
  */
  readonly stackedGroupNameField?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameField;
  /**
  * Specifies the time frame. Can be either absolute or relative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time_frame Dashboard#time_frame}
  */
  readonly timeFrame?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrame;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregation: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationToTerraform(struct!.aggregation),
    filters: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersToTerraform, false)(struct!.filters),
    group_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupNames),
    group_names_fields: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFieldsToTerraform, false)(struct!.groupNamesFields),
    lucene_query: cdktf.stringToTerraform(struct!.luceneQuery),
    stacked_group_name: cdktf.stringToTerraform(struct!.stackedGroupName),
    stacked_group_name_field: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameFieldToTerraform(struct!.stackedGroupNameField),
    time_frame: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameToTerraform(struct!.timeFrame),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregation: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationToHclTerraform(struct!.aggregation),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregation",
    },
    filters: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersList",
    },
    group_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    group_names_fields: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFieldsToHclTerraform, false)(struct!.groupNamesFields),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFieldsList",
    },
    lucene_query: {
      value: cdktf.stringToHclTerraform(struct!.luceneQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stacked_group_name: {
      value: cdktf.stringToHclTerraform(struct!.stackedGroupName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stacked_group_name_field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameFieldToHclTerraform(struct!.stackedGroupNameField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameField",
    },
    time_frame: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameToHclTerraform(struct!.timeFrame),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrame",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregation = this._aggregation?.internalValue;
    }
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._groupNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupNames = this._groupNames;
    }
    if (this._groupNamesFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupNamesFields = this._groupNamesFields?.internalValue;
    }
    if (this._luceneQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.luceneQuery = this._luceneQuery;
    }
    if (this._stackedGroupName !== undefined) {
      hasAnyValues = true;
      internalValueResult.stackedGroupName = this._stackedGroupName;
    }
    if (this._stackedGroupNameField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.stackedGroupNameField = this._stackedGroupNameField?.internalValue;
    }
    if (this._timeFrame?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeFrame = this._timeFrame?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregation.internalValue = undefined;
      this._filters.internalValue = undefined;
      this._groupNames = undefined;
      this._groupNamesFields.internalValue = undefined;
      this._luceneQuery = undefined;
      this._stackedGroupName = undefined;
      this._stackedGroupNameField.internalValue = undefined;
      this._timeFrame.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregation.internalValue = value.aggregation;
      this._filters.internalValue = value.filters;
      this._groupNames = value.groupNames;
      this._groupNamesFields.internalValue = value.groupNamesFields;
      this._luceneQuery = value.luceneQuery;
      this._stackedGroupName = value.stackedGroupName;
      this._stackedGroupNameField.internalValue = value.stackedGroupNameField;
      this._timeFrame.internalValue = value.timeFrame;
    }
  }

  // aggregation - computed: false, optional: false, required: true
  private _aggregation = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregationOutputReference(this, "aggregation");
  public get aggregation() {
    return this._aggregation;
  }
  public putAggregation(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsAggregation) {
    this._aggregation.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregationInput() {
    return this._aggregation.internalValue;
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // group_names - computed: false, optional: true, required: false
  private _groupNames?: string[]; 
  public get groupNames() {
    return this.getListAttribute('group_names');
  }
  public set groupNames(value: string[]) {
    this._groupNames = value;
  }
  public resetGroupNames() {
    this._groupNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupNamesInput() {
    return this._groupNames;
  }

  // group_names_fields - computed: false, optional: true, required: false
  private _groupNamesFields = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFieldsList(this, "group_names_fields", false);
  public get groupNamesFields() {
    return this._groupNamesFields;
  }
  public putGroupNamesFields(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsGroupNamesFields[] | cdktf.IResolvable) {
    this._groupNamesFields.internalValue = value;
  }
  public resetGroupNamesFields() {
    this._groupNamesFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupNamesFieldsInput() {
    return this._groupNamesFields.internalValue;
  }

  // lucene_query - computed: false, optional: true, required: false
  private _luceneQuery?: string; 
  public get luceneQuery() {
    return this.getStringAttribute('lucene_query');
  }
  public set luceneQuery(value: string) {
    this._luceneQuery = value;
  }
  public resetLuceneQuery() {
    this._luceneQuery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get luceneQueryInput() {
    return this._luceneQuery;
  }

  // stacked_group_name - computed: false, optional: true, required: false
  private _stackedGroupName?: string; 
  public get stackedGroupName() {
    return this.getStringAttribute('stacked_group_name');
  }
  public set stackedGroupName(value: string) {
    this._stackedGroupName = value;
  }
  public resetStackedGroupName() {
    this._stackedGroupName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stackedGroupNameInput() {
    return this._stackedGroupName;
  }

  // stacked_group_name_field - computed: false, optional: true, required: false
  private _stackedGroupNameField = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameFieldOutputReference(this, "stacked_group_name_field");
  public get stackedGroupNameField() {
    return this._stackedGroupNameField;
  }
  public putStackedGroupNameField(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsStackedGroupNameField) {
    this._stackedGroupNameField.internalValue = value;
  }
  public resetStackedGroupNameField() {
    this._stackedGroupNameField.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stackedGroupNameFieldInput() {
    return this._stackedGroupNameField.internalValue;
  }

  // time_frame - computed: false, optional: true, required: false
  private _timeFrame = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrameOutputReference(this, "time_frame");
  public get timeFrame() {
    return this._timeFrame;
  }
  public putTimeFrame(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsTimeFrame) {
    this._timeFrame.internalValue = value;
  }
  public resetTimeFrame() {
    this._timeFrame.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeFrameInput() {
    return this._timeFrame.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFilters {
  /**
  * Label associated with the metric.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#label Dashboard#label}
  */
  readonly label?: string;
  /**
  * Metric name to apply the filter on.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metric Dashboard#metric}
  */
  readonly metric: string;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    metric: cdktf.stringToTerraform(struct!.metric),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.stringToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._metric = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._metric = value.metric;
      this._operator.internalValue = value.operator;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // metric - computed: false, optional: false, required: true
  private _metric?: string; 
  public get metric() {
    return this.getStringAttribute('metric');
  }
  public set metric(value: string) {
    this._metric = value;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsolute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end Dashboard#end}
  */
  readonly end: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start Dashboard#start}
  */
  readonly start: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsoluteToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.stringToTerraform(struct!.end),
    start: cdktf.stringToTerraform(struct!.start),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsoluteToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.stringToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.stringToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsoluteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsolute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsolute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: false, required: true
  private _end?: string; 
  public get end() {
    return this.getStringAttribute('end');
  }
  public set end(value: string) {
    this._end = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: false, required: true
  private _start?: string; 
  public get start() {
    return this.getStringAttribute('start');
  }
  public set start(value: string) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelative {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelativeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelativeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelativeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelative | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelative | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrame {
  /**
  * Absolute time frame specifying a fixed start and end time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#absolute Dashboard#absolute}
  */
  readonly absolute?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsolute;
  /**
  * Relative time frame specifying a duration from the current time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#relative Dashboard#relative}
  */
  readonly relative?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelative;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    absolute: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsoluteToTerraform(struct!.absolute),
    relative: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelativeToTerraform(struct!.relative),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    absolute: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsoluteToHclTerraform(struct!.absolute),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsolute",
    },
    relative: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelativeToHclTerraform(struct!.relative),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelative",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrame | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._absolute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.absolute = this._absolute?.internalValue;
    }
    if (this._relative?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relative = this._relative?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrame | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._absolute.internalValue = undefined;
      this._relative.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._absolute.internalValue = value.absolute;
      this._relative.internalValue = value.relative;
    }
  }

  // absolute - computed: false, optional: true, required: false
  private _absolute = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsoluteOutputReference(this, "absolute");
  public get absolute() {
    return this._absolute;
  }
  public putAbsolute(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameAbsolute) {
    this._absolute.internalValue = value;
  }
  public resetAbsolute() {
    this._absolute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get absoluteInput() {
    return this._absolute.internalValue;
  }

  // relative - computed: false, optional: true, required: false
  private _relative = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelativeOutputReference(this, "relative");
  public get relative() {
    return this._relative;
  }
  public putRelative(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameRelative) {
    this._relative.internalValue = value;
  }
  public resetRelative() {
    this._relative.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relativeInput() {
    return this._relative.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetrics {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#filters Dashboard#filters}
  */
  readonly filters?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#group_names Dashboard#group_names}
  */
  readonly groupNames?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#promql_query Dashboard#promql_query}
  */
  readonly promqlQuery: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#stacked_group_name Dashboard#stacked_group_name}
  */
  readonly stackedGroupName?: string;
  /**
  * Specifies the time frame. Can be either absolute or relative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time_frame Dashboard#time_frame}
  */
  readonly timeFrame?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrame;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filters: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersToTerraform, false)(struct!.filters),
    group_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupNames),
    promql_query: cdktf.stringToTerraform(struct!.promqlQuery),
    stacked_group_name: cdktf.stringToTerraform(struct!.stackedGroupName),
    time_frame: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameToTerraform(struct!.timeFrame),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filters: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersList",
    },
    group_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    promql_query: {
      value: cdktf.stringToHclTerraform(struct!.promqlQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stacked_group_name: {
      value: cdktf.stringToHclTerraform(struct!.stackedGroupName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_frame: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameToHclTerraform(struct!.timeFrame),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrame",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._groupNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupNames = this._groupNames;
    }
    if (this._promqlQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.promqlQuery = this._promqlQuery;
    }
    if (this._stackedGroupName !== undefined) {
      hasAnyValues = true;
      internalValueResult.stackedGroupName = this._stackedGroupName;
    }
    if (this._timeFrame?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeFrame = this._timeFrame?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filters.internalValue = undefined;
      this._groupNames = undefined;
      this._promqlQuery = undefined;
      this._stackedGroupName = undefined;
      this._timeFrame.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filters.internalValue = value.filters;
      this._groupNames = value.groupNames;
      this._promqlQuery = value.promqlQuery;
      this._stackedGroupName = value.stackedGroupName;
      this._timeFrame.internalValue = value.timeFrame;
    }
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // group_names - computed: false, optional: true, required: false
  private _groupNames?: string[]; 
  public get groupNames() {
    return this.getListAttribute('group_names');
  }
  public set groupNames(value: string[]) {
    this._groupNames = value;
  }
  public resetGroupNames() {
    this._groupNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupNamesInput() {
    return this._groupNames;
  }

  // promql_query - computed: false, optional: false, required: true
  private _promqlQuery?: string; 
  public get promqlQuery() {
    return this.getStringAttribute('promql_query');
  }
  public set promqlQuery(value: string) {
    this._promqlQuery = value;
  }
  // Temporarily expose input value. Use with caution.
  public get promqlQueryInput() {
    return this._promqlQuery;
  }

  // stacked_group_name - computed: false, optional: true, required: false
  private _stackedGroupName?: string; 
  public get stackedGroupName() {
    return this.getStringAttribute('stacked_group_name');
  }
  public set stackedGroupName(value: string) {
    this._stackedGroupName = value;
  }
  public resetStackedGroupName() {
    this._stackedGroupName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stackedGroupNameInput() {
    return this._stackedGroupName;
  }

  // time_frame - computed: false, optional: true, required: false
  private _timeFrame = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrameOutputReference(this, "time_frame");
  public get timeFrame() {
    return this._timeFrame;
  }
  public putTimeFrame(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsTimeFrame) {
    this._timeFrame.internalValue = value;
  }
  public resetTimeFrame() {
    this._timeFrame.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeFrameInput() {
    return this._timeFrame.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregation {
  /**
  * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["avg" "max" "min" "percentile_50" "percentile_95" "percentile_99" "sum" "unspecified"]. When the aggregation type is `dimension`, can be one of ["error_count" "unique_count" "unspecified"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#aggregation_type Dashboard#aggregation_type}
  */
  readonly aggregationType: string;
  /**
  * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["trace_id" "unspecified"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: string;
  /**
  * Can be one of ["metric" "dimension"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregationToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregation_type: cdktf.stringToTerraform(struct!.aggregationType),
    field: cdktf.stringToTerraform(struct!.field),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregationToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregation_type: {
      value: cdktf.stringToHclTerraform(struct!.aggregationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregationType = this._aggregationType;
    }
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregationType = undefined;
      this._field = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregationType = value.aggregationType;
      this._field = value.field;
      this._type = value.type;
    }
  }

  // aggregation_type - computed: false, optional: false, required: true
  private _aggregationType?: string; 
  public get aggregationType() {
    return this.getStringAttribute('aggregation_type');
  }
  public set aggregationType(value: string) {
    this._aggregationType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregationTypeInput() {
    return this._aggregationType;
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersField {
  /**
  * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
  /**
  * The value of the field. When the field type is `metadata`, can be one of ["application_name" "operation_name" "service_name" "subsystem_name" "unspecified"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#value Dashboard#value}
  */
  readonly value: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersFieldToTerraform(struct!.field),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersFieldToHclTerraform(struct!.field),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field.internalValue = value.field;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersFieldOutputReference(this, "field");
  public get field() {
    return this._field;
  }
  public putField(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersField) {
    this._field.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNames {
  /**
  * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
  /**
  * The value of the field. When the field type is `metadata`, can be one of ["application_name" "operation_name" "service_name" "subsystem_name" "unspecified"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#value Dashboard#value}
  */
  readonly value: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNamesToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNames | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNamesToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNames | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNamesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNames | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNames | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNamesList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNames[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNamesOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNamesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupName {
  /**
  * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
  /**
  * The value of the field. When the field type is `metadata`, can be one of ["application_name" "operation_name" "service_name" "subsystem_name" "unspecified"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#value Dashboard#value}
  */
  readonly value: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupNameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupName | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupNameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupName | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupNameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupName | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupName | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsolute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end Dashboard#end}
  */
  readonly end: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start Dashboard#start}
  */
  readonly start: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsoluteToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.stringToTerraform(struct!.end),
    start: cdktf.stringToTerraform(struct!.start),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsoluteToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.stringToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.stringToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsoluteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsolute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsolute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: false, required: true
  private _end?: string; 
  public get end() {
    return this.getStringAttribute('end');
  }
  public set end(value: string) {
    this._end = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: false, required: true
  private _start?: string; 
  public get start() {
    return this.getStringAttribute('start');
  }
  public set start(value: string) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelative {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelativeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelativeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelativeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelative | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelative | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrame {
  /**
  * Absolute time frame specifying a fixed start and end time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#absolute Dashboard#absolute}
  */
  readonly absolute?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsolute;
  /**
  * Relative time frame specifying a duration from the current time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#relative Dashboard#relative}
  */
  readonly relative?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelative;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    absolute: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsoluteToTerraform(struct!.absolute),
    relative: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelativeToTerraform(struct!.relative),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    absolute: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsoluteToHclTerraform(struct!.absolute),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsolute",
    },
    relative: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelativeToHclTerraform(struct!.relative),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelative",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrame | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._absolute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.absolute = this._absolute?.internalValue;
    }
    if (this._relative?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relative = this._relative?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrame | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._absolute.internalValue = undefined;
      this._relative.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._absolute.internalValue = value.absolute;
      this._relative.internalValue = value.relative;
    }
  }

  // absolute - computed: false, optional: true, required: false
  private _absolute = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsoluteOutputReference(this, "absolute");
  public get absolute() {
    return this._absolute;
  }
  public putAbsolute(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameAbsolute) {
    this._absolute.internalValue = value;
  }
  public resetAbsolute() {
    this._absolute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get absoluteInput() {
    return this._absolute.internalValue;
  }

  // relative - computed: false, optional: true, required: false
  private _relative = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelativeOutputReference(this, "relative");
  public get relative() {
    return this._relative;
  }
  public putRelative(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameRelative) {
    this._relative.internalValue = value;
  }
  public resetRelative() {
    this._relative.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relativeInput() {
    return this._relative.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpans {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#aggregation Dashboard#aggregation}
  */
  readonly aggregation?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregation;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#filters Dashboard#filters}
  */
  readonly filters?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#group_names Dashboard#group_names}
  */
  readonly groupNames?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNames[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#lucene_query Dashboard#lucene_query}
  */
  readonly luceneQuery?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#stacked_group_name Dashboard#stacked_group_name}
  */
  readonly stackedGroupName?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupName;
  /**
  * Specifies the time frame. Can be either absolute or relative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time_frame Dashboard#time_frame}
  */
  readonly timeFrame?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrame;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregation: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregationToTerraform(struct!.aggregation),
    filters: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersToTerraform, false)(struct!.filters),
    group_names: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNamesToTerraform, false)(struct!.groupNames),
    lucene_query: cdktf.stringToTerraform(struct!.luceneQuery),
    stacked_group_name: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupNameToTerraform(struct!.stackedGroupName),
    time_frame: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameToTerraform(struct!.timeFrame),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregation: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregationToHclTerraform(struct!.aggregation),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregation",
    },
    filters: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersList",
    },
    group_names: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNamesToHclTerraform, false)(struct!.groupNames),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNamesList",
    },
    lucene_query: {
      value: cdktf.stringToHclTerraform(struct!.luceneQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stacked_group_name: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupNameToHclTerraform(struct!.stackedGroupName),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupName",
    },
    time_frame: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameToHclTerraform(struct!.timeFrame),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrame",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpans | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregation = this._aggregation?.internalValue;
    }
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._groupNames?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupNames = this._groupNames?.internalValue;
    }
    if (this._luceneQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.luceneQuery = this._luceneQuery;
    }
    if (this._stackedGroupName?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.stackedGroupName = this._stackedGroupName?.internalValue;
    }
    if (this._timeFrame?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeFrame = this._timeFrame?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpans | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregation.internalValue = undefined;
      this._filters.internalValue = undefined;
      this._groupNames.internalValue = undefined;
      this._luceneQuery = undefined;
      this._stackedGroupName.internalValue = undefined;
      this._timeFrame.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregation.internalValue = value.aggregation;
      this._filters.internalValue = value.filters;
      this._groupNames.internalValue = value.groupNames;
      this._luceneQuery = value.luceneQuery;
      this._stackedGroupName.internalValue = value.stackedGroupName;
      this._timeFrame.internalValue = value.timeFrame;
    }
  }

  // aggregation - computed: false, optional: true, required: false
  private _aggregation = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregationOutputReference(this, "aggregation");
  public get aggregation() {
    return this._aggregation;
  }
  public putAggregation(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansAggregation) {
    this._aggregation.internalValue = value;
  }
  public resetAggregation() {
    this._aggregation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregationInput() {
    return this._aggregation.internalValue;
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // group_names - computed: false, optional: true, required: false
  private _groupNames = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNamesList(this, "group_names", false);
  public get groupNames() {
    return this._groupNames;
  }
  public putGroupNames(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansGroupNames[] | cdktf.IResolvable) {
    this._groupNames.internalValue = value;
  }
  public resetGroupNames() {
    this._groupNames.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupNamesInput() {
    return this._groupNames.internalValue;
  }

  // lucene_query - computed: false, optional: true, required: false
  private _luceneQuery?: string; 
  public get luceneQuery() {
    return this.getStringAttribute('lucene_query');
  }
  public set luceneQuery(value: string) {
    this._luceneQuery = value;
  }
  public resetLuceneQuery() {
    this._luceneQuery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get luceneQueryInput() {
    return this._luceneQuery;
  }

  // stacked_group_name - computed: false, optional: true, required: false
  private _stackedGroupName = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupNameOutputReference(this, "stacked_group_name");
  public get stackedGroupName() {
    return this._stackedGroupName;
  }
  public putStackedGroupName(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansStackedGroupName) {
    this._stackedGroupName.internalValue = value;
  }
  public resetStackedGroupName() {
    this._stackedGroupName.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stackedGroupNameInput() {
    return this._stackedGroupName.internalValue;
  }

  // time_frame - computed: false, optional: true, required: false
  private _timeFrame = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrameOutputReference(this, "time_frame");
  public get timeFrame() {
    return this._timeFrame;
  }
  public putTimeFrame(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansTimeFrame) {
    this._timeFrame.internalValue = value;
  }
  public resetTimeFrame() {
    this._timeFrame.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeFrameInput() {
    return this._timeFrame.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuery {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#data_prime Dashboard#data_prime}
  */
  readonly dataPrime?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrime;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#logs Dashboard#logs}
  */
  readonly logs?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogs;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metrics Dashboard#metrics}
  */
  readonly metrics?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetrics;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#spans Dashboard#spans}
  */
  readonly spans?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpans;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuery | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data_prime: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeToTerraform(struct!.dataPrime),
    logs: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsToTerraform(struct!.logs),
    metrics: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsToTerraform(struct!.metrics),
    spans: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansToTerraform(struct!.spans),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuery | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data_prime: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeToHclTerraform(struct!.dataPrime),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrime",
    },
    logs: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsToHclTerraform(struct!.logs),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogs",
    },
    metrics: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsToHclTerraform(struct!.metrics),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetrics",
    },
    spans: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansToHclTerraform(struct!.spans),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpans",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuery | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dataPrime?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataPrime = this._dataPrime?.internalValue;
    }
    if (this._logs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logs = this._logs?.internalValue;
    }
    if (this._metrics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics?.internalValue;
    }
    if (this._spans?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spans = this._spans?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuery | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dataPrime.internalValue = undefined;
      this._logs.internalValue = undefined;
      this._metrics.internalValue = undefined;
      this._spans.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dataPrime.internalValue = value.dataPrime;
      this._logs.internalValue = value.logs;
      this._metrics.internalValue = value.metrics;
      this._spans.internalValue = value.spans;
    }
  }

  // data_prime - computed: false, optional: true, required: false
  private _dataPrime = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrimeOutputReference(this, "data_prime");
  public get dataPrime() {
    return this._dataPrime;
  }
  public putDataPrime(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryDataPrime) {
    this._dataPrime.internalValue = value;
  }
  public resetDataPrime() {
    this._dataPrime.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataPrimeInput() {
    return this._dataPrime.internalValue;
  }

  // logs - computed: false, optional: true, required: false
  private _logs = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogsOutputReference(this, "logs");
  public get logs() {
    return this._logs;
  }
  public putLogs(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryLogs) {
    this._logs.internalValue = value;
  }
  public resetLogs() {
    this._logs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logsInput() {
    return this._logs.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetricsOutputReference(this, "metrics");
  public get metrics() {
    return this._metrics;
  }
  public putMetrics(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryMetrics) {
    this._metrics.internalValue = value;
  }
  public resetMetrics() {
    this._metrics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics.internalValue;
  }

  // spans - computed: false, optional: true, required: false
  private _spans = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpansOutputReference(this, "spans");
  public get spans() {
    return this._spans;
  }
  public putSpans(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuerySpans) {
    this._spans.internalValue = value;
  }
  public resetSpans() {
    this._spans.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spansInput() {
    return this._spans.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinition {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#max_slices_per_bar Dashboard#max_slices_per_bar}
  */
  readonly maxSlicesPerBar?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#stack_name_template Dashboard#stack_name_template}
  */
  readonly stackNameTemplate?: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinitionToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_slices_per_bar: cdktf.numberToTerraform(struct!.maxSlicesPerBar),
    stack_name_template: cdktf.stringToTerraform(struct!.stackNameTemplate),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinitionToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_slices_per_bar: {
      value: cdktf.numberToHclTerraform(struct!.maxSlicesPerBar),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stack_name_template: {
      value: cdktf.stringToHclTerraform(struct!.stackNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinitionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinition | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxSlicesPerBar !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSlicesPerBar = this._maxSlicesPerBar;
    }
    if (this._stackNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.stackNameTemplate = this._stackNameTemplate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinition | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxSlicesPerBar = undefined;
      this._stackNameTemplate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxSlicesPerBar = value.maxSlicesPerBar;
      this._stackNameTemplate = value.stackNameTemplate;
    }
  }

  // max_slices_per_bar - computed: false, optional: true, required: false
  private _maxSlicesPerBar?: number; 
  public get maxSlicesPerBar() {
    return this.getNumberAttribute('max_slices_per_bar');
  }
  public set maxSlicesPerBar(value: number) {
    this._maxSlicesPerBar = value;
  }
  public resetMaxSlicesPerBar() {
    this._maxSlicesPerBar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSlicesPerBarInput() {
    return this._maxSlicesPerBar;
  }

  // stack_name_template - computed: false, optional: true, required: false
  private _stackNameTemplate?: string; 
  public get stackNameTemplate() {
    return this.getStringAttribute('stack_name_template');
  }
  public set stackNameTemplate(value: string) {
    this._stackNameTemplate = value;
  }
  public resetStackNameTemplate() {
    this._stackNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stackNameTemplateInput() {
    return this._stackNameTemplate;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTime {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#buckets_presented Dashboard#buckets_presented}
  */
  readonly bucketsPresented?: number;
  /**
  * The time interval to use for the x-axis. Valid values are in duration format, for example `1m0s` or `1h0m0s` (currently leading zeros should be added).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#interval Dashboard#interval}
  */
  readonly interval: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTimeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    buckets_presented: cdktf.numberToTerraform(struct!.bucketsPresented),
    interval: cdktf.stringToTerraform(struct!.interval),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTimeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    buckets_presented: {
      value: cdktf.numberToHclTerraform(struct!.bucketsPresented),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    interval: {
      value: cdktf.stringToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTimeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTime | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bucketsPresented !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucketsPresented = this._bucketsPresented;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTime | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bucketsPresented = undefined;
      this._interval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bucketsPresented = value.bucketsPresented;
      this._interval = value.interval;
    }
  }

  // buckets_presented - computed: false, optional: true, required: false
  private _bucketsPresented?: number; 
  public get bucketsPresented() {
    return this.getNumberAttribute('buckets_presented');
  }
  public set bucketsPresented(value: number) {
    this._bucketsPresented = value;
  }
  public resetBucketsPresented() {
    this._bucketsPresented = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketsPresentedInput() {
    return this._bucketsPresented;
  }

  // interval - computed: false, optional: false, required: true
  private _interval?: string; 
  public get interval() {
    return this.getStringAttribute('interval');
  }
  public set interval(value: string) {
    this._interval = value;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValue {
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValueToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValueToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxis {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time Dashboard#time}
  */
  readonly time?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTime;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#value Dashboard#value}
  */
  readonly value?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValue;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    time: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTimeToTerraform(struct!.time),
    value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValueToTerraform(struct!.value),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    time: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTimeToHclTerraform(struct!.time),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTime",
    },
    value: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxis | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._time?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.time = this._time?.internalValue;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxis | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._time.internalValue = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._time.internalValue = value.time;
      this._value.internalValue = value.value;
    }
  }

  // time - computed: false, optional: true, required: false
  private _time = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTimeOutputReference(this, "time");
  public get time() {
    return this._time;
  }
  public putTime(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisTime) {
    this._time.internalValue = value;
  }
  public resetTime() {
    this._time.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeInput() {
    return this._time.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionBarChart {
  /**
  * The color scheme. Can be one of classic, severity, cold, negative, green, red, blue.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#color_scheme Dashboard#color_scheme}
  */
  readonly colorScheme?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#colors_by Dashboard#colors_by}
  */
  readonly colorsBy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#data_mode_type Dashboard#data_mode_type}
  */
  readonly dataModeType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#group_name_template Dashboard#group_name_template}
  */
  readonly groupNameTemplate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#max_bars_per_chart Dashboard#max_bars_per_chart}
  */
  readonly maxBarsPerChart?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#query Dashboard#query}
  */
  readonly query?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuery;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scale_type Dashboard#scale_type}
  */
  readonly scaleType?: string;
  /**
  * The field to sort by. Can be one of name, unspecified, value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#sort_by Dashboard#sort_by}
  */
  readonly sortBy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#stack_definition Dashboard#stack_definition}
  */
  readonly stackDefinition?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinition;
  /**
  * The unit of the chart. Can be one of bytes, bytes_iec, custom, euro, euro_cents, gbytes, gibytes, kbytes, kibytes, mbytes, mibytes, microseconds, milliseconds, nanoseconds, percent01, percent100, seconds, unspecified, usd, usd_cents.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#unit Dashboard#unit}
  */
  readonly unit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#xaxis Dashboard#xaxis}
  */
  readonly xaxis?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxis;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChart | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    color_scheme: cdktf.stringToTerraform(struct!.colorScheme),
    colors_by: cdktf.stringToTerraform(struct!.colorsBy),
    data_mode_type: cdktf.stringToTerraform(struct!.dataModeType),
    group_name_template: cdktf.stringToTerraform(struct!.groupNameTemplate),
    max_bars_per_chart: cdktf.numberToTerraform(struct!.maxBarsPerChart),
    query: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryToTerraform(struct!.query),
    scale_type: cdktf.stringToTerraform(struct!.scaleType),
    sort_by: cdktf.stringToTerraform(struct!.sortBy),
    stack_definition: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinitionToTerraform(struct!.stackDefinition),
    unit: cdktf.stringToTerraform(struct!.unit),
    xaxis: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisToTerraform(struct!.xaxis),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionBarChartToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionBarChart | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    color_scheme: {
      value: cdktf.stringToHclTerraform(struct!.colorScheme),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    colors_by: {
      value: cdktf.stringToHclTerraform(struct!.colorsBy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    data_mode_type: {
      value: cdktf.stringToHclTerraform(struct!.dataModeType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_name_template: {
      value: cdktf.stringToHclTerraform(struct!.groupNameTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_bars_per_chart: {
      value: cdktf.numberToHclTerraform(struct!.maxBarsPerChart),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    query: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryToHclTerraform(struct!.query),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuery",
    },
    scale_type: {
      value: cdktf.stringToHclTerraform(struct!.scaleType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sort_by: {
      value: cdktf.stringToHclTerraform(struct!.sortBy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stack_definition: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinitionToHclTerraform(struct!.stackDefinition),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinition",
    },
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    xaxis: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisToHclTerraform(struct!.xaxis),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxis",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionBarChartOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionBarChart | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._colorScheme !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorScheme = this._colorScheme;
    }
    if (this._colorsBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorsBy = this._colorsBy;
    }
    if (this._dataModeType !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataModeType = this._dataModeType;
    }
    if (this._groupNameTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupNameTemplate = this._groupNameTemplate;
    }
    if (this._maxBarsPerChart !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBarsPerChart = this._maxBarsPerChart;
    }
    if (this._query?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query?.internalValue;
    }
    if (this._scaleType !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleType = this._scaleType;
    }
    if (this._sortBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.sortBy = this._sortBy;
    }
    if (this._stackDefinition?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.stackDefinition = this._stackDefinition?.internalValue;
    }
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    if (this._xaxis?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.xaxis = this._xaxis?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChart | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._colorScheme = undefined;
      this._colorsBy = undefined;
      this._dataModeType = undefined;
      this._groupNameTemplate = undefined;
      this._maxBarsPerChart = undefined;
      this._query.internalValue = undefined;
      this._scaleType = undefined;
      this._sortBy = undefined;
      this._stackDefinition.internalValue = undefined;
      this._unit = undefined;
      this._xaxis.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._colorScheme = value.colorScheme;
      this._colorsBy = value.colorsBy;
      this._dataModeType = value.dataModeType;
      this._groupNameTemplate = value.groupNameTemplate;
      this._maxBarsPerChart = value.maxBarsPerChart;
      this._query.internalValue = value.query;
      this._scaleType = value.scaleType;
      this._sortBy = value.sortBy;
      this._stackDefinition.internalValue = value.stackDefinition;
      this._unit = value.unit;
      this._xaxis.internalValue = value.xaxis;
    }
  }

  // color_scheme - computed: false, optional: true, required: false
  private _colorScheme?: string; 
  public get colorScheme() {
    return this.getStringAttribute('color_scheme');
  }
  public set colorScheme(value: string) {
    this._colorScheme = value;
  }
  public resetColorScheme() {
    this._colorScheme = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorSchemeInput() {
    return this._colorScheme;
  }

  // colors_by - computed: false, optional: true, required: false
  private _colorsBy?: string; 
  public get colorsBy() {
    return this.getStringAttribute('colors_by');
  }
  public set colorsBy(value: string) {
    this._colorsBy = value;
  }
  public resetColorsBy() {
    this._colorsBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorsByInput() {
    return this._colorsBy;
  }

  // data_mode_type - computed: true, optional: true, required: false
  private _dataModeType?: string; 
  public get dataModeType() {
    return this.getStringAttribute('data_mode_type');
  }
  public set dataModeType(value: string) {
    this._dataModeType = value;
  }
  public resetDataModeType() {
    this._dataModeType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataModeTypeInput() {
    return this._dataModeType;
  }

  // group_name_template - computed: false, optional: true, required: false
  private _groupNameTemplate?: string; 
  public get groupNameTemplate() {
    return this.getStringAttribute('group_name_template');
  }
  public set groupNameTemplate(value: string) {
    this._groupNameTemplate = value;
  }
  public resetGroupNameTemplate() {
    this._groupNameTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupNameTemplateInput() {
    return this._groupNameTemplate;
  }

  // max_bars_per_chart - computed: false, optional: true, required: false
  private _maxBarsPerChart?: number; 
  public get maxBarsPerChart() {
    return this.getNumberAttribute('max_bars_per_chart');
  }
  public set maxBarsPerChart(value: number) {
    this._maxBarsPerChart = value;
  }
  public resetMaxBarsPerChart() {
    this._maxBarsPerChart = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBarsPerChartInput() {
    return this._maxBarsPerChart;
  }

  // query - computed: false, optional: true, required: false
  private _query = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQueryOutputReference(this, "query");
  public get query() {
    return this._query;
  }
  public putQuery(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartQuery) {
    this._query.internalValue = value;
  }
  public resetQuery() {
    this._query.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query.internalValue;
  }

  // scale_type - computed: true, optional: true, required: false
  private _scaleType?: string; 
  public get scaleType() {
    return this.getStringAttribute('scale_type');
  }
  public set scaleType(value: string) {
    this._scaleType = value;
  }
  public resetScaleType() {
    this._scaleType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleTypeInput() {
    return this._scaleType;
  }

  // sort_by - computed: true, optional: true, required: false
  private _sortBy?: string; 
  public get sortBy() {
    return this.getStringAttribute('sort_by');
  }
  public set sortBy(value: string) {
    this._sortBy = value;
  }
  public resetSortBy() {
    this._sortBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sortByInput() {
    return this._sortBy;
  }

  // stack_definition - computed: false, optional: true, required: false
  private _stackDefinition = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinitionOutputReference(this, "stack_definition");
  public get stackDefinition() {
    return this._stackDefinition;
  }
  public putStackDefinition(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartStackDefinition) {
    this._stackDefinition.internalValue = value;
  }
  public resetStackDefinition() {
    this._stackDefinition.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stackDefinitionInput() {
    return this._stackDefinition.internalValue;
  }

  // unit - computed: true, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }

  // xaxis - computed: false, optional: true, required: false
  private _xaxis = new DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxisOutputReference(this, "xaxis");
  public get xaxis() {
    return this._xaxis;
  }
  public putXaxis(value: DashboardLayoutSectionsRowsWidgetsDefinitionBarChartXaxis) {
    this._xaxis.internalValue = value;
  }
  public resetXaxis() {
    this._xaxis.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xaxisInput() {
    return this._xaxis.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumns {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#width Dashboard#width}
  */
  readonly width?: number;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumnsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    width: cdktf.numberToTerraform(struct!.width),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumnsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    width: {
      value: cdktf.numberToHclTerraform(struct!.width),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._width !== undefined) {
      hasAnyValues = true;
      internalValueResult.width = this._width;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._width = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._width = value.width;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // width - computed: true, optional: true, required: false
  private _width?: number; 
  public get width() {
    return this.getNumberAttribute('width');
  }
  public set width(value: number) {
    this._width = value;
  }
  public resetWidth() {
    this._width = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get widthInput() {
    return this._width;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumnsList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumns[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumnsOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumnsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderBy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field?: string;
  /**
  * The order direction. Can be one of ["asc" "desc" "unspecified"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#order_direction Dashboard#order_direction}
  */
  readonly orderDirection?: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderByToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderBy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    order_direction: cdktf.stringToTerraform(struct!.orderDirection),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderByToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderBy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    order_direction: {
      value: cdktf.stringToHclTerraform(struct!.orderDirection),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderByOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderBy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._orderDirection !== undefined) {
      hasAnyValues = true;
      internalValueResult.orderDirection = this._orderDirection;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderBy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._orderDirection = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._orderDirection = value.orderDirection;
    }
  }

  // field - computed: false, optional: true, required: false
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  public resetField() {
    this._field = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // order_direction - computed: true, optional: true, required: false
  private _orderDirection?: string; 
  public get orderDirection() {
    return this.getStringAttribute('order_direction');
  }
  public set orderDirection(value: string) {
    this._orderDirection = value;
  }
  public resetOrderDirection() {
    this._orderDirection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orderDirectionInput() {
    return this._orderDirection;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogs {
  /**
  * Field in the logs to apply the filter on.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#observation_field Dashboard#observation_field}
  */
  readonly observationField?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    observation_field: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationFieldToTerraform(struct!.observationField),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    observation_field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationFieldToHclTerraform(struct!.observationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._observationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.observationField = this._observationField?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._observationField.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._observationField.internalValue = value.observationField;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // observation_field - computed: false, optional: true, required: false
  private _observationField = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationFieldOutputReference(this, "observation_field");
  public get observationField() {
    return this._observationField;
  }
  public putObservationField(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsObservationField) {
    this._observationField.internalValue = value;
  }
  public resetObservationField() {
    this._observationField.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get observationFieldInput() {
    return this._observationField.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetrics {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#label Dashboard#label}
  */
  readonly label?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metric_name Dashboard#metric_name}
  */
  readonly metricName?: string;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    metric_name: cdktf.stringToTerraform(struct!.metricName),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric_name: {
      value: cdktf.stringToHclTerraform(struct!.metricName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._metricName !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricName = this._metricName;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._metricName = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._metricName = value.metricName;
      this._operator.internalValue = value.operator;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // metric_name - computed: false, optional: true, required: false
  private _metricName?: string; 
  public get metricName() {
    return this.getStringAttribute('metric_name');
  }
  public set metricName(value: string) {
    this._metricName = value;
  }
  public resetMetricName() {
    this._metricName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricNameInput() {
    return this._metricName;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansField {
  /**
  * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
  /**
  * The value of the field. When the field type is `metadata`, can be one of ["application_name" "operation_name" "service_name" "subsystem_name" "unspecified"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#value Dashboard#value}
  */
  readonly value: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpans {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansFieldToTerraform(struct!.field),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansFieldToHclTerraform(struct!.field),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpans | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpans | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field.internalValue = value.field;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansFieldOutputReference(this, "field");
  public get field() {
    return this._field;
  }
  public putField(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansField) {
    this._field.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#logs Dashboard#logs}
  */
  readonly logs?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogs;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metrics Dashboard#metrics}
  */
  readonly metrics?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetrics;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#spans Dashboard#spans}
  */
  readonly spans?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpans;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    logs: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsToTerraform(struct!.logs),
    metrics: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsToTerraform(struct!.metrics),
    spans: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansToTerraform(struct!.spans),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    logs: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsToHclTerraform(struct!.logs),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogs",
    },
    metrics: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsToHclTerraform(struct!.metrics),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetrics",
    },
    spans: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansToHclTerraform(struct!.spans),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpans",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._logs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logs = this._logs?.internalValue;
    }
    if (this._metrics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics?.internalValue;
    }
    if (this._spans?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spans = this._spans?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._logs.internalValue = undefined;
      this._metrics.internalValue = undefined;
      this._spans.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._logs.internalValue = value.logs;
      this._metrics.internalValue = value.metrics;
      this._spans.internalValue = value.spans;
    }
  }

  // logs - computed: false, optional: true, required: false
  private _logs = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogsOutputReference(this, "logs");
  public get logs() {
    return this._logs;
  }
  public putLogs(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersLogs) {
    this._logs.internalValue = value;
  }
  public resetLogs() {
    this._logs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logsInput() {
    return this._logs.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetricsOutputReference(this, "metrics");
  public get metrics() {
    return this._metrics;
  }
  public putMetrics(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersMetrics) {
    this._metrics.internalValue = value;
  }
  public resetMetrics() {
    this._metrics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics.internalValue;
  }

  // spans - computed: false, optional: true, required: false
  private _spans = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpansOutputReference(this, "spans");
  public get spans() {
    return this._spans;
  }
  public putSpans(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersSpans) {
    this._spans.internalValue = value;
  }
  public resetSpans() {
    this._spans.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spansInput() {
    return this._spans.internalValue;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsolute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end Dashboard#end}
  */
  readonly end: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start Dashboard#start}
  */
  readonly start: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsoluteToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.stringToTerraform(struct!.end),
    start: cdktf.stringToTerraform(struct!.start),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsoluteToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.stringToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.stringToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsoluteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsolute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsolute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: false, required: true
  private _end?: string; 
  public get end() {
    return this.getStringAttribute('end');
  }
  public set end(value: string) {
    this._end = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: false, required: true
  private _start?: string; 
  public get start() {
    return this.getStringAttribute('start');
  }
  public set start(value: string) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelative {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelativeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelativeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelativeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelative | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelative | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrame {
  /**
  * Absolute time frame specifying a fixed start and end time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#absolute Dashboard#absolute}
  */
  readonly absolute?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsolute;
  /**
  * Relative time frame specifying a duration from the current time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#relative Dashboard#relative}
  */
  readonly relative?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelative;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    absolute: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsoluteToTerraform(struct!.absolute),
    relative: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelativeToTerraform(struct!.relative),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    absolute: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsoluteToHclTerraform(struct!.absolute),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsolute",
    },
    relative: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelativeToHclTerraform(struct!.relative),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelative",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrame | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._absolute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.absolute = this._absolute?.internalValue;
    }
    if (this._relative?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relative = this._relative?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrame | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._absolute.internalValue = undefined;
      this._relative.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._absolute.internalValue = value.absolute;
      this._relative.internalValue = value.relative;
    }
  }

  // absolute - computed: false, optional: true, required: false
  private _absolute = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsoluteOutputReference(this, "absolute");
  public get absolute() {
    return this._absolute;
  }
  public putAbsolute(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameAbsolute) {
    this._absolute.internalValue = value;
  }
  public resetAbsolute() {
    this._absolute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get absoluteInput() {
    return this._absolute.internalValue;
  }

  // relative - computed: false, optional: true, required: false
  private _relative = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelativeOutputReference(this, "relative");
  public get relative() {
    return this._relative;
  }
  public putRelative(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameRelative) {
    this._relative.internalValue = value;
  }
  public resetRelative() {
    this._relative.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relativeInput() {
    return this._relative.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrime {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#filters Dashboard#filters}
  */
  readonly filters?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#query Dashboard#query}
  */
  readonly query?: string;
  /**
  * Specifies the time frame. Can be either absolute or relative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time_frame Dashboard#time_frame}
  */
  readonly timeFrame?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrame;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filters: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersToTerraform, false)(struct!.filters),
    query: cdktf.stringToTerraform(struct!.query),
    time_frame: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameToTerraform(struct!.timeFrame),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filters: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersList",
    },
    query: {
      value: cdktf.stringToHclTerraform(struct!.query),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_frame: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameToHclTerraform(struct!.timeFrame),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrame",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrime | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._query !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query;
    }
    if (this._timeFrame?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeFrame = this._timeFrame?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrime | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filters.internalValue = undefined;
      this._query = undefined;
      this._timeFrame.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filters.internalValue = value.filters;
      this._query = value.query;
      this._timeFrame.internalValue = value.timeFrame;
    }
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // query - computed: false, optional: true, required: false
  private _query?: string; 
  public get query() {
    return this.getStringAttribute('query');
  }
  public set query(value: string) {
    this._query = value;
  }
  public resetQuery() {
    this._query = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query;
  }

  // time_frame - computed: false, optional: true, required: false
  private _timeFrame = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrameOutputReference(this, "time_frame");
  public get timeFrame() {
    return this._timeFrame;
  }
  public putTimeFrame(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeTimeFrame) {
    this._timeFrame.internalValue = value;
  }
  public resetTimeFrame() {
    this._timeFrame.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeFrameInput() {
    return this._timeFrame.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#observation_field Dashboard#observation_field}
  */
  readonly observationField?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    observation_field: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationFieldToTerraform(struct!.observationField),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    observation_field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationFieldToHclTerraform(struct!.observationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._observationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.observationField = this._observationField?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._observationField.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._observationField.internalValue = value.observationField;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // observation_field - computed: false, optional: true, required: false
  private _observationField = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationFieldOutputReference(this, "observation_field");
  public get observationField() {
    return this._observationField;
  }
  public putObservationField(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersObservationField) {
    this._observationField.internalValue = value;
  }
  public resetObservationField() {
    this._observationField.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get observationFieldInput() {
    return this._observationField.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#observation_field Dashboard#observation_field}
  */
  readonly observationField?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationField;
  /**
  * The percentage of the aggregation to return. required when type is `percentile`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#percent Dashboard#percent}
  */
  readonly percent?: number;
  /**
  * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    observation_field: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationFieldToTerraform(struct!.observationField),
    percent: cdktf.numberToTerraform(struct!.percent),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    observation_field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationFieldToHclTerraform(struct!.observationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationField",
    },
    percent: {
      value: cdktf.numberToHclTerraform(struct!.percent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._observationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.observationField = this._observationField?.internalValue;
    }
    if (this._percent !== undefined) {
      hasAnyValues = true;
      internalValueResult.percent = this._percent;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._observationField.internalValue = undefined;
      this._percent = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._observationField.internalValue = value.observationField;
      this._percent = value.percent;
      this._type = value.type;
    }
  }

  // field - computed: false, optional: true, required: false
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  public resetField() {
    this._field = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // observation_field - computed: false, optional: true, required: false
  private _observationField = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationFieldOutputReference(this, "observation_field");
  public get observationField() {
    return this._observationField;
  }
  public putObservationField(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationObservationField) {
    this._observationField.internalValue = value;
  }
  public resetObservationField() {
    this._observationField.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get observationFieldInput() {
    return this._observationField.internalValue;
  }

  // percent - computed: false, optional: true, required: false
  private _percent?: number; 
  public get percent() {
    return this.getNumberAttribute('percent');
  }
  public set percent(value: number) {
    this._percent = value;
  }
  public resetPercent() {
    this._percent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentInput() {
    return this._percent;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#aggregation Dashboard#aggregation}
  */
  readonly aggregation: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregation;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#id Dashboard#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#is_visible Dashboard#is_visible}
  */
  readonly isVisible?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#name Dashboard#name}
  */
  readonly name?: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregation: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationToTerraform(struct!.aggregation),
    id: cdktf.stringToTerraform(struct!.id),
    is_visible: cdktf.booleanToTerraform(struct!.isVisible),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregation: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationToHclTerraform(struct!.aggregation),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregation",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    is_visible: {
      value: cdktf.booleanToHclTerraform(struct!.isVisible),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregation = this._aggregation?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._isVisible !== undefined) {
      hasAnyValues = true;
      internalValueResult.isVisible = this._isVisible;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregation.internalValue = undefined;
      this._id = undefined;
      this._isVisible = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregation.internalValue = value.aggregation;
      this._id = value.id;
      this._isVisible = value.isVisible;
      this._name = value.name;
    }
  }

  // aggregation - computed: false, optional: false, required: true
  private _aggregation = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregationOutputReference(this, "aggregation");
  public get aggregation() {
    return this._aggregation;
  }
  public putAggregation(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsAggregation) {
    this._aggregation.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregationInput() {
    return this._aggregation.internalValue;
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // is_visible - computed: true, optional: true, required: false
  private _isVisible?: boolean | cdktf.IResolvable; 
  public get isVisible() {
    return this.getBooleanAttribute('is_visible');
  }
  public set isVisible(value: boolean | cdktf.IResolvable) {
    this._isVisible = value;
  }
  public resetIsVisible() {
    this._isVisible = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isVisibleInput() {
    return this._isVisible;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBysToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBysToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBysList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBys[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBysOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBysOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGrouping {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#aggregations Dashboard#aggregations}
  */
  readonly aggregations?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregations[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#group_bys Dashboard#group_bys}
  */
  readonly groupBys?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBys[] | cdktf.IResolvable;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGrouping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregations: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsToTerraform, false)(struct!.aggregations),
    group_bys: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBysToTerraform, false)(struct!.groupBys),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGrouping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregations: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsToHclTerraform, false)(struct!.aggregations),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsList",
    },
    group_bys: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBysToHclTerraform, false)(struct!.groupBys),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBysList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGrouping | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregations = this._aggregations?.internalValue;
    }
    if (this._groupBys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupBys = this._groupBys?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGrouping | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregations.internalValue = undefined;
      this._groupBys.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregations.internalValue = value.aggregations;
      this._groupBys.internalValue = value.groupBys;
    }
  }

  // aggregations - computed: false, optional: true, required: false
  private _aggregations = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregationsList(this, "aggregations", false);
  public get aggregations() {
    return this._aggregations;
  }
  public putAggregations(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingAggregations[] | cdktf.IResolvable) {
    this._aggregations.internalValue = value;
  }
  public resetAggregations() {
    this._aggregations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregationsInput() {
    return this._aggregations.internalValue;
  }

  // group_bys - computed: false, optional: true, required: false
  private _groupBys = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBysList(this, "group_bys", false);
  public get groupBys() {
    return this._groupBys;
  }
  public putGroupBys(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingGroupBys[] | cdktf.IResolvable) {
    this._groupBys.internalValue = value;
  }
  public resetGroupBys() {
    this._groupBys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupBysInput() {
    return this._groupBys.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsolute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end Dashboard#end}
  */
  readonly end: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start Dashboard#start}
  */
  readonly start: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsoluteToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.stringToTerraform(struct!.end),
    start: cdktf.stringToTerraform(struct!.start),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsoluteToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.stringToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.stringToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsoluteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsolute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsolute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: false, required: true
  private _end?: string; 
  public get end() {
    return this.getStringAttribute('end');
  }
  public set end(value: string) {
    this._end = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: false, required: true
  private _start?: string; 
  public get start() {
    return this.getStringAttribute('start');
  }
  public set start(value: string) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelative {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelativeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelativeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelativeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelative | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelative | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrame {
  /**
  * Absolute time frame specifying a fixed start and end time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#absolute Dashboard#absolute}
  */
  readonly absolute?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsolute;
  /**
  * Relative time frame specifying a duration from the current time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#relative Dashboard#relative}
  */
  readonly relative?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelative;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    absolute: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsoluteToTerraform(struct!.absolute),
    relative: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelativeToTerraform(struct!.relative),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    absolute: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsoluteToHclTerraform(struct!.absolute),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsolute",
    },
    relative: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelativeToHclTerraform(struct!.relative),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelative",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrame | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._absolute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.absolute = this._absolute?.internalValue;
    }
    if (this._relative?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relative = this._relative?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrame | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._absolute.internalValue = undefined;
      this._relative.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._absolute.internalValue = value.absolute;
      this._relative.internalValue = value.relative;
    }
  }

  // absolute - computed: false, optional: true, required: false
  private _absolute = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsoluteOutputReference(this, "absolute");
  public get absolute() {
    return this._absolute;
  }
  public putAbsolute(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameAbsolute) {
    this._absolute.internalValue = value;
  }
  public resetAbsolute() {
    this._absolute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get absoluteInput() {
    return this._absolute.internalValue;
  }

  // relative - computed: false, optional: true, required: false
  private _relative = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelativeOutputReference(this, "relative");
  public get relative() {
    return this._relative;
  }
  public putRelative(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameRelative) {
    this._relative.internalValue = value;
  }
  public resetRelative() {
    this._relative.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relativeInput() {
    return this._relative.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#filters Dashboard#filters}
  */
  readonly filters?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#grouping Dashboard#grouping}
  */
  readonly grouping?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGrouping;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#lucene_query Dashboard#lucene_query}
  */
  readonly luceneQuery?: string;
  /**
  * Specifies the time frame. Can be either absolute or relative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time_frame Dashboard#time_frame}
  */
  readonly timeFrame?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrame;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filters: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersToTerraform, false)(struct!.filters),
    grouping: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingToTerraform(struct!.grouping),
    lucene_query: cdktf.stringToTerraform(struct!.luceneQuery),
    time_frame: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameToTerraform(struct!.timeFrame),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filters: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersList",
    },
    grouping: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingToHclTerraform(struct!.grouping),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGrouping",
    },
    lucene_query: {
      value: cdktf.stringToHclTerraform(struct!.luceneQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_frame: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameToHclTerraform(struct!.timeFrame),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrame",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._grouping?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grouping = this._grouping?.internalValue;
    }
    if (this._luceneQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.luceneQuery = this._luceneQuery;
    }
    if (this._timeFrame?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeFrame = this._timeFrame?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filters.internalValue = undefined;
      this._grouping.internalValue = undefined;
      this._luceneQuery = undefined;
      this._timeFrame.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filters.internalValue = value.filters;
      this._grouping.internalValue = value.grouping;
      this._luceneQuery = value.luceneQuery;
      this._timeFrame.internalValue = value.timeFrame;
    }
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // grouping - computed: false, optional: true, required: false
  private _grouping = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGroupingOutputReference(this, "grouping");
  public get grouping() {
    return this._grouping;
  }
  public putGrouping(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsGrouping) {
    this._grouping.internalValue = value;
  }
  public resetGrouping() {
    this._grouping.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupingInput() {
    return this._grouping.internalValue;
  }

  // lucene_query - computed: false, optional: true, required: false
  private _luceneQuery?: string; 
  public get luceneQuery() {
    return this.getStringAttribute('lucene_query');
  }
  public set luceneQuery(value: string) {
    this._luceneQuery = value;
  }
  public resetLuceneQuery() {
    this._luceneQuery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get luceneQueryInput() {
    return this._luceneQuery;
  }

  // time_frame - computed: false, optional: true, required: false
  private _timeFrame = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrameOutputReference(this, "time_frame");
  public get timeFrame() {
    return this._timeFrame;
  }
  public putTimeFrame(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsTimeFrame) {
    this._timeFrame.internalValue = value;
  }
  public resetTimeFrame() {
    this._timeFrame.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeFrameInput() {
    return this._timeFrame.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFilters {
  /**
  * Label associated with the metric.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#label Dashboard#label}
  */
  readonly label?: string;
  /**
  * Metric name to apply the filter on.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metric Dashboard#metric}
  */
  readonly metric: string;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    metric: cdktf.stringToTerraform(struct!.metric),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.stringToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._metric = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._metric = value.metric;
      this._operator.internalValue = value.operator;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // metric - computed: false, optional: false, required: true
  private _metric?: string; 
  public get metric() {
    return this.getStringAttribute('metric');
  }
  public set metric(value: string) {
    this._metric = value;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsolute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end Dashboard#end}
  */
  readonly end: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start Dashboard#start}
  */
  readonly start: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsoluteToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.stringToTerraform(struct!.end),
    start: cdktf.stringToTerraform(struct!.start),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsoluteToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.stringToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.stringToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsoluteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsolute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsolute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: false, required: true
  private _end?: string; 
  public get end() {
    return this.getStringAttribute('end');
  }
  public set end(value: string) {
    this._end = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: false, required: true
  private _start?: string; 
  public get start() {
    return this.getStringAttribute('start');
  }
  public set start(value: string) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelative {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelativeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelativeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelativeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelative | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelative | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrame {
  /**
  * Absolute time frame specifying a fixed start and end time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#absolute Dashboard#absolute}
  */
  readonly absolute?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsolute;
  /**
  * Relative time frame specifying a duration from the current time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#relative Dashboard#relative}
  */
  readonly relative?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelative;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    absolute: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsoluteToTerraform(struct!.absolute),
    relative: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelativeToTerraform(struct!.relative),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    absolute: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsoluteToHclTerraform(struct!.absolute),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsolute",
    },
    relative: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelativeToHclTerraform(struct!.relative),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelative",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrame | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._absolute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.absolute = this._absolute?.internalValue;
    }
    if (this._relative?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relative = this._relative?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrame | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._absolute.internalValue = undefined;
      this._relative.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._absolute.internalValue = value.absolute;
      this._relative.internalValue = value.relative;
    }
  }

  // absolute - computed: false, optional: true, required: false
  private _absolute = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsoluteOutputReference(this, "absolute");
  public get absolute() {
    return this._absolute;
  }
  public putAbsolute(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameAbsolute) {
    this._absolute.internalValue = value;
  }
  public resetAbsolute() {
    this._absolute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get absoluteInput() {
    return this._absolute.internalValue;
  }

  // relative - computed: false, optional: true, required: false
  private _relative = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelativeOutputReference(this, "relative");
  public get relative() {
    return this._relative;
  }
  public putRelative(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameRelative) {
    this._relative.internalValue = value;
  }
  public resetRelative() {
    this._relative.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relativeInput() {
    return this._relative.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetrics {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#filters Dashboard#filters}
  */
  readonly filters?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#promql_query Dashboard#promql_query}
  */
  readonly promqlQuery: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#promql_query_type Dashboard#promql_query_type}
  */
  readonly promqlQueryType?: string;
  /**
  * Specifies the time frame. Can be either absolute or relative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time_frame Dashboard#time_frame}
  */
  readonly timeFrame?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrame;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filters: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersToTerraform, false)(struct!.filters),
    promql_query: cdktf.stringToTerraform(struct!.promqlQuery),
    promql_query_type: cdktf.stringToTerraform(struct!.promqlQueryType),
    time_frame: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameToTerraform(struct!.timeFrame),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filters: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersList",
    },
    promql_query: {
      value: cdktf.stringToHclTerraform(struct!.promqlQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    promql_query_type: {
      value: cdktf.stringToHclTerraform(struct!.promqlQueryType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_frame: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameToHclTerraform(struct!.timeFrame),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrame",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._promqlQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.promqlQuery = this._promqlQuery;
    }
    if (this._promqlQueryType !== undefined) {
      hasAnyValues = true;
      internalValueResult.promqlQueryType = this._promqlQueryType;
    }
    if (this._timeFrame?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeFrame = this._timeFrame?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filters.internalValue = undefined;
      this._promqlQuery = undefined;
      this._promqlQueryType = undefined;
      this._timeFrame.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filters.internalValue = value.filters;
      this._promqlQuery = value.promqlQuery;
      this._promqlQueryType = value.promqlQueryType;
      this._timeFrame.internalValue = value.timeFrame;
    }
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // promql_query - computed: false, optional: false, required: true
  private _promqlQuery?: string; 
  public get promqlQuery() {
    return this.getStringAttribute('promql_query');
  }
  public set promqlQuery(value: string) {
    this._promqlQuery = value;
  }
  // Temporarily expose input value. Use with caution.
  public get promqlQueryInput() {
    return this._promqlQuery;
  }

  // promql_query_type - computed: true, optional: true, required: false
  private _promqlQueryType?: string; 
  public get promqlQueryType() {
    return this.getStringAttribute('promql_query_type');
  }
  public set promqlQueryType(value: string) {
    this._promqlQueryType = value;
  }
  public resetPromqlQueryType() {
    this._promqlQueryType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get promqlQueryTypeInput() {
    return this._promqlQueryType;
  }

  // time_frame - computed: false, optional: true, required: false
  private _timeFrame = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrameOutputReference(this, "time_frame");
  public get timeFrame() {
    return this._timeFrame;
  }
  public putTimeFrame(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsTimeFrame) {
    this._timeFrame.internalValue = value;
  }
  public resetTimeFrame() {
    this._timeFrame.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeFrameInput() {
    return this._timeFrame.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersField {
  /**
  * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
  /**
  * The value of the field. When the field type is `metadata`, can be one of ["application_name" "operation_name" "service_name" "subsystem_name" "unspecified"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#value Dashboard#value}
  */
  readonly value: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersFieldToTerraform(struct!.field),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersFieldToHclTerraform(struct!.field),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field.internalValue = value.field;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersFieldOutputReference(this, "field");
  public get field() {
    return this._field;
  }
  public putField(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersField) {
    this._field.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregation {
  /**
  * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["avg" "max" "min" "percentile_50" "percentile_95" "percentile_99" "sum" "unspecified"]. When the aggregation type is `dimension`, can be one of ["error_count" "unique_count" "unspecified"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#aggregation_type Dashboard#aggregation_type}
  */
  readonly aggregationType: string;
  /**
  * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["trace_id" "unspecified"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: string;
  /**
  * Can be one of ["metric" "dimension"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregationToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregation_type: cdktf.stringToTerraform(struct!.aggregationType),
    field: cdktf.stringToTerraform(struct!.field),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregationToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregation_type: {
      value: cdktf.stringToHclTerraform(struct!.aggregationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregationType = this._aggregationType;
    }
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregationType = undefined;
      this._field = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregationType = value.aggregationType;
      this._field = value.field;
      this._type = value.type;
    }
  }

  // aggregation_type - computed: false, optional: false, required: true
  private _aggregationType?: string; 
  public get aggregationType() {
    return this.getStringAttribute('aggregation_type');
  }
  public set aggregationType(value: string) {
    this._aggregationType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregationTypeInput() {
    return this._aggregationType;
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#aggregation Dashboard#aggregation}
  */
  readonly aggregation?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregation;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#is_visible Dashboard#is_visible}
  */
  readonly isVisible?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#name Dashboard#name}
  */
  readonly name?: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregation: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregationToTerraform(struct!.aggregation),
    is_visible: cdktf.booleanToTerraform(struct!.isVisible),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregation: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregationToHclTerraform(struct!.aggregation),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregation",
    },
    is_visible: {
      value: cdktf.booleanToHclTerraform(struct!.isVisible),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregation = this._aggregation?.internalValue;
    }
    if (this._isVisible !== undefined) {
      hasAnyValues = true;
      internalValueResult.isVisible = this._isVisible;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregation.internalValue = undefined;
      this._isVisible = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregation.internalValue = value.aggregation;
      this._isVisible = value.isVisible;
      this._name = value.name;
    }
  }

  // aggregation - computed: false, optional: true, required: false
  private _aggregation = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregationOutputReference(this, "aggregation");
  public get aggregation() {
    return this._aggregation;
  }
  public putAggregation(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsAggregation) {
    this._aggregation.internalValue = value;
  }
  public resetAggregation() {
    this._aggregation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregationInput() {
    return this._aggregation.internalValue;
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // is_visible - computed: true, optional: true, required: false
  private _isVisible?: boolean | cdktf.IResolvable; 
  public get isVisible() {
    return this.getBooleanAttribute('is_visible');
  }
  public set isVisible(value: boolean | cdktf.IResolvable) {
    this._isVisible = value;
  }
  public resetIsVisible() {
    this._isVisible = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isVisibleInput() {
    return this._isVisible;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupBy {
  /**
  * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
  /**
  * The value of the field. When the field type is `metadata`, can be one of ["application_name" "operation_name" "service_name" "subsystem_name" "unspecified"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#value Dashboard#value}
  */
  readonly value: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupByToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupBy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupByToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupBy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupByOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupBy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupBy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupByList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupBy[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupByOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupByOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGrouping {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#aggregations Dashboard#aggregations}
  */
  readonly aggregations?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregations[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#group_by Dashboard#group_by}
  */
  readonly groupBy?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupBy[] | cdktf.IResolvable;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGrouping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregations: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsToTerraform, false)(struct!.aggregations),
    group_by: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupByToTerraform, false)(struct!.groupBy),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGrouping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregations: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsToHclTerraform, false)(struct!.aggregations),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsList",
    },
    group_by: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupByToHclTerraform, false)(struct!.groupBy),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupByList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGrouping | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregations = this._aggregations?.internalValue;
    }
    if (this._groupBy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupBy = this._groupBy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGrouping | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregations.internalValue = undefined;
      this._groupBy.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregations.internalValue = value.aggregations;
      this._groupBy.internalValue = value.groupBy;
    }
  }

  // aggregations - computed: false, optional: true, required: false
  private _aggregations = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregationsList(this, "aggregations", false);
  public get aggregations() {
    return this._aggregations;
  }
  public putAggregations(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingAggregations[] | cdktf.IResolvable) {
    this._aggregations.internalValue = value;
  }
  public resetAggregations() {
    this._aggregations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregationsInput() {
    return this._aggregations.internalValue;
  }

  // group_by - computed: false, optional: true, required: false
  private _groupBy = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupByList(this, "group_by", false);
  public get groupBy() {
    return this._groupBy;
  }
  public putGroupBy(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingGroupBy[] | cdktf.IResolvable) {
    this._groupBy.internalValue = value;
  }
  public resetGroupBy() {
    this._groupBy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupByInput() {
    return this._groupBy.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsolute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end Dashboard#end}
  */
  readonly end: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start Dashboard#start}
  */
  readonly start: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsoluteToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.stringToTerraform(struct!.end),
    start: cdktf.stringToTerraform(struct!.start),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsoluteToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.stringToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.stringToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsoluteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsolute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsolute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: false, required: true
  private _end?: string; 
  public get end() {
    return this.getStringAttribute('end');
  }
  public set end(value: string) {
    this._end = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: false, required: true
  private _start?: string; 
  public get start() {
    return this.getStringAttribute('start');
  }
  public set start(value: string) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelative {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelativeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelativeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelativeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelative | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelative | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrame {
  /**
  * Absolute time frame specifying a fixed start and end time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#absolute Dashboard#absolute}
  */
  readonly absolute?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsolute;
  /**
  * Relative time frame specifying a duration from the current time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#relative Dashboard#relative}
  */
  readonly relative?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelative;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    absolute: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsoluteToTerraform(struct!.absolute),
    relative: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelativeToTerraform(struct!.relative),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    absolute: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsoluteToHclTerraform(struct!.absolute),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsolute",
    },
    relative: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelativeToHclTerraform(struct!.relative),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelative",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrame | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._absolute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.absolute = this._absolute?.internalValue;
    }
    if (this._relative?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relative = this._relative?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrame | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._absolute.internalValue = undefined;
      this._relative.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._absolute.internalValue = value.absolute;
      this._relative.internalValue = value.relative;
    }
  }

  // absolute - computed: false, optional: true, required: false
  private _absolute = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsoluteOutputReference(this, "absolute");
  public get absolute() {
    return this._absolute;
  }
  public putAbsolute(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameAbsolute) {
    this._absolute.internalValue = value;
  }
  public resetAbsolute() {
    this._absolute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get absoluteInput() {
    return this._absolute.internalValue;
  }

  // relative - computed: false, optional: true, required: false
  private _relative = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelativeOutputReference(this, "relative");
  public get relative() {
    return this._relative;
  }
  public putRelative(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameRelative) {
    this._relative.internalValue = value;
  }
  public resetRelative() {
    this._relative.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relativeInput() {
    return this._relative.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpans {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#filters Dashboard#filters}
  */
  readonly filters?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#grouping Dashboard#grouping}
  */
  readonly grouping?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGrouping;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#lucene_query Dashboard#lucene_query}
  */
  readonly luceneQuery?: string;
  /**
  * Specifies the time frame. Can be either absolute or relative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time_frame Dashboard#time_frame}
  */
  readonly timeFrame?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrame;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filters: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersToTerraform, false)(struct!.filters),
    grouping: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingToTerraform(struct!.grouping),
    lucene_query: cdktf.stringToTerraform(struct!.luceneQuery),
    time_frame: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameToTerraform(struct!.timeFrame),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filters: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersList",
    },
    grouping: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingToHclTerraform(struct!.grouping),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGrouping",
    },
    lucene_query: {
      value: cdktf.stringToHclTerraform(struct!.luceneQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_frame: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameToHclTerraform(struct!.timeFrame),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrame",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpans | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._grouping?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grouping = this._grouping?.internalValue;
    }
    if (this._luceneQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.luceneQuery = this._luceneQuery;
    }
    if (this._timeFrame?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeFrame = this._timeFrame?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpans | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filters.internalValue = undefined;
      this._grouping.internalValue = undefined;
      this._luceneQuery = undefined;
      this._timeFrame.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filters.internalValue = value.filters;
      this._grouping.internalValue = value.grouping;
      this._luceneQuery = value.luceneQuery;
      this._timeFrame.internalValue = value.timeFrame;
    }
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // grouping - computed: false, optional: true, required: false
  private _grouping = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGroupingOutputReference(this, "grouping");
  public get grouping() {
    return this._grouping;
  }
  public putGrouping(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansGrouping) {
    this._grouping.internalValue = value;
  }
  public resetGrouping() {
    this._grouping.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupingInput() {
    return this._grouping.internalValue;
  }

  // lucene_query - computed: false, optional: true, required: false
  private _luceneQuery?: string; 
  public get luceneQuery() {
    return this.getStringAttribute('lucene_query');
  }
  public set luceneQuery(value: string) {
    this._luceneQuery = value;
  }
  public resetLuceneQuery() {
    this._luceneQuery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get luceneQueryInput() {
    return this._luceneQuery;
  }

  // time_frame - computed: false, optional: true, required: false
  private _timeFrame = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrameOutputReference(this, "time_frame");
  public get timeFrame() {
    return this._timeFrame;
  }
  public putTimeFrame(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansTimeFrame) {
    this._timeFrame.internalValue = value;
  }
  public resetTimeFrame() {
    this._timeFrame.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeFrameInput() {
    return this._timeFrame.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuery {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#data_prime Dashboard#data_prime}
  */
  readonly dataPrime?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrime;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#logs Dashboard#logs}
  */
  readonly logs?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogs;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metrics Dashboard#metrics}
  */
  readonly metrics?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetrics;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#spans Dashboard#spans}
  */
  readonly spans?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpans;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuery | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data_prime: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeToTerraform(struct!.dataPrime),
    logs: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsToTerraform(struct!.logs),
    metrics: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsToTerraform(struct!.metrics),
    spans: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansToTerraform(struct!.spans),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuery | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data_prime: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeToHclTerraform(struct!.dataPrime),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrime",
    },
    logs: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsToHclTerraform(struct!.logs),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogs",
    },
    metrics: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsToHclTerraform(struct!.metrics),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetrics",
    },
    spans: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansToHclTerraform(struct!.spans),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpans",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuery | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dataPrime?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataPrime = this._dataPrime?.internalValue;
    }
    if (this._logs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logs = this._logs?.internalValue;
    }
    if (this._metrics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics?.internalValue;
    }
    if (this._spans?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spans = this._spans?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuery | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dataPrime.internalValue = undefined;
      this._logs.internalValue = undefined;
      this._metrics.internalValue = undefined;
      this._spans.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dataPrime.internalValue = value.dataPrime;
      this._logs.internalValue = value.logs;
      this._metrics.internalValue = value.metrics;
      this._spans.internalValue = value.spans;
    }
  }

  // data_prime - computed: false, optional: true, required: false
  private _dataPrime = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrimeOutputReference(this, "data_prime");
  public get dataPrime() {
    return this._dataPrime;
  }
  public putDataPrime(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryDataPrime) {
    this._dataPrime.internalValue = value;
  }
  public resetDataPrime() {
    this._dataPrime.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataPrimeInput() {
    return this._dataPrime.internalValue;
  }

  // logs - computed: false, optional: true, required: false
  private _logs = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogsOutputReference(this, "logs");
  public get logs() {
    return this._logs;
  }
  public putLogs(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryLogs) {
    this._logs.internalValue = value;
  }
  public resetLogs() {
    this._logs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logsInput() {
    return this._logs.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetricsOutputReference(this, "metrics");
  public get metrics() {
    return this._metrics;
  }
  public putMetrics(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryMetrics) {
    this._metrics.internalValue = value;
  }
  public resetMetrics() {
    this._metrics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics.internalValue;
  }

  // spans - computed: false, optional: true, required: false
  private _spans = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpansOutputReference(this, "spans");
  public get spans() {
    return this._spans;
  }
  public putSpans(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuerySpans) {
    this._spans.internalValue = value;
  }
  public resetSpans() {
    this._spans.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spansInput() {
    return this._spans.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionDataTable {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#columns Dashboard#columns}
  */
  readonly columns?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumns[] | cdktf.IResolvable;
  /**
  * The data mode type. Can be one of ["archive" "unspecified"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#data_mode_type Dashboard#data_mode_type}
  */
  readonly dataModeType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#order_by Dashboard#order_by}
  */
  readonly orderBy?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderBy;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#query Dashboard#query}
  */
  readonly query: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuery;
  /**
  * The number of results to display per page.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#results_per_page Dashboard#results_per_page}
  */
  readonly resultsPerPage: number;
  /**
  * The style of the rows. Can be one of ["condensed" "json" "list" "one_line" "two_line" "unspecified"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#row_style Dashboard#row_style}
  */
  readonly rowStyle: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    columns: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumnsToTerraform, false)(struct!.columns),
    data_mode_type: cdktf.stringToTerraform(struct!.dataModeType),
    order_by: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderByToTerraform(struct!.orderBy),
    query: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryToTerraform(struct!.query),
    results_per_page: cdktf.numberToTerraform(struct!.resultsPerPage),
    row_style: cdktf.stringToTerraform(struct!.rowStyle),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionDataTableToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionDataTable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    columns: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumnsToHclTerraform, false)(struct!.columns),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumnsList",
    },
    data_mode_type: {
      value: cdktf.stringToHclTerraform(struct!.dataModeType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    order_by: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderByToHclTerraform(struct!.orderBy),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderBy",
    },
    query: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryToHclTerraform(struct!.query),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuery",
    },
    results_per_page: {
      value: cdktf.numberToHclTerraform(struct!.resultsPerPage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    row_style: {
      value: cdktf.stringToHclTerraform(struct!.rowStyle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionDataTableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionDataTable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._columns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.columns = this._columns?.internalValue;
    }
    if (this._dataModeType !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataModeType = this._dataModeType;
    }
    if (this._orderBy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.orderBy = this._orderBy?.internalValue;
    }
    if (this._query?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query?.internalValue;
    }
    if (this._resultsPerPage !== undefined) {
      hasAnyValues = true;
      internalValueResult.resultsPerPage = this._resultsPerPage;
    }
    if (this._rowStyle !== undefined) {
      hasAnyValues = true;
      internalValueResult.rowStyle = this._rowStyle;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._columns.internalValue = undefined;
      this._dataModeType = undefined;
      this._orderBy.internalValue = undefined;
      this._query.internalValue = undefined;
      this._resultsPerPage = undefined;
      this._rowStyle = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._columns.internalValue = value.columns;
      this._dataModeType = value.dataModeType;
      this._orderBy.internalValue = value.orderBy;
      this._query.internalValue = value.query;
      this._resultsPerPage = value.resultsPerPage;
      this._rowStyle = value.rowStyle;
    }
  }

  // columns - computed: false, optional: true, required: false
  private _columns = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumnsList(this, "columns", false);
  public get columns() {
    return this._columns;
  }
  public putColumns(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableColumns[] | cdktf.IResolvable) {
    this._columns.internalValue = value;
  }
  public resetColumns() {
    this._columns.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get columnsInput() {
    return this._columns.internalValue;
  }

  // data_mode_type - computed: true, optional: true, required: false
  private _dataModeType?: string; 
  public get dataModeType() {
    return this.getStringAttribute('data_mode_type');
  }
  public set dataModeType(value: string) {
    this._dataModeType = value;
  }
  public resetDataModeType() {
    this._dataModeType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataModeTypeInput() {
    return this._dataModeType;
  }

  // order_by - computed: false, optional: true, required: false
  private _orderBy = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderByOutputReference(this, "order_by");
  public get orderBy() {
    return this._orderBy;
  }
  public putOrderBy(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableOrderBy) {
    this._orderBy.internalValue = value;
  }
  public resetOrderBy() {
    this._orderBy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orderByInput() {
    return this._orderBy.internalValue;
  }

  // query - computed: false, optional: false, required: true
  private _query = new DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQueryOutputReference(this, "query");
  public get query() {
    return this._query;
  }
  public putQuery(value: DashboardLayoutSectionsRowsWidgetsDefinitionDataTableQuery) {
    this._query.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query.internalValue;
  }

  // results_per_page - computed: false, optional: false, required: true
  private _resultsPerPage?: number; 
  public get resultsPerPage() {
    return this.getNumberAttribute('results_per_page');
  }
  public set resultsPerPage(value: number) {
    this._resultsPerPage = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resultsPerPageInput() {
    return this._resultsPerPage;
  }

  // row_style - computed: false, optional: false, required: true
  private _rowStyle?: string; 
  public get rowStyle() {
    return this.getStringAttribute('row_style');
  }
  public set rowStyle(value: string) {
    this._rowStyle = value;
  }
  // Temporarily expose input value. Use with caution.
  public get rowStyleInput() {
    return this._rowStyle;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogs {
  /**
  * Field in the logs to apply the filter on.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#observation_field Dashboard#observation_field}
  */
  readonly observationField?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    observation_field: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationFieldToTerraform(struct!.observationField),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    observation_field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationFieldToHclTerraform(struct!.observationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._observationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.observationField = this._observationField?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._observationField.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._observationField.internalValue = value.observationField;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // observation_field - computed: false, optional: true, required: false
  private _observationField = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationFieldOutputReference(this, "observation_field");
  public get observationField() {
    return this._observationField;
  }
  public putObservationField(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsObservationField) {
    this._observationField.internalValue = value;
  }
  public resetObservationField() {
    this._observationField.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get observationFieldInput() {
    return this._observationField.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetrics {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#label Dashboard#label}
  */
  readonly label?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metric_name Dashboard#metric_name}
  */
  readonly metricName?: string;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    metric_name: cdktf.stringToTerraform(struct!.metricName),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric_name: {
      value: cdktf.stringToHclTerraform(struct!.metricName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._metricName !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricName = this._metricName;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._metricName = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._metricName = value.metricName;
      this._operator.internalValue = value.operator;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // metric_name - computed: false, optional: true, required: false
  private _metricName?: string; 
  public get metricName() {
    return this.getStringAttribute('metric_name');
  }
  public set metricName(value: string) {
    this._metricName = value;
  }
  public resetMetricName() {
    this._metricName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricNameInput() {
    return this._metricName;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansField {
  /**
  * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
  /**
  * The value of the field. When the field type is `metadata`, can be one of ["application_name" "operation_name" "service_name" "subsystem_name" "unspecified"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#value Dashboard#value}
  */
  readonly value: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpans {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansFieldToTerraform(struct!.field),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansFieldToHclTerraform(struct!.field),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpans | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpans | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field.internalValue = value.field;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansFieldOutputReference(this, "field");
  public get field() {
    return this._field;
  }
  public putField(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansField) {
    this._field.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#logs Dashboard#logs}
  */
  readonly logs?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogs;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metrics Dashboard#metrics}
  */
  readonly metrics?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetrics;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#spans Dashboard#spans}
  */
  readonly spans?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpans;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    logs: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsToTerraform(struct!.logs),
    metrics: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsToTerraform(struct!.metrics),
    spans: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansToTerraform(struct!.spans),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    logs: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsToHclTerraform(struct!.logs),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogs",
    },
    metrics: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsToHclTerraform(struct!.metrics),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetrics",
    },
    spans: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansToHclTerraform(struct!.spans),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpans",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._logs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logs = this._logs?.internalValue;
    }
    if (this._metrics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics?.internalValue;
    }
    if (this._spans?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spans = this._spans?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._logs.internalValue = undefined;
      this._metrics.internalValue = undefined;
      this._spans.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._logs.internalValue = value.logs;
      this._metrics.internalValue = value.metrics;
      this._spans.internalValue = value.spans;
    }
  }

  // logs - computed: false, optional: true, required: false
  private _logs = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogsOutputReference(this, "logs");
  public get logs() {
    return this._logs;
  }
  public putLogs(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersLogs) {
    this._logs.internalValue = value;
  }
  public resetLogs() {
    this._logs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logsInput() {
    return this._logs.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetricsOutputReference(this, "metrics");
  public get metrics() {
    return this._metrics;
  }
  public putMetrics(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersMetrics) {
    this._metrics.internalValue = value;
  }
  public resetMetrics() {
    this._metrics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics.internalValue;
  }

  // spans - computed: false, optional: true, required: false
  private _spans = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpansOutputReference(this, "spans");
  public get spans() {
    return this._spans;
  }
  public putSpans(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersSpans) {
    this._spans.internalValue = value;
  }
  public resetSpans() {
    this._spans.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spansInput() {
    return this._spans.internalValue;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsolute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end Dashboard#end}
  */
  readonly end: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start Dashboard#start}
  */
  readonly start: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsoluteToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.stringToTerraform(struct!.end),
    start: cdktf.stringToTerraform(struct!.start),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsoluteToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.stringToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.stringToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsoluteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsolute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsolute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: false, required: true
  private _end?: string; 
  public get end() {
    return this.getStringAttribute('end');
  }
  public set end(value: string) {
    this._end = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: false, required: true
  private _start?: string; 
  public get start() {
    return this.getStringAttribute('start');
  }
  public set start(value: string) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelative {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelativeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelativeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelativeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelative | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelative | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrame {
  /**
  * Absolute time frame specifying a fixed start and end time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#absolute Dashboard#absolute}
  */
  readonly absolute?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsolute;
  /**
  * Relative time frame specifying a duration from the current time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#relative Dashboard#relative}
  */
  readonly relative?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelative;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    absolute: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsoluteToTerraform(struct!.absolute),
    relative: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelativeToTerraform(struct!.relative),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    absolute: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsoluteToHclTerraform(struct!.absolute),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsolute",
    },
    relative: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelativeToHclTerraform(struct!.relative),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelative",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrame | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._absolute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.absolute = this._absolute?.internalValue;
    }
    if (this._relative?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relative = this._relative?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrame | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._absolute.internalValue = undefined;
      this._relative.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._absolute.internalValue = value.absolute;
      this._relative.internalValue = value.relative;
    }
  }

  // absolute - computed: false, optional: true, required: false
  private _absolute = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsoluteOutputReference(this, "absolute");
  public get absolute() {
    return this._absolute;
  }
  public putAbsolute(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameAbsolute) {
    this._absolute.internalValue = value;
  }
  public resetAbsolute() {
    this._absolute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get absoluteInput() {
    return this._absolute.internalValue;
  }

  // relative - computed: false, optional: true, required: false
  private _relative = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelativeOutputReference(this, "relative");
  public get relative() {
    return this._relative;
  }
  public putRelative(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameRelative) {
    this._relative.internalValue = value;
  }
  public resetRelative() {
    this._relative.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relativeInput() {
    return this._relative.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrime {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#filters Dashboard#filters}
  */
  readonly filters?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#query Dashboard#query}
  */
  readonly query?: string;
  /**
  * Specifies the time frame. Can be either absolute or relative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time_frame Dashboard#time_frame}
  */
  readonly timeFrame?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrame;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filters: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersToTerraform, false)(struct!.filters),
    query: cdktf.stringToTerraform(struct!.query),
    time_frame: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameToTerraform(struct!.timeFrame),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrime | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filters: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersList",
    },
    query: {
      value: cdktf.stringToHclTerraform(struct!.query),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_frame: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameToHclTerraform(struct!.timeFrame),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrame",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrime | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._query !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query;
    }
    if (this._timeFrame?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeFrame = this._timeFrame?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrime | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filters.internalValue = undefined;
      this._query = undefined;
      this._timeFrame.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filters.internalValue = value.filters;
      this._query = value.query;
      this._timeFrame.internalValue = value.timeFrame;
    }
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // query - computed: false, optional: true, required: false
  private _query?: string; 
  public get query() {
    return this.getStringAttribute('query');
  }
  public set query(value: string) {
    this._query = value;
  }
  public resetQuery() {
    this._query = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query;
  }

  // time_frame - computed: false, optional: true, required: false
  private _timeFrame = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrameOutputReference(this, "time_frame");
  public get timeFrame() {
    return this._timeFrame;
  }
  public putTimeFrame(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeTimeFrame) {
    this._timeFrame.internalValue = value;
  }
  public resetTimeFrame() {
    this._timeFrame.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeFrameInput() {
    return this._timeFrame.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#observation_field Dashboard#observation_field}
  */
  readonly observationField?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    observation_field: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationFieldToTerraform(struct!.observationField),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    observation_field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationFieldToHclTerraform(struct!.observationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._observationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.observationField = this._observationField?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._observationField.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._observationField.internalValue = value.observationField;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // observation_field - computed: false, optional: true, required: false
  private _observationField = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationFieldOutputReference(this, "observation_field");
  public get observationField() {
    return this._observationField;
  }
  public putObservationField(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersObservationField) {
    this._observationField.internalValue = value;
  }
  public resetObservationField() {
    this._observationField.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get observationFieldInput() {
    return this._observationField.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#observation_field Dashboard#observation_field}
  */
  readonly observationField?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationField;
  /**
  * The percentage of the aggregation to return. required when type is `percentile`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#percent Dashboard#percent}
  */
  readonly percent?: number;
  /**
  * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    observation_field: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationFieldToTerraform(struct!.observationField),
    percent: cdktf.numberToTerraform(struct!.percent),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    observation_field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationFieldToHclTerraform(struct!.observationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationField",
    },
    percent: {
      value: cdktf.numberToHclTerraform(struct!.percent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._observationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.observationField = this._observationField?.internalValue;
    }
    if (this._percent !== undefined) {
      hasAnyValues = true;
      internalValueResult.percent = this._percent;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._observationField.internalValue = undefined;
      this._percent = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._observationField.internalValue = value.observationField;
      this._percent = value.percent;
      this._type = value.type;
    }
  }

  // field - computed: false, optional: true, required: false
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  public resetField() {
    this._field = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // observation_field - computed: false, optional: true, required: false
  private _observationField = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationFieldOutputReference(this, "observation_field");
  public get observationField() {
    return this._observationField;
  }
  public putObservationField(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationObservationField) {
    this._observationField.internalValue = value;
  }
  public resetObservationField() {
    this._observationField.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get observationFieldInput() {
    return this._observationField.internalValue;
  }

  // percent - computed: false, optional: true, required: false
  private _percent?: number; 
  public get percent() {
    return this.getNumberAttribute('percent');
  }
  public set percent(value: number) {
    this._percent = value;
  }
  public resetPercent() {
    this._percent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentInput() {
    return this._percent;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsolute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end Dashboard#end}
  */
  readonly end: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start Dashboard#start}
  */
  readonly start: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsoluteToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.stringToTerraform(struct!.end),
    start: cdktf.stringToTerraform(struct!.start),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsoluteToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.stringToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.stringToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsoluteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsolute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsolute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: false, required: true
  private _end?: string; 
  public get end() {
    return this.getStringAttribute('end');
  }
  public set end(value: string) {
    this._end = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: false, required: true
  private _start?: string; 
  public get start() {
    return this.getStringAttribute('start');
  }
  public set start(value: string) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelative {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelativeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelativeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelativeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelative | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelative | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrame {
  /**
  * Absolute time frame specifying a fixed start and end time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#absolute Dashboard#absolute}
  */
  readonly absolute?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsolute;
  /**
  * Relative time frame specifying a duration from the current time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#relative Dashboard#relative}
  */
  readonly relative?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelative;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    absolute: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsoluteToTerraform(struct!.absolute),
    relative: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelativeToTerraform(struct!.relative),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    absolute: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsoluteToHclTerraform(struct!.absolute),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsolute",
    },
    relative: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelativeToHclTerraform(struct!.relative),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelative",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrame | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._absolute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.absolute = this._absolute?.internalValue;
    }
    if (this._relative?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relative = this._relative?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrame | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._absolute.internalValue = undefined;
      this._relative.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._absolute.internalValue = value.absolute;
      this._relative.internalValue = value.relative;
    }
  }

  // absolute - computed: false, optional: true, required: false
  private _absolute = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsoluteOutputReference(this, "absolute");
  public get absolute() {
    return this._absolute;
  }
  public putAbsolute(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameAbsolute) {
    this._absolute.internalValue = value;
  }
  public resetAbsolute() {
    this._absolute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get absoluteInput() {
    return this._absolute.internalValue;
  }

  // relative - computed: false, optional: true, required: false
  private _relative = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelativeOutputReference(this, "relative");
  public get relative() {
    return this._relative;
  }
  public putRelative(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameRelative) {
    this._relative.internalValue = value;
  }
  public resetRelative() {
    this._relative.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relativeInput() {
    return this._relative.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#filters Dashboard#filters}
  */
  readonly filters?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#logs_aggregation Dashboard#logs_aggregation}
  */
  readonly logsAggregation: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregation;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#lucene_query Dashboard#lucene_query}
  */
  readonly luceneQuery?: string;
  /**
  * Specifies the time frame. Can be either absolute or relative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time_frame Dashboard#time_frame}
  */
  readonly timeFrame?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrame;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filters: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersToTerraform, false)(struct!.filters),
    logs_aggregation: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationToTerraform(struct!.logsAggregation),
    lucene_query: cdktf.stringToTerraform(struct!.luceneQuery),
    time_frame: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameToTerraform(struct!.timeFrame),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filters: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersList",
    },
    logs_aggregation: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationToHclTerraform(struct!.logsAggregation),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregation",
    },
    lucene_query: {
      value: cdktf.stringToHclTerraform(struct!.luceneQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_frame: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameToHclTerraform(struct!.timeFrame),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrame",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._logsAggregation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logsAggregation = this._logsAggregation?.internalValue;
    }
    if (this._luceneQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.luceneQuery = this._luceneQuery;
    }
    if (this._timeFrame?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeFrame = this._timeFrame?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filters.internalValue = undefined;
      this._logsAggregation.internalValue = undefined;
      this._luceneQuery = undefined;
      this._timeFrame.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filters.internalValue = value.filters;
      this._logsAggregation.internalValue = value.logsAggregation;
      this._luceneQuery = value.luceneQuery;
      this._timeFrame.internalValue = value.timeFrame;
    }
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // logs_aggregation - computed: false, optional: false, required: true
  private _logsAggregation = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregationOutputReference(this, "logs_aggregation");
  public get logsAggregation() {
    return this._logsAggregation;
  }
  public putLogsAggregation(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsLogsAggregation) {
    this._logsAggregation.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logsAggregationInput() {
    return this._logsAggregation.internalValue;
  }

  // lucene_query - computed: false, optional: true, required: false
  private _luceneQuery?: string; 
  public get luceneQuery() {
    return this.getStringAttribute('lucene_query');
  }
  public set luceneQuery(value: string) {
    this._luceneQuery = value;
  }
  public resetLuceneQuery() {
    this._luceneQuery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get luceneQueryInput() {
    return this._luceneQuery;
  }

  // time_frame - computed: false, optional: true, required: false
  private _timeFrame = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrameOutputReference(this, "time_frame");
  public get timeFrame() {
    return this._timeFrame;
  }
  public putTimeFrame(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsTimeFrame) {
    this._timeFrame.internalValue = value;
  }
  public resetTimeFrame() {
    this._timeFrame.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeFrameInput() {
    return this._timeFrame.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFilters {
  /**
  * Label associated with the metric.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#label Dashboard#label}
  */
  readonly label?: string;
  /**
  * Metric name to apply the filter on.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metric Dashboard#metric}
  */
  readonly metric: string;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    metric: cdktf.stringToTerraform(struct!.metric),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric: {
      value: cdktf.stringToHclTerraform(struct!.metric),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._metric !== undefined) {
      hasAnyValues = true;
      internalValueResult.metric = this._metric;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._metric = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._metric = value.metric;
      this._operator.internalValue = value.operator;
    }
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // metric - computed: false, optional: false, required: true
  private _metric?: string; 
  public get metric() {
    return this.getStringAttribute('metric');
  }
  public set metric(value: string) {
    this._metric = value;
  }
  // Temporarily expose input value. Use with caution.
  public get metricInput() {
    return this._metric;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsolute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end Dashboard#end}
  */
  readonly end: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start Dashboard#start}
  */
  readonly start: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsoluteToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.stringToTerraform(struct!.end),
    start: cdktf.stringToTerraform(struct!.start),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsoluteToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.stringToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.stringToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsoluteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsolute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsolute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: false, required: true
  private _end?: string; 
  public get end() {
    return this.getStringAttribute('end');
  }
  public set end(value: string) {
    this._end = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: false, required: true
  private _start?: string; 
  public get start() {
    return this.getStringAttribute('start');
  }
  public set start(value: string) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelative {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelativeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelativeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelativeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelative | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelative | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrame {
  /**
  * Absolute time frame specifying a fixed start and end time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#absolute Dashboard#absolute}
  */
  readonly absolute?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsolute;
  /**
  * Relative time frame specifying a duration from the current time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#relative Dashboard#relative}
  */
  readonly relative?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelative;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    absolute: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsoluteToTerraform(struct!.absolute),
    relative: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelativeToTerraform(struct!.relative),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    absolute: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsoluteToHclTerraform(struct!.absolute),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsolute",
    },
    relative: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelativeToHclTerraform(struct!.relative),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelative",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrame | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._absolute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.absolute = this._absolute?.internalValue;
    }
    if (this._relative?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relative = this._relative?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrame | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._absolute.internalValue = undefined;
      this._relative.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._absolute.internalValue = value.absolute;
      this._relative.internalValue = value.relative;
    }
  }

  // absolute - computed: false, optional: true, required: false
  private _absolute = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsoluteOutputReference(this, "absolute");
  public get absolute() {
    return this._absolute;
  }
  public putAbsolute(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameAbsolute) {
    this._absolute.internalValue = value;
  }
  public resetAbsolute() {
    this._absolute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get absoluteInput() {
    return this._absolute.internalValue;
  }

  // relative - computed: false, optional: true, required: false
  private _relative = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelativeOutputReference(this, "relative");
  public get relative() {
    return this._relative;
  }
  public putRelative(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameRelative) {
    this._relative.internalValue = value;
  }
  public resetRelative() {
    this._relative.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relativeInput() {
    return this._relative.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetrics {
  /**
  * The type of aggregation. Can be one of ["avg" "last" "max" "min" "sum" "unspecified"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#aggregation Dashboard#aggregation}
  */
  readonly aggregation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#filters Dashboard#filters}
  */
  readonly filters?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#promql_query Dashboard#promql_query}
  */
  readonly promqlQuery: string;
  /**
  * Specifies the time frame. Can be either absolute or relative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time_frame Dashboard#time_frame}
  */
  readonly timeFrame?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrame;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregation: cdktf.stringToTerraform(struct!.aggregation),
    filters: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersToTerraform, false)(struct!.filters),
    promql_query: cdktf.stringToTerraform(struct!.promqlQuery),
    time_frame: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameToTerraform(struct!.timeFrame),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregation: {
      value: cdktf.stringToHclTerraform(struct!.aggregation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filters: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersList",
    },
    promql_query: {
      value: cdktf.stringToHclTerraform(struct!.promqlQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_frame: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameToHclTerraform(struct!.timeFrame),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrame",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregation !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregation = this._aggregation;
    }
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._promqlQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.promqlQuery = this._promqlQuery;
    }
    if (this._timeFrame?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeFrame = this._timeFrame?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregation = undefined;
      this._filters.internalValue = undefined;
      this._promqlQuery = undefined;
      this._timeFrame.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregation = value.aggregation;
      this._filters.internalValue = value.filters;
      this._promqlQuery = value.promqlQuery;
      this._timeFrame.internalValue = value.timeFrame;
    }
  }

  // aggregation - computed: true, optional: true, required: false
  private _aggregation?: string; 
  public get aggregation() {
    return this.getStringAttribute('aggregation');
  }
  public set aggregation(value: string) {
    this._aggregation = value;
  }
  public resetAggregation() {
    this._aggregation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregationInput() {
    return this._aggregation;
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // promql_query - computed: false, optional: false, required: true
  private _promqlQuery?: string; 
  public get promqlQuery() {
    return this.getStringAttribute('promql_query');
  }
  public set promqlQuery(value: string) {
    this._promqlQuery = value;
  }
  // Temporarily expose input value. Use with caution.
  public get promqlQueryInput() {
    return this._promqlQuery;
  }

  // time_frame - computed: false, optional: true, required: false
  private _timeFrame = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrameOutputReference(this, "time_frame");
  public get timeFrame() {
    return this._timeFrame;
  }
  public putTimeFrame(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsTimeFrame) {
    this._timeFrame.internalValue = value;
  }
  public resetTimeFrame() {
    this._timeFrame.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeFrameInput() {
    return this._timeFrame.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersField {
  /**
  * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
  /**
  * The value of the field. When the field type is `metadata`, can be one of ["application_name" "operation_name" "service_name" "subsystem_name" "unspecified"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#value Dashboard#value}
  */
  readonly value: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersFieldToTerraform(struct!.field),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersFieldToHclTerraform(struct!.field),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field.internalValue = value.field;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersFieldOutputReference(this, "field");
  public get field() {
    return this._field;
  }
  public putField(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersField) {
    this._field.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregation {
  /**
  * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["avg" "max" "min" "percentile_50" "percentile_95" "percentile_99" "sum" "unspecified"]. When the aggregation type is `dimension`, can be one of ["error_count" "unique_count" "unspecified"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#aggregation_type Dashboard#aggregation_type}
  */
  readonly aggregationType: string;
  /**
  * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["trace_id" "unspecified"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: string;
  /**
  * Can be one of ["metric" "dimension"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregationToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggregation_type: cdktf.stringToTerraform(struct!.aggregationType),
    field: cdktf.stringToTerraform(struct!.field),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregationToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggregation_type: {
      value: cdktf.stringToHclTerraform(struct!.aggregationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggregationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggregationType = this._aggregationType;
    }
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggregationType = undefined;
      this._field = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggregationType = value.aggregationType;
      this._field = value.field;
      this._type = value.type;
    }
  }

  // aggregation_type - computed: false, optional: false, required: true
  private _aggregationType?: string; 
  public get aggregationType() {
    return this.getStringAttribute('aggregation_type');
  }
  public set aggregationType(value: string) {
    this._aggregationType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get aggregationTypeInput() {
    return this._aggregationType;
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsolute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#end Dashboard#end}
  */
  readonly end: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#start Dashboard#start}
  */
  readonly start: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsoluteToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.stringToTerraform(struct!.end),
    start: cdktf.stringToTerraform(struct!.start),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsoluteToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsolute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.stringToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start: {
      value: cdktf.stringToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsoluteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsolute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsolute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: false, required: true
  private _end?: string; 
  public get end() {
    return this.getStringAttribute('end');
  }
  public set end(value: string) {
    this._end = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: false, required: true
  private _start?: string; 
  public get start() {
    return this.getStringAttribute('start');
  }
  public set start(value: string) {
    this._start = value;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelative {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#duration Dashboard#duration}
  */
  readonly duration: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelativeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelativeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelative | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelativeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelative | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelative | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrame {
  /**
  * Absolute time frame specifying a fixed start and end time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#absolute Dashboard#absolute}
  */
  readonly absolute?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsolute;
  /**
  * Relative time frame specifying a duration from the current time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#relative Dashboard#relative}
  */
  readonly relative?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelative;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    absolute: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsoluteToTerraform(struct!.absolute),
    relative: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelativeToTerraform(struct!.relative),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrame | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    absolute: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsoluteToHclTerraform(struct!.absolute),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsolute",
    },
    relative: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelativeToHclTerraform(struct!.relative),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelative",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrame | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._absolute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.absolute = this._absolute?.internalValue;
    }
    if (this._relative?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.relative = this._relative?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrame | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._absolute.internalValue = undefined;
      this._relative.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._absolute.internalValue = value.absolute;
      this._relative.internalValue = value.relative;
    }
  }

  // absolute - computed: false, optional: true, required: false
  private _absolute = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsoluteOutputReference(this, "absolute");
  public get absolute() {
    return this._absolute;
  }
  public putAbsolute(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameAbsolute) {
    this._absolute.internalValue = value;
  }
  public resetAbsolute() {
    this._absolute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get absoluteInput() {
    return this._absolute.internalValue;
  }

  // relative - computed: false, optional: true, required: false
  private _relative = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelativeOutputReference(this, "relative");
  public get relative() {
    return this._relative;
  }
  public putRelative(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameRelative) {
    this._relative.internalValue = value;
  }
  public resetRelative() {
    this._relative.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relativeInput() {
    return this._relative.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpans {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#filters Dashboard#filters}
  */
  readonly filters?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFilters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#lucene_query Dashboard#lucene_query}
  */
  readonly luceneQuery?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#spans_aggregation Dashboard#spans_aggregation}
  */
  readonly spansAggregation?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregation;
  /**
  * Specifies the time frame. Can be either absolute or relative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#time_frame Dashboard#time_frame}
  */
  readonly timeFrame?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrame;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filters: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersToTerraform, false)(struct!.filters),
    lucene_query: cdktf.stringToTerraform(struct!.luceneQuery),
    spans_aggregation: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregationToTerraform(struct!.spansAggregation),
    time_frame: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameToTerraform(struct!.timeFrame),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpans | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filters: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersList",
    },
    lucene_query: {
      value: cdktf.stringToHclTerraform(struct!.luceneQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    spans_aggregation: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregationToHclTerraform(struct!.spansAggregation),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregation",
    },
    time_frame: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameToHclTerraform(struct!.timeFrame),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrame",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpans | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._luceneQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.luceneQuery = this._luceneQuery;
    }
    if (this._spansAggregation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spansAggregation = this._spansAggregation?.internalValue;
    }
    if (this._timeFrame?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeFrame = this._timeFrame?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpans | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filters.internalValue = undefined;
      this._luceneQuery = undefined;
      this._spansAggregation.internalValue = undefined;
      this._timeFrame.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filters.internalValue = value.filters;
      this._luceneQuery = value.luceneQuery;
      this._spansAggregation.internalValue = value.spansAggregation;
      this._timeFrame.internalValue = value.timeFrame;
    }
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // lucene_query - computed: false, optional: true, required: false
  private _luceneQuery?: string; 
  public get luceneQuery() {
    return this.getStringAttribute('lucene_query');
  }
  public set luceneQuery(value: string) {
    this._luceneQuery = value;
  }
  public resetLuceneQuery() {
    this._luceneQuery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get luceneQueryInput() {
    return this._luceneQuery;
  }

  // spans_aggregation - computed: false, optional: true, required: false
  private _spansAggregation = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregationOutputReference(this, "spans_aggregation");
  public get spansAggregation() {
    return this._spansAggregation;
  }
  public putSpansAggregation(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansSpansAggregation) {
    this._spansAggregation.internalValue = value;
  }
  public resetSpansAggregation() {
    this._spansAggregation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spansAggregationInput() {
    return this._spansAggregation.internalValue;
  }

  // time_frame - computed: false, optional: true, required: false
  private _timeFrame = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrameOutputReference(this, "time_frame");
  public get timeFrame() {
    return this._timeFrame;
  }
  public putTimeFrame(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansTimeFrame) {
    this._timeFrame.internalValue = value;
  }
  public resetTimeFrame() {
    this._timeFrame.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeFrameInput() {
    return this._timeFrame.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuery {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#data_prime Dashboard#data_prime}
  */
  readonly dataPrime?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrime;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#logs Dashboard#logs}
  */
  readonly logs?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogs;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#metrics Dashboard#metrics}
  */
  readonly metrics?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetrics;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#spans Dashboard#spans}
  */
  readonly spans?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpans;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuery | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data_prime: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeToTerraform(struct!.dataPrime),
    logs: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsToTerraform(struct!.logs),
    metrics: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsToTerraform(struct!.metrics),
    spans: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansToTerraform(struct!.spans),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuery | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data_prime: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeToHclTerraform(struct!.dataPrime),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrime",
    },
    logs: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsToHclTerraform(struct!.logs),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogs",
    },
    metrics: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsToHclTerraform(struct!.metrics),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetrics",
    },
    spans: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansToHclTerraform(struct!.spans),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpans",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuery | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dataPrime?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataPrime = this._dataPrime?.internalValue;
    }
    if (this._logs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logs = this._logs?.internalValue;
    }
    if (this._metrics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics?.internalValue;
    }
    if (this._spans?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spans = this._spans?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuery | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dataPrime.internalValue = undefined;
      this._logs.internalValue = undefined;
      this._metrics.internalValue = undefined;
      this._spans.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dataPrime.internalValue = value.dataPrime;
      this._logs.internalValue = value.logs;
      this._metrics.internalValue = value.metrics;
      this._spans.internalValue = value.spans;
    }
  }

  // data_prime - computed: false, optional: true, required: false
  private _dataPrime = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrimeOutputReference(this, "data_prime");
  public get dataPrime() {
    return this._dataPrime;
  }
  public putDataPrime(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryDataPrime) {
    this._dataPrime.internalValue = value;
  }
  public resetDataPrime() {
    this._dataPrime.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataPrimeInput() {
    return this._dataPrime.internalValue;
  }

  // logs - computed: false, optional: true, required: false
  private _logs = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogsOutputReference(this, "logs");
  public get logs() {
    return this._logs;
  }
  public putLogs(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryLogs) {
    this._logs.internalValue = value;
  }
  public resetLogs() {
    this._logs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logsInput() {
    return this._logs.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetricsOutputReference(this, "metrics");
  public get metrics() {
    return this._metrics;
  }
  public putMetrics(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryMetrics) {
    this._metrics.internalValue = value;
  }
  public resetMetrics() {
    this._metrics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics.internalValue;
  }

  // spans - computed: false, optional: true, required: false
  private _spans = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpansOutputReference(this, "spans");
  public get spans() {
    return this._spans;
  }
  public putSpans(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuerySpans) {
    this._spans.internalValue = value;
  }
  public resetSpans() {
    this._spans.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spansInput() {
    return this._spans.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholds {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#color Dashboard#color}
  */
  readonly color?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#from Dashboard#from}
  */
  readonly from?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#label Dashboard#label}
  */
  readonly label?: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholdsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    color: cdktf.stringToTerraform(struct!.color),
    from: cdktf.numberToTerraform(struct!.from),
    label: cdktf.stringToTerraform(struct!.label),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholdsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    from: {
      value: cdktf.numberToHclTerraform(struct!.from),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholdsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholds | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._from !== undefined) {
      hasAnyValues = true;
      internalValueResult.from = this._from;
    }
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholds | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._color = undefined;
      this._from = undefined;
      this._label = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._color = value.color;
      this._from = value.from;
      this._label = value.label;
    }
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // from - computed: false, optional: true, required: false
  private _from?: number; 
  public get from() {
    return this.getNumberAttribute('from');
  }
  public set from(value: number) {
    this._from = value;
  }
  public resetFrom() {
    this._from = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromInput() {
    return this._from;
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholdsList extends cdktf.ComplexList {
  public internalValue? : DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholds[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholdsOutputReference {
    return new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholdsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionGauge {
  /**
  * The data mode type. Can be one of ["archive" "unspecified"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#data_mode_type Dashboard#data_mode_type}
  */
  readonly dataModeType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#decimal Dashboard#decimal}
  */
  readonly decimal?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#display_series_name Dashboard#display_series_name}
  */
  readonly displaySeriesName?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#max Dashboard#max}
  */
  readonly max?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#min Dashboard#min}
  */
  readonly min?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#query Dashboard#query}
  */
  readonly query: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuery;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#show_inner_arc Dashboard#show_inner_arc}
  */
  readonly showInnerArc?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#show_outer_arc Dashboard#show_outer_arc}
  */
  readonly showOuterArc?: boolean | cdktf.IResolvable;
  /**
  * The threshold by. Can be one of ["background" "unspecified" "value"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#threshold_by Dashboard#threshold_by}
  */
  readonly thresholdBy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#thresholds Dashboard#thresholds}
  */
  readonly thresholds?: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholds[] | cdktf.IResolvable;
  /**
  * The unit of the gauge. Can be one of ["bytes" "bytes_iec" "custom" "euro" "euro_cents" "gbytes" "gibytes" "kbytes" "kibytes" "mbytes" "mibytes" "microseconds" "milliseconds" "nanoseconds" "none" "percent" "percent01" "percent100" "seconds" "unspecified" "usd" "usd_cents"].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#unit Dashboard#unit}
  */
  readonly unit: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGauge | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data_mode_type: cdktf.stringToTerraform(struct!.dataModeType),
    decimal: cdktf.numberToTerraform(struct!.decimal),
    display_series_name: cdktf.booleanToTerraform(struct!.displaySeriesName),
    max: cdktf.numberToTerraform(struct!.max),
    min: cdktf.numberToTerraform(struct!.min),
    query: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryToTerraform(struct!.query),
    show_inner_arc: cdktf.booleanToTerraform(struct!.showInnerArc),
    show_outer_arc: cdktf.booleanToTerraform(struct!.showOuterArc),
    threshold_by: cdktf.stringToTerraform(struct!.thresholdBy),
    thresholds: cdktf.listMapper(dashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholdsToTerraform, false)(struct!.thresholds),
    unit: cdktf.stringToTerraform(struct!.unit),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionGaugeToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionGauge | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data_mode_type: {
      value: cdktf.stringToHclTerraform(struct!.dataModeType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    decimal: {
      value: cdktf.numberToHclTerraform(struct!.decimal),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    display_series_name: {
      value: cdktf.booleanToHclTerraform(struct!.displaySeriesName),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max: {
      value: cdktf.numberToHclTerraform(struct!.max),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    min: {
      value: cdktf.numberToHclTerraform(struct!.min),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    query: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryToHclTerraform(struct!.query),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuery",
    },
    show_inner_arc: {
      value: cdktf.booleanToHclTerraform(struct!.showInnerArc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    show_outer_arc: {
      value: cdktf.booleanToHclTerraform(struct!.showOuterArc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    threshold_by: {
      value: cdktf.stringToHclTerraform(struct!.thresholdBy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    thresholds: {
      value: cdktf.listMapperHcl(dashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholdsToHclTerraform, false)(struct!.thresholds),
      isBlock: true,
      type: "list",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholdsList",
    },
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionGaugeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionGauge | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dataModeType !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataModeType = this._dataModeType;
    }
    if (this._decimal !== undefined) {
      hasAnyValues = true;
      internalValueResult.decimal = this._decimal;
    }
    if (this._displaySeriesName !== undefined) {
      hasAnyValues = true;
      internalValueResult.displaySeriesName = this._displaySeriesName;
    }
    if (this._max !== undefined) {
      hasAnyValues = true;
      internalValueResult.max = this._max;
    }
    if (this._min !== undefined) {
      hasAnyValues = true;
      internalValueResult.min = this._min;
    }
    if (this._query?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query?.internalValue;
    }
    if (this._showInnerArc !== undefined) {
      hasAnyValues = true;
      internalValueResult.showInnerArc = this._showInnerArc;
    }
    if (this._showOuterArc !== undefined) {
      hasAnyValues = true;
      internalValueResult.showOuterArc = this._showOuterArc;
    }
    if (this._thresholdBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.thresholdBy = this._thresholdBy;
    }
    if (this._thresholds?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.thresholds = this._thresholds?.internalValue;
    }
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionGauge | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dataModeType = undefined;
      this._decimal = undefined;
      this._displaySeriesName = undefined;
      this._max = undefined;
      this._min = undefined;
      this._query.internalValue = undefined;
      this._showInnerArc = undefined;
      this._showOuterArc = undefined;
      this._thresholdBy = undefined;
      this._thresholds.internalValue = undefined;
      this._unit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dataModeType = value.dataModeType;
      this._decimal = value.decimal;
      this._displaySeriesName = value.displaySeriesName;
      this._max = value.max;
      this._min = value.min;
      this._query.internalValue = value.query;
      this._showInnerArc = value.showInnerArc;
      this._showOuterArc = value.showOuterArc;
      this._thresholdBy = value.thresholdBy;
      this._thresholds.internalValue = value.thresholds;
      this._unit = value.unit;
    }
  }

  // data_mode_type - computed: true, optional: true, required: false
  private _dataModeType?: string; 
  public get dataModeType() {
    return this.getStringAttribute('data_mode_type');
  }
  public set dataModeType(value: string) {
    this._dataModeType = value;
  }
  public resetDataModeType() {
    this._dataModeType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataModeTypeInput() {
    return this._dataModeType;
  }

  // decimal - computed: false, optional: true, required: false
  private _decimal?: number; 
  public get decimal() {
    return this.getNumberAttribute('decimal');
  }
  public set decimal(value: number) {
    this._decimal = value;
  }
  public resetDecimal() {
    this._decimal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get decimalInput() {
    return this._decimal;
  }

  // display_series_name - computed: true, optional: true, required: false
  private _displaySeriesName?: boolean | cdktf.IResolvable; 
  public get displaySeriesName() {
    return this.getBooleanAttribute('display_series_name');
  }
  public set displaySeriesName(value: boolean | cdktf.IResolvable) {
    this._displaySeriesName = value;
  }
  public resetDisplaySeriesName() {
    this._displaySeriesName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get displaySeriesNameInput() {
    return this._displaySeriesName;
  }

  // max - computed: true, optional: true, required: false
  private _max?: number; 
  public get max() {
    return this.getNumberAttribute('max');
  }
  public set max(value: number) {
    this._max = value;
  }
  public resetMax() {
    this._max = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxInput() {
    return this._max;
  }

  // min - computed: true, optional: true, required: false
  private _min?: number; 
  public get min() {
    return this.getNumberAttribute('min');
  }
  public set min(value: number) {
    this._min = value;
  }
  public resetMin() {
    this._min = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minInput() {
    return this._min;
  }

  // query - computed: false, optional: false, required: true
  private _query = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQueryOutputReference(this, "query");
  public get query() {
    return this._query;
  }
  public putQuery(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeQuery) {
    this._query.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query.internalValue;
  }

  // show_inner_arc - computed: true, optional: true, required: false
  private _showInnerArc?: boolean | cdktf.IResolvable; 
  public get showInnerArc() {
    return this.getBooleanAttribute('show_inner_arc');
  }
  public set showInnerArc(value: boolean | cdktf.IResolvable) {
    this._showInnerArc = value;
  }
  public resetShowInnerArc() {
    this._showInnerArc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get showInnerArcInput() {
    return this._showInnerArc;
  }

  // show_outer_arc - computed: true, optional: true, required: false
  private _showOuterArc?: boolean | cdktf.IResolvable; 
  public get showOuterArc() {
    return this.getBooleanAttribute('show_outer_arc');
  }
  public set showOuterArc(value: boolean | cdktf.IResolvable) {
    this._showOuterArc = value;
  }
  public resetShowOuterArc() {
    this._showOuterArc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get showOuterArcInput() {
    return this._showOuterArc;
  }

  // threshold_by - computed: true, optional: true, required: false
  private _thresholdBy?: string; 
  public get thresholdBy() {
    return this.getStringAttribute('threshold_by');
  }
  public set thresholdBy(value: string) {
    this._thresholdBy = value;
  }
  public resetThresholdBy() {
    this._thresholdBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdByInput() {
    return this._thresholdBy;
  }

  // thresholds - computed: false, optional: true, required: false
  private _thresholds = new DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholdsList(this, "thresholds", false);
  public get thresholds() {
    return this._thresholds;
  }
  public putThresholds(value: DashboardLayoutSectionsRowsWidgetsDefinitionGaugeThresholds[] | cdktf.IResolvable) {
    this._thresholds.internalValue = value;
  }
  public resetThresholds() {
    this._thresholds.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdsInput() {
    return this._thresholds.internalValue;
  }

  // unit - computed: false, optional: false, required: true
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionHexagonLegend {
  /**
  * The columns to display in the legend. Valid values are: avg, last, max, min, name, sum, unspecified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#columns Dashboard#columns}
  */
  readonly columns?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#group_by_query Dashboard#group_by_query}
  */
  readonly groupByQuery?: boolean | cdktf.IResolvable;
  /**
  * Whether to display the legend. True by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#is_visible Dashboard#is_visible}
  */
  readonly isVisible?: boolean | cdktf.IResolvable;
  /**
  * The placement of the legend. Valid values are: auto, bottom, hidden, side, unspecified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#placement Dashboard#placement}
  */
  readonly placement?: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionHexagonLegendToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonLegend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    columns: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.columns),
    group_by_query: cdktf.booleanToTerraform(struct!.groupByQuery),
    is_visible: cdktf.booleanToTerraform(struct!.isVisible),
    placement: cdktf.stringToTerraform(struct!.placement),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionHexagonLegendToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonLegend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    columns: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.columns),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    group_by_query: {
      value: cdktf.booleanToHclTerraform(struct!.groupByQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    is_visible: {
      value: cdktf.booleanToHclTerraform(struct!.isVisible),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    placement: {
      value: cdktf.stringToHclTerraform(struct!.placement),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionHexagonLegendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionHexagonLegend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._columns !== undefined) {
      hasAnyValues = true;
      internalValueResult.columns = this._columns;
    }
    if (this._groupByQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupByQuery = this._groupByQuery;
    }
    if (this._isVisible !== undefined) {
      hasAnyValues = true;
      internalValueResult.isVisible = this._isVisible;
    }
    if (this._placement !== undefined) {
      hasAnyValues = true;
      internalValueResult.placement = this._placement;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonLegend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._columns = undefined;
      this._groupByQuery = undefined;
      this._isVisible = undefined;
      this._placement = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._columns = value.columns;
      this._groupByQuery = value.groupByQuery;
      this._isVisible = value.isVisible;
      this._placement = value.placement;
    }
  }

  // columns - computed: false, optional: true, required: false
  private _columns?: string[]; 
  public get columns() {
    return this.getListAttribute('columns');
  }
  public set columns(value: string[]) {
    this._columns = value;
  }
  public resetColumns() {
    this._columns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get columnsInput() {
    return this._columns;
  }

  // group_by_query - computed: true, optional: true, required: false
  private _groupByQuery?: boolean | cdktf.IResolvable; 
  public get groupByQuery() {
    return this.getBooleanAttribute('group_by_query');
  }
  public set groupByQuery(value: boolean | cdktf.IResolvable) {
    this._groupByQuery = value;
  }
  public resetGroupByQuery() {
    this._groupByQuery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupByQueryInput() {
    return this._groupByQuery;
  }

  // is_visible - computed: true, optional: true, required: false
  private _isVisible?: boolean | cdktf.IResolvable; 
  public get isVisible() {
    return this.getBooleanAttribute('is_visible');
  }
  public set isVisible(value: boolean | cdktf.IResolvable) {
    this._isVisible = value;
  }
  public resetIsVisible() {
    this._isVisible = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isVisibleInput() {
    return this._isVisible;
  }

  // placement - computed: true, optional: true, required: false
  private _placement?: string; 
  public get placement() {
    return this.getStringAttribute('placement');
  }
  public set placement(value: string) {
    this._placement = value;
  }
  public resetPlacement() {
    this._placement = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get placementInput() {
    return this._placement;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#keypath Dashboard#keypath}
  */
  readonly keypath: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#scope Dashboard#scope}
  */
  readonly scope: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationFieldToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keypath: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keypath),
    scope: cdktf.stringToTerraform(struct!.scope),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationFieldToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keypath: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keypath),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keypath !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypath = this._keypath;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keypath = undefined;
      this._scope = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keypath = value.keypath;
      this._scope = value.scope;
    }
  }

  // keypath - computed: false, optional: false, required: true
  private _keypath?: string[]; 
  public get keypath() {
    return this.getListAttribute('keypath');
  }
  public set keypath(value: string[]) {
    this._keypath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keypathInput() {
    return this._keypath;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogs {
  /**
  * Field in the logs to apply the filter on.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#field Dashboard#field}
  */
  readonly field: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#observation_field Dashboard#observation_field}
  */
  readonly observationField?: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationField;
  /**
  * Operator to use for filtering.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#operator Dashboard#operator}
  */
  readonly operator: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperator;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    observation_field: dashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationFieldToTerraform(struct!.observationField),
    operator: dashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperatorToTerraform(struct!.operator),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    observation_field: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationFieldToHclTerraform(struct!.observationField),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationField",
    },
    operator: {
      value: dashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperatorToHclTerraform(struct!.operator),
      isBlock: true,
      type: "struct",
      storageClassType: "DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperator",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._observationField?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.observationField = this._observationField?.internalValue;
    }
    if (this._operator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._observationField.internalValue = undefined;
      this._operator.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._observationField.internalValue = value.observationField;
      this._operator.internalValue = value.operator;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // observation_field - computed: false, optional: true, required: false
  private _observationField = new DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationFieldOutputReference(this, "observation_field");
  public get observationField() {
    return this._observationField;
  }
  public putObservationField(value: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsObservationField) {
    this._observationField.internalValue = value;
  }
  public resetObservationField() {
    this._observationField.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get observationFieldInput() {
    return this._observationField.internalValue;
  }

  // operator - computed: false, optional: false, required: true
  private _operator = new DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperatorOutputReference(this, "operator");
  public get operator() {
    return this._operator;
  }
  public putOperator(value: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersLogsOperator) {
    this._operator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator.internalValue;
  }
}
export interface DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersMetricsOperator {
  /**
  * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#selected_values Dashboard#selected_values}
  */
  readonly selectedValues?: string[];
  /**
  * The type of the operator. Can be one of `equals` or `not_equals`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/coralogix/coralogix/2.2.3/docs/resources/dashboard#type Dashboard#type}
  */
  readonly type: string;
}

export function dashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersMetricsOperatorToTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selected_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.selectedValues),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersMetricsOperatorToHclTerraform(struct?: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selected_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.selectedValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersMetricsOperatorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectedValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectedValues = this._selectedValues;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DashboardLayoutSectionsRowsWidgetsDefinitionHexagonQueryDataPrimeFiltersMetricsOperator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectedValues = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectedValues = value.selectedValues;
      this._type = value.type;
    }
  }

  // selected_values - computed: false, optional: true, required: false
  private _selectedValues?: string[]; 
  public get selectedValues() {
    return this.getListAttribute('selected_values');
  }
  public set selectedValues(value: string[]) {
    this._selectedValues = value;
  }
  public resetSelectedValues() {
    this._selectedValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectedValuesInput() {
    return this._selectedValues;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
