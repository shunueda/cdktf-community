// https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface TransferEndpointConfig extends cdktf.TerraformMetaArguments {
  /**
  * Endpoint description
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#description TransferEndpoint#description}
  */
  readonly description?: string;
  /**
  * Endpoint name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#name TransferEndpoint#name}
  */
  readonly name: string;
  /**
  * Project ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#project_id TransferEndpoint#project_id}
  */
  readonly projectId: string;
  /**
  * settings block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#settings TransferEndpoint#settings}
  */
  readonly settings?: TransferEndpointSettings;
}
export interface TransferEndpointSettingsAwsCloudtrailSource {
  /**
  * AWS CloudTrail Access Key ID. See [documentation](https://docs.airbyte.io/integrations/sources/aws-cloudtrail) for information on how to obtain this value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#key_id TransferEndpoint#key_id}
  */
  readonly keyId?: string;
  /**
  * The default AWS region; for example, `us-west-1`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#region_name TransferEndpoint#region_name}
  */
  readonly regionName?: string;
  /**
  * AWS CloudTrail Secret Key. See [documentation](https://docs.airbyte.io/integrations/sources/aws-cloudtrail) for information on how to obtain this value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#secret_key TransferEndpoint#secret_key}
  */
  readonly secretKey?: string;
  /**
  * The date from which replication should start. Note that in AWS CloudTrail, historical data are available for the last 90 days only. Format `YYYY-MM-DD`; for example, `2021-01-25`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#start_date TransferEndpoint#start_date}
  */
  readonly startDate?: string;
}

export function transferEndpointSettingsAwsCloudtrailSourceToTerraform(struct?: TransferEndpointSettingsAwsCloudtrailSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key_id: cdktf.stringToTerraform(struct!.keyId),
    region_name: cdktf.stringToTerraform(struct!.regionName),
    secret_key: cdktf.stringToTerraform(struct!.secretKey),
    start_date: cdktf.stringToTerraform(struct!.startDate),
  }
}


export function transferEndpointSettingsAwsCloudtrailSourceToHclTerraform(struct?: TransferEndpointSettingsAwsCloudtrailSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key_id: {
      value: cdktf.stringToHclTerraform(struct!.keyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region_name: {
      value: cdktf.stringToHclTerraform(struct!.regionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_key: {
      value: cdktf.stringToHclTerraform(struct!.secretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start_date: {
      value: cdktf.stringToHclTerraform(struct!.startDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsAwsCloudtrailSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsAwsCloudtrailSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyId = this._keyId;
    }
    if (this._regionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.regionName = this._regionName;
    }
    if (this._secretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKey = this._secretKey;
    }
    if (this._startDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.startDate = this._startDate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsAwsCloudtrailSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keyId = undefined;
      this._regionName = undefined;
      this._secretKey = undefined;
      this._startDate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keyId = value.keyId;
      this._regionName = value.regionName;
      this._secretKey = value.secretKey;
      this._startDate = value.startDate;
    }
  }

  // key_id - computed: false, optional: true, required: false
  private _keyId?: string; 
  public get keyId() {
    return this.getStringAttribute('key_id');
  }
  public set keyId(value: string) {
    this._keyId = value;
  }
  public resetKeyId() {
    this._keyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyIdInput() {
    return this._keyId;
  }

  // region_name - computed: false, optional: true, required: false
  private _regionName?: string; 
  public get regionName() {
    return this.getStringAttribute('region_name');
  }
  public set regionName(value: string) {
    this._regionName = value;
  }
  public resetRegionName() {
    this._regionName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionNameInput() {
    return this._regionName;
  }

  // secret_key - computed: false, optional: true, required: false
  private _secretKey?: string; 
  public get secretKey() {
    return this.getStringAttribute('secret_key');
  }
  public set secretKey(value: string) {
    this._secretKey = value;
  }
  public resetSecretKey() {
    this._secretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyInput() {
    return this._secretKey;
  }

  // start_date - computed: false, optional: true, required: false
  private _startDate?: string; 
  public get startDate() {
    return this.getStringAttribute('start_date');
  }
  public set startDate(value: string) {
    this._startDate = value;
  }
  public resetStartDate() {
    this._startDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startDateInput() {
    return this._startDate;
  }
}
export interface TransferEndpointSettingsBigquerySource {
  /**
  * The contents of your Service Account Key JSON file. See the [documentation](https://docs.airbyte.io/integrations/sources/bigquery#setup-the-bigquery-source-in-airbyte) for more information on how to obtain this key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#credentials_json TransferEndpoint#credentials_json}
  */
  readonly credentialsJson?: string;
  /**
  * The dataset ID to search for tables and views. If you are only loading data from one dataset, setting this option could result in much faster schema discovery.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#dataset_id TransferEndpoint#dataset_id}
  */
  readonly datasetId?: string;
  /**
  * The GCP project ID for the project containing the target BigQuery dataset.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#project_id TransferEndpoint#project_id}
  */
  readonly projectId?: string;
}

export function transferEndpointSettingsBigquerySourceToTerraform(struct?: TransferEndpointSettingsBigquerySource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_json: cdktf.stringToTerraform(struct!.credentialsJson),
    dataset_id: cdktf.stringToTerraform(struct!.datasetId),
    project_id: cdktf.stringToTerraform(struct!.projectId),
  }
}


export function transferEndpointSettingsBigquerySourceToHclTerraform(struct?: TransferEndpointSettingsBigquerySource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_json: {
      value: cdktf.stringToHclTerraform(struct!.credentialsJson),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dataset_id: {
      value: cdktf.stringToHclTerraform(struct!.datasetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsBigquerySourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsBigquerySource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsJson !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsJson = this._credentialsJson;
    }
    if (this._datasetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.datasetId = this._datasetId;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsBigquerySource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsJson = undefined;
      this._datasetId = undefined;
      this._projectId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsJson = value.credentialsJson;
      this._datasetId = value.datasetId;
      this._projectId = value.projectId;
    }
  }

  // credentials_json - computed: false, optional: true, required: false
  private _credentialsJson?: string; 
  public get credentialsJson() {
    return this.getStringAttribute('credentials_json');
  }
  public set credentialsJson(value: string) {
    this._credentialsJson = value;
  }
  public resetCredentialsJson() {
    this._credentialsJson = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsJsonInput() {
    return this._credentialsJson;
  }

  // dataset_id - computed: false, optional: true, required: false
  private _datasetId?: string; 
  public get datasetId() {
    return this.getStringAttribute('dataset_id');
  }
  public set datasetId(value: string) {
    this._datasetId = value;
  }
  public resetDatasetId() {
    this._datasetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datasetIdInput() {
    return this._datasetId;
  }

  // project_id - computed: false, optional: true, required: false
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  public resetProjectId() {
    this._projectId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }
}
export interface TransferEndpointSettingsBigqueryTarget {
  /**
  * The contents of your Service Account Key JSON file. See the [documentation](https://docs.airbyte.io/integrations/sources/bigquery#setup-the-bigquery-source-in-airbyte) for more information on how to obtain this key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#credentials_json TransferEndpoint#credentials_json}
  */
  readonly credentialsJson?: string;
  /**
  * The dataset ID to search for tables and views. If you are only loading data from one dataset, setting this option could result in much faster schema discovery.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#dataset_id TransferEndpoint#dataset_id}
  */
  readonly datasetId?: string;
  /**
  * The GCP project ID for the project containing the target BigQuery dataset.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#project_id TransferEndpoint#project_id}
  */
  readonly projectId?: string;
}

export function transferEndpointSettingsBigqueryTargetToTerraform(struct?: TransferEndpointSettingsBigqueryTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_json: cdktf.stringToTerraform(struct!.credentialsJson),
    dataset_id: cdktf.stringToTerraform(struct!.datasetId),
    project_id: cdktf.stringToTerraform(struct!.projectId),
  }
}


export function transferEndpointSettingsBigqueryTargetToHclTerraform(struct?: TransferEndpointSettingsBigqueryTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_json: {
      value: cdktf.stringToHclTerraform(struct!.credentialsJson),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dataset_id: {
      value: cdktf.stringToHclTerraform(struct!.datasetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsBigqueryTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsBigqueryTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsJson !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsJson = this._credentialsJson;
    }
    if (this._datasetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.datasetId = this._datasetId;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsBigqueryTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsJson = undefined;
      this._datasetId = undefined;
      this._projectId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsJson = value.credentialsJson;
      this._datasetId = value.datasetId;
      this._projectId = value.projectId;
    }
  }

  // credentials_json - computed: false, optional: true, required: false
  private _credentialsJson?: string; 
  public get credentialsJson() {
    return this.getStringAttribute('credentials_json');
  }
  public set credentialsJson(value: string) {
    this._credentialsJson = value;
  }
  public resetCredentialsJson() {
    this._credentialsJson = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsJsonInput() {
    return this._credentialsJson;
  }

  // dataset_id - computed: false, optional: true, required: false
  private _datasetId?: string; 
  public get datasetId() {
    return this.getStringAttribute('dataset_id');
  }
  public set datasetId(value: string) {
    this._datasetId = value;
  }
  public resetDatasetId() {
    this._datasetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datasetIdInput() {
    return this._datasetId;
  }

  // project_id - computed: false, optional: true, required: false
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  public resetProjectId() {
    this._projectId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }
}
export interface TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShard {
  /**
  * List of hosts
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#hosts TransferEndpoint#hosts}
  */
  readonly hosts?: string[];
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#name TransferEndpoint#name}
  */
  readonly name?: string;
}

export function transferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShardToTerraform(struct?: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function transferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShardToHclTerraform(struct?: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hosts = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hosts = value.hosts;
      this._name = value.name;
    }
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  public resetHosts() {
    this._hosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShardList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShard[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShardOutputReference {
    return new TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShardOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsMode {
  /**
  * X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. When CA certificate is specified TLS is used to connect to the server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ca_certificate TransferEndpoint#ca_certificate}
  */
  readonly caCertificate?: string;
}

export function transferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsModeToTerraform(struct?: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificate: cdktf.stringToTerraform(struct!.caCertificate),
  }
}


export function transferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsModeToHclTerraform(struct?: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.caCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificate = this._caCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificate = value.caCertificate;
    }
  }

  // ca_certificate - computed: false, optional: true, required: false
  private _caCertificate?: string; 
  public get caCertificate() {
    return this.getStringAttribute('ca_certificate');
  }
  public set caCertificate(value: string) {
    this._caCertificate = value;
  }
  public resetCaCertificate() {
    this._caCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificateInput() {
    return this._caCertificate;
  }
}
export interface TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremise {
  /**
  * HTTP port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#http_port TransferEndpoint#http_port}
  */
  readonly httpPort?: number;
  /**
  * Native port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#native_port TransferEndpoint#native_port}
  */
  readonly nativePort?: number;
  /**
  * shard block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#shard TransferEndpoint#shard}
  */
  readonly shard?: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShard[] | cdktf.IResolvable;
  /**
  * tls_mode block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tls_mode TransferEndpoint#tls_mode}
  */
  readonly tlsMode?: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsMode;
}

export function transferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseToTerraform(struct?: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http_port: cdktf.numberToTerraform(struct!.httpPort),
    native_port: cdktf.numberToTerraform(struct!.nativePort),
    shard: cdktf.listMapper(transferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShardToTerraform, true)(struct!.shard),
    tls_mode: transferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsModeToTerraform(struct!.tlsMode),
  }
}


export function transferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseToHclTerraform(struct?: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http_port: {
      value: cdktf.numberToHclTerraform(struct!.httpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    native_port: {
      value: cdktf.numberToHclTerraform(struct!.nativePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    shard: {
      value: cdktf.listMapperHcl(transferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShardToHclTerraform, true)(struct!.shard),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShardList",
    },
    tls_mode: {
      value: transferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsModeToHclTerraform(struct!.tlsMode),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsMode",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._httpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPort = this._httpPort;
    }
    if (this._nativePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.nativePort = this._nativePort;
    }
    if (this._shard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.shard = this._shard?.internalValue;
    }
    if (this._tlsMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMode = this._tlsMode?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._httpPort = undefined;
      this._nativePort = undefined;
      this._shard.internalValue = undefined;
      this._tlsMode.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._httpPort = value.httpPort;
      this._nativePort = value.nativePort;
      this._shard.internalValue = value.shard;
      this._tlsMode.internalValue = value.tlsMode;
    }
  }

  // http_port - computed: true, optional: true, required: false
  private _httpPort?: number; 
  public get httpPort() {
    return this.getNumberAttribute('http_port');
  }
  public set httpPort(value: number) {
    this._httpPort = value;
  }
  public resetHttpPort() {
    this._httpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPortInput() {
    return this._httpPort;
  }

  // native_port - computed: true, optional: true, required: false
  private _nativePort?: number; 
  public get nativePort() {
    return this.getNumberAttribute('native_port');
  }
  public set nativePort(value: number) {
    this._nativePort = value;
  }
  public resetNativePort() {
    this._nativePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nativePortInput() {
    return this._nativePort;
  }

  // shard - computed: false, optional: true, required: false
  private _shard = new TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShardList(this, "shard", false);
  public get shard() {
    return this._shard;
  }
  public putShard(value: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseShard[] | cdktf.IResolvable) {
    this._shard.internalValue = value;
  }
  public resetShard() {
    this._shard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shardInput() {
    return this._shard.internalValue;
  }

  // tls_mode - computed: false, optional: true, required: false
  private _tlsMode = new TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsModeOutputReference(this, "tls_mode");
  public get tlsMode() {
    return this._tlsMode;
  }
  public putTlsMode(value: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseTlsMode) {
    this._tlsMode.internalValue = value;
  }
  public resetTlsMode() {
    this._tlsMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsModeInput() {
    return this._tlsMode.internalValue;
  }
}
export interface TransferEndpointSettingsClickhouseSourceConnectionAddress {
  /**
  * Cluster ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#cluster_id TransferEndpoint#cluster_id}
  */
  readonly clusterId?: string;
  /**
  * on_premise block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#on_premise TransferEndpoint#on_premise}
  */
  readonly onPremise?: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremise;
}

export function transferEndpointSettingsClickhouseSourceConnectionAddressToTerraform(struct?: TransferEndpointSettingsClickhouseSourceConnectionAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_id: cdktf.stringToTerraform(struct!.clusterId),
    on_premise: transferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseToTerraform(struct!.onPremise),
  }
}


export function transferEndpointSettingsClickhouseSourceConnectionAddressToHclTerraform(struct?: TransferEndpointSettingsClickhouseSourceConnectionAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.clusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_premise: {
      value: transferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseToHclTerraform(struct!.onPremise),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremise",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseSourceConnectionAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseSourceConnectionAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterId = this._clusterId;
    }
    if (this._onPremise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.onPremise = this._onPremise?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseSourceConnectionAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterId = undefined;
      this._onPremise.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterId = value.clusterId;
      this._onPremise.internalValue = value.onPremise;
    }
  }

  // cluster_id - computed: false, optional: true, required: false
  private _clusterId?: string; 
  public get clusterId() {
    return this.getStringAttribute('cluster_id');
  }
  public set clusterId(value: string) {
    this._clusterId = value;
  }
  public resetClusterId() {
    this._clusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIdInput() {
    return this._clusterId;
  }

  // on_premise - computed: false, optional: true, required: false
  private _onPremise = new TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremiseOutputReference(this, "on_premise");
  public get onPremise() {
    return this._onPremise;
  }
  public putOnPremise(value: TransferEndpointSettingsClickhouseSourceConnectionAddressOnPremise) {
    this._onPremise.internalValue = value;
  }
  public resetOnPremise() {
    this._onPremise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onPremiseInput() {
    return this._onPremise.internalValue;
  }
}
export interface TransferEndpointSettingsClickhouseSourceConnection {
  /**
  * Database
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#database TransferEndpoint#database}
  */
  readonly database?: string;
  /**
  * Database user password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * Database user
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#user TransferEndpoint#user}
  */
  readonly user?: string;
  /**
  * address block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#address TransferEndpoint#address}
  */
  readonly address?: TransferEndpointSettingsClickhouseSourceConnectionAddress;
}

export function transferEndpointSettingsClickhouseSourceConnectionToTerraform(struct?: TransferEndpointSettingsClickhouseSourceConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    database: cdktf.stringToTerraform(struct!.database),
    password: cdktf.stringToTerraform(struct!.password),
    user: cdktf.stringToTerraform(struct!.user),
    address: transferEndpointSettingsClickhouseSourceConnectionAddressToTerraform(struct!.address),
  }
}


export function transferEndpointSettingsClickhouseSourceConnectionToHclTerraform(struct?: TransferEndpointSettingsClickhouseSourceConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    address: {
      value: transferEndpointSettingsClickhouseSourceConnectionAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsClickhouseSourceConnectionAddress",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseSourceConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseSourceConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseSourceConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._database = undefined;
      this._password = undefined;
      this._user = undefined;
      this._address.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._database = value.database;
      this._password = value.password;
      this._user = value.user;
      this._address.internalValue = value.address;
    }
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // address - computed: false, optional: true, required: false
  private _address = new TransferEndpointSettingsClickhouseSourceConnectionAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: TransferEndpointSettingsClickhouseSourceConnectionAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }
}
export interface TransferEndpointSettingsClickhouseSource {
  /**
  * List of tables to exclude
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#exclude_tables TransferEndpoint#exclude_tables}
  */
  readonly excludeTables?: string[];
  /**
  * List of tables to include
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#include_tables TransferEndpoint#include_tables}
  */
  readonly includeTables?: string[];
  /**
  * connection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection TransferEndpoint#connection}
  */
  readonly connection?: TransferEndpointSettingsClickhouseSourceConnection;
}

export function transferEndpointSettingsClickhouseSourceToTerraform(struct?: TransferEndpointSettingsClickhouseSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exclude_tables: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeTables),
    include_tables: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.includeTables),
    connection: transferEndpointSettingsClickhouseSourceConnectionToTerraform(struct!.connection),
  }
}


export function transferEndpointSettingsClickhouseSourceToHclTerraform(struct?: TransferEndpointSettingsClickhouseSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exclude_tables: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeTables),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    include_tables: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.includeTables),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connection: {
      value: transferEndpointSettingsClickhouseSourceConnectionToHclTerraform(struct!.connection),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsClickhouseSourceConnection",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._excludeTables !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeTables = this._excludeTables;
    }
    if (this._includeTables !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeTables = this._includeTables;
    }
    if (this._connection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connection = this._connection?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._excludeTables = undefined;
      this._includeTables = undefined;
      this._connection.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._excludeTables = value.excludeTables;
      this._includeTables = value.includeTables;
      this._connection.internalValue = value.connection;
    }
  }

  // exclude_tables - computed: false, optional: true, required: false
  private _excludeTables?: string[]; 
  public get excludeTables() {
    return this.getListAttribute('exclude_tables');
  }
  public set excludeTables(value: string[]) {
    this._excludeTables = value;
  }
  public resetExcludeTables() {
    this._excludeTables = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeTablesInput() {
    return this._excludeTables;
  }

  // include_tables - computed: false, optional: true, required: false
  private _includeTables?: string[]; 
  public get includeTables() {
    return this.getListAttribute('include_tables');
  }
  public set includeTables(value: string[]) {
    this._includeTables = value;
  }
  public resetIncludeTables() {
    this._includeTables = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeTablesInput() {
    return this._includeTables;
  }

  // connection - computed: false, optional: true, required: false
  private _connection = new TransferEndpointSettingsClickhouseSourceConnectionOutputReference(this, "connection");
  public get connection() {
    return this._connection;
  }
  public putConnection(value: TransferEndpointSettingsClickhouseSourceConnection) {
    this._connection.internalValue = value;
  }
  public resetConnection() {
    this._connection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionInput() {
    return this._connection.internalValue;
  }
}
export interface TransferEndpointSettingsClickhouseTargetAltName {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#from_name TransferEndpoint#from_name}
  */
  readonly fromName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#to_name TransferEndpoint#to_name}
  */
  readonly toName?: string;
}

export function transferEndpointSettingsClickhouseTargetAltNameToTerraform(struct?: TransferEndpointSettingsClickhouseTargetAltName | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    from_name: cdktf.stringToTerraform(struct!.fromName),
    to_name: cdktf.stringToTerraform(struct!.toName),
  }
}


export function transferEndpointSettingsClickhouseTargetAltNameToHclTerraform(struct?: TransferEndpointSettingsClickhouseTargetAltName | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    from_name: {
      value: cdktf.stringToHclTerraform(struct!.fromName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    to_name: {
      value: cdktf.stringToHclTerraform(struct!.toName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseTargetAltNameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseTargetAltName | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fromName !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromName = this._fromName;
    }
    if (this._toName !== undefined) {
      hasAnyValues = true;
      internalValueResult.toName = this._toName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseTargetAltName | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fromName = undefined;
      this._toName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fromName = value.fromName;
      this._toName = value.toName;
    }
  }

  // from_name - computed: false, optional: true, required: false
  private _fromName?: string; 
  public get fromName() {
    return this.getStringAttribute('from_name');
  }
  public set fromName(value: string) {
    this._fromName = value;
  }
  public resetFromName() {
    this._fromName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromNameInput() {
    return this._fromName;
  }

  // to_name - computed: false, optional: true, required: false
  private _toName?: string; 
  public get toName() {
    return this.getStringAttribute('to_name');
  }
  public set toName(value: string) {
    this._toName = value;
  }
  public resetToName() {
    this._toName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toNameInput() {
    return this._toName;
  }
}

export class TransferEndpointSettingsClickhouseTargetAltNameList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsClickhouseTargetAltName[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsClickhouseTargetAltNameOutputReference {
    return new TransferEndpointSettingsClickhouseTargetAltNameOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShard {
  /**
  * List of hosts
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#hosts TransferEndpoint#hosts}
  */
  readonly hosts?: string[];
  /**
  * Name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#name TransferEndpoint#name}
  */
  readonly name?: string;
}

export function transferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShardToTerraform(struct?: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function transferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShardToHclTerraform(struct?: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hosts = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hosts = value.hosts;
      this._name = value.name;
    }
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  public resetHosts() {
    this._hosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShardList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShard[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShardOutputReference {
    return new TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShardOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsMode {
  /**
  * X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. When CA certificate is specified TLS is used to connect to the server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ca_certificate TransferEndpoint#ca_certificate}
  */
  readonly caCertificate?: string;
}

export function transferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsModeToTerraform(struct?: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificate: cdktf.stringToTerraform(struct!.caCertificate),
  }
}


export function transferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsModeToHclTerraform(struct?: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.caCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificate = this._caCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificate = value.caCertificate;
    }
  }

  // ca_certificate - computed: false, optional: true, required: false
  private _caCertificate?: string; 
  public get caCertificate() {
    return this.getStringAttribute('ca_certificate');
  }
  public set caCertificate(value: string) {
    this._caCertificate = value;
  }
  public resetCaCertificate() {
    this._caCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificateInput() {
    return this._caCertificate;
  }
}
export interface TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremise {
  /**
  * HTTP port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#http_port TransferEndpoint#http_port}
  */
  readonly httpPort?: number;
  /**
  * Native port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#native_port TransferEndpoint#native_port}
  */
  readonly nativePort?: number;
  /**
  * shard block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#shard TransferEndpoint#shard}
  */
  readonly shard?: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShard[] | cdktf.IResolvable;
  /**
  * tls_mode block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tls_mode TransferEndpoint#tls_mode}
  */
  readonly tlsMode?: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsMode;
}

export function transferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseToTerraform(struct?: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http_port: cdktf.numberToTerraform(struct!.httpPort),
    native_port: cdktf.numberToTerraform(struct!.nativePort),
    shard: cdktf.listMapper(transferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShardToTerraform, true)(struct!.shard),
    tls_mode: transferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsModeToTerraform(struct!.tlsMode),
  }
}


export function transferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseToHclTerraform(struct?: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http_port: {
      value: cdktf.numberToHclTerraform(struct!.httpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    native_port: {
      value: cdktf.numberToHclTerraform(struct!.nativePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    shard: {
      value: cdktf.listMapperHcl(transferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShardToHclTerraform, true)(struct!.shard),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShardList",
    },
    tls_mode: {
      value: transferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsModeToHclTerraform(struct!.tlsMode),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsMode",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._httpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPort = this._httpPort;
    }
    if (this._nativePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.nativePort = this._nativePort;
    }
    if (this._shard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.shard = this._shard?.internalValue;
    }
    if (this._tlsMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMode = this._tlsMode?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._httpPort = undefined;
      this._nativePort = undefined;
      this._shard.internalValue = undefined;
      this._tlsMode.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._httpPort = value.httpPort;
      this._nativePort = value.nativePort;
      this._shard.internalValue = value.shard;
      this._tlsMode.internalValue = value.tlsMode;
    }
  }

  // http_port - computed: true, optional: true, required: false
  private _httpPort?: number; 
  public get httpPort() {
    return this.getNumberAttribute('http_port');
  }
  public set httpPort(value: number) {
    this._httpPort = value;
  }
  public resetHttpPort() {
    this._httpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPortInput() {
    return this._httpPort;
  }

  // native_port - computed: true, optional: true, required: false
  private _nativePort?: number; 
  public get nativePort() {
    return this.getNumberAttribute('native_port');
  }
  public set nativePort(value: number) {
    this._nativePort = value;
  }
  public resetNativePort() {
    this._nativePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nativePortInput() {
    return this._nativePort;
  }

  // shard - computed: false, optional: true, required: false
  private _shard = new TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShardList(this, "shard", false);
  public get shard() {
    return this._shard;
  }
  public putShard(value: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseShard[] | cdktf.IResolvable) {
    this._shard.internalValue = value;
  }
  public resetShard() {
    this._shard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shardInput() {
    return this._shard.internalValue;
  }

  // tls_mode - computed: false, optional: true, required: false
  private _tlsMode = new TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsModeOutputReference(this, "tls_mode");
  public get tlsMode() {
    return this._tlsMode;
  }
  public putTlsMode(value: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseTlsMode) {
    this._tlsMode.internalValue = value;
  }
  public resetTlsMode() {
    this._tlsMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsModeInput() {
    return this._tlsMode.internalValue;
  }
}
export interface TransferEndpointSettingsClickhouseTargetConnectionAddress {
  /**
  * Cluster ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#cluster_id TransferEndpoint#cluster_id}
  */
  readonly clusterId?: string;
  /**
  * on_premise block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#on_premise TransferEndpoint#on_premise}
  */
  readonly onPremise?: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremise;
}

export function transferEndpointSettingsClickhouseTargetConnectionAddressToTerraform(struct?: TransferEndpointSettingsClickhouseTargetConnectionAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_id: cdktf.stringToTerraform(struct!.clusterId),
    on_premise: transferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseToTerraform(struct!.onPremise),
  }
}


export function transferEndpointSettingsClickhouseTargetConnectionAddressToHclTerraform(struct?: TransferEndpointSettingsClickhouseTargetConnectionAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.clusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_premise: {
      value: transferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseToHclTerraform(struct!.onPremise),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremise",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseTargetConnectionAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseTargetConnectionAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterId = this._clusterId;
    }
    if (this._onPremise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.onPremise = this._onPremise?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseTargetConnectionAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterId = undefined;
      this._onPremise.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterId = value.clusterId;
      this._onPremise.internalValue = value.onPremise;
    }
  }

  // cluster_id - computed: false, optional: true, required: false
  private _clusterId?: string; 
  public get clusterId() {
    return this.getStringAttribute('cluster_id');
  }
  public set clusterId(value: string) {
    this._clusterId = value;
  }
  public resetClusterId() {
    this._clusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIdInput() {
    return this._clusterId;
  }

  // on_premise - computed: false, optional: true, required: false
  private _onPremise = new TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremiseOutputReference(this, "on_premise");
  public get onPremise() {
    return this._onPremise;
  }
  public putOnPremise(value: TransferEndpointSettingsClickhouseTargetConnectionAddressOnPremise) {
    this._onPremise.internalValue = value;
  }
  public resetOnPremise() {
    this._onPremise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onPremiseInput() {
    return this._onPremise.internalValue;
  }
}
export interface TransferEndpointSettingsClickhouseTargetConnection {
  /**
  * Database
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#database TransferEndpoint#database}
  */
  readonly database?: string;
  /**
  * Database user password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * Database user
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#user TransferEndpoint#user}
  */
  readonly user?: string;
  /**
  * address block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#address TransferEndpoint#address}
  */
  readonly address?: TransferEndpointSettingsClickhouseTargetConnectionAddress;
}

export function transferEndpointSettingsClickhouseTargetConnectionToTerraform(struct?: TransferEndpointSettingsClickhouseTargetConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    database: cdktf.stringToTerraform(struct!.database),
    password: cdktf.stringToTerraform(struct!.password),
    user: cdktf.stringToTerraform(struct!.user),
    address: transferEndpointSettingsClickhouseTargetConnectionAddressToTerraform(struct!.address),
  }
}


export function transferEndpointSettingsClickhouseTargetConnectionToHclTerraform(struct?: TransferEndpointSettingsClickhouseTargetConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    address: {
      value: transferEndpointSettingsClickhouseTargetConnectionAddressToHclTerraform(struct!.address),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsClickhouseTargetConnectionAddress",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseTargetConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseTargetConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._address?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseTargetConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._database = undefined;
      this._password = undefined;
      this._user = undefined;
      this._address.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._database = value.database;
      this._password = value.password;
      this._user = value.user;
      this._address.internalValue = value.address;
    }
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // address - computed: false, optional: true, required: false
  private _address = new TransferEndpointSettingsClickhouseTargetConnectionAddressOutputReference(this, "address");
  public get address() {
    return this._address;
  }
  public putAddress(value: TransferEndpointSettingsClickhouseTargetConnectionAddress) {
    this._address.internalValue = value;
  }
  public resetAddress() {
    this._address.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address.internalValue;
  }
}
export interface TransferEndpointSettingsClickhouseTarget {
  /**
  * ClickHouse cleanup policy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#clickhouse_cleanup_policy TransferEndpoint#clickhouse_cleanup_policy}
  */
  readonly clickhouseCleanupPolicy?: string;
  /**
  * ClickHouse cluster name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#clickhouse_cluster_name TransferEndpoint#clickhouse_cluster_name}
  */
  readonly clickhouseClusterName?: string;
  /**
  * alt_name block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#alt_name TransferEndpoint#alt_name}
  */
  readonly altName?: TransferEndpointSettingsClickhouseTargetAltName[] | cdktf.IResolvable;
  /**
  * connection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection TransferEndpoint#connection}
  */
  readonly connection?: TransferEndpointSettingsClickhouseTargetConnection;
}

export function transferEndpointSettingsClickhouseTargetToTerraform(struct?: TransferEndpointSettingsClickhouseTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clickhouse_cleanup_policy: cdktf.stringToTerraform(struct!.clickhouseCleanupPolicy),
    clickhouse_cluster_name: cdktf.stringToTerraform(struct!.clickhouseClusterName),
    alt_name: cdktf.listMapper(transferEndpointSettingsClickhouseTargetAltNameToTerraform, true)(struct!.altName),
    connection: transferEndpointSettingsClickhouseTargetConnectionToTerraform(struct!.connection),
  }
}


export function transferEndpointSettingsClickhouseTargetToHclTerraform(struct?: TransferEndpointSettingsClickhouseTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clickhouse_cleanup_policy: {
      value: cdktf.stringToHclTerraform(struct!.clickhouseCleanupPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clickhouse_cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clickhouseClusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    alt_name: {
      value: cdktf.listMapperHcl(transferEndpointSettingsClickhouseTargetAltNameToHclTerraform, true)(struct!.altName),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsClickhouseTargetAltNameList",
    },
    connection: {
      value: transferEndpointSettingsClickhouseTargetConnectionToHclTerraform(struct!.connection),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsClickhouseTargetConnection",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsClickhouseTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsClickhouseTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clickhouseCleanupPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.clickhouseCleanupPolicy = this._clickhouseCleanupPolicy;
    }
    if (this._clickhouseClusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clickhouseClusterName = this._clickhouseClusterName;
    }
    if (this._altName?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.altName = this._altName?.internalValue;
    }
    if (this._connection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connection = this._connection?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsClickhouseTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clickhouseCleanupPolicy = undefined;
      this._clickhouseClusterName = undefined;
      this._altName.internalValue = undefined;
      this._connection.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clickhouseCleanupPolicy = value.clickhouseCleanupPolicy;
      this._clickhouseClusterName = value.clickhouseClusterName;
      this._altName.internalValue = value.altName;
      this._connection.internalValue = value.connection;
    }
  }

  // clickhouse_cleanup_policy - computed: true, optional: true, required: false
  private _clickhouseCleanupPolicy?: string; 
  public get clickhouseCleanupPolicy() {
    return this.getStringAttribute('clickhouse_cleanup_policy');
  }
  public set clickhouseCleanupPolicy(value: string) {
    this._clickhouseCleanupPolicy = value;
  }
  public resetClickhouseCleanupPolicy() {
    this._clickhouseCleanupPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clickhouseCleanupPolicyInput() {
    return this._clickhouseCleanupPolicy;
  }

  // clickhouse_cluster_name - computed: true, optional: true, required: false
  private _clickhouseClusterName?: string; 
  public get clickhouseClusterName() {
    return this.getStringAttribute('clickhouse_cluster_name');
  }
  public set clickhouseClusterName(value: string) {
    this._clickhouseClusterName = value;
  }
  public resetClickhouseClusterName() {
    this._clickhouseClusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clickhouseClusterNameInput() {
    return this._clickhouseClusterName;
  }

  // alt_name - computed: false, optional: true, required: false
  private _altName = new TransferEndpointSettingsClickhouseTargetAltNameList(this, "alt_name", false);
  public get altName() {
    return this._altName;
  }
  public putAltName(value: TransferEndpointSettingsClickhouseTargetAltName[] | cdktf.IResolvable) {
    this._altName.internalValue = value;
  }
  public resetAltName() {
    this._altName.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get altNameInput() {
    return this._altName.internalValue;
  }

  // connection - computed: false, optional: true, required: false
  private _connection = new TransferEndpointSettingsClickhouseTargetConnectionOutputReference(this, "connection");
  public get connection() {
    return this._connection;
  }
  public putConnection(value: TransferEndpointSettingsClickhouseTargetConnection) {
    this._connection.internalValue = value;
  }
  public resetConnection() {
    this._connection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionInput() {
    return this._connection.internalValue;
  }
}
export interface TransferEndpointSettingsFacebookmarketingSourceCustomInsights {
  /**
  * `action_breakdowns` request parameter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#action_breakdowns TransferEndpoint#action_breakdowns}
  */
  readonly actionBreakdowns?: string[];
  /**
  * `breakdowns` request parameter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#breakdowns TransferEndpoint#breakdowns}
  */
  readonly breakdowns?: string[];
  /**
  * `fields` request parameter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#fields TransferEndpoint#fields}
  */
  readonly fields?: string[];
  /**
  * Insight name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#name TransferEndpoint#name}
  */
  readonly name?: string;
}

export function transferEndpointSettingsFacebookmarketingSourceCustomInsightsToTerraform(struct?: TransferEndpointSettingsFacebookmarketingSourceCustomInsights | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action_breakdowns: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.actionBreakdowns),
    breakdowns: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakdowns),
    fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fields),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function transferEndpointSettingsFacebookmarketingSourceCustomInsightsToHclTerraform(struct?: TransferEndpointSettingsFacebookmarketingSourceCustomInsights | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action_breakdowns: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.actionBreakdowns),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    breakdowns: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakdowns),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsFacebookmarketingSourceCustomInsightsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsFacebookmarketingSourceCustomInsights | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actionBreakdowns !== undefined) {
      hasAnyValues = true;
      internalValueResult.actionBreakdowns = this._actionBreakdowns;
    }
    if (this._breakdowns !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakdowns = this._breakdowns;
    }
    if (this._fields !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsFacebookmarketingSourceCustomInsights | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actionBreakdowns = undefined;
      this._breakdowns = undefined;
      this._fields = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actionBreakdowns = value.actionBreakdowns;
      this._breakdowns = value.breakdowns;
      this._fields = value.fields;
      this._name = value.name;
    }
  }

  // action_breakdowns - computed: false, optional: true, required: false
  private _actionBreakdowns?: string[]; 
  public get actionBreakdowns() {
    return this.getListAttribute('action_breakdowns');
  }
  public set actionBreakdowns(value: string[]) {
    this._actionBreakdowns = value;
  }
  public resetActionBreakdowns() {
    this._actionBreakdowns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionBreakdownsInput() {
    return this._actionBreakdowns;
  }

  // breakdowns - computed: false, optional: true, required: false
  private _breakdowns?: string[]; 
  public get breakdowns() {
    return this.getListAttribute('breakdowns');
  }
  public set breakdowns(value: string[]) {
    this._breakdowns = value;
  }
  public resetBreakdowns() {
    this._breakdowns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakdownsInput() {
    return this._breakdowns;
  }

  // fields - computed: false, optional: true, required: false
  private _fields?: string[]; 
  public get fields() {
    return this.getListAttribute('fields');
  }
  public set fields(value: string[]) {
    this._fields = value;
  }
  public resetFields() {
    this._fields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class TransferEndpointSettingsFacebookmarketingSourceCustomInsightsList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsFacebookmarketingSourceCustomInsights[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsFacebookmarketingSourceCustomInsightsOutputReference {
    return new TransferEndpointSettingsFacebookmarketingSourceCustomInsightsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsFacebookmarketingSource {
  /**
  * The value of the access token. See  [documentation](https://docs.airbyte.io/integrations/sources/facebook-marketing) for more information on the meaning of this token and how to obtain it
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#access_token TransferEndpoint#access_token}
  */
  readonly accessToken?: string;
  /**
  * The Facebook Ad account ID to use when pulling data from the Facebook Marketing API. Example: `111111111111111`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#account_id TransferEndpoint#account_id}
  */
  readonly accountId?: string;
  /**
  * Insights. Each entry must have a name and can contains `fields`, `breakdowns`, or `action_breakdowns`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#custom_insights TransferEndpoint#custom_insights}
  */
  readonly customInsights?: TransferEndpointSettingsFacebookmarketingSourceCustomInsights[] | cdktf.IResolvable;
  /**
  * The date until which you'd like to replicate data for all incremental streams, in the format `YYYY-MM-DDT00:00:00Z`. All data generated between `start_date` and this date will be replicated. Not setting this option will result in always syncing the latest data. Example: `2017-01-25T23:59:59Z`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#end_date TransferEndpoint#end_date}
  */
  readonly endDate?: string;
  /**
  * In each Ad Creative, fetch the `thumbnail_url` and store the result in `thumbnail_data_url`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#fetch_thumbnail_images TransferEndpoint#fetch_thumbnail_images}
  */
  readonly fetchThumbnailImages?: boolean | cdktf.IResolvable;
  /**
  * Include data from deleted Campaigns, Ads, and AdSets
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#include_deleted TransferEndpoint#include_deleted}
  */
  readonly includeDeleted?: boolean | cdktf.IResolvable;
  /**
  * The date from which to replicate data for all incremental streams, in the format `YYYY-MM-DDT00:00:00Z`. All data generated after this date and before `end_date` (if set) will be replicated. Example: `2017-01-25T00:00:00Z`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#start_date TransferEndpoint#start_date}
  */
  readonly startDate?: string;
}

export function transferEndpointSettingsFacebookmarketingSourceToTerraform(struct?: TransferEndpointSettingsFacebookmarketingSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: cdktf.stringToTerraform(struct!.accessToken),
    account_id: cdktf.stringToTerraform(struct!.accountId),
    custom_insights: cdktf.listMapper(transferEndpointSettingsFacebookmarketingSourceCustomInsightsToTerraform, false)(struct!.customInsights),
    end_date: cdktf.stringToTerraform(struct!.endDate),
    fetch_thumbnail_images: cdktf.booleanToTerraform(struct!.fetchThumbnailImages),
    include_deleted: cdktf.booleanToTerraform(struct!.includeDeleted),
    start_date: cdktf.stringToTerraform(struct!.startDate),
  }
}


export function transferEndpointSettingsFacebookmarketingSourceToHclTerraform(struct?: TransferEndpointSettingsFacebookmarketingSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: cdktf.stringToHclTerraform(struct!.accessToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    account_id: {
      value: cdktf.stringToHclTerraform(struct!.accountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_insights: {
      value: cdktf.listMapperHcl(transferEndpointSettingsFacebookmarketingSourceCustomInsightsToHclTerraform, false)(struct!.customInsights),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsFacebookmarketingSourceCustomInsightsList",
    },
    end_date: {
      value: cdktf.stringToHclTerraform(struct!.endDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    fetch_thumbnail_images: {
      value: cdktf.booleanToHclTerraform(struct!.fetchThumbnailImages),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    include_deleted: {
      value: cdktf.booleanToHclTerraform(struct!.includeDeleted),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    start_date: {
      value: cdktf.stringToHclTerraform(struct!.startDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsFacebookmarketingSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsFacebookmarketingSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken;
    }
    if (this._accountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.accountId = this._accountId;
    }
    if (this._customInsights?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customInsights = this._customInsights?.internalValue;
    }
    if (this._endDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.endDate = this._endDate;
    }
    if (this._fetchThumbnailImages !== undefined) {
      hasAnyValues = true;
      internalValueResult.fetchThumbnailImages = this._fetchThumbnailImages;
    }
    if (this._includeDeleted !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeDeleted = this._includeDeleted;
    }
    if (this._startDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.startDate = this._startDate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsFacebookmarketingSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken = undefined;
      this._accountId = undefined;
      this._customInsights.internalValue = undefined;
      this._endDate = undefined;
      this._fetchThumbnailImages = undefined;
      this._includeDeleted = undefined;
      this._startDate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken = value.accessToken;
      this._accountId = value.accountId;
      this._customInsights.internalValue = value.customInsights;
      this._endDate = value.endDate;
      this._fetchThumbnailImages = value.fetchThumbnailImages;
      this._includeDeleted = value.includeDeleted;
      this._startDate = value.startDate;
    }
  }

  // access_token - computed: false, optional: true, required: false
  private _accessToken?: string; 
  public get accessToken() {
    return this.getStringAttribute('access_token');
  }
  public set accessToken(value: string) {
    this._accessToken = value;
  }
  public resetAccessToken() {
    this._accessToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken;
  }

  // account_id - computed: false, optional: true, required: false
  private _accountId?: string; 
  public get accountId() {
    return this.getStringAttribute('account_id');
  }
  public set accountId(value: string) {
    this._accountId = value;
  }
  public resetAccountId() {
    this._accountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accountIdInput() {
    return this._accountId;
  }

  // custom_insights - computed: false, optional: true, required: false
  private _customInsights = new TransferEndpointSettingsFacebookmarketingSourceCustomInsightsList(this, "custom_insights", false);
  public get customInsights() {
    return this._customInsights;
  }
  public putCustomInsights(value: TransferEndpointSettingsFacebookmarketingSourceCustomInsights[] | cdktf.IResolvable) {
    this._customInsights.internalValue = value;
  }
  public resetCustomInsights() {
    this._customInsights.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customInsightsInput() {
    return this._customInsights.internalValue;
  }

  // end_date - computed: false, optional: true, required: false
  private _endDate?: string; 
  public get endDate() {
    return this.getStringAttribute('end_date');
  }
  public set endDate(value: string) {
    this._endDate = value;
  }
  public resetEndDate() {
    this._endDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endDateInput() {
    return this._endDate;
  }

  // fetch_thumbnail_images - computed: true, optional: true, required: false
  private _fetchThumbnailImages?: boolean | cdktf.IResolvable; 
  public get fetchThumbnailImages() {
    return this.getBooleanAttribute('fetch_thumbnail_images');
  }
  public set fetchThumbnailImages(value: boolean | cdktf.IResolvable) {
    this._fetchThumbnailImages = value;
  }
  public resetFetchThumbnailImages() {
    this._fetchThumbnailImages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fetchThumbnailImagesInput() {
    return this._fetchThumbnailImages;
  }

  // include_deleted - computed: true, optional: true, required: false
  private _includeDeleted?: boolean | cdktf.IResolvable; 
  public get includeDeleted() {
    return this.getBooleanAttribute('include_deleted');
  }
  public set includeDeleted(value: boolean | cdktf.IResolvable) {
    this._includeDeleted = value;
  }
  public resetIncludeDeleted() {
    this._includeDeleted = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeDeletedInput() {
    return this._includeDeleted;
  }

  // start_date - computed: false, optional: true, required: false
  private _startDate?: string; 
  public get startDate() {
    return this.getStringAttribute('start_date');
  }
  public set startDate(value: string) {
    this._startDate = value;
  }
  public resetStartDate() {
    this._startDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startDateInput() {
    return this._startDate;
  }
}
export interface TransferEndpointSettingsGoogleadsSourceCustomQueries {
  /**
  * Query
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#query TransferEndpoint#query}
  */
  readonly query?: string;
  /**
  * Table name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#table_name TransferEndpoint#table_name}
  */
  readonly tableName?: string;
}

export function transferEndpointSettingsGoogleadsSourceCustomQueriesToTerraform(struct?: TransferEndpointSettingsGoogleadsSourceCustomQueries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    query: cdktf.stringToTerraform(struct!.query),
    table_name: cdktf.stringToTerraform(struct!.tableName),
  }
}


export function transferEndpointSettingsGoogleadsSourceCustomQueriesToHclTerraform(struct?: TransferEndpointSettingsGoogleadsSourceCustomQueries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    query: {
      value: cdktf.stringToHclTerraform(struct!.query),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    table_name: {
      value: cdktf.stringToHclTerraform(struct!.tableName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsGoogleadsSourceCustomQueriesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsGoogleadsSourceCustomQueries | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._query !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query;
    }
    if (this._tableName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tableName = this._tableName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsGoogleadsSourceCustomQueries | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._query = undefined;
      this._tableName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._query = value.query;
      this._tableName = value.tableName;
    }
  }

  // query - computed: false, optional: true, required: false
  private _query?: string; 
  public get query() {
    return this.getStringAttribute('query');
  }
  public set query(value: string) {
    this._query = value;
  }
  public resetQuery() {
    this._query = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query;
  }

  // table_name - computed: false, optional: true, required: false
  private _tableName?: string; 
  public get tableName() {
    return this.getStringAttribute('table_name');
  }
  public set tableName(value: string) {
    this._tableName = value;
  }
  public resetTableName() {
    this._tableName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tableNameInput() {
    return this._tableName;
  }
}

export class TransferEndpointSettingsGoogleadsSourceCustomQueriesList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsGoogleadsSourceCustomQueries[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsGoogleadsSourceCustomQueriesOutputReference {
    return new TransferEndpointSettingsGoogleadsSourceCustomQueriesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsGoogleadsSourceCredentials {
  /**
  * Access token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#access_token TransferEndpoint#access_token}
  */
  readonly accessToken?: string;
  /**
  * Client ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#client_id TransferEndpoint#client_id}
  */
  readonly clientId?: string;
  /**
  * Client secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#client_secret TransferEndpoint#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Developer token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#developer_token TransferEndpoint#developer_token}
  */
  readonly developerToken?: string;
  /**
  * Refresh token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#refresh_token TransferEndpoint#refresh_token}
  */
  readonly refreshToken?: string;
}

export function transferEndpointSettingsGoogleadsSourceCredentialsToTerraform(struct?: TransferEndpointSettingsGoogleadsSourceCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: cdktf.stringToTerraform(struct!.accessToken),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    developer_token: cdktf.stringToTerraform(struct!.developerToken),
    refresh_token: cdktf.stringToTerraform(struct!.refreshToken),
  }
}


export function transferEndpointSettingsGoogleadsSourceCredentialsToHclTerraform(struct?: TransferEndpointSettingsGoogleadsSourceCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: cdktf.stringToHclTerraform(struct!.accessToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    developer_token: {
      value: cdktf.stringToHclTerraform(struct!.developerToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    refresh_token: {
      value: cdktf.stringToHclTerraform(struct!.refreshToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsGoogleadsSourceCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsGoogleadsSourceCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._developerToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.developerToken = this._developerToken;
    }
    if (this._refreshToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.refreshToken = this._refreshToken;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsGoogleadsSourceCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken = undefined;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._developerToken = undefined;
      this._refreshToken = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken = value.accessToken;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._developerToken = value.developerToken;
      this._refreshToken = value.refreshToken;
    }
  }

  // access_token - computed: false, optional: true, required: false
  private _accessToken?: string; 
  public get accessToken() {
    return this.getStringAttribute('access_token');
  }
  public set accessToken(value: string) {
    this._accessToken = value;
  }
  public resetAccessToken() {
    this._accessToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken;
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // developer_token - computed: false, optional: true, required: false
  private _developerToken?: string; 
  public get developerToken() {
    return this.getStringAttribute('developer_token');
  }
  public set developerToken(value: string) {
    this._developerToken = value;
  }
  public resetDeveloperToken() {
    this._developerToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get developerTokenInput() {
    return this._developerToken;
  }

  // refresh_token - computed: false, optional: true, required: false
  private _refreshToken?: string; 
  public get refreshToken() {
    return this.getStringAttribute('refresh_token');
  }
  public set refreshToken(value: string) {
    this._refreshToken = value;
  }
  public resetRefreshToken() {
    this._refreshToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refreshTokenInput() {
    return this._refreshToken;
  }
}
export interface TransferEndpointSettingsGoogleadsSource {
  /**
  * Conversion window in days
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#conversion_window_days TransferEndpoint#conversion_window_days}
  */
  readonly conversionWindowDays?: number;
  /**
  * Custom queries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#custom_queries TransferEndpoint#custom_queries}
  */
  readonly customQueries?: TransferEndpointSettingsGoogleadsSourceCustomQueries[] | cdktf.IResolvable;
  /**
  * Customer ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#customer_id TransferEndpoint#customer_id}
  */
  readonly customerId?: string;
  /**
  * End date
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#end_date TransferEndpoint#end_date}
  */
  readonly endDate?: string;
  /**
  * Login customer ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#login_customer_id TransferEndpoint#login_customer_id}
  */
  readonly loginCustomerId?: string;
  /**
  * Start date
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#start_date TransferEndpoint#start_date}
  */
  readonly startDate?: string;
  /**
  * credentials block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#credentials TransferEndpoint#credentials}
  */
  readonly credentials?: TransferEndpointSettingsGoogleadsSourceCredentials;
}

export function transferEndpointSettingsGoogleadsSourceToTerraform(struct?: TransferEndpointSettingsGoogleadsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    conversion_window_days: cdktf.numberToTerraform(struct!.conversionWindowDays),
    custom_queries: cdktf.listMapper(transferEndpointSettingsGoogleadsSourceCustomQueriesToTerraform, false)(struct!.customQueries),
    customer_id: cdktf.stringToTerraform(struct!.customerId),
    end_date: cdktf.stringToTerraform(struct!.endDate),
    login_customer_id: cdktf.stringToTerraform(struct!.loginCustomerId),
    start_date: cdktf.stringToTerraform(struct!.startDate),
    credentials: transferEndpointSettingsGoogleadsSourceCredentialsToTerraform(struct!.credentials),
  }
}


export function transferEndpointSettingsGoogleadsSourceToHclTerraform(struct?: TransferEndpointSettingsGoogleadsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    conversion_window_days: {
      value: cdktf.numberToHclTerraform(struct!.conversionWindowDays),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_queries: {
      value: cdktf.listMapperHcl(transferEndpointSettingsGoogleadsSourceCustomQueriesToHclTerraform, false)(struct!.customQueries),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsGoogleadsSourceCustomQueriesList",
    },
    customer_id: {
      value: cdktf.stringToHclTerraform(struct!.customerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    end_date: {
      value: cdktf.stringToHclTerraform(struct!.endDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_customer_id: {
      value: cdktf.stringToHclTerraform(struct!.loginCustomerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start_date: {
      value: cdktf.stringToHclTerraform(struct!.startDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials: {
      value: transferEndpointSettingsGoogleadsSourceCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsGoogleadsSourceCredentials",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsGoogleadsSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsGoogleadsSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._conversionWindowDays !== undefined) {
      hasAnyValues = true;
      internalValueResult.conversionWindowDays = this._conversionWindowDays;
    }
    if (this._customQueries?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customQueries = this._customQueries?.internalValue;
    }
    if (this._customerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.customerId = this._customerId;
    }
    if (this._endDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.endDate = this._endDate;
    }
    if (this._loginCustomerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginCustomerId = this._loginCustomerId;
    }
    if (this._startDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.startDate = this._startDate;
    }
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsGoogleadsSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._conversionWindowDays = undefined;
      this._customQueries.internalValue = undefined;
      this._customerId = undefined;
      this._endDate = undefined;
      this._loginCustomerId = undefined;
      this._startDate = undefined;
      this._credentials.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._conversionWindowDays = value.conversionWindowDays;
      this._customQueries.internalValue = value.customQueries;
      this._customerId = value.customerId;
      this._endDate = value.endDate;
      this._loginCustomerId = value.loginCustomerId;
      this._startDate = value.startDate;
      this._credentials.internalValue = value.credentials;
    }
  }

  // conversion_window_days - computed: false, optional: true, required: false
  private _conversionWindowDays?: number; 
  public get conversionWindowDays() {
    return this.getNumberAttribute('conversion_window_days');
  }
  public set conversionWindowDays(value: number) {
    this._conversionWindowDays = value;
  }
  public resetConversionWindowDays() {
    this._conversionWindowDays = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conversionWindowDaysInput() {
    return this._conversionWindowDays;
  }

  // custom_queries - computed: false, optional: true, required: false
  private _customQueries = new TransferEndpointSettingsGoogleadsSourceCustomQueriesList(this, "custom_queries", false);
  public get customQueries() {
    return this._customQueries;
  }
  public putCustomQueries(value: TransferEndpointSettingsGoogleadsSourceCustomQueries[] | cdktf.IResolvable) {
    this._customQueries.internalValue = value;
  }
  public resetCustomQueries() {
    this._customQueries.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customQueriesInput() {
    return this._customQueries.internalValue;
  }

  // customer_id - computed: false, optional: true, required: false
  private _customerId?: string; 
  public get customerId() {
    return this.getStringAttribute('customer_id');
  }
  public set customerId(value: string) {
    this._customerId = value;
  }
  public resetCustomerId() {
    this._customerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customerIdInput() {
    return this._customerId;
  }

  // end_date - computed: false, optional: true, required: false
  private _endDate?: string; 
  public get endDate() {
    return this.getStringAttribute('end_date');
  }
  public set endDate(value: string) {
    this._endDate = value;
  }
  public resetEndDate() {
    this._endDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endDateInput() {
    return this._endDate;
  }

  // login_customer_id - computed: false, optional: true, required: false
  private _loginCustomerId?: string; 
  public get loginCustomerId() {
    return this.getStringAttribute('login_customer_id');
  }
  public set loginCustomerId(value: string) {
    this._loginCustomerId = value;
  }
  public resetLoginCustomerId() {
    this._loginCustomerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginCustomerIdInput() {
    return this._loginCustomerId;
  }

  // start_date - computed: false, optional: true, required: false
  private _startDate?: string; 
  public get startDate() {
    return this.getStringAttribute('start_date');
  }
  public set startDate(value: string) {
    this._startDate = value;
  }
  public resetStartDate() {
    this._startDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startDateInput() {
    return this._startDate;
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new TransferEndpointSettingsGoogleadsSourceCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: TransferEndpointSettingsGoogleadsSourceCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }
}
export interface TransferEndpointSettingsHubspotSourceCredentialsPrivateApp {
  /**
  * Access token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#access_token TransferEndpoint#access_token}
  */
  readonly accessToken?: string;
}

export function transferEndpointSettingsHubspotSourceCredentialsPrivateAppToTerraform(struct?: TransferEndpointSettingsHubspotSourceCredentialsPrivateApp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: cdktf.stringToTerraform(struct!.accessToken),
  }
}


export function transferEndpointSettingsHubspotSourceCredentialsPrivateAppToHclTerraform(struct?: TransferEndpointSettingsHubspotSourceCredentialsPrivateApp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: cdktf.stringToHclTerraform(struct!.accessToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsHubspotSourceCredentialsPrivateAppOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsHubspotSourceCredentialsPrivateApp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsHubspotSourceCredentialsPrivateApp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken = value.accessToken;
    }
  }

  // access_token - computed: false, optional: true, required: false
  private _accessToken?: string; 
  public get accessToken() {
    return this.getStringAttribute('access_token');
  }
  public set accessToken(value: string) {
    this._accessToken = value;
  }
  public resetAccessToken() {
    this._accessToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken;
  }
}
export interface TransferEndpointSettingsHubspotSourceCredentials {
  /**
  * private_app block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#private_app TransferEndpoint#private_app}
  */
  readonly privateApp?: TransferEndpointSettingsHubspotSourceCredentialsPrivateApp;
}

export function transferEndpointSettingsHubspotSourceCredentialsToTerraform(struct?: TransferEndpointSettingsHubspotSourceCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    private_app: transferEndpointSettingsHubspotSourceCredentialsPrivateAppToTerraform(struct!.privateApp),
  }
}


export function transferEndpointSettingsHubspotSourceCredentialsToHclTerraform(struct?: TransferEndpointSettingsHubspotSourceCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    private_app: {
      value: transferEndpointSettingsHubspotSourceCredentialsPrivateAppToHclTerraform(struct!.privateApp),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsHubspotSourceCredentialsPrivateApp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsHubspotSourceCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsHubspotSourceCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._privateApp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateApp = this._privateApp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsHubspotSourceCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._privateApp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._privateApp.internalValue = value.privateApp;
    }
  }

  // private_app - computed: false, optional: true, required: false
  private _privateApp = new TransferEndpointSettingsHubspotSourceCredentialsPrivateAppOutputReference(this, "private_app");
  public get privateApp() {
    return this._privateApp;
  }
  public putPrivateApp(value: TransferEndpointSettingsHubspotSourceCredentialsPrivateApp) {
    this._privateApp.internalValue = value;
  }
  public resetPrivateApp() {
    this._privateApp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateAppInput() {
    return this._privateApp.internalValue;
  }
}
export interface TransferEndpointSettingsHubspotSource {
  /**
  * If enabled then experimental streams become available for sync.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#enable_experimental_streams TransferEndpoint#enable_experimental_streams}
  */
  readonly enableExperimentalStreams?: boolean | cdktf.IResolvable;
  /**
  * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#start_date TransferEndpoint#start_date}
  */
  readonly startDate?: string;
  /**
  * credentials block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#credentials TransferEndpoint#credentials}
  */
  readonly credentials?: TransferEndpointSettingsHubspotSourceCredentials;
}

export function transferEndpointSettingsHubspotSourceToTerraform(struct?: TransferEndpointSettingsHubspotSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable_experimental_streams: cdktf.booleanToTerraform(struct!.enableExperimentalStreams),
    start_date: cdktf.stringToTerraform(struct!.startDate),
    credentials: transferEndpointSettingsHubspotSourceCredentialsToTerraform(struct!.credentials),
  }
}


export function transferEndpointSettingsHubspotSourceToHclTerraform(struct?: TransferEndpointSettingsHubspotSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable_experimental_streams: {
      value: cdktf.booleanToHclTerraform(struct!.enableExperimentalStreams),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    start_date: {
      value: cdktf.stringToHclTerraform(struct!.startDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials: {
      value: transferEndpointSettingsHubspotSourceCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsHubspotSourceCredentials",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsHubspotSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsHubspotSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enableExperimentalStreams !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableExperimentalStreams = this._enableExperimentalStreams;
    }
    if (this._startDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.startDate = this._startDate;
    }
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsHubspotSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enableExperimentalStreams = undefined;
      this._startDate = undefined;
      this._credentials.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enableExperimentalStreams = value.enableExperimentalStreams;
      this._startDate = value.startDate;
      this._credentials.internalValue = value.credentials;
    }
  }

  // enable_experimental_streams - computed: false, optional: true, required: false
  private _enableExperimentalStreams?: boolean | cdktf.IResolvable; 
  public get enableExperimentalStreams() {
    return this.getBooleanAttribute('enable_experimental_streams');
  }
  public set enableExperimentalStreams(value: boolean | cdktf.IResolvable) {
    this._enableExperimentalStreams = value;
  }
  public resetEnableExperimentalStreams() {
    this._enableExperimentalStreams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableExperimentalStreamsInput() {
    return this._enableExperimentalStreams;
  }

  // start_date - computed: false, optional: true, required: false
  private _startDate?: string; 
  public get startDate() {
    return this.getStringAttribute('start_date');
  }
  public set startDate(value: string) {
    this._startDate = value;
  }
  public resetStartDate() {
    this._startDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startDateInput() {
    return this._startDate;
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new TransferEndpointSettingsHubspotSourceCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: TransferEndpointSettingsHubspotSourceCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }
}
export interface TransferEndpointSettingsInstagramSource {
  /**
  * The value of the access token generated. See [Airbyte documentation](https://docs.airbyte.io/integrations/sources/instagram) for more information
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#access_token TransferEndpoint#access_token}
  */
  readonly accessToken?: string;
  /**
  * The date in format YYYY-MM-DDT00:00:00Z to start replicating data for User Insights. All data generated after this date will be replicated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#start_date TransferEndpoint#start_date}
  */
  readonly startDate?: string;
}

export function transferEndpointSettingsInstagramSourceToTerraform(struct?: TransferEndpointSettingsInstagramSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: cdktf.stringToTerraform(struct!.accessToken),
    start_date: cdktf.stringToTerraform(struct!.startDate),
  }
}


export function transferEndpointSettingsInstagramSourceToHclTerraform(struct?: TransferEndpointSettingsInstagramSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: cdktf.stringToHclTerraform(struct!.accessToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start_date: {
      value: cdktf.stringToHclTerraform(struct!.startDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsInstagramSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsInstagramSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken;
    }
    if (this._startDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.startDate = this._startDate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsInstagramSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken = undefined;
      this._startDate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken = value.accessToken;
      this._startDate = value.startDate;
    }
  }

  // access_token - computed: false, optional: true, required: false
  private _accessToken?: string; 
  public get accessToken() {
    return this.getStringAttribute('access_token');
  }
  public set accessToken(value: string) {
    this._accessToken = value;
  }
  public resetAccessToken() {
    this._accessToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken;
  }

  // start_date - computed: false, optional: true, required: false
  private _startDate?: string; 
  public get startDate() {
    return this.getStringAttribute('start_date');
  }
  public set startDate(value: string) {
    this._startDate = value;
  }
  public resetStartDate() {
    this._startDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startDateInput() {
    return this._startDate;
  }
}
export interface TransferEndpointSettingsJiraSource {
  /**
  * API token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#api_token TransferEndpoint#api_token}
  */
  readonly apiToken?: string;
  /**
  * Domain
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#domain TransferEndpoint#domain}
  */
  readonly domain?: string;
  /**
  * Email
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#email TransferEndpoint#email}
  */
  readonly email?: string;
  /**
  * Enable experimental streams
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#enable_experimental_streams TransferEndpoint#enable_experimental_streams}
  */
  readonly enableExperimentalStreams?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#issues_stream_expand_with TransferEndpoint#issues_stream_expand_with}
  */
  readonly issuesStreamExpandWith?: string[];
  /**
  * Projects
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#projects TransferEndpoint#projects}
  */
  readonly projects?: string[];
  /**
  * Start date
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#start_date TransferEndpoint#start_date}
  */
  readonly startDate?: string;
}

export function transferEndpointSettingsJiraSourceToTerraform(struct?: TransferEndpointSettingsJiraSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_token: cdktf.stringToTerraform(struct!.apiToken),
    domain: cdktf.stringToTerraform(struct!.domain),
    email: cdktf.stringToTerraform(struct!.email),
    enable_experimental_streams: cdktf.booleanToTerraform(struct!.enableExperimentalStreams),
    issues_stream_expand_with: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.issuesStreamExpandWith),
    projects: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.projects),
    start_date: cdktf.stringToTerraform(struct!.startDate),
  }
}


export function transferEndpointSettingsJiraSourceToHclTerraform(struct?: TransferEndpointSettingsJiraSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_token: {
      value: cdktf.stringToHclTerraform(struct!.apiToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    domain: {
      value: cdktf.stringToHclTerraform(struct!.domain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    email: {
      value: cdktf.stringToHclTerraform(struct!.email),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_experimental_streams: {
      value: cdktf.booleanToHclTerraform(struct!.enableExperimentalStreams),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    issues_stream_expand_with: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.issuesStreamExpandWith),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    projects: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.projects),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    start_date: {
      value: cdktf.stringToHclTerraform(struct!.startDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsJiraSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsJiraSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiToken = this._apiToken;
    }
    if (this._domain !== undefined) {
      hasAnyValues = true;
      internalValueResult.domain = this._domain;
    }
    if (this._email !== undefined) {
      hasAnyValues = true;
      internalValueResult.email = this._email;
    }
    if (this._enableExperimentalStreams !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableExperimentalStreams = this._enableExperimentalStreams;
    }
    if (this._issuesStreamExpandWith !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuesStreamExpandWith = this._issuesStreamExpandWith;
    }
    if (this._projects !== undefined) {
      hasAnyValues = true;
      internalValueResult.projects = this._projects;
    }
    if (this._startDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.startDate = this._startDate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsJiraSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiToken = undefined;
      this._domain = undefined;
      this._email = undefined;
      this._enableExperimentalStreams = undefined;
      this._issuesStreamExpandWith = undefined;
      this._projects = undefined;
      this._startDate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiToken = value.apiToken;
      this._domain = value.domain;
      this._email = value.email;
      this._enableExperimentalStreams = value.enableExperimentalStreams;
      this._issuesStreamExpandWith = value.issuesStreamExpandWith;
      this._projects = value.projects;
      this._startDate = value.startDate;
    }
  }

  // api_token - computed: false, optional: true, required: false
  private _apiToken?: string; 
  public get apiToken() {
    return this.getStringAttribute('api_token');
  }
  public set apiToken(value: string) {
    this._apiToken = value;
  }
  public resetApiToken() {
    this._apiToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiTokenInput() {
    return this._apiToken;
  }

  // domain - computed: false, optional: true, required: false
  private _domain?: string; 
  public get domain() {
    return this.getStringAttribute('domain');
  }
  public set domain(value: string) {
    this._domain = value;
  }
  public resetDomain() {
    this._domain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainInput() {
    return this._domain;
  }

  // email - computed: false, optional: true, required: false
  private _email?: string; 
  public get email() {
    return this.getStringAttribute('email');
  }
  public set email(value: string) {
    this._email = value;
  }
  public resetEmail() {
    this._email = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emailInput() {
    return this._email;
  }

  // enable_experimental_streams - computed: true, optional: true, required: false
  private _enableExperimentalStreams?: boolean | cdktf.IResolvable; 
  public get enableExperimentalStreams() {
    return this.getBooleanAttribute('enable_experimental_streams');
  }
  public set enableExperimentalStreams(value: boolean | cdktf.IResolvable) {
    this._enableExperimentalStreams = value;
  }
  public resetEnableExperimentalStreams() {
    this._enableExperimentalStreams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableExperimentalStreamsInput() {
    return this._enableExperimentalStreams;
  }

  // issues_stream_expand_with - computed: false, optional: true, required: false
  private _issuesStreamExpandWith?: string[]; 
  public get issuesStreamExpandWith() {
    return this.getListAttribute('issues_stream_expand_with');
  }
  public set issuesStreamExpandWith(value: string[]) {
    this._issuesStreamExpandWith = value;
  }
  public resetIssuesStreamExpandWith() {
    this._issuesStreamExpandWith = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get issuesStreamExpandWithInput() {
    return this._issuesStreamExpandWith;
  }

  // projects - computed: false, optional: true, required: false
  private _projects?: string[]; 
  public get projects() {
    return this.getListAttribute('projects');
  }
  public set projects(value: string[]) {
    this._projects = value;
  }
  public resetProjects() {
    this._projects = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectsInput() {
    return this._projects;
  }

  // start_date - computed: false, optional: true, required: false
  private _startDate?: string; 
  public get startDate() {
    return this.getStringAttribute('start_date');
  }
  public set startDate(value: string) {
    this._startDate = value;
  }
  public resetStartDate() {
    this._startDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startDateInput() {
    return this._startDate;
  }
}
export interface TransferEndpointSettingsKafkaSourceAuthNoAuth {
}

export function transferEndpointSettingsKafkaSourceAuthNoAuthToTerraform(struct?: TransferEndpointSettingsKafkaSourceAuthNoAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsKafkaSourceAuthNoAuthToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceAuthNoAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsKafkaSourceAuthNoAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceAuthNoAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceAuthNoAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsKafkaSourceAuthSasl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#mechanism TransferEndpoint#mechanism}
  */
  readonly mechanism?: string;
  /**
  * Password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * User
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#user TransferEndpoint#user}
  */
  readonly user?: string;
}

export function transferEndpointSettingsKafkaSourceAuthSaslToTerraform(struct?: TransferEndpointSettingsKafkaSourceAuthSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mechanism: cdktf.stringToTerraform(struct!.mechanism),
    password: cdktf.stringToTerraform(struct!.password),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function transferEndpointSettingsKafkaSourceAuthSaslToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceAuthSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mechanism: {
      value: cdktf.stringToHclTerraform(struct!.mechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceAuthSaslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceAuthSasl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.mechanism = this._mechanism;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceAuthSasl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mechanism = undefined;
      this._password = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mechanism = value.mechanism;
      this._password = value.password;
      this._user = value.user;
    }
  }

  // mechanism - computed: false, optional: true, required: false
  private _mechanism?: string; 
  public get mechanism() {
    return this.getStringAttribute('mechanism');
  }
  public set mechanism(value: string) {
    this._mechanism = value;
  }
  public resetMechanism() {
    this._mechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mechanismInput() {
    return this._mechanism;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface TransferEndpointSettingsKafkaSourceAuth {
  /**
  * no_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#no_auth TransferEndpoint#no_auth}
  */
  readonly noAuth?: TransferEndpointSettingsKafkaSourceAuthNoAuth;
  /**
  * sasl block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#sasl TransferEndpoint#sasl}
  */
  readonly sasl?: TransferEndpointSettingsKafkaSourceAuthSasl;
}

export function transferEndpointSettingsKafkaSourceAuthToTerraform(struct?: TransferEndpointSettingsKafkaSourceAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    no_auth: transferEndpointSettingsKafkaSourceAuthNoAuthToTerraform(struct!.noAuth),
    sasl: transferEndpointSettingsKafkaSourceAuthSaslToTerraform(struct!.sasl),
  }
}


export function transferEndpointSettingsKafkaSourceAuthToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    no_auth: {
      value: transferEndpointSettingsKafkaSourceAuthNoAuthToHclTerraform(struct!.noAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceAuthNoAuth",
    },
    sasl: {
      value: transferEndpointSettingsKafkaSourceAuthSaslToHclTerraform(struct!.sasl),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceAuthSasl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._noAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.noAuth = this._noAuth?.internalValue;
    }
    if (this._sasl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sasl = this._sasl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._noAuth.internalValue = undefined;
      this._sasl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._noAuth.internalValue = value.noAuth;
      this._sasl.internalValue = value.sasl;
    }
  }

  // no_auth - computed: false, optional: true, required: true
  private _noAuth = new TransferEndpointSettingsKafkaSourceAuthNoAuthOutputReference(this, "no_auth");
  public get noAuth() {
    return this._noAuth;
  }
  public putNoAuth(value: TransferEndpointSettingsKafkaSourceAuthNoAuth) {
    this._noAuth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get noAuthInput() {
    return this._noAuth.internalValue;
  }

  // sasl - computed: false, optional: true, required: false
  private _sasl = new TransferEndpointSettingsKafkaSourceAuthSaslOutputReference(this, "sasl");
  public get sasl() {
    return this._sasl;
  }
  public putSasl(value: TransferEndpointSettingsKafkaSourceAuthSasl) {
    this._sasl.internalValue = value;
  }
  public resetSasl() {
    this._sasl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saslInput() {
    return this._sasl.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode {
  /**
  * X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. When CA certificate is specified TLS is used to connect to the server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ca_certificate TransferEndpoint#ca_certificate}
  */
  readonly caCertificate?: string;
}

export function transferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeToTerraform(struct?: TransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificate: cdktf.stringToTerraform(struct!.caCertificate),
  }
}


export function transferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.caCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificate = this._caCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificate = value.caCertificate;
    }
  }

  // ca_certificate - computed: false, optional: true, required: false
  private _caCertificate?: string; 
  public get caCertificate() {
    return this.getStringAttribute('ca_certificate');
  }
  public set caCertificate(value: string) {
    this._caCertificate = value;
  }
  public resetCaCertificate() {
    this._caCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificateInput() {
    return this._caCertificate;
  }
}
export interface TransferEndpointSettingsKafkaSourceConnectionOnPremise {
  /**
  * Kafka broker URLs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#broker_urls TransferEndpoint#broker_urls}
  */
  readonly brokerUrls?: string[];
  /**
  * tls_mode block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tls_mode TransferEndpoint#tls_mode}
  */
  readonly tlsMode?: TransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode;
}

export function transferEndpointSettingsKafkaSourceConnectionOnPremiseToTerraform(struct?: TransferEndpointSettingsKafkaSourceConnectionOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    broker_urls: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokerUrls),
    tls_mode: transferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeToTerraform(struct!.tlsMode),
  }
}


export function transferEndpointSettingsKafkaSourceConnectionOnPremiseToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceConnectionOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    broker_urls: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokerUrls),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls_mode: {
      value: transferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeToHclTerraform(struct!.tlsMode),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceConnectionOnPremiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceConnectionOnPremise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._brokerUrls !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokerUrls = this._brokerUrls;
    }
    if (this._tlsMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMode = this._tlsMode?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceConnectionOnPremise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._brokerUrls = undefined;
      this._tlsMode.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._brokerUrls = value.brokerUrls;
      this._tlsMode.internalValue = value.tlsMode;
    }
  }

  // broker_urls - computed: false, optional: true, required: false
  private _brokerUrls?: string[]; 
  public get brokerUrls() {
    return this.getListAttribute('broker_urls');
  }
  public set brokerUrls(value: string[]) {
    this._brokerUrls = value;
  }
  public resetBrokerUrls() {
    this._brokerUrls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brokerUrlsInput() {
    return this._brokerUrls;
  }

  // tls_mode - computed: false, optional: true, required: false
  private _tlsMode = new TransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeOutputReference(this, "tls_mode");
  public get tlsMode() {
    return this._tlsMode;
  }
  public putTlsMode(value: TransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode) {
    this._tlsMode.internalValue = value;
  }
  public resetTlsMode() {
    this._tlsMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsModeInput() {
    return this._tlsMode.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaSourceConnection {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#cluster_id TransferEndpoint#cluster_id}
  */
  readonly clusterId?: string;
  /**
  * on_premise block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#on_premise TransferEndpoint#on_premise}
  */
  readonly onPremise?: TransferEndpointSettingsKafkaSourceConnectionOnPremise;
}

export function transferEndpointSettingsKafkaSourceConnectionToTerraform(struct?: TransferEndpointSettingsKafkaSourceConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_id: cdktf.stringToTerraform(struct!.clusterId),
    on_premise: transferEndpointSettingsKafkaSourceConnectionOnPremiseToTerraform(struct!.onPremise),
  }
}


export function transferEndpointSettingsKafkaSourceConnectionToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.clusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_premise: {
      value: transferEndpointSettingsKafkaSourceConnectionOnPremiseToHclTerraform(struct!.onPremise),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceConnectionOnPremise",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterId = this._clusterId;
    }
    if (this._onPremise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.onPremise = this._onPremise?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterId = undefined;
      this._onPremise.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterId = value.clusterId;
      this._onPremise.internalValue = value.onPremise;
    }
  }

  // cluster_id - computed: false, optional: true, required: false
  private _clusterId?: string; 
  public get clusterId() {
    return this.getStringAttribute('cluster_id');
  }
  public set clusterId(value: string) {
    this._clusterId = value;
  }
  public resetClusterId() {
    this._clusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIdInput() {
    return this._clusterId;
  }

  // on_premise - computed: false, optional: true, required: false
  private _onPremise = new TransferEndpointSettingsKafkaSourceConnectionOnPremiseOutputReference(this, "on_premise");
  public get onPremise() {
    return this._onPremise;
  }
  public putOnPremise(value: TransferEndpointSettingsKafkaSourceConnectionOnPremise) {
    this._onPremise.internalValue = value;
  }
  public resetOnPremise() {
    this._onPremise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onPremiseInput() {
    return this._onPremise.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserBlank {
}

export function transferEndpointSettingsKafkaSourceParserBlankToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserBlank | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsKafkaSourceParserBlankToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserBlank | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsKafkaSourceParserBlankOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserBlank | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserBlank | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#key TransferEndpoint#key}
  */
  readonly key?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#name TransferEndpoint#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#path TransferEndpoint#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#required TransferEndpoint#required}
  */
  readonly required?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#type TransferEndpoint#type}
  */
  readonly type?: string;
}

export function transferEndpointSettingsKafkaSourceParserJsonSchemaFieldsFieldToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.booleanToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    required: cdktf.booleanToTerraform(struct!.required),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function transferEndpointSettingsKafkaSourceParserJsonSchemaFieldsFieldToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.booleanToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    required: {
      value: cdktf.booleanToHclTerraform(struct!.required),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._required !== undefined) {
      hasAnyValues = true;
      internalValueResult.required = this._required;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._path = undefined;
      this._required = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._path = value.path;
      this._required = value.required;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: boolean | cdktf.IResolvable; 
  public get key() {
    return this.getBooleanAttribute('key');
  }
  public set key(value: boolean | cdktf.IResolvable) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // required - computed: false, optional: true, required: false
  private _required?: boolean | cdktf.IResolvable; 
  public get required() {
    return this.getBooleanAttribute('required');
  }
  public set required(value: boolean | cdktf.IResolvable) {
    this._required = value;
  }
  public resetRequired() {
    this._required = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredInput() {
    return this._required;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsFieldList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsField[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsFieldOutputReference {
    return new TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsFieldOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsKafkaSourceParserJsonSchemaFields {
  /**
  * field block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#field TransferEndpoint#field}
  */
  readonly field?: TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsField[] | cdktf.IResolvable;
}

export function transferEndpointSettingsKafkaSourceParserJsonSchemaFieldsToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserJsonSchemaFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.listMapper(transferEndpointSettingsKafkaSourceParserJsonSchemaFieldsFieldToTerraform, true)(struct!.field),
  }
}


export function transferEndpointSettingsKafkaSourceParserJsonSchemaFieldsToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserJsonSchemaFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.listMapperHcl(transferEndpointSettingsKafkaSourceParserJsonSchemaFieldsFieldToHclTerraform, true)(struct!.field),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsFieldList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserJsonSchemaFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserJsonSchemaFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field.internalValue = value.field;
    }
  }

  // field - computed: false, optional: true, required: false
  private _field = new TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsFieldList(this, "field", false);
  public get field() {
    return this._field;
  }
  public putField(value: TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsField[] | cdktf.IResolvable) {
    this._field.internalValue = value;
  }
  public resetField() {
    this._field.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserJsonSchemaJson {
  /**
  * Fields
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#fields TransferEndpoint#fields}
  */
  readonly fields?: string;
}

export function transferEndpointSettingsKafkaSourceParserJsonSchemaJsonToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserJsonSchemaJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fields: cdktf.stringToTerraform(struct!.fields),
  }
}


export function transferEndpointSettingsKafkaSourceParserJsonSchemaJsonToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserJsonSchemaJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fields: {
      value: cdktf.stringToHclTerraform(struct!.fields),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserJsonSchemaJsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserJsonSchemaJson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fields !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserJsonSchemaJson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fields = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fields = value.fields;
    }
  }

  // fields - computed: false, optional: true, required: false
  private _fields?: string; 
  public get fields() {
    return this.getStringAttribute('fields');
  }
  public set fields(value: string) {
    this._fields = value;
  }
  public resetFields() {
    this._fields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserJsonSchema {
  /**
  * fields block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#fields TransferEndpoint#fields}
  */
  readonly fields?: TransferEndpointSettingsKafkaSourceParserJsonSchemaFields;
  /**
  * json block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#json TransferEndpoint#json}
  */
  readonly json?: TransferEndpointSettingsKafkaSourceParserJsonSchemaJson;
}

export function transferEndpointSettingsKafkaSourceParserJsonSchemaToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserJsonSchema | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fields: transferEndpointSettingsKafkaSourceParserJsonSchemaFieldsToTerraform(struct!.fields),
    json: transferEndpointSettingsKafkaSourceParserJsonSchemaJsonToTerraform(struct!.json),
  }
}


export function transferEndpointSettingsKafkaSourceParserJsonSchemaToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserJsonSchema | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fields: {
      value: transferEndpointSettingsKafkaSourceParserJsonSchemaFieldsToHclTerraform(struct!.fields),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserJsonSchemaFields",
    },
    json: {
      value: transferEndpointSettingsKafkaSourceParserJsonSchemaJsonToHclTerraform(struct!.json),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserJsonSchemaJson",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserJsonSchemaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserJsonSchema | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields?.internalValue;
    }
    if (this._json?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.json = this._json?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserJsonSchema | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fields.internalValue = undefined;
      this._json.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fields.internalValue = value.fields;
      this._json.internalValue = value.json;
    }
  }

  // fields - computed: false, optional: true, required: false
  private _fields = new TransferEndpointSettingsKafkaSourceParserJsonSchemaFieldsOutputReference(this, "fields");
  public get fields() {
    return this._fields;
  }
  public putFields(value: TransferEndpointSettingsKafkaSourceParserJsonSchemaFields) {
    this._fields.internalValue = value;
  }
  public resetFields() {
    this._fields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields.internalValue;
  }

  // json - computed: false, optional: true, required: false
  private _json = new TransferEndpointSettingsKafkaSourceParserJsonSchemaJsonOutputReference(this, "json");
  public get json() {
    return this._json;
  }
  public putJson(value: TransferEndpointSettingsKafkaSourceParserJsonSchemaJson) {
    this._json.internalValue = value;
  }
  public resetJson() {
    this._json.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonInput() {
    return this._json.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserJson {
  /**
  * Add the `_rest` column for all unknown fields
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#add_rest_column TransferEndpoint#add_rest_column}
  */
  readonly addRestColumn?: boolean | cdktf.IResolvable;
  /**
  * Allow null keys. If false, null keys are put to unparsed data
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#null_keys_allowed TransferEndpoint#null_keys_allowed}
  */
  readonly nullKeysAllowed?: boolean | cdktf.IResolvable;
  /**
  * schema block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#schema TransferEndpoint#schema}
  */
  readonly schema?: TransferEndpointSettingsKafkaSourceParserJsonSchema;
}

export function transferEndpointSettingsKafkaSourceParserJsonToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_rest_column: cdktf.booleanToTerraform(struct!.addRestColumn),
    null_keys_allowed: cdktf.booleanToTerraform(struct!.nullKeysAllowed),
    schema: transferEndpointSettingsKafkaSourceParserJsonSchemaToTerraform(struct!.schema),
  }
}


export function transferEndpointSettingsKafkaSourceParserJsonToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_rest_column: {
      value: cdktf.booleanToHclTerraform(struct!.addRestColumn),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    null_keys_allowed: {
      value: cdktf.booleanToHclTerraform(struct!.nullKeysAllowed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    schema: {
      value: transferEndpointSettingsKafkaSourceParserJsonSchemaToHclTerraform(struct!.schema),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserJsonSchema",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserJsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserJson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRestColumn !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRestColumn = this._addRestColumn;
    }
    if (this._nullKeysAllowed !== undefined) {
      hasAnyValues = true;
      internalValueResult.nullKeysAllowed = this._nullKeysAllowed;
    }
    if (this._schema?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserJson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRestColumn = undefined;
      this._nullKeysAllowed = undefined;
      this._schema.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRestColumn = value.addRestColumn;
      this._nullKeysAllowed = value.nullKeysAllowed;
      this._schema.internalValue = value.schema;
    }
  }

  // add_rest_column - computed: false, optional: true, required: false
  private _addRestColumn?: boolean | cdktf.IResolvable; 
  public get addRestColumn() {
    return this.getBooleanAttribute('add_rest_column');
  }
  public set addRestColumn(value: boolean | cdktf.IResolvable) {
    this._addRestColumn = value;
  }
  public resetAddRestColumn() {
    this._addRestColumn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRestColumnInput() {
    return this._addRestColumn;
  }

  // null_keys_allowed - computed: false, optional: true, required: false
  private _nullKeysAllowed?: boolean | cdktf.IResolvable; 
  public get nullKeysAllowed() {
    return this.getBooleanAttribute('null_keys_allowed');
  }
  public set nullKeysAllowed(value: boolean | cdktf.IResolvable) {
    this._nullKeysAllowed = value;
  }
  public resetNullKeysAllowed() {
    this._nullKeysAllowed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullKeysAllowedInput() {
    return this._nullKeysAllowed;
  }

  // schema - computed: false, optional: true, required: false
  private _schema = new TransferEndpointSettingsKafkaSourceParserJsonSchemaOutputReference(this, "schema");
  public get schema() {
    return this._schema;
  }
  public putSchema(value: TransferEndpointSettingsKafkaSourceParserJsonSchema) {
    this._schema.internalValue = value;
  }
  public resetSchema() {
    this._schema.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserRawTable {
  /**
  * Add headers column to output virtual table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#add_headers TransferEndpoint#add_headers}
  */
  readonly addHeaders?: boolean | cdktf.IResolvable;
  /**
  * Add key column to output virtual table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#add_key TransferEndpoint#add_key}
  */
  readonly addKey?: boolean | cdktf.IResolvable;
  /**
  * Add timestamp column to output virtual table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#add_timestamp TransferEndpoint#add_timestamp}
  */
  readonly addTimestamp?: boolean | cdktf.IResolvable;
  /**
  * Make keys column as `bytes`, for non-utf8 characters
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#keys_as_bytes TransferEndpoint#keys_as_bytes}
  */
  readonly keysAsBytes?: boolean | cdktf.IResolvable;
  /**
  * Make value column as `bytes`, for non-utf8 characters
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#value_as_bytes TransferEndpoint#value_as_bytes}
  */
  readonly valueAsBytes?: boolean | cdktf.IResolvable;
}

export function transferEndpointSettingsKafkaSourceParserRawTableToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserRawTable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_headers: cdktf.booleanToTerraform(struct!.addHeaders),
    add_key: cdktf.booleanToTerraform(struct!.addKey),
    add_timestamp: cdktf.booleanToTerraform(struct!.addTimestamp),
    keys_as_bytes: cdktf.booleanToTerraform(struct!.keysAsBytes),
    value_as_bytes: cdktf.booleanToTerraform(struct!.valueAsBytes),
  }
}


export function transferEndpointSettingsKafkaSourceParserRawTableToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserRawTable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_headers: {
      value: cdktf.booleanToHclTerraform(struct!.addHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    add_key: {
      value: cdktf.booleanToHclTerraform(struct!.addKey),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    add_timestamp: {
      value: cdktf.booleanToHclTerraform(struct!.addTimestamp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keys_as_bytes: {
      value: cdktf.booleanToHclTerraform(struct!.keysAsBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value_as_bytes: {
      value: cdktf.booleanToHclTerraform(struct!.valueAsBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserRawTableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserRawTable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.addHeaders = this._addHeaders;
    }
    if (this._addKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.addKey = this._addKey;
    }
    if (this._addTimestamp !== undefined) {
      hasAnyValues = true;
      internalValueResult.addTimestamp = this._addTimestamp;
    }
    if (this._keysAsBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.keysAsBytes = this._keysAsBytes;
    }
    if (this._valueAsBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueAsBytes = this._valueAsBytes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserRawTable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addHeaders = undefined;
      this._addKey = undefined;
      this._addTimestamp = undefined;
      this._keysAsBytes = undefined;
      this._valueAsBytes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addHeaders = value.addHeaders;
      this._addKey = value.addKey;
      this._addTimestamp = value.addTimestamp;
      this._keysAsBytes = value.keysAsBytes;
      this._valueAsBytes = value.valueAsBytes;
    }
  }

  // add_headers - computed: false, optional: true, required: false
  private _addHeaders?: boolean | cdktf.IResolvable; 
  public get addHeaders() {
    return this.getBooleanAttribute('add_headers');
  }
  public set addHeaders(value: boolean | cdktf.IResolvable) {
    this._addHeaders = value;
  }
  public resetAddHeaders() {
    this._addHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addHeadersInput() {
    return this._addHeaders;
  }

  // add_key - computed: false, optional: true, required: false
  private _addKey?: boolean | cdktf.IResolvable; 
  public get addKey() {
    return this.getBooleanAttribute('add_key');
  }
  public set addKey(value: boolean | cdktf.IResolvable) {
    this._addKey = value;
  }
  public resetAddKey() {
    this._addKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addKeyInput() {
    return this._addKey;
  }

  // add_timestamp - computed: false, optional: true, required: false
  private _addTimestamp?: boolean | cdktf.IResolvable; 
  public get addTimestamp() {
    return this.getBooleanAttribute('add_timestamp');
  }
  public set addTimestamp(value: boolean | cdktf.IResolvable) {
    this._addTimestamp = value;
  }
  public resetAddTimestamp() {
    this._addTimestamp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addTimestampInput() {
    return this._addTimestamp;
  }

  // keys_as_bytes - computed: false, optional: true, required: false
  private _keysAsBytes?: boolean | cdktf.IResolvable; 
  public get keysAsBytes() {
    return this.getBooleanAttribute('keys_as_bytes');
  }
  public set keysAsBytes(value: boolean | cdktf.IResolvable) {
    this._keysAsBytes = value;
  }
  public resetKeysAsBytes() {
    this._keysAsBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keysAsBytesInput() {
    return this._keysAsBytes;
  }

  // value_as_bytes - computed: false, optional: true, required: false
  private _valueAsBytes?: boolean | cdktf.IResolvable; 
  public get valueAsBytes() {
    return this.getBooleanAttribute('value_as_bytes');
  }
  public set valueAsBytes(value: boolean | cdktf.IResolvable) {
    this._valueAsBytes = value;
  }
  public resetValueAsBytes() {
    this._valueAsBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueAsBytesInput() {
    return this._valueAsBytes;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasic {
  /**
  * Password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * User name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#user TransferEndpoint#user}
  */
  readonly user?: string;
}

export function transferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasicToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function transferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasicToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._password = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._password = value.password;
      this._user = value.user;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuth {
}

export function transferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuthToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuthToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuth {
  /**
  * basic block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#basic TransferEndpoint#basic}
  */
  readonly basic?: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasic;
  /**
  * no_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#no_auth TransferEndpoint#no_auth}
  */
  readonly noAuth?: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuth;
}

export function transferEndpointSettingsKafkaSourceParserSchemaRegistryAuthToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    basic: transferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasicToTerraform(struct!.basic),
    no_auth: transferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuthToTerraform(struct!.noAuth),
  }
}


export function transferEndpointSettingsKafkaSourceParserSchemaRegistryAuthToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    basic: {
      value: transferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasicToHclTerraform(struct!.basic),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasic",
    },
    no_auth: {
      value: transferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuthToHclTerraform(struct!.noAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuth",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._basic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basic = this._basic?.internalValue;
    }
    if (this._noAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.noAuth = this._noAuth?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._basic.internalValue = undefined;
      this._noAuth.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._basic.internalValue = value.basic;
      this._noAuth.internalValue = value.noAuth;
    }
  }

  // basic - computed: false, optional: true, required: false
  private _basic = new TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasicOutputReference(this, "basic");
  public get basic() {
    return this._basic;
  }
  public putBasic(value: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthBasic) {
    this._basic.internalValue = value;
  }
  public resetBasic() {
    this._basic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicInput() {
    return this._basic.internalValue;
  }

  // no_auth - computed: false, optional: true, required: true
  private _noAuth = new TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuthOutputReference(this, "no_auth");
  public get noAuth() {
    return this._noAuth;
  }
  public putNoAuth(value: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthNoAuth) {
    this._noAuth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get noAuthInput() {
    return this._noAuth.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserSchemaRegistryTls {
  /**
  * X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. When CA certificate is specified TLS is used to connect to the server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ca_certificate TransferEndpoint#ca_certificate}
  */
  readonly caCertificate?: string;
}

export function transferEndpointSettingsKafkaSourceParserSchemaRegistryTlsToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificate: cdktf.stringToTerraform(struct!.caCertificate),
  }
}


export function transferEndpointSettingsKafkaSourceParserSchemaRegistryTlsToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.caCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificate = this._caCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificate = value.caCertificate;
    }
  }

  // ca_certificate - computed: false, optional: true, required: false
  private _caCertificate?: string; 
  public get caCertificate() {
    return this.getStringAttribute('ca_certificate');
  }
  public set caCertificate(value: string) {
    this._caCertificate = value;
  }
  public resetCaCertificate() {
    this._caCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificateInput() {
    return this._caCertificate;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserSchemaRegistry {
  /**
  * Address of schema registry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#url TransferEndpoint#url}
  */
  readonly url?: string;
  /**
  * auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#auth TransferEndpoint#auth}
  */
  readonly auth?: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuth;
  /**
  * tls block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tls TransferEndpoint#tls}
  */
  readonly tls?: TransferEndpointSettingsKafkaSourceParserSchemaRegistryTls;
}

export function transferEndpointSettingsKafkaSourceParserSchemaRegistryToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
    auth: transferEndpointSettingsKafkaSourceParserSchemaRegistryAuthToTerraform(struct!.auth),
    tls: transferEndpointSettingsKafkaSourceParserSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function transferEndpointSettingsKafkaSourceParserSchemaRegistryToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth: {
      value: transferEndpointSettingsKafkaSourceParserSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuth",
    },
    tls: {
      value: transferEndpointSettingsKafkaSourceParserSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
      this._auth.internalValue = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
      this._auth.internalValue = value.auth;
      this._tls.internalValue = value.tls;
    }
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: TransferEndpointSettingsKafkaSourceParserSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new TransferEndpointSettingsKafkaSourceParserSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: TransferEndpointSettingsKafkaSourceParserSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#key TransferEndpoint#key}
  */
  readonly key?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#name TransferEndpoint#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#path TransferEndpoint#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#required TransferEndpoint#required}
  */
  readonly required?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#type TransferEndpoint#type}
  */
  readonly type?: string;
}

export function transferEndpointSettingsKafkaSourceParserTskvSchemaFieldsFieldToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.booleanToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    required: cdktf.booleanToTerraform(struct!.required),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function transferEndpointSettingsKafkaSourceParserTskvSchemaFieldsFieldToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.booleanToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    required: {
      value: cdktf.booleanToHclTerraform(struct!.required),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._required !== undefined) {
      hasAnyValues = true;
      internalValueResult.required = this._required;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._path = undefined;
      this._required = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._path = value.path;
      this._required = value.required;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: boolean | cdktf.IResolvable; 
  public get key() {
    return this.getBooleanAttribute('key');
  }
  public set key(value: boolean | cdktf.IResolvable) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // required - computed: false, optional: true, required: false
  private _required?: boolean | cdktf.IResolvable; 
  public get required() {
    return this.getBooleanAttribute('required');
  }
  public set required(value: boolean | cdktf.IResolvable) {
    this._required = value;
  }
  public resetRequired() {
    this._required = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredInput() {
    return this._required;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsFieldList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsField[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsFieldOutputReference {
    return new TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsFieldOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsKafkaSourceParserTskvSchemaFields {
  /**
  * field block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#field TransferEndpoint#field}
  */
  readonly field?: TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsField[] | cdktf.IResolvable;
}

export function transferEndpointSettingsKafkaSourceParserTskvSchemaFieldsToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserTskvSchemaFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.listMapper(transferEndpointSettingsKafkaSourceParserTskvSchemaFieldsFieldToTerraform, true)(struct!.field),
  }
}


export function transferEndpointSettingsKafkaSourceParserTskvSchemaFieldsToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserTskvSchemaFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.listMapperHcl(transferEndpointSettingsKafkaSourceParserTskvSchemaFieldsFieldToHclTerraform, true)(struct!.field),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsFieldList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserTskvSchemaFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserTskvSchemaFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field.internalValue = value.field;
    }
  }

  // field - computed: false, optional: true, required: false
  private _field = new TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsFieldList(this, "field", false);
  public get field() {
    return this._field;
  }
  public putField(value: TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsField[] | cdktf.IResolvable) {
    this._field.internalValue = value;
  }
  public resetField() {
    this._field.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserTskvSchemaJson {
  /**
  * Fields
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#fields TransferEndpoint#fields}
  */
  readonly fields?: string;
}

export function transferEndpointSettingsKafkaSourceParserTskvSchemaJsonToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserTskvSchemaJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fields: cdktf.stringToTerraform(struct!.fields),
  }
}


export function transferEndpointSettingsKafkaSourceParserTskvSchemaJsonToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserTskvSchemaJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fields: {
      value: cdktf.stringToHclTerraform(struct!.fields),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserTskvSchemaJsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserTskvSchemaJson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fields !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserTskvSchemaJson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fields = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fields = value.fields;
    }
  }

  // fields - computed: false, optional: true, required: false
  private _fields?: string; 
  public get fields() {
    return this.getStringAttribute('fields');
  }
  public set fields(value: string) {
    this._fields = value;
  }
  public resetFields() {
    this._fields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserTskvSchema {
  /**
  * fields block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#fields TransferEndpoint#fields}
  */
  readonly fields?: TransferEndpointSettingsKafkaSourceParserTskvSchemaFields;
  /**
  * json block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#json TransferEndpoint#json}
  */
  readonly json?: TransferEndpointSettingsKafkaSourceParserTskvSchemaJson;
}

export function transferEndpointSettingsKafkaSourceParserTskvSchemaToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserTskvSchema | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fields: transferEndpointSettingsKafkaSourceParserTskvSchemaFieldsToTerraform(struct!.fields),
    json: transferEndpointSettingsKafkaSourceParserTskvSchemaJsonToTerraform(struct!.json),
  }
}


export function transferEndpointSettingsKafkaSourceParserTskvSchemaToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserTskvSchema | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fields: {
      value: transferEndpointSettingsKafkaSourceParserTskvSchemaFieldsToHclTerraform(struct!.fields),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserTskvSchemaFields",
    },
    json: {
      value: transferEndpointSettingsKafkaSourceParserTskvSchemaJsonToHclTerraform(struct!.json),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserTskvSchemaJson",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserTskvSchemaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserTskvSchema | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields?.internalValue;
    }
    if (this._json?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.json = this._json?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserTskvSchema | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fields.internalValue = undefined;
      this._json.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fields.internalValue = value.fields;
      this._json.internalValue = value.json;
    }
  }

  // fields - computed: false, optional: true, required: false
  private _fields = new TransferEndpointSettingsKafkaSourceParserTskvSchemaFieldsOutputReference(this, "fields");
  public get fields() {
    return this._fields;
  }
  public putFields(value: TransferEndpointSettingsKafkaSourceParserTskvSchemaFields) {
    this._fields.internalValue = value;
  }
  public resetFields() {
    this._fields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields.internalValue;
  }

  // json - computed: false, optional: true, required: false
  private _json = new TransferEndpointSettingsKafkaSourceParserTskvSchemaJsonOutputReference(this, "json");
  public get json() {
    return this._json;
  }
  public putJson(value: TransferEndpointSettingsKafkaSourceParserTskvSchemaJson) {
    this._json.internalValue = value;
  }
  public resetJson() {
    this._json.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonInput() {
    return this._json.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaSourceParserTskv {
  /**
  * Add the `_rest` column for all unknown fields
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#add_rest_column TransferEndpoint#add_rest_column}
  */
  readonly addRestColumn?: boolean | cdktf.IResolvable;
  /**
  * Allow null keys. If false, null keys are put to unparsed data
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#null_keys_allowed TransferEndpoint#null_keys_allowed}
  */
  readonly nullKeysAllowed?: boolean | cdktf.IResolvable;
  /**
  * schema block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#schema TransferEndpoint#schema}
  */
  readonly schema?: TransferEndpointSettingsKafkaSourceParserTskvSchema;
}

export function transferEndpointSettingsKafkaSourceParserTskvToTerraform(struct?: TransferEndpointSettingsKafkaSourceParserTskv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_rest_column: cdktf.booleanToTerraform(struct!.addRestColumn),
    null_keys_allowed: cdktf.booleanToTerraform(struct!.nullKeysAllowed),
    schema: transferEndpointSettingsKafkaSourceParserTskvSchemaToTerraform(struct!.schema),
  }
}


export function transferEndpointSettingsKafkaSourceParserTskvToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParserTskv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_rest_column: {
      value: cdktf.booleanToHclTerraform(struct!.addRestColumn),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    null_keys_allowed: {
      value: cdktf.booleanToHclTerraform(struct!.nullKeysAllowed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    schema: {
      value: transferEndpointSettingsKafkaSourceParserTskvSchemaToHclTerraform(struct!.schema),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserTskvSchema",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserTskvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParserTskv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRestColumn !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRestColumn = this._addRestColumn;
    }
    if (this._nullKeysAllowed !== undefined) {
      hasAnyValues = true;
      internalValueResult.nullKeysAllowed = this._nullKeysAllowed;
    }
    if (this._schema?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParserTskv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRestColumn = undefined;
      this._nullKeysAllowed = undefined;
      this._schema.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRestColumn = value.addRestColumn;
      this._nullKeysAllowed = value.nullKeysAllowed;
      this._schema.internalValue = value.schema;
    }
  }

  // add_rest_column - computed: false, optional: true, required: false
  private _addRestColumn?: boolean | cdktf.IResolvable; 
  public get addRestColumn() {
    return this.getBooleanAttribute('add_rest_column');
  }
  public set addRestColumn(value: boolean | cdktf.IResolvable) {
    this._addRestColumn = value;
  }
  public resetAddRestColumn() {
    this._addRestColumn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRestColumnInput() {
    return this._addRestColumn;
  }

  // null_keys_allowed - computed: false, optional: true, required: false
  private _nullKeysAllowed?: boolean | cdktf.IResolvable; 
  public get nullKeysAllowed() {
    return this.getBooleanAttribute('null_keys_allowed');
  }
  public set nullKeysAllowed(value: boolean | cdktf.IResolvable) {
    this._nullKeysAllowed = value;
  }
  public resetNullKeysAllowed() {
    this._nullKeysAllowed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullKeysAllowedInput() {
    return this._nullKeysAllowed;
  }

  // schema - computed: false, optional: true, required: false
  private _schema = new TransferEndpointSettingsKafkaSourceParserTskvSchemaOutputReference(this, "schema");
  public get schema() {
    return this._schema;
  }
  public putSchema(value: TransferEndpointSettingsKafkaSourceParserTskvSchema) {
    this._schema.internalValue = value;
  }
  public resetSchema() {
    this._schema.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaSourceParser {
  /**
  * blank block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#blank TransferEndpoint#blank}
  */
  readonly blank?: TransferEndpointSettingsKafkaSourceParserBlank;
  /**
  * json block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#json TransferEndpoint#json}
  */
  readonly json?: TransferEndpointSettingsKafkaSourceParserJson;
  /**
  * raw_table block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#raw_table TransferEndpoint#raw_table}
  */
  readonly rawTable?: TransferEndpointSettingsKafkaSourceParserRawTable;
  /**
  * schema_registry block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#schema_registry TransferEndpoint#schema_registry}
  */
  readonly schemaRegistry?: TransferEndpointSettingsKafkaSourceParserSchemaRegistry;
  /**
  * tskv block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tskv TransferEndpoint#tskv}
  */
  readonly tskv?: TransferEndpointSettingsKafkaSourceParserTskv;
}

export function transferEndpointSettingsKafkaSourceParserToTerraform(struct?: TransferEndpointSettingsKafkaSourceParser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    blank: transferEndpointSettingsKafkaSourceParserBlankToTerraform(struct!.blank),
    json: transferEndpointSettingsKafkaSourceParserJsonToTerraform(struct!.json),
    raw_table: transferEndpointSettingsKafkaSourceParserRawTableToTerraform(struct!.rawTable),
    schema_registry: transferEndpointSettingsKafkaSourceParserSchemaRegistryToTerraform(struct!.schemaRegistry),
    tskv: transferEndpointSettingsKafkaSourceParserTskvToTerraform(struct!.tskv),
  }
}


export function transferEndpointSettingsKafkaSourceParserToHclTerraform(struct?: TransferEndpointSettingsKafkaSourceParser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    blank: {
      value: transferEndpointSettingsKafkaSourceParserBlankToHclTerraform(struct!.blank),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserBlank",
    },
    json: {
      value: transferEndpointSettingsKafkaSourceParserJsonToHclTerraform(struct!.json),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserJson",
    },
    raw_table: {
      value: transferEndpointSettingsKafkaSourceParserRawTableToHclTerraform(struct!.rawTable),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserRawTable",
    },
    schema_registry: {
      value: transferEndpointSettingsKafkaSourceParserSchemaRegistryToHclTerraform(struct!.schemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserSchemaRegistry",
    },
    tskv: {
      value: transferEndpointSettingsKafkaSourceParserTskvToHclTerraform(struct!.tskv),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParserTskv",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceParserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSourceParser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._blank?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.blank = this._blank?.internalValue;
    }
    if (this._json?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.json = this._json?.internalValue;
    }
    if (this._rawTable?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rawTable = this._rawTable?.internalValue;
    }
    if (this._schemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistry = this._schemaRegistry?.internalValue;
    }
    if (this._tskv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tskv = this._tskv?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSourceParser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._blank.internalValue = undefined;
      this._json.internalValue = undefined;
      this._rawTable.internalValue = undefined;
      this._schemaRegistry.internalValue = undefined;
      this._tskv.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._blank.internalValue = value.blank;
      this._json.internalValue = value.json;
      this._rawTable.internalValue = value.rawTable;
      this._schemaRegistry.internalValue = value.schemaRegistry;
      this._tskv.internalValue = value.tskv;
    }
  }

  // blank - computed: false, optional: true, required: true
  private _blank = new TransferEndpointSettingsKafkaSourceParserBlankOutputReference(this, "blank");
  public get blank() {
    return this._blank;
  }
  public putBlank(value: TransferEndpointSettingsKafkaSourceParserBlank) {
    this._blank.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get blankInput() {
    return this._blank.internalValue;
  }

  // json - computed: false, optional: true, required: false
  private _json = new TransferEndpointSettingsKafkaSourceParserJsonOutputReference(this, "json");
  public get json() {
    return this._json;
  }
  public putJson(value: TransferEndpointSettingsKafkaSourceParserJson) {
    this._json.internalValue = value;
  }
  public resetJson() {
    this._json.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonInput() {
    return this._json.internalValue;
  }

  // raw_table - computed: false, optional: true, required: false
  private _rawTable = new TransferEndpointSettingsKafkaSourceParserRawTableOutputReference(this, "raw_table");
  public get rawTable() {
    return this._rawTable;
  }
  public putRawTable(value: TransferEndpointSettingsKafkaSourceParserRawTable) {
    this._rawTable.internalValue = value;
  }
  public resetRawTable() {
    this._rawTable.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rawTableInput() {
    return this._rawTable.internalValue;
  }

  // schema_registry - computed: false, optional: true, required: false
  private _schemaRegistry = new TransferEndpointSettingsKafkaSourceParserSchemaRegistryOutputReference(this, "schema_registry");
  public get schemaRegistry() {
    return this._schemaRegistry;
  }
  public putSchemaRegistry(value: TransferEndpointSettingsKafkaSourceParserSchemaRegistry) {
    this._schemaRegistry.internalValue = value;
  }
  public resetSchemaRegistry() {
    this._schemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryInput() {
    return this._schemaRegistry.internalValue;
  }

  // tskv - computed: false, optional: true, required: false
  private _tskv = new TransferEndpointSettingsKafkaSourceParserTskvOutputReference(this, "tskv");
  public get tskv() {
    return this._tskv;
  }
  public putTskv(value: TransferEndpointSettingsKafkaSourceParserTskv) {
    this._tskv.internalValue = value;
  }
  public resetTskv() {
    this._tskv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tskvInput() {
    return this._tskv.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaSource {
  /**
  * Full source topic name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#topic_name TransferEndpoint#topic_name}
  */
  readonly topicName?: string;
  /**
  * auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#auth TransferEndpoint#auth}
  */
  readonly auth?: TransferEndpointSettingsKafkaSourceAuth;
  /**
  * connection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection TransferEndpoint#connection}
  */
  readonly connection?: TransferEndpointSettingsKafkaSourceConnection;
  /**
  * parser block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#parser TransferEndpoint#parser}
  */
  readonly parser?: TransferEndpointSettingsKafkaSourceParser;
}

export function transferEndpointSettingsKafkaSourceToTerraform(struct?: TransferEndpointSettingsKafkaSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    topic_name: cdktf.stringToTerraform(struct!.topicName),
    auth: transferEndpointSettingsKafkaSourceAuthToTerraform(struct!.auth),
    connection: transferEndpointSettingsKafkaSourceConnectionToTerraform(struct!.connection),
    parser: transferEndpointSettingsKafkaSourceParserToTerraform(struct!.parser),
  }
}


export function transferEndpointSettingsKafkaSourceToHclTerraform(struct?: TransferEndpointSettingsKafkaSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    topic_name: {
      value: cdktf.stringToHclTerraform(struct!.topicName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth: {
      value: transferEndpointSettingsKafkaSourceAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceAuth",
    },
    connection: {
      value: transferEndpointSettingsKafkaSourceConnectionToHclTerraform(struct!.connection),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceConnection",
    },
    parser: {
      value: transferEndpointSettingsKafkaSourceParserToHclTerraform(struct!.parser),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSourceParser",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._topicName !== undefined) {
      hasAnyValues = true;
      internalValueResult.topicName = this._topicName;
    }
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connection = this._connection?.internalValue;
    }
    if (this._parser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parser = this._parser?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._topicName = undefined;
      this._auth.internalValue = undefined;
      this._connection.internalValue = undefined;
      this._parser.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._topicName = value.topicName;
      this._auth.internalValue = value.auth;
      this._connection.internalValue = value.connection;
      this._parser.internalValue = value.parser;
    }
  }

  // topic_name - computed: false, optional: true, required: false
  private _topicName?: string; 
  public get topicName() {
    return this.getStringAttribute('topic_name');
  }
  public set topicName(value: string) {
    this._topicName = value;
  }
  public resetTopicName() {
    this._topicName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicNameInput() {
    return this._topicName;
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new TransferEndpointSettingsKafkaSourceAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: TransferEndpointSettingsKafkaSourceAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection - computed: false, optional: true, required: false
  private _connection = new TransferEndpointSettingsKafkaSourceConnectionOutputReference(this, "connection");
  public get connection() {
    return this._connection;
  }
  public putConnection(value: TransferEndpointSettingsKafkaSourceConnection) {
    this._connection.internalValue = value;
  }
  public resetConnection() {
    this._connection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionInput() {
    return this._connection.internalValue;
  }

  // parser - computed: false, optional: true, required: false
  private _parser = new TransferEndpointSettingsKafkaSourceParserOutputReference(this, "parser");
  public get parser() {
    return this._parser;
  }
  public putParser(value: TransferEndpointSettingsKafkaSourceParser) {
    this._parser.internalValue = value;
  }
  public resetParser() {
    this._parser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parserInput() {
    return this._parser.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaTargetAuthNoAuth {
}

export function transferEndpointSettingsKafkaTargetAuthNoAuthToTerraform(struct?: TransferEndpointSettingsKafkaTargetAuthNoAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsKafkaTargetAuthNoAuthToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetAuthNoAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsKafkaTargetAuthNoAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetAuthNoAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetAuthNoAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsKafkaTargetAuthSasl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#mechanism TransferEndpoint#mechanism}
  */
  readonly mechanism?: string;
  /**
  * Password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * User
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#user TransferEndpoint#user}
  */
  readonly user?: string;
}

export function transferEndpointSettingsKafkaTargetAuthSaslToTerraform(struct?: TransferEndpointSettingsKafkaTargetAuthSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mechanism: cdktf.stringToTerraform(struct!.mechanism),
    password: cdktf.stringToTerraform(struct!.password),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function transferEndpointSettingsKafkaTargetAuthSaslToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetAuthSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mechanism: {
      value: cdktf.stringToHclTerraform(struct!.mechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaTargetAuthSaslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetAuthSasl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.mechanism = this._mechanism;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetAuthSasl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mechanism = undefined;
      this._password = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mechanism = value.mechanism;
      this._password = value.password;
      this._user = value.user;
    }
  }

  // mechanism - computed: false, optional: true, required: false
  private _mechanism?: string; 
  public get mechanism() {
    return this.getStringAttribute('mechanism');
  }
  public set mechanism(value: string) {
    this._mechanism = value;
  }
  public resetMechanism() {
    this._mechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mechanismInput() {
    return this._mechanism;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface TransferEndpointSettingsKafkaTargetAuth {
  /**
  * no_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#no_auth TransferEndpoint#no_auth}
  */
  readonly noAuth?: TransferEndpointSettingsKafkaTargetAuthNoAuth;
  /**
  * sasl block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#sasl TransferEndpoint#sasl}
  */
  readonly sasl?: TransferEndpointSettingsKafkaTargetAuthSasl;
}

export function transferEndpointSettingsKafkaTargetAuthToTerraform(struct?: TransferEndpointSettingsKafkaTargetAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    no_auth: transferEndpointSettingsKafkaTargetAuthNoAuthToTerraform(struct!.noAuth),
    sasl: transferEndpointSettingsKafkaTargetAuthSaslToTerraform(struct!.sasl),
  }
}


export function transferEndpointSettingsKafkaTargetAuthToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    no_auth: {
      value: transferEndpointSettingsKafkaTargetAuthNoAuthToHclTerraform(struct!.noAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTargetAuthNoAuth",
    },
    sasl: {
      value: transferEndpointSettingsKafkaTargetAuthSaslToHclTerraform(struct!.sasl),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTargetAuthSasl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaTargetAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._noAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.noAuth = this._noAuth?.internalValue;
    }
    if (this._sasl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sasl = this._sasl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._noAuth.internalValue = undefined;
      this._sasl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._noAuth.internalValue = value.noAuth;
      this._sasl.internalValue = value.sasl;
    }
  }

  // no_auth - computed: false, optional: true, required: true
  private _noAuth = new TransferEndpointSettingsKafkaTargetAuthNoAuthOutputReference(this, "no_auth");
  public get noAuth() {
    return this._noAuth;
  }
  public putNoAuth(value: TransferEndpointSettingsKafkaTargetAuthNoAuth) {
    this._noAuth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get noAuthInput() {
    return this._noAuth.internalValue;
  }

  // sasl - computed: false, optional: true, required: false
  private _sasl = new TransferEndpointSettingsKafkaTargetAuthSaslOutputReference(this, "sasl");
  public get sasl() {
    return this._sasl;
  }
  public putSasl(value: TransferEndpointSettingsKafkaTargetAuthSasl) {
    this._sasl.internalValue = value;
  }
  public resetSasl() {
    this._sasl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saslInput() {
    return this._sasl.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode {
  /**
  * X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. When CA certificate is specified TLS is used to connect to the server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ca_certificate TransferEndpoint#ca_certificate}
  */
  readonly caCertificate?: string;
}

export function transferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeToTerraform(struct?: TransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificate: cdktf.stringToTerraform(struct!.caCertificate),
  }
}


export function transferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.caCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificate = this._caCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificate = value.caCertificate;
    }
  }

  // ca_certificate - computed: false, optional: true, required: false
  private _caCertificate?: string; 
  public get caCertificate() {
    return this.getStringAttribute('ca_certificate');
  }
  public set caCertificate(value: string) {
    this._caCertificate = value;
  }
  public resetCaCertificate() {
    this._caCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificateInput() {
    return this._caCertificate;
  }
}
export interface TransferEndpointSettingsKafkaTargetConnectionOnPremise {
  /**
  * Kafka broker URLs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#broker_urls TransferEndpoint#broker_urls}
  */
  readonly brokerUrls?: string[];
  /**
  * tls_mode block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tls_mode TransferEndpoint#tls_mode}
  */
  readonly tlsMode?: TransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode;
}

export function transferEndpointSettingsKafkaTargetConnectionOnPremiseToTerraform(struct?: TransferEndpointSettingsKafkaTargetConnectionOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    broker_urls: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokerUrls),
    tls_mode: transferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeToTerraform(struct!.tlsMode),
  }
}


export function transferEndpointSettingsKafkaTargetConnectionOnPremiseToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetConnectionOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    broker_urls: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokerUrls),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls_mode: {
      value: transferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeToHclTerraform(struct!.tlsMode),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaTargetConnectionOnPremiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetConnectionOnPremise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._brokerUrls !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokerUrls = this._brokerUrls;
    }
    if (this._tlsMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMode = this._tlsMode?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetConnectionOnPremise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._brokerUrls = undefined;
      this._tlsMode.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._brokerUrls = value.brokerUrls;
      this._tlsMode.internalValue = value.tlsMode;
    }
  }

  // broker_urls - computed: false, optional: true, required: false
  private _brokerUrls?: string[]; 
  public get brokerUrls() {
    return this.getListAttribute('broker_urls');
  }
  public set brokerUrls(value: string[]) {
    this._brokerUrls = value;
  }
  public resetBrokerUrls() {
    this._brokerUrls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brokerUrlsInput() {
    return this._brokerUrls;
  }

  // tls_mode - computed: false, optional: true, required: false
  private _tlsMode = new TransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeOutputReference(this, "tls_mode");
  public get tlsMode() {
    return this._tlsMode;
  }
  public putTlsMode(value: TransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode) {
    this._tlsMode.internalValue = value;
  }
  public resetTlsMode() {
    this._tlsMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsModeInput() {
    return this._tlsMode.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaTargetConnection {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#cluster_id TransferEndpoint#cluster_id}
  */
  readonly clusterId?: string;
  /**
  * on_premise block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#on_premise TransferEndpoint#on_premise}
  */
  readonly onPremise?: TransferEndpointSettingsKafkaTargetConnectionOnPremise;
}

export function transferEndpointSettingsKafkaTargetConnectionToTerraform(struct?: TransferEndpointSettingsKafkaTargetConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_id: cdktf.stringToTerraform(struct!.clusterId),
    on_premise: transferEndpointSettingsKafkaTargetConnectionOnPremiseToTerraform(struct!.onPremise),
  }
}


export function transferEndpointSettingsKafkaTargetConnectionToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.clusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_premise: {
      value: transferEndpointSettingsKafkaTargetConnectionOnPremiseToHclTerraform(struct!.onPremise),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTargetConnectionOnPremise",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaTargetConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterId = this._clusterId;
    }
    if (this._onPremise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.onPremise = this._onPremise?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterId = undefined;
      this._onPremise.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterId = value.clusterId;
      this._onPremise.internalValue = value.onPremise;
    }
  }

  // cluster_id - computed: false, optional: true, required: false
  private _clusterId?: string; 
  public get clusterId() {
    return this.getStringAttribute('cluster_id');
  }
  public set clusterId(value: string) {
    this._clusterId = value;
  }
  public resetClusterId() {
    this._clusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIdInput() {
    return this._clusterId;
  }

  // on_premise - computed: false, optional: true, required: false
  private _onPremise = new TransferEndpointSettingsKafkaTargetConnectionOnPremiseOutputReference(this, "on_premise");
  public get onPremise() {
    return this._onPremise;
  }
  public putOnPremise(value: TransferEndpointSettingsKafkaTargetConnectionOnPremise) {
    this._onPremise.internalValue = value;
  }
  public resetOnPremise() {
    this._onPremise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onPremiseInput() {
    return this._onPremise.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaTargetSerializerAuto {
}

export function transferEndpointSettingsKafkaTargetSerializerAutoToTerraform(struct?: TransferEndpointSettingsKafkaTargetSerializerAuto | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsKafkaTargetSerializerAutoToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetSerializerAuto | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsKafkaTargetSerializerAutoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetSerializerAuto | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetSerializerAuto | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsKafkaTargetSerializerDebeziumParameter {
  /**
  * Key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#key TransferEndpoint#key}
  */
  readonly key?: string;
  /**
  * Value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#value TransferEndpoint#value}
  */
  readonly value?: string;
}

export function transferEndpointSettingsKafkaTargetSerializerDebeziumParameterToTerraform(struct?: TransferEndpointSettingsKafkaTargetSerializerDebeziumParameter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function transferEndpointSettingsKafkaTargetSerializerDebeziumParameterToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetSerializerDebeziumParameter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaTargetSerializerDebeziumParameterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetSerializerDebeziumParameter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetSerializerDebeziumParameter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class TransferEndpointSettingsKafkaTargetSerializerDebeziumParameterList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsKafkaTargetSerializerDebeziumParameter[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsKafkaTargetSerializerDebeziumParameterOutputReference {
    return new TransferEndpointSettingsKafkaTargetSerializerDebeziumParameterOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsKafkaTargetSerializerDebezium {
  /**
  * parameter block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#parameter TransferEndpoint#parameter}
  */
  readonly parameter?: TransferEndpointSettingsKafkaTargetSerializerDebeziumParameter[] | cdktf.IResolvable;
}

export function transferEndpointSettingsKafkaTargetSerializerDebeziumToTerraform(struct?: TransferEndpointSettingsKafkaTargetSerializerDebezium | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    parameter: cdktf.listMapper(transferEndpointSettingsKafkaTargetSerializerDebeziumParameterToTerraform, true)(struct!.parameter),
  }
}


export function transferEndpointSettingsKafkaTargetSerializerDebeziumToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetSerializerDebezium | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    parameter: {
      value: cdktf.listMapperHcl(transferEndpointSettingsKafkaTargetSerializerDebeziumParameterToHclTerraform, true)(struct!.parameter),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsKafkaTargetSerializerDebeziumParameterList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaTargetSerializerDebeziumOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetSerializerDebezium | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._parameter?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameter = this._parameter?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetSerializerDebezium | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._parameter.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._parameter.internalValue = value.parameter;
    }
  }

  // parameter - computed: false, optional: true, required: false
  private _parameter = new TransferEndpointSettingsKafkaTargetSerializerDebeziumParameterList(this, "parameter", false);
  public get parameter() {
    return this._parameter;
  }
  public putParameter(value: TransferEndpointSettingsKafkaTargetSerializerDebeziumParameter[] | cdktf.IResolvable) {
    this._parameter.internalValue = value;
  }
  public resetParameter() {
    this._parameter.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parameterInput() {
    return this._parameter.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaTargetSerializerJson {
}

export function transferEndpointSettingsKafkaTargetSerializerJsonToTerraform(struct?: TransferEndpointSettingsKafkaTargetSerializerJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsKafkaTargetSerializerJsonToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetSerializerJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsKafkaTargetSerializerJsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetSerializerJson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetSerializerJson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsKafkaTargetSerializer {
  /**
  * auto block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#auto TransferEndpoint#auto}
  */
  readonly auto?: TransferEndpointSettingsKafkaTargetSerializerAuto;
  /**
  * debezium block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#debezium TransferEndpoint#debezium}
  */
  readonly debezium?: TransferEndpointSettingsKafkaTargetSerializerDebezium;
  /**
  * json block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#json TransferEndpoint#json}
  */
  readonly json?: TransferEndpointSettingsKafkaTargetSerializerJson;
}

export function transferEndpointSettingsKafkaTargetSerializerToTerraform(struct?: TransferEndpointSettingsKafkaTargetSerializer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto: transferEndpointSettingsKafkaTargetSerializerAutoToTerraform(struct!.auto),
    debezium: transferEndpointSettingsKafkaTargetSerializerDebeziumToTerraform(struct!.debezium),
    json: transferEndpointSettingsKafkaTargetSerializerJsonToTerraform(struct!.json),
  }
}


export function transferEndpointSettingsKafkaTargetSerializerToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetSerializer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto: {
      value: transferEndpointSettingsKafkaTargetSerializerAutoToHclTerraform(struct!.auto),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTargetSerializerAuto",
    },
    debezium: {
      value: transferEndpointSettingsKafkaTargetSerializerDebeziumToHclTerraform(struct!.debezium),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTargetSerializerDebezium",
    },
    json: {
      value: transferEndpointSettingsKafkaTargetSerializerJsonToHclTerraform(struct!.json),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTargetSerializerJson",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaTargetSerializerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetSerializer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auto?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auto = this._auto?.internalValue;
    }
    if (this._debezium?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.debezium = this._debezium?.internalValue;
    }
    if (this._json?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.json = this._json?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetSerializer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auto.internalValue = undefined;
      this._debezium.internalValue = undefined;
      this._json.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auto.internalValue = value.auto;
      this._debezium.internalValue = value.debezium;
      this._json.internalValue = value.json;
    }
  }

  // auto - computed: false, optional: true, required: true
  private _auto = new TransferEndpointSettingsKafkaTargetSerializerAutoOutputReference(this, "auto");
  public get auto() {
    return this._auto;
  }
  public putAuto(value: TransferEndpointSettingsKafkaTargetSerializerAuto) {
    this._auto.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get autoInput() {
    return this._auto.internalValue;
  }

  // debezium - computed: false, optional: true, required: false
  private _debezium = new TransferEndpointSettingsKafkaTargetSerializerDebeziumOutputReference(this, "debezium");
  public get debezium() {
    return this._debezium;
  }
  public putDebezium(value: TransferEndpointSettingsKafkaTargetSerializerDebezium) {
    this._debezium.internalValue = value;
  }
  public resetDebezium() {
    this._debezium.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debeziumInput() {
    return this._debezium.internalValue;
  }

  // json - computed: false, optional: true, required: true
  private _json = new TransferEndpointSettingsKafkaTargetSerializerJsonOutputReference(this, "json");
  public get json() {
    return this._json;
  }
  public putJson(value: TransferEndpointSettingsKafkaTargetSerializerJson) {
    this._json.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonInput() {
    return this._json.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaTargetTopicSettingsTopic {
  /**
  * Save transactions order. Not to split events queue into separate per-table queues.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#save_tx_order TransferEndpoint#save_tx_order}
  */
  readonly saveTxOrder?: boolean | cdktf.IResolvable;
  /**
  * Topic name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#topic_name TransferEndpoint#topic_name}
  */
  readonly topicName?: string;
}

export function transferEndpointSettingsKafkaTargetTopicSettingsTopicToTerraform(struct?: TransferEndpointSettingsKafkaTargetTopicSettingsTopic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    save_tx_order: cdktf.booleanToTerraform(struct!.saveTxOrder),
    topic_name: cdktf.stringToTerraform(struct!.topicName),
  }
}


export function transferEndpointSettingsKafkaTargetTopicSettingsTopicToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetTopicSettingsTopic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    save_tx_order: {
      value: cdktf.booleanToHclTerraform(struct!.saveTxOrder),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    topic_name: {
      value: cdktf.stringToHclTerraform(struct!.topicName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaTargetTopicSettingsTopicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetTopicSettingsTopic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._saveTxOrder !== undefined) {
      hasAnyValues = true;
      internalValueResult.saveTxOrder = this._saveTxOrder;
    }
    if (this._topicName !== undefined) {
      hasAnyValues = true;
      internalValueResult.topicName = this._topicName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetTopicSettingsTopic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._saveTxOrder = undefined;
      this._topicName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._saveTxOrder = value.saveTxOrder;
      this._topicName = value.topicName;
    }
  }

  // save_tx_order - computed: false, optional: true, required: false
  private _saveTxOrder?: boolean | cdktf.IResolvable; 
  public get saveTxOrder() {
    return this.getBooleanAttribute('save_tx_order');
  }
  public set saveTxOrder(value: boolean | cdktf.IResolvable) {
    this._saveTxOrder = value;
  }
  public resetSaveTxOrder() {
    this._saveTxOrder = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saveTxOrderInput() {
    return this._saveTxOrder;
  }

  // topic_name - computed: false, optional: true, required: false
  private _topicName?: string; 
  public get topicName() {
    return this.getStringAttribute('topic_name');
  }
  public set topicName(value: string) {
    this._topicName = value;
  }
  public resetTopicName() {
    this._topicName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicNameInput() {
    return this._topicName;
  }
}
export interface TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntries {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#config_name TransferEndpoint#config_name}
  */
  readonly configName: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#config_value TransferEndpoint#config_value}
  */
  readonly configValue: string;
}

export function transferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntriesToTerraform(struct?: TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_name: cdktf.stringToTerraform(struct!.configName),
    config_value: cdktf.stringToTerraform(struct!.configValue),
  }
}


export function transferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntriesToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_name: {
      value: cdktf.stringToHclTerraform(struct!.configName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    config_value: {
      value: cdktf.stringToHclTerraform(struct!.configValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntriesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntries | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configName !== undefined) {
      hasAnyValues = true;
      internalValueResult.configName = this._configName;
    }
    if (this._configValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configValue = this._configValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntries | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configName = undefined;
      this._configValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configName = value.configName;
      this._configValue = value.configValue;
    }
  }

  // config_name - computed: false, optional: false, required: true
  private _configName?: string; 
  public get configName() {
    return this.getStringAttribute('config_name');
  }
  public set configName(value: string) {
    this._configName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get configNameInput() {
    return this._configName;
  }

  // config_value - computed: false, optional: false, required: true
  private _configValue?: string; 
  public get configValue() {
    return this.getStringAttribute('config_value');
  }
  public set configValue(value: string) {
    this._configValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get configValueInput() {
    return this._configValue;
  }
}

export class TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntriesList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntries[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntriesOutputReference {
    return new TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntriesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsKafkaTargetTopicSettings {
  /**
  * Analogue of the Debezium setting database.server.name. Messages will be sent to topic with name <topic_prefix>.<schema>.<table_name>.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#topic_prefix TransferEndpoint#topic_prefix}
  */
  readonly topicPrefix?: string;
  /**
  * topic block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#topic TransferEndpoint#topic}
  */
  readonly topic?: TransferEndpointSettingsKafkaTargetTopicSettingsTopic;
  /**
  * topic_config_entries block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#topic_config_entries TransferEndpoint#topic_config_entries}
  */
  readonly topicConfigEntries?: TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntries[] | cdktf.IResolvable;
}

export function transferEndpointSettingsKafkaTargetTopicSettingsToTerraform(struct?: TransferEndpointSettingsKafkaTargetTopicSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    topic_prefix: cdktf.stringToTerraform(struct!.topicPrefix),
    topic: transferEndpointSettingsKafkaTargetTopicSettingsTopicToTerraform(struct!.topic),
    topic_config_entries: cdktf.listMapper(transferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntriesToTerraform, true)(struct!.topicConfigEntries),
  }
}


export function transferEndpointSettingsKafkaTargetTopicSettingsToHclTerraform(struct?: TransferEndpointSettingsKafkaTargetTopicSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    topic_prefix: {
      value: cdktf.stringToHclTerraform(struct!.topicPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    topic: {
      value: transferEndpointSettingsKafkaTargetTopicSettingsTopicToHclTerraform(struct!.topic),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTargetTopicSettingsTopic",
    },
    topic_config_entries: {
      value: cdktf.listMapperHcl(transferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntriesToHclTerraform, true)(struct!.topicConfigEntries),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntriesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaTargetTopicSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTargetTopicSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._topicPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.topicPrefix = this._topicPrefix;
    }
    if (this._topic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.topic = this._topic?.internalValue;
    }
    if (this._topicConfigEntries?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.topicConfigEntries = this._topicConfigEntries?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTargetTopicSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._topicPrefix = undefined;
      this._topic.internalValue = undefined;
      this._topicConfigEntries.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._topicPrefix = value.topicPrefix;
      this._topic.internalValue = value.topic;
      this._topicConfigEntries.internalValue = value.topicConfigEntries;
    }
  }

  // topic_prefix - computed: false, optional: true, required: false
  private _topicPrefix?: string; 
  public get topicPrefix() {
    return this.getStringAttribute('topic_prefix');
  }
  public set topicPrefix(value: string) {
    this._topicPrefix = value;
  }
  public resetTopicPrefix() {
    this._topicPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicPrefixInput() {
    return this._topicPrefix;
  }

  // topic - computed: false, optional: true, required: false
  private _topic = new TransferEndpointSettingsKafkaTargetTopicSettingsTopicOutputReference(this, "topic");
  public get topic() {
    return this._topic;
  }
  public putTopic(value: TransferEndpointSettingsKafkaTargetTopicSettingsTopic) {
    this._topic.internalValue = value;
  }
  public resetTopic() {
    this._topic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicInput() {
    return this._topic.internalValue;
  }

  // topic_config_entries - computed: false, optional: true, required: false
  private _topicConfigEntries = new TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntriesList(this, "topic_config_entries", false);
  public get topicConfigEntries() {
    return this._topicConfigEntries;
  }
  public putTopicConfigEntries(value: TransferEndpointSettingsKafkaTargetTopicSettingsTopicConfigEntries[] | cdktf.IResolvable) {
    this._topicConfigEntries.internalValue = value;
  }
  public resetTopicConfigEntries() {
    this._topicConfigEntries.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicConfigEntriesInput() {
    return this._topicConfigEntries.internalValue;
  }
}
export interface TransferEndpointSettingsKafkaTarget {
  /**
  * auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#auth TransferEndpoint#auth}
  */
  readonly auth?: TransferEndpointSettingsKafkaTargetAuth;
  /**
  * connection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection TransferEndpoint#connection}
  */
  readonly connection?: TransferEndpointSettingsKafkaTargetConnection;
  /**
  * serializer block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#serializer TransferEndpoint#serializer}
  */
  readonly serializer?: TransferEndpointSettingsKafkaTargetSerializer;
  /**
  * topic_settings block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#topic_settings TransferEndpoint#topic_settings}
  */
  readonly topicSettings?: TransferEndpointSettingsKafkaTargetTopicSettings;
}

export function transferEndpointSettingsKafkaTargetToTerraform(struct?: TransferEndpointSettingsKafkaTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: transferEndpointSettingsKafkaTargetAuthToTerraform(struct!.auth),
    connection: transferEndpointSettingsKafkaTargetConnectionToTerraform(struct!.connection),
    serializer: transferEndpointSettingsKafkaTargetSerializerToTerraform(struct!.serializer),
    topic_settings: transferEndpointSettingsKafkaTargetTopicSettingsToTerraform(struct!.topicSettings),
  }
}


export function transferEndpointSettingsKafkaTargetToHclTerraform(struct?: TransferEndpointSettingsKafkaTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: transferEndpointSettingsKafkaTargetAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTargetAuth",
    },
    connection: {
      value: transferEndpointSettingsKafkaTargetConnectionToHclTerraform(struct!.connection),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTargetConnection",
    },
    serializer: {
      value: transferEndpointSettingsKafkaTargetSerializerToHclTerraform(struct!.serializer),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTargetSerializer",
    },
    topic_settings: {
      value: transferEndpointSettingsKafkaTargetTopicSettingsToHclTerraform(struct!.topicSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTargetTopicSettings",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKafkaTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKafkaTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connection = this._connection?.internalValue;
    }
    if (this._serializer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serializer = this._serializer?.internalValue;
    }
    if (this._topicSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.topicSettings = this._topicSettings?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKafkaTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connection.internalValue = undefined;
      this._serializer.internalValue = undefined;
      this._topicSettings.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connection.internalValue = value.connection;
      this._serializer.internalValue = value.serializer;
      this._topicSettings.internalValue = value.topicSettings;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new TransferEndpointSettingsKafkaTargetAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: TransferEndpointSettingsKafkaTargetAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection - computed: false, optional: true, required: false
  private _connection = new TransferEndpointSettingsKafkaTargetConnectionOutputReference(this, "connection");
  public get connection() {
    return this._connection;
  }
  public putConnection(value: TransferEndpointSettingsKafkaTargetConnection) {
    this._connection.internalValue = value;
  }
  public resetConnection() {
    this._connection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionInput() {
    return this._connection.internalValue;
  }

  // serializer - computed: false, optional: true, required: false
  private _serializer = new TransferEndpointSettingsKafkaTargetSerializerOutputReference(this, "serializer");
  public get serializer() {
    return this._serializer;
  }
  public putSerializer(value: TransferEndpointSettingsKafkaTargetSerializer) {
    this._serializer.internalValue = value;
  }
  public resetSerializer() {
    this._serializer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serializerInput() {
    return this._serializer.internalValue;
  }

  // topic_settings - computed: false, optional: true, required: false
  private _topicSettings = new TransferEndpointSettingsKafkaTargetTopicSettingsOutputReference(this, "topic_settings");
  public get topicSettings() {
    return this._topicSettings;
  }
  public putTopicSettings(value: TransferEndpointSettingsKafkaTargetTopicSettings) {
    this._topicSettings.internalValue = value;
  }
  public resetTopicSettings() {
    this._topicSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicSettingsInput() {
    return this._topicSettings.internalValue;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserBlank {
}

export function transferEndpointSettingsKinesisSourceParserBlankToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserBlank | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsKinesisSourceParserBlankToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserBlank | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsKinesisSourceParserBlankOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserBlank | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserBlank | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#key TransferEndpoint#key}
  */
  readonly key?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#name TransferEndpoint#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#path TransferEndpoint#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#required TransferEndpoint#required}
  */
  readonly required?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#type TransferEndpoint#type}
  */
  readonly type?: string;
}

export function transferEndpointSettingsKinesisSourceParserJsonSchemaFieldsFieldToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.booleanToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    required: cdktf.booleanToTerraform(struct!.required),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function transferEndpointSettingsKinesisSourceParserJsonSchemaFieldsFieldToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.booleanToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    required: {
      value: cdktf.booleanToHclTerraform(struct!.required),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._required !== undefined) {
      hasAnyValues = true;
      internalValueResult.required = this._required;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._path = undefined;
      this._required = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._path = value.path;
      this._required = value.required;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: boolean | cdktf.IResolvable; 
  public get key() {
    return this.getBooleanAttribute('key');
  }
  public set key(value: boolean | cdktf.IResolvable) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // required - computed: false, optional: true, required: false
  private _required?: boolean | cdktf.IResolvable; 
  public get required() {
    return this.getBooleanAttribute('required');
  }
  public set required(value: boolean | cdktf.IResolvable) {
    this._required = value;
  }
  public resetRequired() {
    this._required = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredInput() {
    return this._required;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsFieldList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsField[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsFieldOutputReference {
    return new TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsFieldOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsKinesisSourceParserJsonSchemaFields {
  /**
  * field block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#field TransferEndpoint#field}
  */
  readonly field?: TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsField[] | cdktf.IResolvable;
}

export function transferEndpointSettingsKinesisSourceParserJsonSchemaFieldsToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserJsonSchemaFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.listMapper(transferEndpointSettingsKinesisSourceParserJsonSchemaFieldsFieldToTerraform, true)(struct!.field),
  }
}


export function transferEndpointSettingsKinesisSourceParserJsonSchemaFieldsToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserJsonSchemaFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.listMapperHcl(transferEndpointSettingsKinesisSourceParserJsonSchemaFieldsFieldToHclTerraform, true)(struct!.field),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsFieldList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserJsonSchemaFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserJsonSchemaFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field.internalValue = value.field;
    }
  }

  // field - computed: false, optional: true, required: false
  private _field = new TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsFieldList(this, "field", false);
  public get field() {
    return this._field;
  }
  public putField(value: TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsField[] | cdktf.IResolvable) {
    this._field.internalValue = value;
  }
  public resetField() {
    this._field.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field.internalValue;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserJsonSchemaJson {
  /**
  * Fields
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#fields TransferEndpoint#fields}
  */
  readonly fields?: string;
}

export function transferEndpointSettingsKinesisSourceParserJsonSchemaJsonToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserJsonSchemaJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fields: cdktf.stringToTerraform(struct!.fields),
  }
}


export function transferEndpointSettingsKinesisSourceParserJsonSchemaJsonToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserJsonSchemaJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fields: {
      value: cdktf.stringToHclTerraform(struct!.fields),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserJsonSchemaJsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserJsonSchemaJson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fields !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserJsonSchemaJson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fields = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fields = value.fields;
    }
  }

  // fields - computed: false, optional: true, required: false
  private _fields?: string; 
  public get fields() {
    return this.getStringAttribute('fields');
  }
  public set fields(value: string) {
    this._fields = value;
  }
  public resetFields() {
    this._fields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserJsonSchema {
  /**
  * fields block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#fields TransferEndpoint#fields}
  */
  readonly fields?: TransferEndpointSettingsKinesisSourceParserJsonSchemaFields;
  /**
  * json block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#json TransferEndpoint#json}
  */
  readonly json?: TransferEndpointSettingsKinesisSourceParserJsonSchemaJson;
}

export function transferEndpointSettingsKinesisSourceParserJsonSchemaToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserJsonSchema | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fields: transferEndpointSettingsKinesisSourceParserJsonSchemaFieldsToTerraform(struct!.fields),
    json: transferEndpointSettingsKinesisSourceParserJsonSchemaJsonToTerraform(struct!.json),
  }
}


export function transferEndpointSettingsKinesisSourceParserJsonSchemaToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserJsonSchema | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fields: {
      value: transferEndpointSettingsKinesisSourceParserJsonSchemaFieldsToHclTerraform(struct!.fields),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserJsonSchemaFields",
    },
    json: {
      value: transferEndpointSettingsKinesisSourceParserJsonSchemaJsonToHclTerraform(struct!.json),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserJsonSchemaJson",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserJsonSchemaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserJsonSchema | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields?.internalValue;
    }
    if (this._json?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.json = this._json?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserJsonSchema | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fields.internalValue = undefined;
      this._json.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fields.internalValue = value.fields;
      this._json.internalValue = value.json;
    }
  }

  // fields - computed: false, optional: true, required: false
  private _fields = new TransferEndpointSettingsKinesisSourceParserJsonSchemaFieldsOutputReference(this, "fields");
  public get fields() {
    return this._fields;
  }
  public putFields(value: TransferEndpointSettingsKinesisSourceParserJsonSchemaFields) {
    this._fields.internalValue = value;
  }
  public resetFields() {
    this._fields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields.internalValue;
  }

  // json - computed: false, optional: true, required: false
  private _json = new TransferEndpointSettingsKinesisSourceParserJsonSchemaJsonOutputReference(this, "json");
  public get json() {
    return this._json;
  }
  public putJson(value: TransferEndpointSettingsKinesisSourceParserJsonSchemaJson) {
    this._json.internalValue = value;
  }
  public resetJson() {
    this._json.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonInput() {
    return this._json.internalValue;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserJson {
  /**
  * Add the `_rest` column for all unknown fields
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#add_rest_column TransferEndpoint#add_rest_column}
  */
  readonly addRestColumn?: boolean | cdktf.IResolvable;
  /**
  * Allow null keys. If false, null keys are put to unparsed data
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#null_keys_allowed TransferEndpoint#null_keys_allowed}
  */
  readonly nullKeysAllowed?: boolean | cdktf.IResolvable;
  /**
  * schema block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#schema TransferEndpoint#schema}
  */
  readonly schema?: TransferEndpointSettingsKinesisSourceParserJsonSchema;
}

export function transferEndpointSettingsKinesisSourceParserJsonToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_rest_column: cdktf.booleanToTerraform(struct!.addRestColumn),
    null_keys_allowed: cdktf.booleanToTerraform(struct!.nullKeysAllowed),
    schema: transferEndpointSettingsKinesisSourceParserJsonSchemaToTerraform(struct!.schema),
  }
}


export function transferEndpointSettingsKinesisSourceParserJsonToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_rest_column: {
      value: cdktf.booleanToHclTerraform(struct!.addRestColumn),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    null_keys_allowed: {
      value: cdktf.booleanToHclTerraform(struct!.nullKeysAllowed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    schema: {
      value: transferEndpointSettingsKinesisSourceParserJsonSchemaToHclTerraform(struct!.schema),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserJsonSchema",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserJsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserJson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRestColumn !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRestColumn = this._addRestColumn;
    }
    if (this._nullKeysAllowed !== undefined) {
      hasAnyValues = true;
      internalValueResult.nullKeysAllowed = this._nullKeysAllowed;
    }
    if (this._schema?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserJson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRestColumn = undefined;
      this._nullKeysAllowed = undefined;
      this._schema.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRestColumn = value.addRestColumn;
      this._nullKeysAllowed = value.nullKeysAllowed;
      this._schema.internalValue = value.schema;
    }
  }

  // add_rest_column - computed: false, optional: true, required: false
  private _addRestColumn?: boolean | cdktf.IResolvable; 
  public get addRestColumn() {
    return this.getBooleanAttribute('add_rest_column');
  }
  public set addRestColumn(value: boolean | cdktf.IResolvable) {
    this._addRestColumn = value;
  }
  public resetAddRestColumn() {
    this._addRestColumn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRestColumnInput() {
    return this._addRestColumn;
  }

  // null_keys_allowed - computed: false, optional: true, required: false
  private _nullKeysAllowed?: boolean | cdktf.IResolvable; 
  public get nullKeysAllowed() {
    return this.getBooleanAttribute('null_keys_allowed');
  }
  public set nullKeysAllowed(value: boolean | cdktf.IResolvable) {
    this._nullKeysAllowed = value;
  }
  public resetNullKeysAllowed() {
    this._nullKeysAllowed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullKeysAllowedInput() {
    return this._nullKeysAllowed;
  }

  // schema - computed: false, optional: true, required: false
  private _schema = new TransferEndpointSettingsKinesisSourceParserJsonSchemaOutputReference(this, "schema");
  public get schema() {
    return this._schema;
  }
  public putSchema(value: TransferEndpointSettingsKinesisSourceParserJsonSchema) {
    this._schema.internalValue = value;
  }
  public resetSchema() {
    this._schema.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema.internalValue;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserRawTable {
  /**
  * Add headers column to output virtual table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#add_headers TransferEndpoint#add_headers}
  */
  readonly addHeaders?: boolean | cdktf.IResolvable;
  /**
  * Add key column to output virtual table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#add_key TransferEndpoint#add_key}
  */
  readonly addKey?: boolean | cdktf.IResolvable;
  /**
  * Add timestamp column to output virtual table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#add_timestamp TransferEndpoint#add_timestamp}
  */
  readonly addTimestamp?: boolean | cdktf.IResolvable;
  /**
  * Make keys column as `bytes`, for non-utf8 characters
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#keys_as_bytes TransferEndpoint#keys_as_bytes}
  */
  readonly keysAsBytes?: boolean | cdktf.IResolvable;
  /**
  * Make value column as `bytes`, for non-utf8 characters
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#value_as_bytes TransferEndpoint#value_as_bytes}
  */
  readonly valueAsBytes?: boolean | cdktf.IResolvable;
}

export function transferEndpointSettingsKinesisSourceParserRawTableToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserRawTable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_headers: cdktf.booleanToTerraform(struct!.addHeaders),
    add_key: cdktf.booleanToTerraform(struct!.addKey),
    add_timestamp: cdktf.booleanToTerraform(struct!.addTimestamp),
    keys_as_bytes: cdktf.booleanToTerraform(struct!.keysAsBytes),
    value_as_bytes: cdktf.booleanToTerraform(struct!.valueAsBytes),
  }
}


export function transferEndpointSettingsKinesisSourceParserRawTableToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserRawTable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_headers: {
      value: cdktf.booleanToHclTerraform(struct!.addHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    add_key: {
      value: cdktf.booleanToHclTerraform(struct!.addKey),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    add_timestamp: {
      value: cdktf.booleanToHclTerraform(struct!.addTimestamp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keys_as_bytes: {
      value: cdktf.booleanToHclTerraform(struct!.keysAsBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value_as_bytes: {
      value: cdktf.booleanToHclTerraform(struct!.valueAsBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserRawTableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserRawTable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.addHeaders = this._addHeaders;
    }
    if (this._addKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.addKey = this._addKey;
    }
    if (this._addTimestamp !== undefined) {
      hasAnyValues = true;
      internalValueResult.addTimestamp = this._addTimestamp;
    }
    if (this._keysAsBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.keysAsBytes = this._keysAsBytes;
    }
    if (this._valueAsBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueAsBytes = this._valueAsBytes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserRawTable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addHeaders = undefined;
      this._addKey = undefined;
      this._addTimestamp = undefined;
      this._keysAsBytes = undefined;
      this._valueAsBytes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addHeaders = value.addHeaders;
      this._addKey = value.addKey;
      this._addTimestamp = value.addTimestamp;
      this._keysAsBytes = value.keysAsBytes;
      this._valueAsBytes = value.valueAsBytes;
    }
  }

  // add_headers - computed: false, optional: true, required: false
  private _addHeaders?: boolean | cdktf.IResolvable; 
  public get addHeaders() {
    return this.getBooleanAttribute('add_headers');
  }
  public set addHeaders(value: boolean | cdktf.IResolvable) {
    this._addHeaders = value;
  }
  public resetAddHeaders() {
    this._addHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addHeadersInput() {
    return this._addHeaders;
  }

  // add_key - computed: false, optional: true, required: false
  private _addKey?: boolean | cdktf.IResolvable; 
  public get addKey() {
    return this.getBooleanAttribute('add_key');
  }
  public set addKey(value: boolean | cdktf.IResolvable) {
    this._addKey = value;
  }
  public resetAddKey() {
    this._addKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addKeyInput() {
    return this._addKey;
  }

  // add_timestamp - computed: false, optional: true, required: false
  private _addTimestamp?: boolean | cdktf.IResolvable; 
  public get addTimestamp() {
    return this.getBooleanAttribute('add_timestamp');
  }
  public set addTimestamp(value: boolean | cdktf.IResolvable) {
    this._addTimestamp = value;
  }
  public resetAddTimestamp() {
    this._addTimestamp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addTimestampInput() {
    return this._addTimestamp;
  }

  // keys_as_bytes - computed: false, optional: true, required: false
  private _keysAsBytes?: boolean | cdktf.IResolvable; 
  public get keysAsBytes() {
    return this.getBooleanAttribute('keys_as_bytes');
  }
  public set keysAsBytes(value: boolean | cdktf.IResolvable) {
    this._keysAsBytes = value;
  }
  public resetKeysAsBytes() {
    this._keysAsBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keysAsBytesInput() {
    return this._keysAsBytes;
  }

  // value_as_bytes - computed: false, optional: true, required: false
  private _valueAsBytes?: boolean | cdktf.IResolvable; 
  public get valueAsBytes() {
    return this.getBooleanAttribute('value_as_bytes');
  }
  public set valueAsBytes(value: boolean | cdktf.IResolvable) {
    this._valueAsBytes = value;
  }
  public resetValueAsBytes() {
    this._valueAsBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueAsBytesInput() {
    return this._valueAsBytes;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasic {
  /**
  * Password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * User name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#user TransferEndpoint#user}
  */
  readonly user?: string;
}

export function transferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasicToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function transferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasicToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._password = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._password = value.password;
      this._user = value.user;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuth {
}

export function transferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuthToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuthToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuth {
  /**
  * basic block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#basic TransferEndpoint#basic}
  */
  readonly basic?: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasic;
  /**
  * no_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#no_auth TransferEndpoint#no_auth}
  */
  readonly noAuth?: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuth;
}

export function transferEndpointSettingsKinesisSourceParserSchemaRegistryAuthToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    basic: transferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasicToTerraform(struct!.basic),
    no_auth: transferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuthToTerraform(struct!.noAuth),
  }
}


export function transferEndpointSettingsKinesisSourceParserSchemaRegistryAuthToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    basic: {
      value: transferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasicToHclTerraform(struct!.basic),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasic",
    },
    no_auth: {
      value: transferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuthToHclTerraform(struct!.noAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuth",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._basic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basic = this._basic?.internalValue;
    }
    if (this._noAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.noAuth = this._noAuth?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._basic.internalValue = undefined;
      this._noAuth.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._basic.internalValue = value.basic;
      this._noAuth.internalValue = value.noAuth;
    }
  }

  // basic - computed: false, optional: true, required: false
  private _basic = new TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasicOutputReference(this, "basic");
  public get basic() {
    return this._basic;
  }
  public putBasic(value: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthBasic) {
    this._basic.internalValue = value;
  }
  public resetBasic() {
    this._basic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicInput() {
    return this._basic.internalValue;
  }

  // no_auth - computed: false, optional: true, required: true
  private _noAuth = new TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuthOutputReference(this, "no_auth");
  public get noAuth() {
    return this._noAuth;
  }
  public putNoAuth(value: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthNoAuth) {
    this._noAuth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get noAuthInput() {
    return this._noAuth.internalValue;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserSchemaRegistryTls {
  /**
  * X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. When CA certificate is specified TLS is used to connect to the server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ca_certificate TransferEndpoint#ca_certificate}
  */
  readonly caCertificate?: string;
}

export function transferEndpointSettingsKinesisSourceParserSchemaRegistryTlsToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificate: cdktf.stringToTerraform(struct!.caCertificate),
  }
}


export function transferEndpointSettingsKinesisSourceParserSchemaRegistryTlsToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.caCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificate = this._caCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificate = value.caCertificate;
    }
  }

  // ca_certificate - computed: false, optional: true, required: false
  private _caCertificate?: string; 
  public get caCertificate() {
    return this.getStringAttribute('ca_certificate');
  }
  public set caCertificate(value: string) {
    this._caCertificate = value;
  }
  public resetCaCertificate() {
    this._caCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificateInput() {
    return this._caCertificate;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserSchemaRegistry {
  /**
  * Address of schema registry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#url TransferEndpoint#url}
  */
  readonly url?: string;
  /**
  * auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#auth TransferEndpoint#auth}
  */
  readonly auth?: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuth;
  /**
  * tls block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tls TransferEndpoint#tls}
  */
  readonly tls?: TransferEndpointSettingsKinesisSourceParserSchemaRegistryTls;
}

export function transferEndpointSettingsKinesisSourceParserSchemaRegistryToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
    auth: transferEndpointSettingsKinesisSourceParserSchemaRegistryAuthToTerraform(struct!.auth),
    tls: transferEndpointSettingsKinesisSourceParserSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function transferEndpointSettingsKinesisSourceParserSchemaRegistryToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth: {
      value: transferEndpointSettingsKinesisSourceParserSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuth",
    },
    tls: {
      value: transferEndpointSettingsKinesisSourceParserSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
      this._auth.internalValue = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
      this._auth.internalValue = value.auth;
      this._tls.internalValue = value.tls;
    }
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: TransferEndpointSettingsKinesisSourceParserSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new TransferEndpointSettingsKinesisSourceParserSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: TransferEndpointSettingsKinesisSourceParserSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#key TransferEndpoint#key}
  */
  readonly key?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#name TransferEndpoint#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#path TransferEndpoint#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#required TransferEndpoint#required}
  */
  readonly required?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#type TransferEndpoint#type}
  */
  readonly type?: string;
}

export function transferEndpointSettingsKinesisSourceParserTskvSchemaFieldsFieldToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.booleanToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    required: cdktf.booleanToTerraform(struct!.required),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function transferEndpointSettingsKinesisSourceParserTskvSchemaFieldsFieldToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.booleanToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    required: {
      value: cdktf.booleanToHclTerraform(struct!.required),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._required !== undefined) {
      hasAnyValues = true;
      internalValueResult.required = this._required;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._path = undefined;
      this._required = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._path = value.path;
      this._required = value.required;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: boolean | cdktf.IResolvable; 
  public get key() {
    return this.getBooleanAttribute('key');
  }
  public set key(value: boolean | cdktf.IResolvable) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // required - computed: false, optional: true, required: false
  private _required?: boolean | cdktf.IResolvable; 
  public get required() {
    return this.getBooleanAttribute('required');
  }
  public set required(value: boolean | cdktf.IResolvable) {
    this._required = value;
  }
  public resetRequired() {
    this._required = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredInput() {
    return this._required;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsFieldList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsField[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsFieldOutputReference {
    return new TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsFieldOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsKinesisSourceParserTskvSchemaFields {
  /**
  * field block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#field TransferEndpoint#field}
  */
  readonly field?: TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsField[] | cdktf.IResolvable;
}

export function transferEndpointSettingsKinesisSourceParserTskvSchemaFieldsToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserTskvSchemaFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.listMapper(transferEndpointSettingsKinesisSourceParserTskvSchemaFieldsFieldToTerraform, true)(struct!.field),
  }
}


export function transferEndpointSettingsKinesisSourceParserTskvSchemaFieldsToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserTskvSchemaFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.listMapperHcl(transferEndpointSettingsKinesisSourceParserTskvSchemaFieldsFieldToHclTerraform, true)(struct!.field),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsFieldList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserTskvSchemaFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserTskvSchemaFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field.internalValue = value.field;
    }
  }

  // field - computed: false, optional: true, required: false
  private _field = new TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsFieldList(this, "field", false);
  public get field() {
    return this._field;
  }
  public putField(value: TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsField[] | cdktf.IResolvable) {
    this._field.internalValue = value;
  }
  public resetField() {
    this._field.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field.internalValue;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserTskvSchemaJson {
  /**
  * Fields
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#fields TransferEndpoint#fields}
  */
  readonly fields?: string;
}

export function transferEndpointSettingsKinesisSourceParserTskvSchemaJsonToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserTskvSchemaJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fields: cdktf.stringToTerraform(struct!.fields),
  }
}


export function transferEndpointSettingsKinesisSourceParserTskvSchemaJsonToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserTskvSchemaJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fields: {
      value: cdktf.stringToHclTerraform(struct!.fields),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserTskvSchemaJsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserTskvSchemaJson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fields !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserTskvSchemaJson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fields = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fields = value.fields;
    }
  }

  // fields - computed: false, optional: true, required: false
  private _fields?: string; 
  public get fields() {
    return this.getStringAttribute('fields');
  }
  public set fields(value: string) {
    this._fields = value;
  }
  public resetFields() {
    this._fields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserTskvSchema {
  /**
  * fields block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#fields TransferEndpoint#fields}
  */
  readonly fields?: TransferEndpointSettingsKinesisSourceParserTskvSchemaFields;
  /**
  * json block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#json TransferEndpoint#json}
  */
  readonly json?: TransferEndpointSettingsKinesisSourceParserTskvSchemaJson;
}

export function transferEndpointSettingsKinesisSourceParserTskvSchemaToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserTskvSchema | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fields: transferEndpointSettingsKinesisSourceParserTskvSchemaFieldsToTerraform(struct!.fields),
    json: transferEndpointSettingsKinesisSourceParserTskvSchemaJsonToTerraform(struct!.json),
  }
}


export function transferEndpointSettingsKinesisSourceParserTskvSchemaToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserTskvSchema | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fields: {
      value: transferEndpointSettingsKinesisSourceParserTskvSchemaFieldsToHclTerraform(struct!.fields),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserTskvSchemaFields",
    },
    json: {
      value: transferEndpointSettingsKinesisSourceParserTskvSchemaJsonToHclTerraform(struct!.json),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserTskvSchemaJson",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserTskvSchemaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserTskvSchema | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields?.internalValue;
    }
    if (this._json?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.json = this._json?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserTskvSchema | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fields.internalValue = undefined;
      this._json.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fields.internalValue = value.fields;
      this._json.internalValue = value.json;
    }
  }

  // fields - computed: false, optional: true, required: false
  private _fields = new TransferEndpointSettingsKinesisSourceParserTskvSchemaFieldsOutputReference(this, "fields");
  public get fields() {
    return this._fields;
  }
  public putFields(value: TransferEndpointSettingsKinesisSourceParserTskvSchemaFields) {
    this._fields.internalValue = value;
  }
  public resetFields() {
    this._fields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields.internalValue;
  }

  // json - computed: false, optional: true, required: false
  private _json = new TransferEndpointSettingsKinesisSourceParserTskvSchemaJsonOutputReference(this, "json");
  public get json() {
    return this._json;
  }
  public putJson(value: TransferEndpointSettingsKinesisSourceParserTskvSchemaJson) {
    this._json.internalValue = value;
  }
  public resetJson() {
    this._json.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonInput() {
    return this._json.internalValue;
  }
}
export interface TransferEndpointSettingsKinesisSourceParserTskv {
  /**
  * Add the `_rest` column for all unknown fields
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#add_rest_column TransferEndpoint#add_rest_column}
  */
  readonly addRestColumn?: boolean | cdktf.IResolvable;
  /**
  * Allow null keys. If false, null keys are put to unparsed data
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#null_keys_allowed TransferEndpoint#null_keys_allowed}
  */
  readonly nullKeysAllowed?: boolean | cdktf.IResolvable;
  /**
  * schema block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#schema TransferEndpoint#schema}
  */
  readonly schema?: TransferEndpointSettingsKinesisSourceParserTskvSchema;
}

export function transferEndpointSettingsKinesisSourceParserTskvToTerraform(struct?: TransferEndpointSettingsKinesisSourceParserTskv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_rest_column: cdktf.booleanToTerraform(struct!.addRestColumn),
    null_keys_allowed: cdktf.booleanToTerraform(struct!.nullKeysAllowed),
    schema: transferEndpointSettingsKinesisSourceParserTskvSchemaToTerraform(struct!.schema),
  }
}


export function transferEndpointSettingsKinesisSourceParserTskvToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParserTskv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_rest_column: {
      value: cdktf.booleanToHclTerraform(struct!.addRestColumn),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    null_keys_allowed: {
      value: cdktf.booleanToHclTerraform(struct!.nullKeysAllowed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    schema: {
      value: transferEndpointSettingsKinesisSourceParserTskvSchemaToHclTerraform(struct!.schema),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserTskvSchema",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserTskvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParserTskv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addRestColumn !== undefined) {
      hasAnyValues = true;
      internalValueResult.addRestColumn = this._addRestColumn;
    }
    if (this._nullKeysAllowed !== undefined) {
      hasAnyValues = true;
      internalValueResult.nullKeysAllowed = this._nullKeysAllowed;
    }
    if (this._schema?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParserTskv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addRestColumn = undefined;
      this._nullKeysAllowed = undefined;
      this._schema.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addRestColumn = value.addRestColumn;
      this._nullKeysAllowed = value.nullKeysAllowed;
      this._schema.internalValue = value.schema;
    }
  }

  // add_rest_column - computed: false, optional: true, required: false
  private _addRestColumn?: boolean | cdktf.IResolvable; 
  public get addRestColumn() {
    return this.getBooleanAttribute('add_rest_column');
  }
  public set addRestColumn(value: boolean | cdktf.IResolvable) {
    this._addRestColumn = value;
  }
  public resetAddRestColumn() {
    this._addRestColumn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addRestColumnInput() {
    return this._addRestColumn;
  }

  // null_keys_allowed - computed: false, optional: true, required: false
  private _nullKeysAllowed?: boolean | cdktf.IResolvable; 
  public get nullKeysAllowed() {
    return this.getBooleanAttribute('null_keys_allowed');
  }
  public set nullKeysAllowed(value: boolean | cdktf.IResolvable) {
    this._nullKeysAllowed = value;
  }
  public resetNullKeysAllowed() {
    this._nullKeysAllowed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullKeysAllowedInput() {
    return this._nullKeysAllowed;
  }

  // schema - computed: false, optional: true, required: false
  private _schema = new TransferEndpointSettingsKinesisSourceParserTskvSchemaOutputReference(this, "schema");
  public get schema() {
    return this._schema;
  }
  public putSchema(value: TransferEndpointSettingsKinesisSourceParserTskvSchema) {
    this._schema.internalValue = value;
  }
  public resetSchema() {
    this._schema.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema.internalValue;
  }
}
export interface TransferEndpointSettingsKinesisSourceParser {
  /**
  * blank block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#blank TransferEndpoint#blank}
  */
  readonly blank?: TransferEndpointSettingsKinesisSourceParserBlank;
  /**
  * json block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#json TransferEndpoint#json}
  */
  readonly json?: TransferEndpointSettingsKinesisSourceParserJson;
  /**
  * raw_table block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#raw_table TransferEndpoint#raw_table}
  */
  readonly rawTable?: TransferEndpointSettingsKinesisSourceParserRawTable;
  /**
  * schema_registry block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#schema_registry TransferEndpoint#schema_registry}
  */
  readonly schemaRegistry?: TransferEndpointSettingsKinesisSourceParserSchemaRegistry;
  /**
  * tskv block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tskv TransferEndpoint#tskv}
  */
  readonly tskv?: TransferEndpointSettingsKinesisSourceParserTskv;
}

export function transferEndpointSettingsKinesisSourceParserToTerraform(struct?: TransferEndpointSettingsKinesisSourceParser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    blank: transferEndpointSettingsKinesisSourceParserBlankToTerraform(struct!.blank),
    json: transferEndpointSettingsKinesisSourceParserJsonToTerraform(struct!.json),
    raw_table: transferEndpointSettingsKinesisSourceParserRawTableToTerraform(struct!.rawTable),
    schema_registry: transferEndpointSettingsKinesisSourceParserSchemaRegistryToTerraform(struct!.schemaRegistry),
    tskv: transferEndpointSettingsKinesisSourceParserTskvToTerraform(struct!.tskv),
  }
}


export function transferEndpointSettingsKinesisSourceParserToHclTerraform(struct?: TransferEndpointSettingsKinesisSourceParser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    blank: {
      value: transferEndpointSettingsKinesisSourceParserBlankToHclTerraform(struct!.blank),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserBlank",
    },
    json: {
      value: transferEndpointSettingsKinesisSourceParserJsonToHclTerraform(struct!.json),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserJson",
    },
    raw_table: {
      value: transferEndpointSettingsKinesisSourceParserRawTableToHclTerraform(struct!.rawTable),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserRawTable",
    },
    schema_registry: {
      value: transferEndpointSettingsKinesisSourceParserSchemaRegistryToHclTerraform(struct!.schemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserSchemaRegistry",
    },
    tskv: {
      value: transferEndpointSettingsKinesisSourceParserTskvToHclTerraform(struct!.tskv),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParserTskv",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceParserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSourceParser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._blank?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.blank = this._blank?.internalValue;
    }
    if (this._json?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.json = this._json?.internalValue;
    }
    if (this._rawTable?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rawTable = this._rawTable?.internalValue;
    }
    if (this._schemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistry = this._schemaRegistry?.internalValue;
    }
    if (this._tskv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tskv = this._tskv?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSourceParser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._blank.internalValue = undefined;
      this._json.internalValue = undefined;
      this._rawTable.internalValue = undefined;
      this._schemaRegistry.internalValue = undefined;
      this._tskv.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._blank.internalValue = value.blank;
      this._json.internalValue = value.json;
      this._rawTable.internalValue = value.rawTable;
      this._schemaRegistry.internalValue = value.schemaRegistry;
      this._tskv.internalValue = value.tskv;
    }
  }

  // blank - computed: false, optional: true, required: true
  private _blank = new TransferEndpointSettingsKinesisSourceParserBlankOutputReference(this, "blank");
  public get blank() {
    return this._blank;
  }
  public putBlank(value: TransferEndpointSettingsKinesisSourceParserBlank) {
    this._blank.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get blankInput() {
    return this._blank.internalValue;
  }

  // json - computed: false, optional: true, required: false
  private _json = new TransferEndpointSettingsKinesisSourceParserJsonOutputReference(this, "json");
  public get json() {
    return this._json;
  }
  public putJson(value: TransferEndpointSettingsKinesisSourceParserJson) {
    this._json.internalValue = value;
  }
  public resetJson() {
    this._json.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonInput() {
    return this._json.internalValue;
  }

  // raw_table - computed: false, optional: true, required: false
  private _rawTable = new TransferEndpointSettingsKinesisSourceParserRawTableOutputReference(this, "raw_table");
  public get rawTable() {
    return this._rawTable;
  }
  public putRawTable(value: TransferEndpointSettingsKinesisSourceParserRawTable) {
    this._rawTable.internalValue = value;
  }
  public resetRawTable() {
    this._rawTable.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rawTableInput() {
    return this._rawTable.internalValue;
  }

  // schema_registry - computed: false, optional: true, required: false
  private _schemaRegistry = new TransferEndpointSettingsKinesisSourceParserSchemaRegistryOutputReference(this, "schema_registry");
  public get schemaRegistry() {
    return this._schemaRegistry;
  }
  public putSchemaRegistry(value: TransferEndpointSettingsKinesisSourceParserSchemaRegistry) {
    this._schemaRegistry.internalValue = value;
  }
  public resetSchemaRegistry() {
    this._schemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryInput() {
    return this._schemaRegistry.internalValue;
  }

  // tskv - computed: false, optional: true, required: false
  private _tskv = new TransferEndpointSettingsKinesisSourceParserTskvOutputReference(this, "tskv");
  public get tskv() {
    return this._tskv;
  }
  public putTskv(value: TransferEndpointSettingsKinesisSourceParserTskv) {
    this._tskv.internalValue = value;
  }
  public resetTskv() {
    this._tskv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tskvInput() {
    return this._tskv.internalValue;
  }
}
export interface TransferEndpointSettingsKinesisSource {
  /**
  * AWS Access Key with access to this stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#aws_access_key_id TransferEndpoint#aws_access_key_id}
  */
  readonly awsAccessKeyId?: string;
  /**
  * AWS Secret Access Key with access to this stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#aws_secret_access_key TransferEndpoint#aws_secret_access_key}
  */
  readonly awsSecretAccessKey?: string;
  /**
  * Name of AWS Region where stream is deployed
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#region TransferEndpoint#region}
  */
  readonly region?: string;
  /**
  * Name of AWS Kinesis Data Stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#stream_name TransferEndpoint#stream_name}
  */
  readonly streamName?: string;
  /**
  * parser block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#parser TransferEndpoint#parser}
  */
  readonly parser?: TransferEndpointSettingsKinesisSourceParser;
}

export function transferEndpointSettingsKinesisSourceToTerraform(struct?: TransferEndpointSettingsKinesisSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws_access_key_id: cdktf.stringToTerraform(struct!.awsAccessKeyId),
    aws_secret_access_key: cdktf.stringToTerraform(struct!.awsSecretAccessKey),
    region: cdktf.stringToTerraform(struct!.region),
    stream_name: cdktf.stringToTerraform(struct!.streamName),
    parser: transferEndpointSettingsKinesisSourceParserToTerraform(struct!.parser),
  }
}


export function transferEndpointSettingsKinesisSourceToHclTerraform(struct?: TransferEndpointSettingsKinesisSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws_access_key_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccessKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stream_name: {
      value: cdktf.stringToHclTerraform(struct!.streamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parser: {
      value: transferEndpointSettingsKinesisSourceParserToHclTerraform(struct!.parser),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSourceParser",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsKinesisSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsKinesisSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._awsAccessKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccessKeyId = this._awsAccessKeyId;
    }
    if (this._awsSecretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretAccessKey = this._awsSecretAccessKey;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._streamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamName = this._streamName;
    }
    if (this._parser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parser = this._parser?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsKinesisSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._awsAccessKeyId = undefined;
      this._awsSecretAccessKey = undefined;
      this._region = undefined;
      this._streamName = undefined;
      this._parser.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._awsAccessKeyId = value.awsAccessKeyId;
      this._awsSecretAccessKey = value.awsSecretAccessKey;
      this._region = value.region;
      this._streamName = value.streamName;
      this._parser.internalValue = value.parser;
    }
  }

  // aws_access_key_id - computed: false, optional: true, required: false
  private _awsAccessKeyId?: string; 
  public get awsAccessKeyId() {
    return this.getStringAttribute('aws_access_key_id');
  }
  public set awsAccessKeyId(value: string) {
    this._awsAccessKeyId = value;
  }
  public resetAwsAccessKeyId() {
    this._awsAccessKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccessKeyIdInput() {
    return this._awsAccessKeyId;
  }

  // aws_secret_access_key - computed: false, optional: true, required: false
  private _awsSecretAccessKey?: string; 
  public get awsSecretAccessKey() {
    return this.getStringAttribute('aws_secret_access_key');
  }
  public set awsSecretAccessKey(value: string) {
    this._awsSecretAccessKey = value;
  }
  public resetAwsSecretAccessKey() {
    this._awsSecretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretAccessKeyInput() {
    return this._awsSecretAccessKey;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // stream_name - computed: false, optional: true, required: false
  private _streamName?: string; 
  public get streamName() {
    return this.getStringAttribute('stream_name');
  }
  public set streamName(value: string) {
    this._streamName = value;
  }
  public resetStreamName() {
    this._streamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamNameInput() {
    return this._streamName;
  }

  // parser - computed: false, optional: true, required: false
  private _parser = new TransferEndpointSettingsKinesisSourceParserOutputReference(this, "parser");
  public get parser() {
    return this._parser;
  }
  public putParser(value: TransferEndpointSettingsKinesisSourceParser) {
    this._parser.internalValue = value;
  }
  public resetParser() {
    this._parser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parserInput() {
    return this._parser.internalValue;
  }
}
export interface TransferEndpointSettingsLinkedinadsSourceCredentialsAccessToken {
  /**
  * Access token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#access_token TransferEndpoint#access_token}
  */
  readonly accessToken?: string;
}

export function transferEndpointSettingsLinkedinadsSourceCredentialsAccessTokenToTerraform(struct?: TransferEndpointSettingsLinkedinadsSourceCredentialsAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: cdktf.stringToTerraform(struct!.accessToken),
  }
}


export function transferEndpointSettingsLinkedinadsSourceCredentialsAccessTokenToHclTerraform(struct?: TransferEndpointSettingsLinkedinadsSourceCredentialsAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: cdktf.stringToHclTerraform(struct!.accessToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsLinkedinadsSourceCredentialsAccessTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsLinkedinadsSourceCredentialsAccessToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsLinkedinadsSourceCredentialsAccessToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken = value.accessToken;
    }
  }

  // access_token - computed: false, optional: true, required: false
  private _accessToken?: string; 
  public get accessToken() {
    return this.getStringAttribute('access_token');
  }
  public set accessToken(value: string) {
    this._accessToken = value;
  }
  public resetAccessToken() {
    this._accessToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken;
  }
}
export interface TransferEndpointSettingsLinkedinadsSourceCredentialsOauth {
  /**
  * Client ID of the LinkedIn Ads developer application
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#client_id TransferEndpoint#client_id}
  */
  readonly clientId?: string;
  /**
  * Client Secret for the LinkedIn Ads developer application
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#client_secret TransferEndpoint#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Key to refresh the expired access token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#refresh_token TransferEndpoint#refresh_token}
  */
  readonly refreshToken?: string;
}

export function transferEndpointSettingsLinkedinadsSourceCredentialsOauthToTerraform(struct?: TransferEndpointSettingsLinkedinadsSourceCredentialsOauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    refresh_token: cdktf.stringToTerraform(struct!.refreshToken),
  }
}


export function transferEndpointSettingsLinkedinadsSourceCredentialsOauthToHclTerraform(struct?: TransferEndpointSettingsLinkedinadsSourceCredentialsOauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    refresh_token: {
      value: cdktf.stringToHclTerraform(struct!.refreshToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsLinkedinadsSourceCredentialsOauthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsLinkedinadsSourceCredentialsOauth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._refreshToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.refreshToken = this._refreshToken;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsLinkedinadsSourceCredentialsOauth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._refreshToken = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._refreshToken = value.refreshToken;
    }
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // refresh_token - computed: false, optional: true, required: false
  private _refreshToken?: string; 
  public get refreshToken() {
    return this.getStringAttribute('refresh_token');
  }
  public set refreshToken(value: string) {
    this._refreshToken = value;
  }
  public resetRefreshToken() {
    this._refreshToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refreshTokenInput() {
    return this._refreshToken;
  }
}
export interface TransferEndpointSettingsLinkedinadsSourceCredentials {
  /**
  * access_token block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#access_token TransferEndpoint#access_token}
  */
  readonly accessToken?: TransferEndpointSettingsLinkedinadsSourceCredentialsAccessToken;
  /**
  * oauth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#oauth TransferEndpoint#oauth}
  */
  readonly oauth?: TransferEndpointSettingsLinkedinadsSourceCredentialsOauth;
}

export function transferEndpointSettingsLinkedinadsSourceCredentialsToTerraform(struct?: TransferEndpointSettingsLinkedinadsSourceCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: transferEndpointSettingsLinkedinadsSourceCredentialsAccessTokenToTerraform(struct!.accessToken),
    oauth: transferEndpointSettingsLinkedinadsSourceCredentialsOauthToTerraform(struct!.oauth),
  }
}


export function transferEndpointSettingsLinkedinadsSourceCredentialsToHclTerraform(struct?: TransferEndpointSettingsLinkedinadsSourceCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: transferEndpointSettingsLinkedinadsSourceCredentialsAccessTokenToHclTerraform(struct!.accessToken),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsLinkedinadsSourceCredentialsAccessToken",
    },
    oauth: {
      value: transferEndpointSettingsLinkedinadsSourceCredentialsOauthToHclTerraform(struct!.oauth),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsLinkedinadsSourceCredentialsOauth",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsLinkedinadsSourceCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsLinkedinadsSourceCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken?.internalValue;
    }
    if (this._oauth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth = this._oauth?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsLinkedinadsSourceCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = undefined;
      this._oauth.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = value.accessToken;
      this._oauth.internalValue = value.oauth;
    }
  }

  // access_token - computed: false, optional: true, required: false
  private _accessToken = new TransferEndpointSettingsLinkedinadsSourceCredentialsAccessTokenOutputReference(this, "access_token");
  public get accessToken() {
    return this._accessToken;
  }
  public putAccessToken(value: TransferEndpointSettingsLinkedinadsSourceCredentialsAccessToken) {
    this._accessToken.internalValue = value;
  }
  public resetAccessToken() {
    this._accessToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken.internalValue;
  }

  // oauth - computed: false, optional: true, required: false
  private _oauth = new TransferEndpointSettingsLinkedinadsSourceCredentialsOauthOutputReference(this, "oauth");
  public get oauth() {
    return this._oauth;
  }
  public putOauth(value: TransferEndpointSettingsLinkedinadsSourceCredentialsOauth) {
    this._oauth.internalValue = value;
  }
  public resetOauth() {
    this._oauth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthInput() {
    return this._oauth.internalValue;
  }
}
export interface TransferEndpointSettingsLinkedinadsSource {
  /**
  * Space-separated account IDs to pull the data from. Leave empty if you want to pull data from all the associated accounts
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#account_ids TransferEndpoint#account_ids}
  */
  readonly accountIds?: number[];
  /**
  * UTC date in the `YYYY-MM-DD` format. Any data before this date will not be replicated
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#start_date TransferEndpoint#start_date}
  */
  readonly startDate?: string;
  /**
  * credentials block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#credentials TransferEndpoint#credentials}
  */
  readonly credentials?: TransferEndpointSettingsLinkedinadsSourceCredentials;
}

export function transferEndpointSettingsLinkedinadsSourceToTerraform(struct?: TransferEndpointSettingsLinkedinadsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    account_ids: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.accountIds),
    start_date: cdktf.stringToTerraform(struct!.startDate),
    credentials: transferEndpointSettingsLinkedinadsSourceCredentialsToTerraform(struct!.credentials),
  }
}


export function transferEndpointSettingsLinkedinadsSourceToHclTerraform(struct?: TransferEndpointSettingsLinkedinadsSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    account_ids: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.accountIds),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    start_date: {
      value: cdktf.stringToHclTerraform(struct!.startDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials: {
      value: transferEndpointSettingsLinkedinadsSourceCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsLinkedinadsSourceCredentials",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsLinkedinadsSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsLinkedinadsSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accountIds !== undefined) {
      hasAnyValues = true;
      internalValueResult.accountIds = this._accountIds;
    }
    if (this._startDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.startDate = this._startDate;
    }
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsLinkedinadsSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accountIds = undefined;
      this._startDate = undefined;
      this._credentials.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accountIds = value.accountIds;
      this._startDate = value.startDate;
      this._credentials.internalValue = value.credentials;
    }
  }

  // account_ids - computed: false, optional: true, required: false
  private _accountIds?: number[]; 
  public get accountIds() {
    return this.getNumberListAttribute('account_ids');
  }
  public set accountIds(value: number[]) {
    this._accountIds = value;
  }
  public resetAccountIds() {
    this._accountIds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accountIdsInput() {
    return this._accountIds;
  }

  // start_date - computed: false, optional: true, required: false
  private _startDate?: string; 
  public get startDate() {
    return this.getStringAttribute('start_date');
  }
  public set startDate(value: string) {
    this._startDate = value;
  }
  public resetStartDate() {
    this._startDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startDateInput() {
    return this._startDate;
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new TransferEndpointSettingsLinkedinadsSourceCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: TransferEndpointSettingsLinkedinadsSourceCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }
}
export interface TransferEndpointSettingsMetricaSourceMetricaStream {
  /**
  * The type of the Metrica stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#stream_type TransferEndpoint#stream_type}
  */
  readonly streamType?: string;
}

export function transferEndpointSettingsMetricaSourceMetricaStreamToTerraform(struct?: TransferEndpointSettingsMetricaSourceMetricaStream | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    stream_type: cdktf.stringToTerraform(struct!.streamType),
  }
}


export function transferEndpointSettingsMetricaSourceMetricaStreamToHclTerraform(struct?: TransferEndpointSettingsMetricaSourceMetricaStream | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    stream_type: {
      value: cdktf.stringToHclTerraform(struct!.streamType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMetricaSourceMetricaStreamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsMetricaSourceMetricaStream | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._streamType !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamType = this._streamType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMetricaSourceMetricaStream | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._streamType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._streamType = value.streamType;
    }
  }

  // stream_type - computed: false, optional: true, required: false
  private _streamType?: string; 
  public get streamType() {
    return this.getStringAttribute('stream_type');
  }
  public set streamType(value: string) {
    this._streamType = value;
  }
  public resetStreamType() {
    this._streamType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamTypeInput() {
    return this._streamType;
  }
}

export class TransferEndpointSettingsMetricaSourceMetricaStreamList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsMetricaSourceMetricaStream[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsMetricaSourceMetricaStreamOutputReference {
    return new TransferEndpointSettingsMetricaSourceMetricaStreamOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsMetricaSource {
  /**
  * List of counter IDs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#counter_ids TransferEndpoint#counter_ids}
  */
  readonly counterIds?: number[];
  /**
  * Access token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#token TransferEndpoint#token}
  */
  readonly token?: string;
  /**
  * metrica_stream block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#metrica_stream TransferEndpoint#metrica_stream}
  */
  readonly metricaStream?: TransferEndpointSettingsMetricaSourceMetricaStream[] | cdktf.IResolvable;
}

export function transferEndpointSettingsMetricaSourceToTerraform(struct?: TransferEndpointSettingsMetricaSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    counter_ids: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.counterIds),
    token: cdktf.stringToTerraform(struct!.token),
    metrica_stream: cdktf.listMapper(transferEndpointSettingsMetricaSourceMetricaStreamToTerraform, true)(struct!.metricaStream),
  }
}


export function transferEndpointSettingsMetricaSourceToHclTerraform(struct?: TransferEndpointSettingsMetricaSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    counter_ids: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.counterIds),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrica_stream: {
      value: cdktf.listMapperHcl(transferEndpointSettingsMetricaSourceMetricaStreamToHclTerraform, true)(struct!.metricaStream),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsMetricaSourceMetricaStreamList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMetricaSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMetricaSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._counterIds !== undefined) {
      hasAnyValues = true;
      internalValueResult.counterIds = this._counterIds;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._metricaStream?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricaStream = this._metricaStream?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMetricaSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._counterIds = undefined;
      this._token = undefined;
      this._metricaStream.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._counterIds = value.counterIds;
      this._token = value.token;
      this._metricaStream.internalValue = value.metricaStream;
    }
  }

  // counter_ids - computed: false, optional: true, required: false
  private _counterIds?: number[]; 
  public get counterIds() {
    return this.getNumberListAttribute('counter_ids');
  }
  public set counterIds(value: number[]) {
    this._counterIds = value;
  }
  public resetCounterIds() {
    this._counterIds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get counterIdsInput() {
    return this._counterIds;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // metrica_stream - computed: false, optional: true, required: false
  private _metricaStream = new TransferEndpointSettingsMetricaSourceMetricaStreamList(this, "metrica_stream", false);
  public get metricaStream() {
    return this._metricaStream;
  }
  public putMetricaStream(value: TransferEndpointSettingsMetricaSourceMetricaStream[] | cdktf.IResolvable) {
    this._metricaStream.internalValue = value;
  }
  public resetMetricaStream() {
    this._metricaStream.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricaStreamInput() {
    return this._metricaStream.internalValue;
  }
}
export interface TransferEndpointSettingsMongoSourceCollection {
  /**
  * Collection name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#collection_name TransferEndpoint#collection_name}
  */
  readonly collectionName?: string;
  /**
  * Database name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#database_name TransferEndpoint#database_name}
  */
  readonly databaseName?: string;
}

export function transferEndpointSettingsMongoSourceCollectionToTerraform(struct?: TransferEndpointSettingsMongoSourceCollection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collection_name: cdktf.stringToTerraform(struct!.collectionName),
    database_name: cdktf.stringToTerraform(struct!.databaseName),
  }
}


export function transferEndpointSettingsMongoSourceCollectionToHclTerraform(struct?: TransferEndpointSettingsMongoSourceCollection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collection_name: {
      value: cdktf.stringToHclTerraform(struct!.collectionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database_name: {
      value: cdktf.stringToHclTerraform(struct!.databaseName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoSourceCollectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsMongoSourceCollection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectionName = this._collectionName;
    }
    if (this._databaseName !== undefined) {
      hasAnyValues = true;
      internalValueResult.databaseName = this._databaseName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoSourceCollection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectionName = undefined;
      this._databaseName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectionName = value.collectionName;
      this._databaseName = value.databaseName;
    }
  }

  // collection_name - computed: false, optional: true, required: false
  private _collectionName?: string; 
  public get collectionName() {
    return this.getStringAttribute('collection_name');
  }
  public set collectionName(value: string) {
    this._collectionName = value;
  }
  public resetCollectionName() {
    this._collectionName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectionNameInput() {
    return this._collectionName;
  }

  // database_name - computed: false, optional: true, required: false
  private _databaseName?: string; 
  public get databaseName() {
    return this.getStringAttribute('database_name');
  }
  public set databaseName(value: string) {
    this._databaseName = value;
  }
  public resetDatabaseName() {
    this._databaseName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseNameInput() {
    return this._databaseName;
  }
}

export class TransferEndpointSettingsMongoSourceCollectionList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsMongoSourceCollection[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsMongoSourceCollectionOutputReference {
    return new TransferEndpointSettingsMongoSourceCollectionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremise {
  /**
  * List of hosts
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#hosts TransferEndpoint#hosts}
  */
  readonly hosts?: string[];
  /**
  * Port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#port TransferEndpoint#port}
  */
  readonly port?: number;
}

export function transferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremiseToTerraform(struct?: TransferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function transferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremiseToHclTerraform(struct?: TransferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hosts = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hosts = value.hosts;
      this._port = value.port;
    }
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  public resetHosts() {
    this._hosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface TransferEndpointSettingsMongoSourceConnectionConnectionTypeSrv {
  /**
  * SRV hostname
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#hostname TransferEndpoint#hostname}
  */
  readonly hostname?: string;
}

export function transferEndpointSettingsMongoSourceConnectionConnectionTypeSrvToTerraform(struct?: TransferEndpointSettingsMongoSourceConnectionConnectionTypeSrv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostname: cdktf.stringToTerraform(struct!.hostname),
  }
}


export function transferEndpointSettingsMongoSourceConnectionConnectionTypeSrvToHclTerraform(struct?: TransferEndpointSettingsMongoSourceConnectionConnectionTypeSrv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoSourceConnectionConnectionTypeSrvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMongoSourceConnectionConnectionTypeSrv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoSourceConnectionConnectionTypeSrv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostname = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostname = value.hostname;
    }
  }

  // hostname - computed: false, optional: true, required: false
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  public resetHostname() {
    this._hostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }
}
export interface TransferEndpointSettingsMongoSourceConnectionConnectionTypeTlsMode {
  /**
  * X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. When CA certificate is specified TLS is used to connect to the server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ca_certificate TransferEndpoint#ca_certificate}
  */
  readonly caCertificate?: string;
}

export function transferEndpointSettingsMongoSourceConnectionConnectionTypeTlsModeToTerraform(struct?: TransferEndpointSettingsMongoSourceConnectionConnectionTypeTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificate: cdktf.stringToTerraform(struct!.caCertificate),
  }
}


export function transferEndpointSettingsMongoSourceConnectionConnectionTypeTlsModeToHclTerraform(struct?: TransferEndpointSettingsMongoSourceConnectionConnectionTypeTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.caCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoSourceConnectionConnectionTypeTlsModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMongoSourceConnectionConnectionTypeTlsMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificate = this._caCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoSourceConnectionConnectionTypeTlsMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificate = value.caCertificate;
    }
  }

  // ca_certificate - computed: false, optional: true, required: false
  private _caCertificate?: string; 
  public get caCertificate() {
    return this.getStringAttribute('ca_certificate');
  }
  public set caCertificate(value: string) {
    this._caCertificate = value;
  }
  public resetCaCertificate() {
    this._caCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificateInput() {
    return this._caCertificate;
  }
}
export interface TransferEndpointSettingsMongoSourceConnectionConnectionType {
  /**
  * Replica set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#replica_set TransferEndpoint#replica_set}
  */
  readonly replicaSet?: string;
  /**
  * on_premise block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#on_premise TransferEndpoint#on_premise}
  */
  readonly onPremise?: TransferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremise;
  /**
  * srv block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#srv TransferEndpoint#srv}
  */
  readonly srv?: TransferEndpointSettingsMongoSourceConnectionConnectionTypeSrv;
  /**
  * tls_mode block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tls_mode TransferEndpoint#tls_mode}
  */
  readonly tlsMode?: TransferEndpointSettingsMongoSourceConnectionConnectionTypeTlsMode;
}

export function transferEndpointSettingsMongoSourceConnectionConnectionTypeToTerraform(struct?: TransferEndpointSettingsMongoSourceConnectionConnectionType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    replica_set: cdktf.stringToTerraform(struct!.replicaSet),
    on_premise: transferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremiseToTerraform(struct!.onPremise),
    srv: transferEndpointSettingsMongoSourceConnectionConnectionTypeSrvToTerraform(struct!.srv),
    tls_mode: transferEndpointSettingsMongoSourceConnectionConnectionTypeTlsModeToTerraform(struct!.tlsMode),
  }
}


export function transferEndpointSettingsMongoSourceConnectionConnectionTypeToHclTerraform(struct?: TransferEndpointSettingsMongoSourceConnectionConnectionType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    replica_set: {
      value: cdktf.stringToHclTerraform(struct!.replicaSet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_premise: {
      value: transferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremiseToHclTerraform(struct!.onPremise),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremise",
    },
    srv: {
      value: transferEndpointSettingsMongoSourceConnectionConnectionTypeSrvToHclTerraform(struct!.srv),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMongoSourceConnectionConnectionTypeSrv",
    },
    tls_mode: {
      value: transferEndpointSettingsMongoSourceConnectionConnectionTypeTlsModeToHclTerraform(struct!.tlsMode),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMongoSourceConnectionConnectionTypeTlsMode",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoSourceConnectionConnectionTypeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMongoSourceConnectionConnectionType | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._replicaSet !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicaSet = this._replicaSet;
    }
    if (this._onPremise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.onPremise = this._onPremise?.internalValue;
    }
    if (this._srv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.srv = this._srv?.internalValue;
    }
    if (this._tlsMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMode = this._tlsMode?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoSourceConnectionConnectionType | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._replicaSet = undefined;
      this._onPremise.internalValue = undefined;
      this._srv.internalValue = undefined;
      this._tlsMode.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._replicaSet = value.replicaSet;
      this._onPremise.internalValue = value.onPremise;
      this._srv.internalValue = value.srv;
      this._tlsMode.internalValue = value.tlsMode;
    }
  }

  // replica_set - computed: false, optional: true, required: false
  private _replicaSet?: string; 
  public get replicaSet() {
    return this.getStringAttribute('replica_set');
  }
  public set replicaSet(value: string) {
    this._replicaSet = value;
  }
  public resetReplicaSet() {
    this._replicaSet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicaSetInput() {
    return this._replicaSet;
  }

  // on_premise - computed: false, optional: true, required: false
  private _onPremise = new TransferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremiseOutputReference(this, "on_premise");
  public get onPremise() {
    return this._onPremise;
  }
  public putOnPremise(value: TransferEndpointSettingsMongoSourceConnectionConnectionTypeOnPremise) {
    this._onPremise.internalValue = value;
  }
  public resetOnPremise() {
    this._onPremise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onPremiseInput() {
    return this._onPremise.internalValue;
  }

  // srv - computed: false, optional: true, required: false
  private _srv = new TransferEndpointSettingsMongoSourceConnectionConnectionTypeSrvOutputReference(this, "srv");
  public get srv() {
    return this._srv;
  }
  public putSrv(value: TransferEndpointSettingsMongoSourceConnectionConnectionTypeSrv) {
    this._srv.internalValue = value;
  }
  public resetSrv() {
    this._srv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get srvInput() {
    return this._srv.internalValue;
  }

  // tls_mode - computed: false, optional: true, required: false
  private _tlsMode = new TransferEndpointSettingsMongoSourceConnectionConnectionTypeTlsModeOutputReference(this, "tls_mode");
  public get tlsMode() {
    return this._tlsMode;
  }
  public putTlsMode(value: TransferEndpointSettingsMongoSourceConnectionConnectionTypeTlsMode) {
    this._tlsMode.internalValue = value;
  }
  public resetTlsMode() {
    this._tlsMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsModeInput() {
    return this._tlsMode.internalValue;
  }
}
export interface TransferEndpointSettingsMongoSourceConnection {
  /**
  * Authentication database associated with the user
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#auth_source TransferEndpoint#auth_source}
  */
  readonly authSource?: string;
  /**
  * Database user password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * Database user
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#user TransferEndpoint#user}
  */
  readonly user?: string;
  /**
  * connection_type block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection_type TransferEndpoint#connection_type}
  */
  readonly connectionType?: TransferEndpointSettingsMongoSourceConnectionConnectionType;
}

export function transferEndpointSettingsMongoSourceConnectionToTerraform(struct?: TransferEndpointSettingsMongoSourceConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_source: cdktf.stringToTerraform(struct!.authSource),
    password: cdktf.stringToTerraform(struct!.password),
    user: cdktf.stringToTerraform(struct!.user),
    connection_type: transferEndpointSettingsMongoSourceConnectionConnectionTypeToTerraform(struct!.connectionType),
  }
}


export function transferEndpointSettingsMongoSourceConnectionToHclTerraform(struct?: TransferEndpointSettingsMongoSourceConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_source: {
      value: cdktf.stringToHclTerraform(struct!.authSource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_type: {
      value: transferEndpointSettingsMongoSourceConnectionConnectionTypeToHclTerraform(struct!.connectionType),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMongoSourceConnectionConnectionType",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoSourceConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMongoSourceConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authSource !== undefined) {
      hasAnyValues = true;
      internalValueResult.authSource = this._authSource;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._connectionType?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionType = this._connectionType?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoSourceConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authSource = undefined;
      this._password = undefined;
      this._user = undefined;
      this._connectionType.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authSource = value.authSource;
      this._password = value.password;
      this._user = value.user;
      this._connectionType.internalValue = value.connectionType;
    }
  }

  // auth_source - computed: false, optional: true, required: false
  private _authSource?: string; 
  public get authSource() {
    return this.getStringAttribute('auth_source');
  }
  public set authSource(value: string) {
    this._authSource = value;
  }
  public resetAuthSource() {
    this._authSource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authSourceInput() {
    return this._authSource;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // connection_type - computed: false, optional: true, required: false
  private _connectionType = new TransferEndpointSettingsMongoSourceConnectionConnectionTypeOutputReference(this, "connection_type");
  public get connectionType() {
    return this._connectionType;
  }
  public putConnectionType(value: TransferEndpointSettingsMongoSourceConnectionConnectionType) {
    this._connectionType.internalValue = value;
  }
  public resetConnectionType() {
    this._connectionType.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTypeInput() {
    return this._connectionType.internalValue;
  }
}
export interface TransferEndpointSettingsMongoSourceExcludedCollection {
  /**
  * Collection name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#collection_name TransferEndpoint#collection_name}
  */
  readonly collectionName?: string;
  /**
  * Database name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#database_name TransferEndpoint#database_name}
  */
  readonly databaseName?: string;
}

export function transferEndpointSettingsMongoSourceExcludedCollectionToTerraform(struct?: TransferEndpointSettingsMongoSourceExcludedCollection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collection_name: cdktf.stringToTerraform(struct!.collectionName),
    database_name: cdktf.stringToTerraform(struct!.databaseName),
  }
}


export function transferEndpointSettingsMongoSourceExcludedCollectionToHclTerraform(struct?: TransferEndpointSettingsMongoSourceExcludedCollection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collection_name: {
      value: cdktf.stringToHclTerraform(struct!.collectionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database_name: {
      value: cdktf.stringToHclTerraform(struct!.databaseName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoSourceExcludedCollectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsMongoSourceExcludedCollection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectionName = this._collectionName;
    }
    if (this._databaseName !== undefined) {
      hasAnyValues = true;
      internalValueResult.databaseName = this._databaseName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoSourceExcludedCollection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectionName = undefined;
      this._databaseName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectionName = value.collectionName;
      this._databaseName = value.databaseName;
    }
  }

  // collection_name - computed: false, optional: true, required: false
  private _collectionName?: string; 
  public get collectionName() {
    return this.getStringAttribute('collection_name');
  }
  public set collectionName(value: string) {
    this._collectionName = value;
  }
  public resetCollectionName() {
    this._collectionName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectionNameInput() {
    return this._collectionName;
  }

  // database_name - computed: false, optional: true, required: false
  private _databaseName?: string; 
  public get databaseName() {
    return this.getStringAttribute('database_name');
  }
  public set databaseName(value: string) {
    this._databaseName = value;
  }
  public resetDatabaseName() {
    this._databaseName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseNameInput() {
    return this._databaseName;
  }
}

export class TransferEndpointSettingsMongoSourceExcludedCollectionList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsMongoSourceExcludedCollection[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsMongoSourceExcludedCollectionOutputReference {
    return new TransferEndpointSettingsMongoSourceExcludedCollectionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsMongoSource {
  /**
  * Read mode of the MongoDB client
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#secondary_preferred_mode TransferEndpoint#secondary_preferred_mode}
  */
  readonly secondaryPreferredMode?: boolean | cdktf.IResolvable;
  /**
  * collection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#collection TransferEndpoint#collection}
  */
  readonly collection?: TransferEndpointSettingsMongoSourceCollection[] | cdktf.IResolvable;
  /**
  * connection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection TransferEndpoint#connection}
  */
  readonly connection?: TransferEndpointSettingsMongoSourceConnection;
  /**
  * excluded_collection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#excluded_collection TransferEndpoint#excluded_collection}
  */
  readonly excludedCollection?: TransferEndpointSettingsMongoSourceExcludedCollection[] | cdktf.IResolvable;
}

export function transferEndpointSettingsMongoSourceToTerraform(struct?: TransferEndpointSettingsMongoSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secondary_preferred_mode: cdktf.booleanToTerraform(struct!.secondaryPreferredMode),
    collection: cdktf.listMapper(transferEndpointSettingsMongoSourceCollectionToTerraform, true)(struct!.collection),
    connection: transferEndpointSettingsMongoSourceConnectionToTerraform(struct!.connection),
    excluded_collection: cdktf.listMapper(transferEndpointSettingsMongoSourceExcludedCollectionToTerraform, true)(struct!.excludedCollection),
  }
}


export function transferEndpointSettingsMongoSourceToHclTerraform(struct?: TransferEndpointSettingsMongoSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secondary_preferred_mode: {
      value: cdktf.booleanToHclTerraform(struct!.secondaryPreferredMode),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    collection: {
      value: cdktf.listMapperHcl(transferEndpointSettingsMongoSourceCollectionToHclTerraform, true)(struct!.collection),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsMongoSourceCollectionList",
    },
    connection: {
      value: transferEndpointSettingsMongoSourceConnectionToHclTerraform(struct!.connection),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMongoSourceConnection",
    },
    excluded_collection: {
      value: cdktf.listMapperHcl(transferEndpointSettingsMongoSourceExcludedCollectionToHclTerraform, true)(struct!.excludedCollection),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsMongoSourceExcludedCollectionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMongoSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secondaryPreferredMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondaryPreferredMode = this._secondaryPreferredMode;
    }
    if (this._collection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collection = this._collection?.internalValue;
    }
    if (this._connection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connection = this._connection?.internalValue;
    }
    if (this._excludedCollection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludedCollection = this._excludedCollection?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secondaryPreferredMode = undefined;
      this._collection.internalValue = undefined;
      this._connection.internalValue = undefined;
      this._excludedCollection.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secondaryPreferredMode = value.secondaryPreferredMode;
      this._collection.internalValue = value.collection;
      this._connection.internalValue = value.connection;
      this._excludedCollection.internalValue = value.excludedCollection;
    }
  }

  // secondary_preferred_mode - computed: false, optional: true, required: false
  private _secondaryPreferredMode?: boolean | cdktf.IResolvable; 
  public get secondaryPreferredMode() {
    return this.getBooleanAttribute('secondary_preferred_mode');
  }
  public set secondaryPreferredMode(value: boolean | cdktf.IResolvable) {
    this._secondaryPreferredMode = value;
  }
  public resetSecondaryPreferredMode() {
    this._secondaryPreferredMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondaryPreferredModeInput() {
    return this._secondaryPreferredMode;
  }

  // collection - computed: false, optional: true, required: false
  private _collection = new TransferEndpointSettingsMongoSourceCollectionList(this, "collection", false);
  public get collection() {
    return this._collection;
  }
  public putCollection(value: TransferEndpointSettingsMongoSourceCollection[] | cdktf.IResolvable) {
    this._collection.internalValue = value;
  }
  public resetCollection() {
    this._collection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectionInput() {
    return this._collection.internalValue;
  }

  // connection - computed: false, optional: true, required: false
  private _connection = new TransferEndpointSettingsMongoSourceConnectionOutputReference(this, "connection");
  public get connection() {
    return this._connection;
  }
  public putConnection(value: TransferEndpointSettingsMongoSourceConnection) {
    this._connection.internalValue = value;
  }
  public resetConnection() {
    this._connection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionInput() {
    return this._connection.internalValue;
  }

  // excluded_collection - computed: false, optional: true, required: false
  private _excludedCollection = new TransferEndpointSettingsMongoSourceExcludedCollectionList(this, "excluded_collection", false);
  public get excludedCollection() {
    return this._excludedCollection;
  }
  public putExcludedCollection(value: TransferEndpointSettingsMongoSourceExcludedCollection[] | cdktf.IResolvable) {
    this._excludedCollection.internalValue = value;
  }
  public resetExcludedCollection() {
    this._excludedCollection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludedCollectionInput() {
    return this._excludedCollection.internalValue;
  }
}
export interface TransferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremise {
  /**
  * List of hosts
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#hosts TransferEndpoint#hosts}
  */
  readonly hosts?: string[];
  /**
  * Port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#port TransferEndpoint#port}
  */
  readonly port?: number;
}

export function transferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremiseToTerraform(struct?: TransferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function transferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremiseToHclTerraform(struct?: TransferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hosts = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hosts = value.hosts;
      this._port = value.port;
    }
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  public resetHosts() {
    this._hosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface TransferEndpointSettingsMongoTargetConnectionConnectionTypeSrv {
  /**
  * SRV hostname
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#hostname TransferEndpoint#hostname}
  */
  readonly hostname?: string;
}

export function transferEndpointSettingsMongoTargetConnectionConnectionTypeSrvToTerraform(struct?: TransferEndpointSettingsMongoTargetConnectionConnectionTypeSrv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostname: cdktf.stringToTerraform(struct!.hostname),
  }
}


export function transferEndpointSettingsMongoTargetConnectionConnectionTypeSrvToHclTerraform(struct?: TransferEndpointSettingsMongoTargetConnectionConnectionTypeSrv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoTargetConnectionConnectionTypeSrvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMongoTargetConnectionConnectionTypeSrv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoTargetConnectionConnectionTypeSrv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostname = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostname = value.hostname;
    }
  }

  // hostname - computed: false, optional: true, required: false
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  public resetHostname() {
    this._hostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }
}
export interface TransferEndpointSettingsMongoTargetConnectionConnectionTypeTlsMode {
  /**
  * X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. When CA certificate is specified TLS is used to connect to the server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ca_certificate TransferEndpoint#ca_certificate}
  */
  readonly caCertificate?: string;
}

export function transferEndpointSettingsMongoTargetConnectionConnectionTypeTlsModeToTerraform(struct?: TransferEndpointSettingsMongoTargetConnectionConnectionTypeTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificate: cdktf.stringToTerraform(struct!.caCertificate),
  }
}


export function transferEndpointSettingsMongoTargetConnectionConnectionTypeTlsModeToHclTerraform(struct?: TransferEndpointSettingsMongoTargetConnectionConnectionTypeTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.caCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoTargetConnectionConnectionTypeTlsModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMongoTargetConnectionConnectionTypeTlsMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificate = this._caCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoTargetConnectionConnectionTypeTlsMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificate = value.caCertificate;
    }
  }

  // ca_certificate - computed: false, optional: true, required: false
  private _caCertificate?: string; 
  public get caCertificate() {
    return this.getStringAttribute('ca_certificate');
  }
  public set caCertificate(value: string) {
    this._caCertificate = value;
  }
  public resetCaCertificate() {
    this._caCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificateInput() {
    return this._caCertificate;
  }
}
export interface TransferEndpointSettingsMongoTargetConnectionConnectionType {
  /**
  * Replica set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#replica_set TransferEndpoint#replica_set}
  */
  readonly replicaSet?: string;
  /**
  * on_premise block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#on_premise TransferEndpoint#on_premise}
  */
  readonly onPremise?: TransferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremise;
  /**
  * srv block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#srv TransferEndpoint#srv}
  */
  readonly srv?: TransferEndpointSettingsMongoTargetConnectionConnectionTypeSrv;
  /**
  * tls_mode block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tls_mode TransferEndpoint#tls_mode}
  */
  readonly tlsMode?: TransferEndpointSettingsMongoTargetConnectionConnectionTypeTlsMode;
}

export function transferEndpointSettingsMongoTargetConnectionConnectionTypeToTerraform(struct?: TransferEndpointSettingsMongoTargetConnectionConnectionType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    replica_set: cdktf.stringToTerraform(struct!.replicaSet),
    on_premise: transferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremiseToTerraform(struct!.onPremise),
    srv: transferEndpointSettingsMongoTargetConnectionConnectionTypeSrvToTerraform(struct!.srv),
    tls_mode: transferEndpointSettingsMongoTargetConnectionConnectionTypeTlsModeToTerraform(struct!.tlsMode),
  }
}


export function transferEndpointSettingsMongoTargetConnectionConnectionTypeToHclTerraform(struct?: TransferEndpointSettingsMongoTargetConnectionConnectionType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    replica_set: {
      value: cdktf.stringToHclTerraform(struct!.replicaSet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_premise: {
      value: transferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremiseToHclTerraform(struct!.onPremise),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremise",
    },
    srv: {
      value: transferEndpointSettingsMongoTargetConnectionConnectionTypeSrvToHclTerraform(struct!.srv),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMongoTargetConnectionConnectionTypeSrv",
    },
    tls_mode: {
      value: transferEndpointSettingsMongoTargetConnectionConnectionTypeTlsModeToHclTerraform(struct!.tlsMode),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMongoTargetConnectionConnectionTypeTlsMode",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoTargetConnectionConnectionTypeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMongoTargetConnectionConnectionType | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._replicaSet !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicaSet = this._replicaSet;
    }
    if (this._onPremise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.onPremise = this._onPremise?.internalValue;
    }
    if (this._srv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.srv = this._srv?.internalValue;
    }
    if (this._tlsMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMode = this._tlsMode?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoTargetConnectionConnectionType | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._replicaSet = undefined;
      this._onPremise.internalValue = undefined;
      this._srv.internalValue = undefined;
      this._tlsMode.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._replicaSet = value.replicaSet;
      this._onPremise.internalValue = value.onPremise;
      this._srv.internalValue = value.srv;
      this._tlsMode.internalValue = value.tlsMode;
    }
  }

  // replica_set - computed: false, optional: true, required: false
  private _replicaSet?: string; 
  public get replicaSet() {
    return this.getStringAttribute('replica_set');
  }
  public set replicaSet(value: string) {
    this._replicaSet = value;
  }
  public resetReplicaSet() {
    this._replicaSet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicaSetInput() {
    return this._replicaSet;
  }

  // on_premise - computed: false, optional: true, required: false
  private _onPremise = new TransferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremiseOutputReference(this, "on_premise");
  public get onPremise() {
    return this._onPremise;
  }
  public putOnPremise(value: TransferEndpointSettingsMongoTargetConnectionConnectionTypeOnPremise) {
    this._onPremise.internalValue = value;
  }
  public resetOnPremise() {
    this._onPremise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onPremiseInput() {
    return this._onPremise.internalValue;
  }

  // srv - computed: false, optional: true, required: false
  private _srv = new TransferEndpointSettingsMongoTargetConnectionConnectionTypeSrvOutputReference(this, "srv");
  public get srv() {
    return this._srv;
  }
  public putSrv(value: TransferEndpointSettingsMongoTargetConnectionConnectionTypeSrv) {
    this._srv.internalValue = value;
  }
  public resetSrv() {
    this._srv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get srvInput() {
    return this._srv.internalValue;
  }

  // tls_mode - computed: false, optional: true, required: false
  private _tlsMode = new TransferEndpointSettingsMongoTargetConnectionConnectionTypeTlsModeOutputReference(this, "tls_mode");
  public get tlsMode() {
    return this._tlsMode;
  }
  public putTlsMode(value: TransferEndpointSettingsMongoTargetConnectionConnectionTypeTlsMode) {
    this._tlsMode.internalValue = value;
  }
  public resetTlsMode() {
    this._tlsMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsModeInput() {
    return this._tlsMode.internalValue;
  }
}
export interface TransferEndpointSettingsMongoTargetConnection {
  /**
  * Authentication database associated with the user
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#auth_source TransferEndpoint#auth_source}
  */
  readonly authSource?: string;
  /**
  * Database user password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * Database user
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#user TransferEndpoint#user}
  */
  readonly user?: string;
  /**
  * connection_type block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection_type TransferEndpoint#connection_type}
  */
  readonly connectionType?: TransferEndpointSettingsMongoTargetConnectionConnectionType;
}

export function transferEndpointSettingsMongoTargetConnectionToTerraform(struct?: TransferEndpointSettingsMongoTargetConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_source: cdktf.stringToTerraform(struct!.authSource),
    password: cdktf.stringToTerraform(struct!.password),
    user: cdktf.stringToTerraform(struct!.user),
    connection_type: transferEndpointSettingsMongoTargetConnectionConnectionTypeToTerraform(struct!.connectionType),
  }
}


export function transferEndpointSettingsMongoTargetConnectionToHclTerraform(struct?: TransferEndpointSettingsMongoTargetConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_source: {
      value: cdktf.stringToHclTerraform(struct!.authSource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_type: {
      value: transferEndpointSettingsMongoTargetConnectionConnectionTypeToHclTerraform(struct!.connectionType),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMongoTargetConnectionConnectionType",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoTargetConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMongoTargetConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authSource !== undefined) {
      hasAnyValues = true;
      internalValueResult.authSource = this._authSource;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._connectionType?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionType = this._connectionType?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoTargetConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authSource = undefined;
      this._password = undefined;
      this._user = undefined;
      this._connectionType.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authSource = value.authSource;
      this._password = value.password;
      this._user = value.user;
      this._connectionType.internalValue = value.connectionType;
    }
  }

  // auth_source - computed: false, optional: true, required: false
  private _authSource?: string; 
  public get authSource() {
    return this.getStringAttribute('auth_source');
  }
  public set authSource(value: string) {
    this._authSource = value;
  }
  public resetAuthSource() {
    this._authSource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authSourceInput() {
    return this._authSource;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // connection_type - computed: false, optional: true, required: false
  private _connectionType = new TransferEndpointSettingsMongoTargetConnectionConnectionTypeOutputReference(this, "connection_type");
  public get connectionType() {
    return this._connectionType;
  }
  public putConnectionType(value: TransferEndpointSettingsMongoTargetConnectionConnectionType) {
    this._connectionType.internalValue = value;
  }
  public resetConnectionType() {
    this._connectionType.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTypeInput() {
    return this._connectionType.internalValue;
  }
}
export interface TransferEndpointSettingsMongoTarget {
  /**
  * Cleanup policy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#cleanup_policy TransferEndpoint#cleanup_policy}
  */
  readonly cleanupPolicy?: string;
  /**
  * Database
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#database TransferEndpoint#database}
  */
  readonly database?: string;
  /**
  * connection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection TransferEndpoint#connection}
  */
  readonly connection?: TransferEndpointSettingsMongoTargetConnection;
}

export function transferEndpointSettingsMongoTargetToTerraform(struct?: TransferEndpointSettingsMongoTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cleanup_policy: cdktf.stringToTerraform(struct!.cleanupPolicy),
    database: cdktf.stringToTerraform(struct!.database),
    connection: transferEndpointSettingsMongoTargetConnectionToTerraform(struct!.connection),
  }
}


export function transferEndpointSettingsMongoTargetToHclTerraform(struct?: TransferEndpointSettingsMongoTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cleanup_policy: {
      value: cdktf.stringToHclTerraform(struct!.cleanupPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection: {
      value: transferEndpointSettingsMongoTargetConnectionToHclTerraform(struct!.connection),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMongoTargetConnection",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMongoTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMongoTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cleanupPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.cleanupPolicy = this._cleanupPolicy;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._connection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connection = this._connection?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMongoTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cleanupPolicy = undefined;
      this._database = undefined;
      this._connection.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cleanupPolicy = value.cleanupPolicy;
      this._database = value.database;
      this._connection.internalValue = value.connection;
    }
  }

  // cleanup_policy - computed: true, optional: true, required: false
  private _cleanupPolicy?: string; 
  public get cleanupPolicy() {
    return this.getStringAttribute('cleanup_policy');
  }
  public set cleanupPolicy(value: string) {
    this._cleanupPolicy = value;
  }
  public resetCleanupPolicy() {
    this._cleanupPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cleanupPolicyInput() {
    return this._cleanupPolicy;
  }

  // database - computed: true, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // connection - computed: false, optional: true, required: false
  private _connection = new TransferEndpointSettingsMongoTargetConnectionOutputReference(this, "connection");
  public get connection() {
    return this._connection;
  }
  public putConnection(value: TransferEndpointSettingsMongoTargetConnection) {
    this._connection.internalValue = value;
  }
  public resetConnection() {
    this._connection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionInput() {
    return this._connection.internalValue;
  }
}
export interface TransferEndpointSettingsMssqlSourceSslMethodEncryptedTrusted {
}

export function transferEndpointSettingsMssqlSourceSslMethodEncryptedTrustedToTerraform(struct?: TransferEndpointSettingsMssqlSourceSslMethodEncryptedTrusted | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsMssqlSourceSslMethodEncryptedTrustedToHclTerraform(struct?: TransferEndpointSettingsMssqlSourceSslMethodEncryptedTrusted | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsMssqlSourceSslMethodEncryptedTrustedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMssqlSourceSslMethodEncryptedTrusted | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMssqlSourceSslMethodEncryptedTrusted | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCert {
  /**
  * Specifies the host name of the server. The value of this property must match the subject property of the certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#host_name_in_certificate TransferEndpoint#host_name_in_certificate}
  */
  readonly hostNameInCertificate?: string;
}

export function transferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCertToTerraform(struct?: TransferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host_name_in_certificate: cdktf.stringToTerraform(struct!.hostNameInCertificate),
  }
}


export function transferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCertToHclTerraform(struct?: TransferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host_name_in_certificate: {
      value: cdktf.stringToHclTerraform(struct!.hostNameInCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostNameInCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostNameInCertificate = this._hostNameInCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostNameInCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostNameInCertificate = value.hostNameInCertificate;
    }
  }

  // host_name_in_certificate - computed: false, optional: true, required: false
  private _hostNameInCertificate?: string; 
  public get hostNameInCertificate() {
    return this.getStringAttribute('host_name_in_certificate');
  }
  public set hostNameInCertificate(value: string) {
    this._hostNameInCertificate = value;
  }
  public resetHostNameInCertificate() {
    this._hostNameInCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostNameInCertificateInput() {
    return this._hostNameInCertificate;
  }
}
export interface TransferEndpointSettingsMssqlSourceSslMethodUnencrypted {
}

export function transferEndpointSettingsMssqlSourceSslMethodUnencryptedToTerraform(struct?: TransferEndpointSettingsMssqlSourceSslMethodUnencrypted | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsMssqlSourceSslMethodUnencryptedToHclTerraform(struct?: TransferEndpointSettingsMssqlSourceSslMethodUnencrypted | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsMssqlSourceSslMethodUnencryptedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMssqlSourceSslMethodUnencrypted | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMssqlSourceSslMethodUnencrypted | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsMssqlSourceSslMethod {
  /**
  * encrypted_trusted block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#encrypted_trusted TransferEndpoint#encrypted_trusted}
  */
  readonly encryptedTrusted?: TransferEndpointSettingsMssqlSourceSslMethodEncryptedTrusted;
  /**
  * encrypted_verify_cert block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#encrypted_verify_cert TransferEndpoint#encrypted_verify_cert}
  */
  readonly encryptedVerifyCert?: TransferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCert;
  /**
  * unencrypted block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#unencrypted TransferEndpoint#unencrypted}
  */
  readonly unencrypted?: TransferEndpointSettingsMssqlSourceSslMethodUnencrypted;
}

export function transferEndpointSettingsMssqlSourceSslMethodToTerraform(struct?: TransferEndpointSettingsMssqlSourceSslMethod | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    encrypted_trusted: transferEndpointSettingsMssqlSourceSslMethodEncryptedTrustedToTerraform(struct!.encryptedTrusted),
    encrypted_verify_cert: transferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCertToTerraform(struct!.encryptedVerifyCert),
    unencrypted: transferEndpointSettingsMssqlSourceSslMethodUnencryptedToTerraform(struct!.unencrypted),
  }
}


export function transferEndpointSettingsMssqlSourceSslMethodToHclTerraform(struct?: TransferEndpointSettingsMssqlSourceSslMethod | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    encrypted_trusted: {
      value: transferEndpointSettingsMssqlSourceSslMethodEncryptedTrustedToHclTerraform(struct!.encryptedTrusted),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMssqlSourceSslMethodEncryptedTrusted",
    },
    encrypted_verify_cert: {
      value: transferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCertToHclTerraform(struct!.encryptedVerifyCert),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCert",
    },
    unencrypted: {
      value: transferEndpointSettingsMssqlSourceSslMethodUnencryptedToHclTerraform(struct!.unencrypted),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMssqlSourceSslMethodUnencrypted",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMssqlSourceSslMethodOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMssqlSourceSslMethod | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._encryptedTrusted?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptedTrusted = this._encryptedTrusted?.internalValue;
    }
    if (this._encryptedVerifyCert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptedVerifyCert = this._encryptedVerifyCert?.internalValue;
    }
    if (this._unencrypted?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unencrypted = this._unencrypted?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMssqlSourceSslMethod | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._encryptedTrusted.internalValue = undefined;
      this._encryptedVerifyCert.internalValue = undefined;
      this._unencrypted.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._encryptedTrusted.internalValue = value.encryptedTrusted;
      this._encryptedVerifyCert.internalValue = value.encryptedVerifyCert;
      this._unencrypted.internalValue = value.unencrypted;
    }
  }

  // encrypted_trusted - computed: false, optional: true, required: true
  private _encryptedTrusted = new TransferEndpointSettingsMssqlSourceSslMethodEncryptedTrustedOutputReference(this, "encrypted_trusted");
  public get encryptedTrusted() {
    return this._encryptedTrusted;
  }
  public putEncryptedTrusted(value: TransferEndpointSettingsMssqlSourceSslMethodEncryptedTrusted) {
    this._encryptedTrusted.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptedTrustedInput() {
    return this._encryptedTrusted.internalValue;
  }

  // encrypted_verify_cert - computed: false, optional: true, required: false
  private _encryptedVerifyCert = new TransferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCertOutputReference(this, "encrypted_verify_cert");
  public get encryptedVerifyCert() {
    return this._encryptedVerifyCert;
  }
  public putEncryptedVerifyCert(value: TransferEndpointSettingsMssqlSourceSslMethodEncryptedVerifyCert) {
    this._encryptedVerifyCert.internalValue = value;
  }
  public resetEncryptedVerifyCert() {
    this._encryptedVerifyCert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptedVerifyCertInput() {
    return this._encryptedVerifyCert.internalValue;
  }

  // unencrypted - computed: false, optional: true, required: true
  private _unencrypted = new TransferEndpointSettingsMssqlSourceSslMethodUnencryptedOutputReference(this, "unencrypted");
  public get unencrypted() {
    return this._unencrypted;
  }
  public putUnencrypted(value: TransferEndpointSettingsMssqlSourceSslMethodUnencrypted) {
    this._unencrypted.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get unencryptedInput() {
    return this._unencrypted.internalValue;
  }
}
export interface TransferEndpointSettingsMssqlSource {
  /**
  * The name of the database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#database TransferEndpoint#database}
  */
  readonly database?: string;
  /**
  * The hostname of the database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#host TransferEndpoint#host}
  */
  readonly host?: string;
  /**
  * The password associated with the username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * The port of the database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#port TransferEndpoint#port}
  */
  readonly port?: number;
  /**
  * The replication method used for extracting data from the database. STANDARD replication requires no setup on the DB side but will not be able to represent deletions incrementally. CDC uses {TBC} to detect inserts, updates, and deletes. This needs to be configured on the source database itself.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#replication_method TransferEndpoint#replication_method}
  */
  readonly replicationMethod?: string;
  /**
  * The username which is used to access the database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#username TransferEndpoint#username}
  */
  readonly username?: string;
  /**
  * ssl_method block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ssl_method TransferEndpoint#ssl_method}
  */
  readonly sslMethod?: TransferEndpointSettingsMssqlSourceSslMethod;
}

export function transferEndpointSettingsMssqlSourceToTerraform(struct?: TransferEndpointSettingsMssqlSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    database: cdktf.stringToTerraform(struct!.database),
    host: cdktf.stringToTerraform(struct!.host),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    replication_method: cdktf.stringToTerraform(struct!.replicationMethod),
    username: cdktf.stringToTerraform(struct!.username),
    ssl_method: transferEndpointSettingsMssqlSourceSslMethodToTerraform(struct!.sslMethod),
  }
}


export function transferEndpointSettingsMssqlSourceToHclTerraform(struct?: TransferEndpointSettingsMssqlSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    replication_method: {
      value: cdktf.stringToHclTerraform(struct!.replicationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssl_method: {
      value: transferEndpointSettingsMssqlSourceSslMethodToHclTerraform(struct!.sslMethod),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMssqlSourceSslMethod",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMssqlSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMssqlSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._replicationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicationMethod = this._replicationMethod;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    if (this._sslMethod?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslMethod = this._sslMethod?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMssqlSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._database = undefined;
      this._host = undefined;
      this._password = undefined;
      this._port = undefined;
      this._replicationMethod = undefined;
      this._username = undefined;
      this._sslMethod.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._database = value.database;
      this._host = value.host;
      this._password = value.password;
      this._port = value.port;
      this._replicationMethod = value.replicationMethod;
      this._username = value.username;
      this._sslMethod.internalValue = value.sslMethod;
    }
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // replication_method - computed: false, optional: true, required: false
  private _replicationMethod?: string; 
  public get replicationMethod() {
    return this.getStringAttribute('replication_method');
  }
  public set replicationMethod(value: string) {
    this._replicationMethod = value;
  }
  public resetReplicationMethod() {
    this._replicationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicationMethodInput() {
    return this._replicationMethod;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }

  // ssl_method - computed: false, optional: true, required: false
  private _sslMethod = new TransferEndpointSettingsMssqlSourceSslMethodOutputReference(this, "ssl_method");
  public get sslMethod() {
    return this._sslMethod;
  }
  public putSslMethod(value: TransferEndpointSettingsMssqlSourceSslMethod) {
    this._sslMethod.internalValue = value;
  }
  public resetSslMethod() {
    this._sslMethod.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslMethodInput() {
    return this._sslMethod.internalValue;
  }
}
export interface TransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode {
  /**
  * X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. When CA certificate is specified TLS is used to connect to the server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ca_certificate TransferEndpoint#ca_certificate}
  */
  readonly caCertificate?: string;
}

export function transferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeToTerraform(struct?: TransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificate: cdktf.stringToTerraform(struct!.caCertificate),
  }
}


export function transferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeToHclTerraform(struct?: TransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.caCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificate = this._caCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificate = value.caCertificate;
    }
  }

  // ca_certificate - computed: false, optional: true, required: false
  private _caCertificate?: string; 
  public get caCertificate() {
    return this.getStringAttribute('ca_certificate');
  }
  public set caCertificate(value: string) {
    this._caCertificate = value;
  }
  public resetCaCertificate() {
    this._caCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificateInput() {
    return this._caCertificate;
  }
}
export interface TransferEndpointSettingsMysqlSourceConnectionOnPremise {
  /**
  * List of MySQL hosts
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#hosts TransferEndpoint#hosts}
  */
  readonly hosts?: string[];
  /**
  * MySQL port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#port TransferEndpoint#port}
  */
  readonly port?: number;
  /**
  * tls_mode block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tls_mode TransferEndpoint#tls_mode}
  */
  readonly tlsMode?: TransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode;
}

export function transferEndpointSettingsMysqlSourceConnectionOnPremiseToTerraform(struct?: TransferEndpointSettingsMysqlSourceConnectionOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    port: cdktf.numberToTerraform(struct!.port),
    tls_mode: transferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeToTerraform(struct!.tlsMode),
  }
}


export function transferEndpointSettingsMysqlSourceConnectionOnPremiseToHclTerraform(struct?: TransferEndpointSettingsMysqlSourceConnectionOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls_mode: {
      value: transferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeToHclTerraform(struct!.tlsMode),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMysqlSourceConnectionOnPremiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMysqlSourceConnectionOnPremise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._tlsMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMode = this._tlsMode?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMysqlSourceConnectionOnPremise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hosts = undefined;
      this._port = undefined;
      this._tlsMode.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hosts = value.hosts;
      this._port = value.port;
      this._tlsMode.internalValue = value.tlsMode;
    }
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  public resetHosts() {
    this._hosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // tls_mode - computed: false, optional: true, required: false
  private _tlsMode = new TransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeOutputReference(this, "tls_mode");
  public get tlsMode() {
    return this._tlsMode;
  }
  public putTlsMode(value: TransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode) {
    this._tlsMode.internalValue = value;
  }
  public resetTlsMode() {
    this._tlsMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsModeInput() {
    return this._tlsMode.internalValue;
  }
}
export interface TransferEndpointSettingsMysqlSourceConnection {
  /**
  * on_premise block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#on_premise TransferEndpoint#on_premise}
  */
  readonly onPremise?: TransferEndpointSettingsMysqlSourceConnectionOnPremise;
}

export function transferEndpointSettingsMysqlSourceConnectionToTerraform(struct?: TransferEndpointSettingsMysqlSourceConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    on_premise: transferEndpointSettingsMysqlSourceConnectionOnPremiseToTerraform(struct!.onPremise),
  }
}


export function transferEndpointSettingsMysqlSourceConnectionToHclTerraform(struct?: TransferEndpointSettingsMysqlSourceConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    on_premise: {
      value: transferEndpointSettingsMysqlSourceConnectionOnPremiseToHclTerraform(struct!.onPremise),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMysqlSourceConnectionOnPremise",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMysqlSourceConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMysqlSourceConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._onPremise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.onPremise = this._onPremise?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMysqlSourceConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._onPremise.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._onPremise.internalValue = value.onPremise;
    }
  }

  // on_premise - computed: false, optional: true, required: false
  private _onPremise = new TransferEndpointSettingsMysqlSourceConnectionOnPremiseOutputReference(this, "on_premise");
  public get onPremise() {
    return this._onPremise;
  }
  public putOnPremise(value: TransferEndpointSettingsMysqlSourceConnectionOnPremise) {
    this._onPremise.internalValue = value;
  }
  public resetOnPremise() {
    this._onPremise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onPremiseInput() {
    return this._onPremise.internalValue;
  }
}
export interface TransferEndpointSettingsMysqlSourceObjectTransferSettings {
  /**
  * CREATE PROCEDURE ... ; CREATE FUNCTION ... ;
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#routine TransferEndpoint#routine}
  */
  readonly routine?: string;
  /**
  * CREATE TABLE ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tables TransferEndpoint#tables}
  */
  readonly tables?: string;
  /**
  * CREATE TRIGGER ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#trigger TransferEndpoint#trigger}
  */
  readonly trigger?: string;
  /**
  * CREATE VIEW ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#view TransferEndpoint#view}
  */
  readonly view?: string;
}

export function transferEndpointSettingsMysqlSourceObjectTransferSettingsToTerraform(struct?: TransferEndpointSettingsMysqlSourceObjectTransferSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    routine: cdktf.stringToTerraform(struct!.routine),
    tables: cdktf.stringToTerraform(struct!.tables),
    trigger: cdktf.stringToTerraform(struct!.trigger),
    view: cdktf.stringToTerraform(struct!.view),
  }
}


export function transferEndpointSettingsMysqlSourceObjectTransferSettingsToHclTerraform(struct?: TransferEndpointSettingsMysqlSourceObjectTransferSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    routine: {
      value: cdktf.stringToHclTerraform(struct!.routine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tables: {
      value: cdktf.stringToHclTerraform(struct!.tables),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    trigger: {
      value: cdktf.stringToHclTerraform(struct!.trigger),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    view: {
      value: cdktf.stringToHclTerraform(struct!.view),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMysqlSourceObjectTransferSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMysqlSourceObjectTransferSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._routine !== undefined) {
      hasAnyValues = true;
      internalValueResult.routine = this._routine;
    }
    if (this._tables !== undefined) {
      hasAnyValues = true;
      internalValueResult.tables = this._tables;
    }
    if (this._trigger !== undefined) {
      hasAnyValues = true;
      internalValueResult.trigger = this._trigger;
    }
    if (this._view !== undefined) {
      hasAnyValues = true;
      internalValueResult.view = this._view;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMysqlSourceObjectTransferSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._routine = undefined;
      this._tables = undefined;
      this._trigger = undefined;
      this._view = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._routine = value.routine;
      this._tables = value.tables;
      this._trigger = value.trigger;
      this._view = value.view;
    }
  }

  // routine - computed: true, optional: true, required: false
  private _routine?: string; 
  public get routine() {
    return this.getStringAttribute('routine');
  }
  public set routine(value: string) {
    this._routine = value;
  }
  public resetRoutine() {
    this._routine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routineInput() {
    return this._routine;
  }

  // tables - computed: true, optional: true, required: false
  private _tables?: string; 
  public get tables() {
    return this.getStringAttribute('tables');
  }
  public set tables(value: string) {
    this._tables = value;
  }
  public resetTables() {
    this._tables = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tablesInput() {
    return this._tables;
  }

  // trigger - computed: true, optional: true, required: false
  private _trigger?: string; 
  public get trigger() {
    return this.getStringAttribute('trigger');
  }
  public set trigger(value: string) {
    this._trigger = value;
  }
  public resetTrigger() {
    this._trigger = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get triggerInput() {
    return this._trigger;
  }

  // view - computed: true, optional: true, required: false
  private _view?: string; 
  public get view() {
    return this.getStringAttribute('view');
  }
  public set view(value: string) {
    this._view = value;
  }
  public resetView() {
    this._view = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get viewInput() {
    return this._view;
  }
}
export interface TransferEndpointSettingsMysqlSource {
  /**
  * Database name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#database TransferEndpoint#database}
  */
  readonly database?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#exclude_tables_regex TransferEndpoint#exclude_tables_regex}
  */
  readonly excludeTablesRegex?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#include_tables_regex TransferEndpoint#include_tables_regex}
  */
  readonly includeTablesRegex?: string[];
  /**
  * Database user password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * Service database name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#service_database TransferEndpoint#service_database}
  */
  readonly serviceDatabase?: string;
  /**
  * Used for parsing timestamps for saving source timezones. Accepts values from the IANA timezone database. Default is the local timezone.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#timezone TransferEndpoint#timezone}
  */
  readonly timezone?: string;
  /**
  * Database user
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#user TransferEndpoint#user}
  */
  readonly user?: string;
  /**
  * connection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection TransferEndpoint#connection}
  */
  readonly connection?: TransferEndpointSettingsMysqlSourceConnection;
  /**
  * object_transfer_settings block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#object_transfer_settings TransferEndpoint#object_transfer_settings}
  */
  readonly objectTransferSettings?: TransferEndpointSettingsMysqlSourceObjectTransferSettings;
}

export function transferEndpointSettingsMysqlSourceToTerraform(struct?: TransferEndpointSettingsMysqlSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    database: cdktf.stringToTerraform(struct!.database),
    exclude_tables_regex: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeTablesRegex),
    include_tables_regex: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.includeTablesRegex),
    password: cdktf.stringToTerraform(struct!.password),
    service_database: cdktf.stringToTerraform(struct!.serviceDatabase),
    timezone: cdktf.stringToTerraform(struct!.timezone),
    user: cdktf.stringToTerraform(struct!.user),
    connection: transferEndpointSettingsMysqlSourceConnectionToTerraform(struct!.connection),
    object_transfer_settings: transferEndpointSettingsMysqlSourceObjectTransferSettingsToTerraform(struct!.objectTransferSettings),
  }
}


export function transferEndpointSettingsMysqlSourceToHclTerraform(struct?: TransferEndpointSettingsMysqlSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_tables_regex: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeTablesRegex),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    include_tables_regex: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.includeTablesRegex),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_database: {
      value: cdktf.stringToHclTerraform(struct!.serviceDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timezone: {
      value: cdktf.stringToHclTerraform(struct!.timezone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection: {
      value: transferEndpointSettingsMysqlSourceConnectionToHclTerraform(struct!.connection),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMysqlSourceConnection",
    },
    object_transfer_settings: {
      value: transferEndpointSettingsMysqlSourceObjectTransferSettingsToHclTerraform(struct!.objectTransferSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMysqlSourceObjectTransferSettings",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMysqlSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMysqlSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._excludeTablesRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeTablesRegex = this._excludeTablesRegex;
    }
    if (this._includeTablesRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeTablesRegex = this._includeTablesRegex;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._serviceDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceDatabase = this._serviceDatabase;
    }
    if (this._timezone !== undefined) {
      hasAnyValues = true;
      internalValueResult.timezone = this._timezone;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._connection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connection = this._connection?.internalValue;
    }
    if (this._objectTransferSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectTransferSettings = this._objectTransferSettings?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMysqlSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._database = undefined;
      this._excludeTablesRegex = undefined;
      this._includeTablesRegex = undefined;
      this._password = undefined;
      this._serviceDatabase = undefined;
      this._timezone = undefined;
      this._user = undefined;
      this._connection.internalValue = undefined;
      this._objectTransferSettings.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._database = value.database;
      this._excludeTablesRegex = value.excludeTablesRegex;
      this._includeTablesRegex = value.includeTablesRegex;
      this._password = value.password;
      this._serviceDatabase = value.serviceDatabase;
      this._timezone = value.timezone;
      this._user = value.user;
      this._connection.internalValue = value.connection;
      this._objectTransferSettings.internalValue = value.objectTransferSettings;
    }
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // exclude_tables_regex - computed: false, optional: true, required: false
  private _excludeTablesRegex?: string[]; 
  public get excludeTablesRegex() {
    return this.getListAttribute('exclude_tables_regex');
  }
  public set excludeTablesRegex(value: string[]) {
    this._excludeTablesRegex = value;
  }
  public resetExcludeTablesRegex() {
    this._excludeTablesRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeTablesRegexInput() {
    return this._excludeTablesRegex;
  }

  // include_tables_regex - computed: false, optional: true, required: false
  private _includeTablesRegex?: string[]; 
  public get includeTablesRegex() {
    return this.getListAttribute('include_tables_regex');
  }
  public set includeTablesRegex(value: string[]) {
    this._includeTablesRegex = value;
  }
  public resetIncludeTablesRegex() {
    this._includeTablesRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeTablesRegexInput() {
    return this._includeTablesRegex;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // service_database - computed: true, optional: true, required: false
  private _serviceDatabase?: string; 
  public get serviceDatabase() {
    return this.getStringAttribute('service_database');
  }
  public set serviceDatabase(value: string) {
    this._serviceDatabase = value;
  }
  public resetServiceDatabase() {
    this._serviceDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceDatabaseInput() {
    return this._serviceDatabase;
  }

  // timezone - computed: true, optional: true, required: false
  private _timezone?: string; 
  public get timezone() {
    return this.getStringAttribute('timezone');
  }
  public set timezone(value: string) {
    this._timezone = value;
  }
  public resetTimezone() {
    this._timezone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timezoneInput() {
    return this._timezone;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // connection - computed: false, optional: true, required: false
  private _connection = new TransferEndpointSettingsMysqlSourceConnectionOutputReference(this, "connection");
  public get connection() {
    return this._connection;
  }
  public putConnection(value: TransferEndpointSettingsMysqlSourceConnection) {
    this._connection.internalValue = value;
  }
  public resetConnection() {
    this._connection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionInput() {
    return this._connection.internalValue;
  }

  // object_transfer_settings - computed: false, optional: true, required: false
  private _objectTransferSettings = new TransferEndpointSettingsMysqlSourceObjectTransferSettingsOutputReference(this, "object_transfer_settings");
  public get objectTransferSettings() {
    return this._objectTransferSettings;
  }
  public putObjectTransferSettings(value: TransferEndpointSettingsMysqlSourceObjectTransferSettings) {
    this._objectTransferSettings.internalValue = value;
  }
  public resetObjectTransferSettings() {
    this._objectTransferSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectTransferSettingsInput() {
    return this._objectTransferSettings.internalValue;
  }
}
export interface TransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode {
  /**
  * X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. When CA certificate is specified TLS is used to connect to the server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ca_certificate TransferEndpoint#ca_certificate}
  */
  readonly caCertificate?: string;
}

export function transferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeToTerraform(struct?: TransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificate: cdktf.stringToTerraform(struct!.caCertificate),
  }
}


export function transferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeToHclTerraform(struct?: TransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.caCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificate = this._caCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificate = value.caCertificate;
    }
  }

  // ca_certificate - computed: false, optional: true, required: false
  private _caCertificate?: string; 
  public get caCertificate() {
    return this.getStringAttribute('ca_certificate');
  }
  public set caCertificate(value: string) {
    this._caCertificate = value;
  }
  public resetCaCertificate() {
    this._caCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificateInput() {
    return this._caCertificate;
  }
}
export interface TransferEndpointSettingsMysqlTargetConnectionOnPremise {
  /**
  * List of PostgreSQL hosts
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#hosts TransferEndpoint#hosts}
  */
  readonly hosts?: string[];
  /**
  * Port of the PostgreSQL instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#port TransferEndpoint#port}
  */
  readonly port?: number;
  /**
  * tls_mode block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tls_mode TransferEndpoint#tls_mode}
  */
  readonly tlsMode?: TransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode;
}

export function transferEndpointSettingsMysqlTargetConnectionOnPremiseToTerraform(struct?: TransferEndpointSettingsMysqlTargetConnectionOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    port: cdktf.numberToTerraform(struct!.port),
    tls_mode: transferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeToTerraform(struct!.tlsMode),
  }
}


export function transferEndpointSettingsMysqlTargetConnectionOnPremiseToHclTerraform(struct?: TransferEndpointSettingsMysqlTargetConnectionOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls_mode: {
      value: transferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeToHclTerraform(struct!.tlsMode),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMysqlTargetConnectionOnPremiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMysqlTargetConnectionOnPremise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._tlsMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMode = this._tlsMode?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMysqlTargetConnectionOnPremise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hosts = undefined;
      this._port = undefined;
      this._tlsMode.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hosts = value.hosts;
      this._port = value.port;
      this._tlsMode.internalValue = value.tlsMode;
    }
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  public resetHosts() {
    this._hosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // tls_mode - computed: false, optional: true, required: false
  private _tlsMode = new TransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeOutputReference(this, "tls_mode");
  public get tlsMode() {
    return this._tlsMode;
  }
  public putTlsMode(value: TransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode) {
    this._tlsMode.internalValue = value;
  }
  public resetTlsMode() {
    this._tlsMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsModeInput() {
    return this._tlsMode.internalValue;
  }
}
export interface TransferEndpointSettingsMysqlTargetConnection {
  /**
  * on_premise block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#on_premise TransferEndpoint#on_premise}
  */
  readonly onPremise?: TransferEndpointSettingsMysqlTargetConnectionOnPremise;
}

export function transferEndpointSettingsMysqlTargetConnectionToTerraform(struct?: TransferEndpointSettingsMysqlTargetConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    on_premise: transferEndpointSettingsMysqlTargetConnectionOnPremiseToTerraform(struct!.onPremise),
  }
}


export function transferEndpointSettingsMysqlTargetConnectionToHclTerraform(struct?: TransferEndpointSettingsMysqlTargetConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    on_premise: {
      value: transferEndpointSettingsMysqlTargetConnectionOnPremiseToHclTerraform(struct!.onPremise),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMysqlTargetConnectionOnPremise",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMysqlTargetConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMysqlTargetConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._onPremise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.onPremise = this._onPremise?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMysqlTargetConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._onPremise.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._onPremise.internalValue = value.onPremise;
    }
  }

  // on_premise - computed: false, optional: true, required: false
  private _onPremise = new TransferEndpointSettingsMysqlTargetConnectionOnPremiseOutputReference(this, "on_premise");
  public get onPremise() {
    return this._onPremise;
  }
  public putOnPremise(value: TransferEndpointSettingsMysqlTargetConnectionOnPremise) {
    this._onPremise.internalValue = value;
  }
  public resetOnPremise() {
    this._onPremise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onPremiseInput() {
    return this._onPremise.internalValue;
  }
}
export interface TransferEndpointSettingsMysqlTarget {
  /**
  * Cleanup policy for activating, reactivating, and reuploading processes. Default is `truncate`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#cleanup_policy TransferEndpoint#cleanup_policy}
  */
  readonly cleanupPolicy?: string;
  /**
  * Database name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#database TransferEndpoint#database}
  */
  readonly database?: string;
  /**
  * Database user password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * Database schema for the service table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#service_database TransferEndpoint#service_database}
  */
  readonly serviceDatabase?: string;
  /**
  * Disable constraint checks
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#skip_constraint_checks TransferEndpoint#skip_constraint_checks}
  */
  readonly skipConstraintChecks?: boolean | cdktf.IResolvable;
  /**
  * SQL mode
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#sql_mode TransferEndpoint#sql_mode}
  */
  readonly sqlMode?: string;
  /**
  * Used for parsing timestamps for saving source timezones. Accepts values from the IANA timezone database. Default is the local timezone.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#timezone TransferEndpoint#timezone}
  */
  readonly timezone?: string;
  /**
  * Database user
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#user TransferEndpoint#user}
  */
  readonly user?: string;
  /**
  * connection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection TransferEndpoint#connection}
  */
  readonly connection?: TransferEndpointSettingsMysqlTargetConnection;
}

export function transferEndpointSettingsMysqlTargetToTerraform(struct?: TransferEndpointSettingsMysqlTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cleanup_policy: cdktf.stringToTerraform(struct!.cleanupPolicy),
    database: cdktf.stringToTerraform(struct!.database),
    password: cdktf.stringToTerraform(struct!.password),
    service_database: cdktf.stringToTerraform(struct!.serviceDatabase),
    skip_constraint_checks: cdktf.booleanToTerraform(struct!.skipConstraintChecks),
    sql_mode: cdktf.stringToTerraform(struct!.sqlMode),
    timezone: cdktf.stringToTerraform(struct!.timezone),
    user: cdktf.stringToTerraform(struct!.user),
    connection: transferEndpointSettingsMysqlTargetConnectionToTerraform(struct!.connection),
  }
}


export function transferEndpointSettingsMysqlTargetToHclTerraform(struct?: TransferEndpointSettingsMysqlTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cleanup_policy: {
      value: cdktf.stringToHclTerraform(struct!.cleanupPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_database: {
      value: cdktf.stringToHclTerraform(struct!.serviceDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_constraint_checks: {
      value: cdktf.booleanToHclTerraform(struct!.skipConstraintChecks),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sql_mode: {
      value: cdktf.stringToHclTerraform(struct!.sqlMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timezone: {
      value: cdktf.stringToHclTerraform(struct!.timezone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection: {
      value: transferEndpointSettingsMysqlTargetConnectionToHclTerraform(struct!.connection),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMysqlTargetConnection",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsMysqlTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsMysqlTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cleanupPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.cleanupPolicy = this._cleanupPolicy;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._serviceDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceDatabase = this._serviceDatabase;
    }
    if (this._skipConstraintChecks !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipConstraintChecks = this._skipConstraintChecks;
    }
    if (this._sqlMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.sqlMode = this._sqlMode;
    }
    if (this._timezone !== undefined) {
      hasAnyValues = true;
      internalValueResult.timezone = this._timezone;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._connection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connection = this._connection?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsMysqlTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cleanupPolicy = undefined;
      this._database = undefined;
      this._password = undefined;
      this._serviceDatabase = undefined;
      this._skipConstraintChecks = undefined;
      this._sqlMode = undefined;
      this._timezone = undefined;
      this._user = undefined;
      this._connection.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cleanupPolicy = value.cleanupPolicy;
      this._database = value.database;
      this._password = value.password;
      this._serviceDatabase = value.serviceDatabase;
      this._skipConstraintChecks = value.skipConstraintChecks;
      this._sqlMode = value.sqlMode;
      this._timezone = value.timezone;
      this._user = value.user;
      this._connection.internalValue = value.connection;
    }
  }

  // cleanup_policy - computed: true, optional: true, required: false
  private _cleanupPolicy?: string; 
  public get cleanupPolicy() {
    return this.getStringAttribute('cleanup_policy');
  }
  public set cleanupPolicy(value: string) {
    this._cleanupPolicy = value;
  }
  public resetCleanupPolicy() {
    this._cleanupPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cleanupPolicyInput() {
    return this._cleanupPolicy;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // service_database - computed: true, optional: true, required: false
  private _serviceDatabase?: string; 
  public get serviceDatabase() {
    return this.getStringAttribute('service_database');
  }
  public set serviceDatabase(value: string) {
    this._serviceDatabase = value;
  }
  public resetServiceDatabase() {
    this._serviceDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceDatabaseInput() {
    return this._serviceDatabase;
  }

  // skip_constraint_checks - computed: true, optional: true, required: false
  private _skipConstraintChecks?: boolean | cdktf.IResolvable; 
  public get skipConstraintChecks() {
    return this.getBooleanAttribute('skip_constraint_checks');
  }
  public set skipConstraintChecks(value: boolean | cdktf.IResolvable) {
    this._skipConstraintChecks = value;
  }
  public resetSkipConstraintChecks() {
    this._skipConstraintChecks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipConstraintChecksInput() {
    return this._skipConstraintChecks;
  }

  // sql_mode - computed: true, optional: true, required: false
  private _sqlMode?: string; 
  public get sqlMode() {
    return this.getStringAttribute('sql_mode');
  }
  public set sqlMode(value: string) {
    this._sqlMode = value;
  }
  public resetSqlMode() {
    this._sqlMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sqlModeInput() {
    return this._sqlMode;
  }

  // timezone - computed: true, optional: true, required: false
  private _timezone?: string; 
  public get timezone() {
    return this.getStringAttribute('timezone');
  }
  public set timezone(value: string) {
    this._timezone = value;
  }
  public resetTimezone() {
    this._timezone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timezoneInput() {
    return this._timezone;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // connection - computed: false, optional: true, required: false
  private _connection = new TransferEndpointSettingsMysqlTargetConnectionOutputReference(this, "connection");
  public get connection() {
    return this._connection;
  }
  public putConnection(value: TransferEndpointSettingsMysqlTargetConnection) {
    this._connection.internalValue = value;
  }
  public resetConnection() {
    this._connection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionInput() {
    return this._connection.internalValue;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceEventSourcePubSub {
}

export function transferEndpointSettingsObjectStorageSourceEventSourcePubSubToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceEventSourcePubSub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsObjectStorageSourceEventSourcePubSubToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceEventSourcePubSub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsObjectStorageSourceEventSourcePubSubOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceEventSourcePubSub | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceEventSourcePubSub | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsObjectStorageSourceEventSourceSns {
}

export function transferEndpointSettingsObjectStorageSourceEventSourceSnsToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceEventSourceSns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsObjectStorageSourceEventSourceSnsToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceEventSourceSns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsObjectStorageSourceEventSourceSnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceEventSourceSns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceEventSourceSns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsObjectStorageSourceEventSourceSqs {
  /**
  * Access key ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#aws_access_key_id TransferEndpoint#aws_access_key_id}
  */
  readonly awsAccessKeyId?: string;
  /**
  * Secret access key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#aws_secret_access_key TransferEndpoint#aws_secret_access_key}
  */
  readonly awsSecretAccessKey?: string;
  /**
  * Endpoint. Leave blank if you're using AWS
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#endpoint TransferEndpoint#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Owner ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#owner_id TransferEndpoint#owner_id}
  */
  readonly ownerId?: string;
  /**
  * Queue name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#queue_name TransferEndpoint#queue_name}
  */
  readonly queueName?: string;
  /**
  * Region
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#region TransferEndpoint#region}
  */
  readonly region?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#use_ssl TransferEndpoint#use_ssl}
  */
  readonly useSsl?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#verify_ssl_cert TransferEndpoint#verify_ssl_cert}
  */
  readonly verifySslCert?: boolean | cdktf.IResolvable;
}

export function transferEndpointSettingsObjectStorageSourceEventSourceSqsToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceEventSourceSqs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws_access_key_id: cdktf.stringToTerraform(struct!.awsAccessKeyId),
    aws_secret_access_key: cdktf.stringToTerraform(struct!.awsSecretAccessKey),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    owner_id: cdktf.stringToTerraform(struct!.ownerId),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    region: cdktf.stringToTerraform(struct!.region),
    use_ssl: cdktf.booleanToTerraform(struct!.useSsl),
    verify_ssl_cert: cdktf.booleanToTerraform(struct!.verifySslCert),
  }
}


export function transferEndpointSettingsObjectStorageSourceEventSourceSqsToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceEventSourceSqs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws_access_key_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccessKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    owner_id: {
      value: cdktf.stringToHclTerraform(struct!.ownerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_ssl: {
      value: cdktf.booleanToHclTerraform(struct!.useSsl),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    verify_ssl_cert: {
      value: cdktf.booleanToHclTerraform(struct!.verifySslCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceEventSourceSqsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceEventSourceSqs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._awsAccessKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccessKeyId = this._awsAccessKeyId;
    }
    if (this._awsSecretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretAccessKey = this._awsSecretAccessKey;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._ownerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.ownerId = this._ownerId;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._useSsl !== undefined) {
      hasAnyValues = true;
      internalValueResult.useSsl = this._useSsl;
    }
    if (this._verifySslCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifySslCert = this._verifySslCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceEventSourceSqs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._awsAccessKeyId = undefined;
      this._awsSecretAccessKey = undefined;
      this._endpoint = undefined;
      this._ownerId = undefined;
      this._queueName = undefined;
      this._region = undefined;
      this._useSsl = undefined;
      this._verifySslCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._awsAccessKeyId = value.awsAccessKeyId;
      this._awsSecretAccessKey = value.awsSecretAccessKey;
      this._endpoint = value.endpoint;
      this._ownerId = value.ownerId;
      this._queueName = value.queueName;
      this._region = value.region;
      this._useSsl = value.useSsl;
      this._verifySslCert = value.verifySslCert;
    }
  }

  // aws_access_key_id - computed: false, optional: true, required: false
  private _awsAccessKeyId?: string; 
  public get awsAccessKeyId() {
    return this.getStringAttribute('aws_access_key_id');
  }
  public set awsAccessKeyId(value: string) {
    this._awsAccessKeyId = value;
  }
  public resetAwsAccessKeyId() {
    this._awsAccessKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccessKeyIdInput() {
    return this._awsAccessKeyId;
  }

  // aws_secret_access_key - computed: false, optional: true, required: false
  private _awsSecretAccessKey?: string; 
  public get awsSecretAccessKey() {
    return this.getStringAttribute('aws_secret_access_key');
  }
  public set awsSecretAccessKey(value: string) {
    this._awsSecretAccessKey = value;
  }
  public resetAwsSecretAccessKey() {
    this._awsSecretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretAccessKeyInput() {
    return this._awsSecretAccessKey;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // owner_id - computed: false, optional: true, required: false
  private _ownerId?: string; 
  public get ownerId() {
    return this.getStringAttribute('owner_id');
  }
  public set ownerId(value: string) {
    this._ownerId = value;
  }
  public resetOwnerId() {
    this._ownerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ownerIdInput() {
    return this._ownerId;
  }

  // queue_name - computed: false, optional: true, required: false
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  public resetQueueName() {
    this._queueName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // use_ssl - computed: true, optional: true, required: false
  private _useSsl?: boolean | cdktf.IResolvable; 
  public get useSsl() {
    return this.getBooleanAttribute('use_ssl');
  }
  public set useSsl(value: boolean | cdktf.IResolvable) {
    this._useSsl = value;
  }
  public resetUseSsl() {
    this._useSsl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useSslInput() {
    return this._useSsl;
  }

  // verify_ssl_cert - computed: true, optional: true, required: false
  private _verifySslCert?: boolean | cdktf.IResolvable; 
  public get verifySslCert() {
    return this.getBooleanAttribute('verify_ssl_cert');
  }
  public set verifySslCert(value: boolean | cdktf.IResolvable) {
    this._verifySslCert = value;
  }
  public resetVerifySslCert() {
    this._verifySslCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifySslCertInput() {
    return this._verifySslCert;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceEventSource {
  /**
  * pub_sub block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#pub_sub TransferEndpoint#pub_sub}
  */
  readonly pubSub?: TransferEndpointSettingsObjectStorageSourceEventSourcePubSub;
  /**
  * sns block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#sns TransferEndpoint#sns}
  */
  readonly sns?: TransferEndpointSettingsObjectStorageSourceEventSourceSns;
  /**
  * sqs block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#sqs TransferEndpoint#sqs}
  */
  readonly sqs?: TransferEndpointSettingsObjectStorageSourceEventSourceSqs;
}

export function transferEndpointSettingsObjectStorageSourceEventSourceToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceEventSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pub_sub: transferEndpointSettingsObjectStorageSourceEventSourcePubSubToTerraform(struct!.pubSub),
    sns: transferEndpointSettingsObjectStorageSourceEventSourceSnsToTerraform(struct!.sns),
    sqs: transferEndpointSettingsObjectStorageSourceEventSourceSqsToTerraform(struct!.sqs),
  }
}


export function transferEndpointSettingsObjectStorageSourceEventSourceToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceEventSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pub_sub: {
      value: transferEndpointSettingsObjectStorageSourceEventSourcePubSubToHclTerraform(struct!.pubSub),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceEventSourcePubSub",
    },
    sns: {
      value: transferEndpointSettingsObjectStorageSourceEventSourceSnsToHclTerraform(struct!.sns),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceEventSourceSns",
    },
    sqs: {
      value: transferEndpointSettingsObjectStorageSourceEventSourceSqsToHclTerraform(struct!.sqs),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceEventSourceSqs",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceEventSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceEventSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pubSub?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pubSub = this._pubSub?.internalValue;
    }
    if (this._sns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sns = this._sns?.internalValue;
    }
    if (this._sqs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sqs = this._sqs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceEventSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pubSub.internalValue = undefined;
      this._sns.internalValue = undefined;
      this._sqs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pubSub.internalValue = value.pubSub;
      this._sns.internalValue = value.sns;
      this._sqs.internalValue = value.sqs;
    }
  }

  // pub_sub - computed: false, optional: true, required: true
  private _pubSub = new TransferEndpointSettingsObjectStorageSourceEventSourcePubSubOutputReference(this, "pub_sub");
  public get pubSub() {
    return this._pubSub;
  }
  public putPubSub(value: TransferEndpointSettingsObjectStorageSourceEventSourcePubSub) {
    this._pubSub.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pubSubInput() {
    return this._pubSub.internalValue;
  }

  // sns - computed: false, optional: true, required: true
  private _sns = new TransferEndpointSettingsObjectStorageSourceEventSourceSnsOutputReference(this, "sns");
  public get sns() {
    return this._sns;
  }
  public putSns(value: TransferEndpointSettingsObjectStorageSourceEventSourceSns) {
    this._sns.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get snsInput() {
    return this._sns.internalValue;
  }

  // sqs - computed: false, optional: true, required: false
  private _sqs = new TransferEndpointSettingsObjectStorageSourceEventSourceSqsOutputReference(this, "sqs");
  public get sqs() {
    return this._sqs;
  }
  public putSqs(value: TransferEndpointSettingsObjectStorageSourceEventSourceSqs) {
    this._sqs.internalValue = value;
  }
  public resetSqs() {
    this._sqs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sqsInput() {
    return this._sqs.internalValue;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceFormatAvro {
}

export function transferEndpointSettingsObjectStorageSourceFormatAvroToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormatAvro | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsObjectStorageSourceFormatAvroToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormatAvro | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsObjectStorageSourceFormatAvroOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceFormatAvro | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceFormatAvro | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#decimal_point TransferEndpoint#decimal_point}
  */
  readonly decimalPoint?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#false_values TransferEndpoint#false_values}
  */
  readonly falseValues?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#include_columns TransferEndpoint#include_columns}
  */
  readonly includeColumns?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#include_missing_columns TransferEndpoint#include_missing_columns}
  */
  readonly includeMissingColumns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#null_values TransferEndpoint#null_values}
  */
  readonly nullValues?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#quoted_strings_can_be_null TransferEndpoint#quoted_strings_can_be_null}
  */
  readonly quotedStringsCanBeNull?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#strings_can_be_null TransferEndpoint#strings_can_be_null}
  */
  readonly stringsCanBeNull?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#timestamp_parsers TransferEndpoint#timestamp_parsers}
  */
  readonly timestampParsers?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#true_values TransferEndpoint#true_values}
  */
  readonly trueValues?: string[];
}

export function transferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptionsToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    decimal_point: cdktf.stringToTerraform(struct!.decimalPoint),
    false_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.falseValues),
    include_columns: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.includeColumns),
    include_missing_columns: cdktf.booleanToTerraform(struct!.includeMissingColumns),
    null_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nullValues),
    quoted_strings_can_be_null: cdktf.booleanToTerraform(struct!.quotedStringsCanBeNull),
    strings_can_be_null: cdktf.booleanToTerraform(struct!.stringsCanBeNull),
    timestamp_parsers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.timestampParsers),
    true_values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.trueValues),
  }
}


export function transferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptionsToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    decimal_point: {
      value: cdktf.stringToHclTerraform(struct!.decimalPoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    false_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.falseValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    include_columns: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.includeColumns),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    include_missing_columns: {
      value: cdktf.booleanToHclTerraform(struct!.includeMissingColumns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    null_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nullValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    quoted_strings_can_be_null: {
      value: cdktf.booleanToHclTerraform(struct!.quotedStringsCanBeNull),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    strings_can_be_null: {
      value: cdktf.booleanToHclTerraform(struct!.stringsCanBeNull),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timestamp_parsers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.timestampParsers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    true_values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.trueValues),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._decimalPoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.decimalPoint = this._decimalPoint;
    }
    if (this._falseValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.falseValues = this._falseValues;
    }
    if (this._includeColumns !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeColumns = this._includeColumns;
    }
    if (this._includeMissingColumns !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeMissingColumns = this._includeMissingColumns;
    }
    if (this._nullValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.nullValues = this._nullValues;
    }
    if (this._quotedStringsCanBeNull !== undefined) {
      hasAnyValues = true;
      internalValueResult.quotedStringsCanBeNull = this._quotedStringsCanBeNull;
    }
    if (this._stringsCanBeNull !== undefined) {
      hasAnyValues = true;
      internalValueResult.stringsCanBeNull = this._stringsCanBeNull;
    }
    if (this._timestampParsers !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampParsers = this._timestampParsers;
    }
    if (this._trueValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.trueValues = this._trueValues;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._decimalPoint = undefined;
      this._falseValues = undefined;
      this._includeColumns = undefined;
      this._includeMissingColumns = undefined;
      this._nullValues = undefined;
      this._quotedStringsCanBeNull = undefined;
      this._stringsCanBeNull = undefined;
      this._timestampParsers = undefined;
      this._trueValues = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._decimalPoint = value.decimalPoint;
      this._falseValues = value.falseValues;
      this._includeColumns = value.includeColumns;
      this._includeMissingColumns = value.includeMissingColumns;
      this._nullValues = value.nullValues;
      this._quotedStringsCanBeNull = value.quotedStringsCanBeNull;
      this._stringsCanBeNull = value.stringsCanBeNull;
      this._timestampParsers = value.timestampParsers;
      this._trueValues = value.trueValues;
    }
  }

  // decimal_point - computed: false, optional: true, required: false
  private _decimalPoint?: string; 
  public get decimalPoint() {
    return this.getStringAttribute('decimal_point');
  }
  public set decimalPoint(value: string) {
    this._decimalPoint = value;
  }
  public resetDecimalPoint() {
    this._decimalPoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get decimalPointInput() {
    return this._decimalPoint;
  }

  // false_values - computed: false, optional: true, required: false
  private _falseValues?: string[]; 
  public get falseValues() {
    return this.getListAttribute('false_values');
  }
  public set falseValues(value: string[]) {
    this._falseValues = value;
  }
  public resetFalseValues() {
    this._falseValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get falseValuesInput() {
    return this._falseValues;
  }

  // include_columns - computed: false, optional: true, required: false
  private _includeColumns?: string[]; 
  public get includeColumns() {
    return this.getListAttribute('include_columns');
  }
  public set includeColumns(value: string[]) {
    this._includeColumns = value;
  }
  public resetIncludeColumns() {
    this._includeColumns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeColumnsInput() {
    return this._includeColumns;
  }

  // include_missing_columns - computed: true, optional: true, required: false
  private _includeMissingColumns?: boolean | cdktf.IResolvable; 
  public get includeMissingColumns() {
    return this.getBooleanAttribute('include_missing_columns');
  }
  public set includeMissingColumns(value: boolean | cdktf.IResolvable) {
    this._includeMissingColumns = value;
  }
  public resetIncludeMissingColumns() {
    this._includeMissingColumns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeMissingColumnsInput() {
    return this._includeMissingColumns;
  }

  // null_values - computed: false, optional: true, required: false
  private _nullValues?: string[]; 
  public get nullValues() {
    return this.getListAttribute('null_values');
  }
  public set nullValues(value: string[]) {
    this._nullValues = value;
  }
  public resetNullValues() {
    this._nullValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullValuesInput() {
    return this._nullValues;
  }

  // quoted_strings_can_be_null - computed: true, optional: true, required: false
  private _quotedStringsCanBeNull?: boolean | cdktf.IResolvable; 
  public get quotedStringsCanBeNull() {
    return this.getBooleanAttribute('quoted_strings_can_be_null');
  }
  public set quotedStringsCanBeNull(value: boolean | cdktf.IResolvable) {
    this._quotedStringsCanBeNull = value;
  }
  public resetQuotedStringsCanBeNull() {
    this._quotedStringsCanBeNull = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get quotedStringsCanBeNullInput() {
    return this._quotedStringsCanBeNull;
  }

  // strings_can_be_null - computed: true, optional: true, required: false
  private _stringsCanBeNull?: boolean | cdktf.IResolvable; 
  public get stringsCanBeNull() {
    return this.getBooleanAttribute('strings_can_be_null');
  }
  public set stringsCanBeNull(value: boolean | cdktf.IResolvable) {
    this._stringsCanBeNull = value;
  }
  public resetStringsCanBeNull() {
    this._stringsCanBeNull = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stringsCanBeNullInput() {
    return this._stringsCanBeNull;
  }

  // timestamp_parsers - computed: false, optional: true, required: false
  private _timestampParsers?: string[]; 
  public get timestampParsers() {
    return this.getListAttribute('timestamp_parsers');
  }
  public set timestampParsers(value: string[]) {
    this._timestampParsers = value;
  }
  public resetTimestampParsers() {
    this._timestampParsers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampParsersInput() {
    return this._timestampParsers;
  }

  // true_values - computed: false, optional: true, required: false
  private _trueValues?: string[]; 
  public get trueValues() {
    return this.getListAttribute('true_values');
  }
  public set trueValues(value: string[]) {
    this._trueValues = value;
  }
  public resetTrueValues() {
    this._trueValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trueValuesInput() {
    return this._trueValues;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptions {
  /**
  * Autogenerate column names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#autogenerate_column_names TransferEndpoint#autogenerate_column_names}
  */
  readonly autogenerateColumnNames?: boolean | cdktf.IResolvable;
  /**
  * Names of columns to transfer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#column_names TransferEndpoint#column_names}
  */
  readonly columnNames?: string[];
  /**
  * Number of rows to skip before the column names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#skip_rows TransferEndpoint#skip_rows}
  */
  readonly skipRows?: number;
  /**
  * Number of rows to skip after the column names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#skip_rows_after_names TransferEndpoint#skip_rows_after_names}
  */
  readonly skipRowsAfterNames?: number;
}

export function transferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptionsToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    autogenerate_column_names: cdktf.booleanToTerraform(struct!.autogenerateColumnNames),
    column_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.columnNames),
    skip_rows: cdktf.numberToTerraform(struct!.skipRows),
    skip_rows_after_names: cdktf.numberToTerraform(struct!.skipRowsAfterNames),
  }
}


export function transferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptionsToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    autogenerate_column_names: {
      value: cdktf.booleanToHclTerraform(struct!.autogenerateColumnNames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    column_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.columnNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    skip_rows: {
      value: cdktf.numberToHclTerraform(struct!.skipRows),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    skip_rows_after_names: {
      value: cdktf.numberToHclTerraform(struct!.skipRowsAfterNames),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autogenerateColumnNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.autogenerateColumnNames = this._autogenerateColumnNames;
    }
    if (this._columnNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.columnNames = this._columnNames;
    }
    if (this._skipRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipRows = this._skipRows;
    }
    if (this._skipRowsAfterNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipRowsAfterNames = this._skipRowsAfterNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autogenerateColumnNames = undefined;
      this._columnNames = undefined;
      this._skipRows = undefined;
      this._skipRowsAfterNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autogenerateColumnNames = value.autogenerateColumnNames;
      this._columnNames = value.columnNames;
      this._skipRows = value.skipRows;
      this._skipRowsAfterNames = value.skipRowsAfterNames;
    }
  }

  // autogenerate_column_names - computed: true, optional: true, required: false
  private _autogenerateColumnNames?: boolean | cdktf.IResolvable; 
  public get autogenerateColumnNames() {
    return this.getBooleanAttribute('autogenerate_column_names');
  }
  public set autogenerateColumnNames(value: boolean | cdktf.IResolvable) {
    this._autogenerateColumnNames = value;
  }
  public resetAutogenerateColumnNames() {
    this._autogenerateColumnNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autogenerateColumnNamesInput() {
    return this._autogenerateColumnNames;
  }

  // column_names - computed: false, optional: true, required: false
  private _columnNames?: string[]; 
  public get columnNames() {
    return this.getListAttribute('column_names');
  }
  public set columnNames(value: string[]) {
    this._columnNames = value;
  }
  public resetColumnNames() {
    this._columnNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get columnNamesInput() {
    return this._columnNames;
  }

  // skip_rows - computed: true, optional: true, required: false
  private _skipRows?: number; 
  public get skipRows() {
    return this.getNumberAttribute('skip_rows');
  }
  public set skipRows(value: number) {
    this._skipRows = value;
  }
  public resetSkipRows() {
    this._skipRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipRowsInput() {
    return this._skipRows;
  }

  // skip_rows_after_names - computed: true, optional: true, required: false
  private _skipRowsAfterNames?: number; 
  public get skipRowsAfterNames() {
    return this.getNumberAttribute('skip_rows_after_names');
  }
  public set skipRowsAfterNames(value: number) {
    this._skipRowsAfterNames = value;
  }
  public resetSkipRowsAfterNames() {
    this._skipRowsAfterNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipRowsAfterNamesInput() {
    return this._skipRowsAfterNames;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceFormatCsv {
  /**
  * Block size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#block_size TransferEndpoint#block_size}
  */
  readonly blockSize?: number;
  /**
  * Delimiter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#delimiter TransferEndpoint#delimiter}
  */
  readonly delimiter?: string;
  /**
  * Replace double quotes with single quotes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#double_quote TransferEndpoint#double_quote}
  */
  readonly doubleQuote?: boolean | cdktf.IResolvable;
  /**
  * Encoding
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#encoding TransferEndpoint#encoding}
  */
  readonly encoding?: string;
  /**
  * Escape character
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#escape_char TransferEndpoint#escape_char}
  */
  readonly escapeChar?: string;
  /**
  * Allow newline characters in values
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#newlines_in_values TransferEndpoint#newlines_in_values}
  */
  readonly newlinesInValues?: boolean | cdktf.IResolvable;
  /**
  * Quote character
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#quote_char TransferEndpoint#quote_char}
  */
  readonly quoteChar?: string;
  /**
  * additional_options block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#additional_options TransferEndpoint#additional_options}
  */
  readonly additionalOptions?: TransferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptions;
  /**
  * advanced_options block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#advanced_options TransferEndpoint#advanced_options}
  */
  readonly advancedOptions?: TransferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptions;
}

export function transferEndpointSettingsObjectStorageSourceFormatCsvToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormatCsv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    block_size: cdktf.numberToTerraform(struct!.blockSize),
    delimiter: cdktf.stringToTerraform(struct!.delimiter),
    double_quote: cdktf.booleanToTerraform(struct!.doubleQuote),
    encoding: cdktf.stringToTerraform(struct!.encoding),
    escape_char: cdktf.stringToTerraform(struct!.escapeChar),
    newlines_in_values: cdktf.booleanToTerraform(struct!.newlinesInValues),
    quote_char: cdktf.stringToTerraform(struct!.quoteChar),
    additional_options: transferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptionsToTerraform(struct!.additionalOptions),
    advanced_options: transferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptionsToTerraform(struct!.advancedOptions),
  }
}


export function transferEndpointSettingsObjectStorageSourceFormatCsvToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormatCsv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    block_size: {
      value: cdktf.numberToHclTerraform(struct!.blockSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    delimiter: {
      value: cdktf.stringToHclTerraform(struct!.delimiter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    double_quote: {
      value: cdktf.booleanToHclTerraform(struct!.doubleQuote),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    encoding: {
      value: cdktf.stringToHclTerraform(struct!.encoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    escape_char: {
      value: cdktf.stringToHclTerraform(struct!.escapeChar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    newlines_in_values: {
      value: cdktf.booleanToHclTerraform(struct!.newlinesInValues),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    quote_char: {
      value: cdktf.stringToHclTerraform(struct!.quoteChar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    additional_options: {
      value: transferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptionsToHclTerraform(struct!.additionalOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptions",
    },
    advanced_options: {
      value: transferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptionsToHclTerraform(struct!.advancedOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptions",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceFormatCsvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceFormatCsv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._blockSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.blockSize = this._blockSize;
    }
    if (this._delimiter !== undefined) {
      hasAnyValues = true;
      internalValueResult.delimiter = this._delimiter;
    }
    if (this._doubleQuote !== undefined) {
      hasAnyValues = true;
      internalValueResult.doubleQuote = this._doubleQuote;
    }
    if (this._encoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.encoding = this._encoding;
    }
    if (this._escapeChar !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeChar = this._escapeChar;
    }
    if (this._newlinesInValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.newlinesInValues = this._newlinesInValues;
    }
    if (this._quoteChar !== undefined) {
      hasAnyValues = true;
      internalValueResult.quoteChar = this._quoteChar;
    }
    if (this._additionalOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalOptions = this._additionalOptions?.internalValue;
    }
    if (this._advancedOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedOptions = this._advancedOptions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceFormatCsv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._blockSize = undefined;
      this._delimiter = undefined;
      this._doubleQuote = undefined;
      this._encoding = undefined;
      this._escapeChar = undefined;
      this._newlinesInValues = undefined;
      this._quoteChar = undefined;
      this._additionalOptions.internalValue = undefined;
      this._advancedOptions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._blockSize = value.blockSize;
      this._delimiter = value.delimiter;
      this._doubleQuote = value.doubleQuote;
      this._encoding = value.encoding;
      this._escapeChar = value.escapeChar;
      this._newlinesInValues = value.newlinesInValues;
      this._quoteChar = value.quoteChar;
      this._additionalOptions.internalValue = value.additionalOptions;
      this._advancedOptions.internalValue = value.advancedOptions;
    }
  }

  // block_size - computed: true, optional: true, required: false
  private _blockSize?: number; 
  public get blockSize() {
    return this.getNumberAttribute('block_size');
  }
  public set blockSize(value: number) {
    this._blockSize = value;
  }
  public resetBlockSize() {
    this._blockSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockSizeInput() {
    return this._blockSize;
  }

  // delimiter - computed: true, optional: true, required: false
  private _delimiter?: string; 
  public get delimiter() {
    return this.getStringAttribute('delimiter');
  }
  public set delimiter(value: string) {
    this._delimiter = value;
  }
  public resetDelimiter() {
    this._delimiter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get delimiterInput() {
    return this._delimiter;
  }

  // double_quote - computed: true, optional: true, required: false
  private _doubleQuote?: boolean | cdktf.IResolvable; 
  public get doubleQuote() {
    return this.getBooleanAttribute('double_quote');
  }
  public set doubleQuote(value: boolean | cdktf.IResolvable) {
    this._doubleQuote = value;
  }
  public resetDoubleQuote() {
    this._doubleQuote = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get doubleQuoteInput() {
    return this._doubleQuote;
  }

  // encoding - computed: false, optional: true, required: false
  private _encoding?: string; 
  public get encoding() {
    return this.getStringAttribute('encoding');
  }
  public set encoding(value: string) {
    this._encoding = value;
  }
  public resetEncoding() {
    this._encoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encodingInput() {
    return this._encoding;
  }

  // escape_char - computed: true, optional: true, required: false
  private _escapeChar?: string; 
  public get escapeChar() {
    return this.getStringAttribute('escape_char');
  }
  public set escapeChar(value: string) {
    this._escapeChar = value;
  }
  public resetEscapeChar() {
    this._escapeChar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharInput() {
    return this._escapeChar;
  }

  // newlines_in_values - computed: true, optional: true, required: false
  private _newlinesInValues?: boolean | cdktf.IResolvable; 
  public get newlinesInValues() {
    return this.getBooleanAttribute('newlines_in_values');
  }
  public set newlinesInValues(value: boolean | cdktf.IResolvable) {
    this._newlinesInValues = value;
  }
  public resetNewlinesInValues() {
    this._newlinesInValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get newlinesInValuesInput() {
    return this._newlinesInValues;
  }

  // quote_char - computed: true, optional: true, required: false
  private _quoteChar?: string; 
  public get quoteChar() {
    return this.getStringAttribute('quote_char');
  }
  public set quoteChar(value: string) {
    this._quoteChar = value;
  }
  public resetQuoteChar() {
    this._quoteChar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get quoteCharInput() {
    return this._quoteChar;
  }

  // additional_options - computed: false, optional: true, required: false
  private _additionalOptions = new TransferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptionsOutputReference(this, "additional_options");
  public get additionalOptions() {
    return this._additionalOptions;
  }
  public putAdditionalOptions(value: TransferEndpointSettingsObjectStorageSourceFormatCsvAdditionalOptions) {
    this._additionalOptions.internalValue = value;
  }
  public resetAdditionalOptions() {
    this._additionalOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalOptionsInput() {
    return this._additionalOptions.internalValue;
  }

  // advanced_options - computed: false, optional: true, required: false
  private _advancedOptions = new TransferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptionsOutputReference(this, "advanced_options");
  public get advancedOptions() {
    return this._advancedOptions;
  }
  public putAdvancedOptions(value: TransferEndpointSettingsObjectStorageSourceFormatCsvAdvancedOptions) {
    this._advancedOptions.internalValue = value;
  }
  public resetAdvancedOptions() {
    this._advancedOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedOptionsInput() {
    return this._advancedOptions.internalValue;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceFormatJsonl {
  /**
  * Block size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#block_size TransferEndpoint#block_size}
  */
  readonly blockSize?: number;
  /**
  * Allow newline characters in values
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#newlines_in_values TransferEndpoint#newlines_in_values}
  */
  readonly newlinesInValues?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#unexpected_field_behavior TransferEndpoint#unexpected_field_behavior}
  */
  readonly unexpectedFieldBehavior?: string;
}

export function transferEndpointSettingsObjectStorageSourceFormatJsonlToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormatJsonl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    block_size: cdktf.numberToTerraform(struct!.blockSize),
    newlines_in_values: cdktf.booleanToTerraform(struct!.newlinesInValues),
    unexpected_field_behavior: cdktf.stringToTerraform(struct!.unexpectedFieldBehavior),
  }
}


export function transferEndpointSettingsObjectStorageSourceFormatJsonlToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormatJsonl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    block_size: {
      value: cdktf.numberToHclTerraform(struct!.blockSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    newlines_in_values: {
      value: cdktf.booleanToHclTerraform(struct!.newlinesInValues),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    unexpected_field_behavior: {
      value: cdktf.stringToHclTerraform(struct!.unexpectedFieldBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceFormatJsonlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceFormatJsonl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._blockSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.blockSize = this._blockSize;
    }
    if (this._newlinesInValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.newlinesInValues = this._newlinesInValues;
    }
    if (this._unexpectedFieldBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.unexpectedFieldBehavior = this._unexpectedFieldBehavior;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceFormatJsonl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._blockSize = undefined;
      this._newlinesInValues = undefined;
      this._unexpectedFieldBehavior = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._blockSize = value.blockSize;
      this._newlinesInValues = value.newlinesInValues;
      this._unexpectedFieldBehavior = value.unexpectedFieldBehavior;
    }
  }

  // block_size - computed: false, optional: true, required: false
  private _blockSize?: number; 
  public get blockSize() {
    return this.getNumberAttribute('block_size');
  }
  public set blockSize(value: number) {
    this._blockSize = value;
  }
  public resetBlockSize() {
    this._blockSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockSizeInput() {
    return this._blockSize;
  }

  // newlines_in_values - computed: true, optional: true, required: false
  private _newlinesInValues?: boolean | cdktf.IResolvable; 
  public get newlinesInValues() {
    return this.getBooleanAttribute('newlines_in_values');
  }
  public set newlinesInValues(value: boolean | cdktf.IResolvable) {
    this._newlinesInValues = value;
  }
  public resetNewlinesInValues() {
    this._newlinesInValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get newlinesInValuesInput() {
    return this._newlinesInValues;
  }

  // unexpected_field_behavior - computed: true, optional: true, required: false
  private _unexpectedFieldBehavior?: string; 
  public get unexpectedFieldBehavior() {
    return this.getStringAttribute('unexpected_field_behavior');
  }
  public set unexpectedFieldBehavior(value: string) {
    this._unexpectedFieldBehavior = value;
  }
  public resetUnexpectedFieldBehavior() {
    this._unexpectedFieldBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unexpectedFieldBehaviorInput() {
    return this._unexpectedFieldBehavior;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceFormatParquet {
}

export function transferEndpointSettingsObjectStorageSourceFormatParquetToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormatParquet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsObjectStorageSourceFormatParquetToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormatParquet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsObjectStorageSourceFormatParquetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceFormatParquet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceFormatParquet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsObjectStorageSourceFormat {
  /**
  * avro block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#avro TransferEndpoint#avro}
  */
  readonly avro?: TransferEndpointSettingsObjectStorageSourceFormatAvro;
  /**
  * csv block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#csv TransferEndpoint#csv}
  */
  readonly csv?: TransferEndpointSettingsObjectStorageSourceFormatCsv;
  /**
  * jsonl block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#jsonl TransferEndpoint#jsonl}
  */
  readonly jsonl?: TransferEndpointSettingsObjectStorageSourceFormatJsonl;
  /**
  * parquet block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#parquet TransferEndpoint#parquet}
  */
  readonly parquet?: TransferEndpointSettingsObjectStorageSourceFormatParquet;
}

export function transferEndpointSettingsObjectStorageSourceFormatToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    avro: transferEndpointSettingsObjectStorageSourceFormatAvroToTerraform(struct!.avro),
    csv: transferEndpointSettingsObjectStorageSourceFormatCsvToTerraform(struct!.csv),
    jsonl: transferEndpointSettingsObjectStorageSourceFormatJsonlToTerraform(struct!.jsonl),
    parquet: transferEndpointSettingsObjectStorageSourceFormatParquetToTerraform(struct!.parquet),
  }
}


export function transferEndpointSettingsObjectStorageSourceFormatToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    avro: {
      value: transferEndpointSettingsObjectStorageSourceFormatAvroToHclTerraform(struct!.avro),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceFormatAvro",
    },
    csv: {
      value: transferEndpointSettingsObjectStorageSourceFormatCsvToHclTerraform(struct!.csv),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceFormatCsv",
    },
    jsonl: {
      value: transferEndpointSettingsObjectStorageSourceFormatJsonlToHclTerraform(struct!.jsonl),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceFormatJsonl",
    },
    parquet: {
      value: transferEndpointSettingsObjectStorageSourceFormatParquetToHclTerraform(struct!.parquet),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceFormatParquet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceFormatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceFormat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._avro?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.avro = this._avro?.internalValue;
    }
    if (this._csv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.csv = this._csv?.internalValue;
    }
    if (this._jsonl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonl = this._jsonl?.internalValue;
    }
    if (this._parquet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquet = this._parquet?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceFormat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._avro.internalValue = undefined;
      this._csv.internalValue = undefined;
      this._jsonl.internalValue = undefined;
      this._parquet.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._avro.internalValue = value.avro;
      this._csv.internalValue = value.csv;
      this._jsonl.internalValue = value.jsonl;
      this._parquet.internalValue = value.parquet;
    }
  }

  // avro - computed: false, optional: true, required: true
  private _avro = new TransferEndpointSettingsObjectStorageSourceFormatAvroOutputReference(this, "avro");
  public get avro() {
    return this._avro;
  }
  public putAvro(value: TransferEndpointSettingsObjectStorageSourceFormatAvro) {
    this._avro.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get avroInput() {
    return this._avro.internalValue;
  }

  // csv - computed: false, optional: true, required: false
  private _csv = new TransferEndpointSettingsObjectStorageSourceFormatCsvOutputReference(this, "csv");
  public get csv() {
    return this._csv;
  }
  public putCsv(value: TransferEndpointSettingsObjectStorageSourceFormatCsv) {
    this._csv.internalValue = value;
  }
  public resetCsv() {
    this._csv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get csvInput() {
    return this._csv.internalValue;
  }

  // jsonl - computed: false, optional: true, required: false
  private _jsonl = new TransferEndpointSettingsObjectStorageSourceFormatJsonlOutputReference(this, "jsonl");
  public get jsonl() {
    return this._jsonl;
  }
  public putJsonl(value: TransferEndpointSettingsObjectStorageSourceFormatJsonl) {
    this._jsonl.internalValue = value;
  }
  public resetJsonl() {
    this._jsonl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonlInput() {
    return this._jsonl.internalValue;
  }

  // parquet - computed: false, optional: true, required: true
  private _parquet = new TransferEndpointSettingsObjectStorageSourceFormatParquetOutputReference(this, "parquet");
  public get parquet() {
    return this._parquet;
  }
  public putParquet(value: TransferEndpointSettingsObjectStorageSourceFormatParquet) {
    this._parquet.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetInput() {
    return this._parquet.internalValue;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceProvider {
  /**
  * Access key ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#aws_access_key_id TransferEndpoint#aws_access_key_id}
  */
  readonly awsAccessKeyId?: string;
  /**
  * Secret access key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#aws_secret_access_key TransferEndpoint#aws_secret_access_key}
  */
  readonly awsSecretAccessKey?: string;
  /**
  * Bucket
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#bucket TransferEndpoint#bucket}
  */
  readonly bucket?: string;
  /**
  * Endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#endpoint TransferEndpoint#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Path prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#path_prefix TransferEndpoint#path_prefix}
  */
  readonly pathPrefix?: string;
  /**
  * Region
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#region TransferEndpoint#region}
  */
  readonly region?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#use_ssl TransferEndpoint#use_ssl}
  */
  readonly useSsl?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#verify_ssl_cert TransferEndpoint#verify_ssl_cert}
  */
  readonly verifySslCert?: boolean | cdktf.IResolvable;
}

export function transferEndpointSettingsObjectStorageSourceProviderToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws_access_key_id: cdktf.stringToTerraform(struct!.awsAccessKeyId),
    aws_secret_access_key: cdktf.stringToTerraform(struct!.awsSecretAccessKey),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    path_prefix: cdktf.stringToTerraform(struct!.pathPrefix),
    region: cdktf.stringToTerraform(struct!.region),
    use_ssl: cdktf.booleanToTerraform(struct!.useSsl),
    verify_ssl_cert: cdktf.booleanToTerraform(struct!.verifySslCert),
  }
}


export function transferEndpointSettingsObjectStorageSourceProviderToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws_access_key_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccessKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path_prefix: {
      value: cdktf.stringToHclTerraform(struct!.pathPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_ssl: {
      value: cdktf.booleanToHclTerraform(struct!.useSsl),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    verify_ssl_cert: {
      value: cdktf.booleanToHclTerraform(struct!.verifySslCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._awsAccessKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccessKeyId = this._awsAccessKeyId;
    }
    if (this._awsSecretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretAccessKey = this._awsSecretAccessKey;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._pathPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathPrefix = this._pathPrefix;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._useSsl !== undefined) {
      hasAnyValues = true;
      internalValueResult.useSsl = this._useSsl;
    }
    if (this._verifySslCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifySslCert = this._verifySslCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._awsAccessKeyId = undefined;
      this._awsSecretAccessKey = undefined;
      this._bucket = undefined;
      this._endpoint = undefined;
      this._pathPrefix = undefined;
      this._region = undefined;
      this._useSsl = undefined;
      this._verifySslCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._awsAccessKeyId = value.awsAccessKeyId;
      this._awsSecretAccessKey = value.awsSecretAccessKey;
      this._bucket = value.bucket;
      this._endpoint = value.endpoint;
      this._pathPrefix = value.pathPrefix;
      this._region = value.region;
      this._useSsl = value.useSsl;
      this._verifySslCert = value.verifySslCert;
    }
  }

  // aws_access_key_id - computed: false, optional: true, required: false
  private _awsAccessKeyId?: string; 
  public get awsAccessKeyId() {
    return this.getStringAttribute('aws_access_key_id');
  }
  public set awsAccessKeyId(value: string) {
    this._awsAccessKeyId = value;
  }
  public resetAwsAccessKeyId() {
    this._awsAccessKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccessKeyIdInput() {
    return this._awsAccessKeyId;
  }

  // aws_secret_access_key - computed: false, optional: true, required: false
  private _awsSecretAccessKey?: string; 
  public get awsSecretAccessKey() {
    return this.getStringAttribute('aws_secret_access_key');
  }
  public set awsSecretAccessKey(value: string) {
    this._awsSecretAccessKey = value;
  }
  public resetAwsSecretAccessKey() {
    this._awsSecretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretAccessKeyInput() {
    return this._awsSecretAccessKey;
  }

  // bucket - computed: false, optional: true, required: false
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  public resetBucket() {
    this._bucket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // path_prefix - computed: false, optional: true, required: false
  private _pathPrefix?: string; 
  public get pathPrefix() {
    return this.getStringAttribute('path_prefix');
  }
  public set pathPrefix(value: string) {
    this._pathPrefix = value;
  }
  public resetPathPrefix() {
    this._pathPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathPrefixInput() {
    return this._pathPrefix;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // use_ssl - computed: true, optional: true, required: false
  private _useSsl?: boolean | cdktf.IResolvable; 
  public get useSsl() {
    return this.getBooleanAttribute('use_ssl');
  }
  public set useSsl(value: boolean | cdktf.IResolvable) {
    this._useSsl = value;
  }
  public resetUseSsl() {
    this._useSsl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useSslInput() {
    return this._useSsl;
  }

  // verify_ssl_cert - computed: true, optional: true, required: false
  private _verifySslCert?: boolean | cdktf.IResolvable; 
  public get verifySslCert() {
    return this.getBooleanAttribute('verify_ssl_cert');
  }
  public set verifySslCert(value: boolean | cdktf.IResolvable) {
    this._verifySslCert = value;
  }
  public resetVerifySslCert() {
    this._verifySslCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifySslCertInput() {
    return this._verifySslCert;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsField {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#key TransferEndpoint#key}
  */
  readonly key?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#name TransferEndpoint#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#path TransferEndpoint#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#required TransferEndpoint#required}
  */
  readonly required?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#type TransferEndpoint#type}
  */
  readonly type?: string;
}

export function transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsFieldToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.booleanToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    required: cdktf.booleanToTerraform(struct!.required),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsFieldToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsField | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.booleanToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    required: {
      value: cdktf.booleanToHclTerraform(struct!.required),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsFieldOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsField | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._required !== undefined) {
      hasAnyValues = true;
      internalValueResult.required = this._required;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsField | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._path = undefined;
      this._required = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._path = value.path;
      this._required = value.required;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: boolean | cdktf.IResolvable; 
  public get key() {
    return this.getBooleanAttribute('key');
  }
  public set key(value: boolean | cdktf.IResolvable) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // required - computed: false, optional: true, required: false
  private _required?: boolean | cdktf.IResolvable; 
  public get required() {
    return this.getBooleanAttribute('required');
  }
  public set required(value: boolean | cdktf.IResolvable) {
    this._required = value;
  }
  public resetRequired() {
    this._required = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredInput() {
    return this._required;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsFieldList extends cdktf.ComplexList {
  public internalValue? : TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsField[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsFieldOutputReference {
    return new TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsFieldOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFields {
  /**
  * field block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#field TransferEndpoint#field}
  */
  readonly field?: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsField[] | cdktf.IResolvable;
}

export function transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.listMapper(transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsFieldToTerraform, true)(struct!.field),
  }
}


export function transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.listMapperHcl(transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsFieldToHclTerraform, true)(struct!.field),
      isBlock: true,
      type: "list",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsFieldList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field.internalValue = value.field;
    }
  }

  // field - computed: false, optional: true, required: false
  private _field = new TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsFieldList(this, "field", false);
  public get field() {
    return this._field;
  }
  public putField(value: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsField[] | cdktf.IResolvable) {
    this._field.internalValue = value;
  }
  public resetField() {
    this._field.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field.internalValue;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFields {
  /**
  * JSON field
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#json_fields TransferEndpoint#json_fields}
  */
  readonly jsonFields?: string;
}

export function transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFieldsToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_fields: cdktf.stringToTerraform(struct!.jsonFields),
  }
}


export function transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFieldsToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_fields: {
      value: cdktf.stringToHclTerraform(struct!.jsonFields),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonFields = this._jsonFields;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonFields = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonFields = value.jsonFields;
    }
  }

  // json_fields - computed: false, optional: true, required: false
  private _jsonFields?: string; 
  public get jsonFields() {
    return this.getStringAttribute('json_fields');
  }
  public set jsonFields(value: string) {
    this._jsonFields = value;
  }
  public resetJsonFields() {
    this._jsonFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonFieldsInput() {
    return this._jsonFields;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchema {
  /**
  * fields block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#fields TransferEndpoint#fields}
  */
  readonly fields?: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFields;
  /**
  * json_fields block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#json_fields TransferEndpoint#json_fields}
  */
  readonly jsonFields?: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFields;
}

export function transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchema | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fields: transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsToTerraform(struct!.fields),
    json_fields: transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFieldsToTerraform(struct!.jsonFields),
  }
}


export function transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchema | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fields: {
      value: transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsToHclTerraform(struct!.fields),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFields",
    },
    json_fields: {
      value: transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFieldsToHclTerraform(struct!.jsonFields),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFields",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchema | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields?.internalValue;
    }
    if (this._jsonFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonFields = this._jsonFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchema | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fields.internalValue = undefined;
      this._jsonFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fields.internalValue = value.fields;
      this._jsonFields.internalValue = value.jsonFields;
    }
  }

  // fields - computed: false, optional: true, required: false
  private _fields = new TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFieldsOutputReference(this, "fields");
  public get fields() {
    return this._fields;
  }
  public putFields(value: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaFields) {
    this._fields.internalValue = value;
  }
  public resetFields() {
    this._fields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields.internalValue;
  }

  // json_fields - computed: false, optional: true, required: false
  private _jsonFields = new TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFieldsOutputReference(this, "json_fields");
  public get jsonFields() {
    return this._jsonFields;
  }
  public putJsonFields(value: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaJsonFields) {
    this._jsonFields.internalValue = value;
  }
  public resetJsonFields() {
    this._jsonFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonFieldsInput() {
    return this._jsonFields.internalValue;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceResultSchemaInfer {
}

export function transferEndpointSettingsObjectStorageSourceResultSchemaInferToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultSchemaInfer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsObjectStorageSourceResultSchemaInferToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultSchemaInfer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsObjectStorageSourceResultSchemaInferOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceResultSchemaInfer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceResultSchemaInfer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsObjectStorageSourceResultSchema {
  /**
  * data_schema block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#data_schema TransferEndpoint#data_schema}
  */
  readonly dataSchema?: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchema;
  /**
  * infer block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#infer TransferEndpoint#infer}
  */
  readonly infer?: TransferEndpointSettingsObjectStorageSourceResultSchemaInfer;
}

export function transferEndpointSettingsObjectStorageSourceResultSchemaToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultSchema | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data_schema: transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaToTerraform(struct!.dataSchema),
    infer: transferEndpointSettingsObjectStorageSourceResultSchemaInferToTerraform(struct!.infer),
  }
}


export function transferEndpointSettingsObjectStorageSourceResultSchemaToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultSchema | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data_schema: {
      value: transferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaToHclTerraform(struct!.dataSchema),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchema",
    },
    infer: {
      value: transferEndpointSettingsObjectStorageSourceResultSchemaInferToHclTerraform(struct!.infer),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceResultSchemaInfer",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceResultSchemaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceResultSchema | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dataSchema?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataSchema = this._dataSchema?.internalValue;
    }
    if (this._infer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.infer = this._infer?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceResultSchema | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dataSchema.internalValue = undefined;
      this._infer.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dataSchema.internalValue = value.dataSchema;
      this._infer.internalValue = value.infer;
    }
  }

  // data_schema - computed: false, optional: true, required: false
  private _dataSchema = new TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchemaOutputReference(this, "data_schema");
  public get dataSchema() {
    return this._dataSchema;
  }
  public putDataSchema(value: TransferEndpointSettingsObjectStorageSourceResultSchemaDataSchema) {
    this._dataSchema.internalValue = value;
  }
  public resetDataSchema() {
    this._dataSchema.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataSchemaInput() {
    return this._dataSchema.internalValue;
  }

  // infer - computed: false, optional: true, required: true
  private _infer = new TransferEndpointSettingsObjectStorageSourceResultSchemaInferOutputReference(this, "infer");
  public get infer() {
    return this._infer;
  }
  public putInfer(value: TransferEndpointSettingsObjectStorageSourceResultSchemaInfer) {
    this._infer.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get inferInput() {
    return this._infer.internalValue;
  }
}
export interface TransferEndpointSettingsObjectStorageSourceResultTable {
  /**
  * Add system columns
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#add_system_cols TransferEndpoint#add_system_cols}
  */
  readonly addSystemCols?: boolean | cdktf.IResolvable;
  /**
  * Table name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#table_name TransferEndpoint#table_name}
  */
  readonly tableName?: string;
  /**
  * Table namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#table_namespace TransferEndpoint#table_namespace}
  */
  readonly tableNamespace?: string;
}

export function transferEndpointSettingsObjectStorageSourceResultTableToTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultTable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_system_cols: cdktf.booleanToTerraform(struct!.addSystemCols),
    table_name: cdktf.stringToTerraform(struct!.tableName),
    table_namespace: cdktf.stringToTerraform(struct!.tableNamespace),
  }
}


export function transferEndpointSettingsObjectStorageSourceResultTableToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSourceResultTable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_system_cols: {
      value: cdktf.booleanToHclTerraform(struct!.addSystemCols),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    table_name: {
      value: cdktf.stringToHclTerraform(struct!.tableName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    table_namespace: {
      value: cdktf.stringToHclTerraform(struct!.tableNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceResultTableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSourceResultTable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addSystemCols !== undefined) {
      hasAnyValues = true;
      internalValueResult.addSystemCols = this._addSystemCols;
    }
    if (this._tableName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tableName = this._tableName;
    }
    if (this._tableNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.tableNamespace = this._tableNamespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSourceResultTable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addSystemCols = undefined;
      this._tableName = undefined;
      this._tableNamespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addSystemCols = value.addSystemCols;
      this._tableName = value.tableName;
      this._tableNamespace = value.tableNamespace;
    }
  }

  // add_system_cols - computed: true, optional: true, required: false
  private _addSystemCols?: boolean | cdktf.IResolvable; 
  public get addSystemCols() {
    return this.getBooleanAttribute('add_system_cols');
  }
  public set addSystemCols(value: boolean | cdktf.IResolvable) {
    this._addSystemCols = value;
  }
  public resetAddSystemCols() {
    this._addSystemCols = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addSystemColsInput() {
    return this._addSystemCols;
  }

  // table_name - computed: false, optional: true, required: false
  private _tableName?: string; 
  public get tableName() {
    return this.getStringAttribute('table_name');
  }
  public set tableName(value: string) {
    this._tableName = value;
  }
  public resetTableName() {
    this._tableName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tableNameInput() {
    return this._tableName;
  }

  // table_namespace - computed: false, optional: true, required: false
  private _tableNamespace?: string; 
  public get tableNamespace() {
    return this.getStringAttribute('table_namespace');
  }
  public set tableNamespace(value: string) {
    this._tableNamespace = value;
  }
  public resetTableNamespace() {
    this._tableNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tableNamespaceInput() {
    return this._tableNamespace;
  }
}
export interface TransferEndpointSettingsObjectStorageSource {
  /**
  * Path pattern
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#path_pattern TransferEndpoint#path_pattern}
  */
  readonly pathPattern?: string;
  /**
  * event_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#event_source TransferEndpoint#event_source}
  */
  readonly eventSource?: TransferEndpointSettingsObjectStorageSourceEventSource;
  /**
  * format block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#format TransferEndpoint#format}
  */
  readonly format?: TransferEndpointSettingsObjectStorageSourceFormat;
  /**
  * provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#provider TransferEndpoint#provider}
  */
  readonly provider?: TransferEndpointSettingsObjectStorageSourceProvider;
  /**
  * result_schema block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#result_schema TransferEndpoint#result_schema}
  */
  readonly resultSchema?: TransferEndpointSettingsObjectStorageSourceResultSchema;
  /**
  * result_table block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#result_table TransferEndpoint#result_table}
  */
  readonly resultTable?: TransferEndpointSettingsObjectStorageSourceResultTable;
}

export function transferEndpointSettingsObjectStorageSourceToTerraform(struct?: TransferEndpointSettingsObjectStorageSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path_pattern: cdktf.stringToTerraform(struct!.pathPattern),
    event_source: transferEndpointSettingsObjectStorageSourceEventSourceToTerraform(struct!.eventSource),
    format: transferEndpointSettingsObjectStorageSourceFormatToTerraform(struct!.format),
    provider: transferEndpointSettingsObjectStorageSourceProviderToTerraform(struct!.provider),
    result_schema: transferEndpointSettingsObjectStorageSourceResultSchemaToTerraform(struct!.resultSchema),
    result_table: transferEndpointSettingsObjectStorageSourceResultTableToTerraform(struct!.resultTable),
  }
}


export function transferEndpointSettingsObjectStorageSourceToHclTerraform(struct?: TransferEndpointSettingsObjectStorageSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path_pattern: {
      value: cdktf.stringToHclTerraform(struct!.pathPattern),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_source: {
      value: transferEndpointSettingsObjectStorageSourceEventSourceToHclTerraform(struct!.eventSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceEventSource",
    },
    format: {
      value: transferEndpointSettingsObjectStorageSourceFormatToHclTerraform(struct!.format),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceFormat",
    },
    provider: {
      value: transferEndpointSettingsObjectStorageSourceProviderToHclTerraform(struct!.provider),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceProvider",
    },
    result_schema: {
      value: transferEndpointSettingsObjectStorageSourceResultSchemaToHclTerraform(struct!.resultSchema),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceResultSchema",
    },
    result_table: {
      value: transferEndpointSettingsObjectStorageSourceResultTableToHclTerraform(struct!.resultTable),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSourceResultTable",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pathPattern !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathPattern = this._pathPattern;
    }
    if (this._eventSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventSource = this._eventSource?.internalValue;
    }
    if (this._format?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format?.internalValue;
    }
    if (this._provider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.provider = this._provider?.internalValue;
    }
    if (this._resultSchema?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resultSchema = this._resultSchema?.internalValue;
    }
    if (this._resultTable?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resultTable = this._resultTable?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pathPattern = undefined;
      this._eventSource.internalValue = undefined;
      this._format.internalValue = undefined;
      this._provider.internalValue = undefined;
      this._resultSchema.internalValue = undefined;
      this._resultTable.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pathPattern = value.pathPattern;
      this._eventSource.internalValue = value.eventSource;
      this._format.internalValue = value.format;
      this._provider.internalValue = value.provider;
      this._resultSchema.internalValue = value.resultSchema;
      this._resultTable.internalValue = value.resultTable;
    }
  }

  // path_pattern - computed: false, optional: true, required: false
  private _pathPattern?: string; 
  public get pathPattern() {
    return this.getStringAttribute('path_pattern');
  }
  public set pathPattern(value: string) {
    this._pathPattern = value;
  }
  public resetPathPattern() {
    this._pathPattern = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathPatternInput() {
    return this._pathPattern;
  }

  // event_source - computed: false, optional: true, required: false
  private _eventSource = new TransferEndpointSettingsObjectStorageSourceEventSourceOutputReference(this, "event_source");
  public get eventSource() {
    return this._eventSource;
  }
  public putEventSource(value: TransferEndpointSettingsObjectStorageSourceEventSource) {
    this._eventSource.internalValue = value;
  }
  public resetEventSource() {
    this._eventSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventSourceInput() {
    return this._eventSource.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format = new TransferEndpointSettingsObjectStorageSourceFormatOutputReference(this, "format");
  public get format() {
    return this._format;
  }
  public putFormat(value: TransferEndpointSettingsObjectStorageSourceFormat) {
    this._format.internalValue = value;
  }
  public resetFormat() {
    this._format.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format.internalValue;
  }

  // provider - computed: false, optional: true, required: false
  private _provider = new TransferEndpointSettingsObjectStorageSourceProviderOutputReference(this, "provider");
  public get provider() {
    return this._provider;
  }
  public putProvider(value: TransferEndpointSettingsObjectStorageSourceProvider) {
    this._provider.internalValue = value;
  }
  public resetProvider() {
    this._provider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerInput() {
    return this._provider.internalValue;
  }

  // result_schema - computed: false, optional: true, required: false
  private _resultSchema = new TransferEndpointSettingsObjectStorageSourceResultSchemaOutputReference(this, "result_schema");
  public get resultSchema() {
    return this._resultSchema;
  }
  public putResultSchema(value: TransferEndpointSettingsObjectStorageSourceResultSchema) {
    this._resultSchema.internalValue = value;
  }
  public resetResultSchema() {
    this._resultSchema.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resultSchemaInput() {
    return this._resultSchema.internalValue;
  }

  // result_table - computed: false, optional: true, required: false
  private _resultTable = new TransferEndpointSettingsObjectStorageSourceResultTableOutputReference(this, "result_table");
  public get resultTable() {
    return this._resultTable;
  }
  public putResultTable(value: TransferEndpointSettingsObjectStorageSourceResultTable) {
    this._resultTable.internalValue = value;
  }
  public resetResultTable() {
    this._resultTable.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resultTableInput() {
    return this._resultTable.internalValue;
  }
}
export interface TransferEndpointSettingsObjectStorageTargetConnection {
  /**
  * Access key ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#aws_access_key_id TransferEndpoint#aws_access_key_id}
  */
  readonly awsAccessKeyId?: string;
  /**
  * Secret access key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#aws_secret_access_key TransferEndpoint#aws_secret_access_key}
  */
  readonly awsSecretAccessKey?: string;
  /**
  * Endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#endpoint TransferEndpoint#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Region
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#region TransferEndpoint#region}
  */
  readonly region?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#use_ssl TransferEndpoint#use_ssl}
  */
  readonly useSsl?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#verify_ssl_cert TransferEndpoint#verify_ssl_cert}
  */
  readonly verifySslCert?: boolean | cdktf.IResolvable;
}

export function transferEndpointSettingsObjectStorageTargetConnectionToTerraform(struct?: TransferEndpointSettingsObjectStorageTargetConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws_access_key_id: cdktf.stringToTerraform(struct!.awsAccessKeyId),
    aws_secret_access_key: cdktf.stringToTerraform(struct!.awsSecretAccessKey),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    region: cdktf.stringToTerraform(struct!.region),
    use_ssl: cdktf.booleanToTerraform(struct!.useSsl),
    verify_ssl_cert: cdktf.booleanToTerraform(struct!.verifySslCert),
  }
}


export function transferEndpointSettingsObjectStorageTargetConnectionToHclTerraform(struct?: TransferEndpointSettingsObjectStorageTargetConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws_access_key_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccessKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_ssl: {
      value: cdktf.booleanToHclTerraform(struct!.useSsl),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    verify_ssl_cert: {
      value: cdktf.booleanToHclTerraform(struct!.verifySslCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageTargetConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageTargetConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._awsAccessKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccessKeyId = this._awsAccessKeyId;
    }
    if (this._awsSecretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretAccessKey = this._awsSecretAccessKey;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._useSsl !== undefined) {
      hasAnyValues = true;
      internalValueResult.useSsl = this._useSsl;
    }
    if (this._verifySslCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifySslCert = this._verifySslCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageTargetConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._awsAccessKeyId = undefined;
      this._awsSecretAccessKey = undefined;
      this._endpoint = undefined;
      this._region = undefined;
      this._useSsl = undefined;
      this._verifySslCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._awsAccessKeyId = value.awsAccessKeyId;
      this._awsSecretAccessKey = value.awsSecretAccessKey;
      this._endpoint = value.endpoint;
      this._region = value.region;
      this._useSsl = value.useSsl;
      this._verifySslCert = value.verifySslCert;
    }
  }

  // aws_access_key_id - computed: false, optional: true, required: false
  private _awsAccessKeyId?: string; 
  public get awsAccessKeyId() {
    return this.getStringAttribute('aws_access_key_id');
  }
  public set awsAccessKeyId(value: string) {
    this._awsAccessKeyId = value;
  }
  public resetAwsAccessKeyId() {
    this._awsAccessKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccessKeyIdInput() {
    return this._awsAccessKeyId;
  }

  // aws_secret_access_key - computed: false, optional: true, required: false
  private _awsSecretAccessKey?: string; 
  public get awsSecretAccessKey() {
    return this.getStringAttribute('aws_secret_access_key');
  }
  public set awsSecretAccessKey(value: string) {
    this._awsSecretAccessKey = value;
  }
  public resetAwsSecretAccessKey() {
    this._awsSecretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretAccessKeyInput() {
    return this._awsSecretAccessKey;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // use_ssl - computed: true, optional: true, required: false
  private _useSsl?: boolean | cdktf.IResolvable; 
  public get useSsl() {
    return this.getBooleanAttribute('use_ssl');
  }
  public set useSsl(value: boolean | cdktf.IResolvable) {
    this._useSsl = value;
  }
  public resetUseSsl() {
    this._useSsl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useSslInput() {
    return this._useSsl;
  }

  // verify_ssl_cert - computed: true, optional: true, required: false
  private _verifySslCert?: boolean | cdktf.IResolvable; 
  public get verifySslCert() {
    return this.getBooleanAttribute('verify_ssl_cert');
  }
  public set verifySslCert(value: boolean | cdktf.IResolvable) {
    this._verifySslCert = value;
  }
  public resetVerifySslCert() {
    this._verifySslCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifySslCertInput() {
    return this._verifySslCert;
  }
}
export interface TransferEndpointSettingsObjectStorageTargetSerializerConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#any_as_string TransferEndpoint#any_as_string}
  */
  readonly anyAsString?: boolean | cdktf.IResolvable;
}

export function transferEndpointSettingsObjectStorageTargetSerializerConfigToTerraform(struct?: TransferEndpointSettingsObjectStorageTargetSerializerConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    any_as_string: cdktf.booleanToTerraform(struct!.anyAsString),
  }
}


export function transferEndpointSettingsObjectStorageTargetSerializerConfigToHclTerraform(struct?: TransferEndpointSettingsObjectStorageTargetSerializerConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    any_as_string: {
      value: cdktf.booleanToHclTerraform(struct!.anyAsString),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageTargetSerializerConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageTargetSerializerConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._anyAsString !== undefined) {
      hasAnyValues = true;
      internalValueResult.anyAsString = this._anyAsString;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageTargetSerializerConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._anyAsString = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._anyAsString = value.anyAsString;
    }
  }

  // any_as_string - computed: true, optional: true, required: false
  private _anyAsString?: boolean | cdktf.IResolvable; 
  public get anyAsString() {
    return this.getBooleanAttribute('any_as_string');
  }
  public set anyAsString(value: boolean | cdktf.IResolvable) {
    this._anyAsString = value;
  }
  public resetAnyAsString() {
    this._anyAsString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyAsStringInput() {
    return this._anyAsString;
  }
}
export interface TransferEndpointSettingsObjectStorageTarget {
  /**
  * Target bucket
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#bucket TransferEndpoint#bucket}
  */
  readonly bucket?: string;
  /**
  * Bucket layout
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#bucket_layout TransferEndpoint#bucket_layout}
  */
  readonly bucketLayout?: string;
  /**
  * Bucket layout column
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#bucket_layout_column TransferEndpoint#bucket_layout_column}
  */
  readonly bucketLayoutColumn?: string;
  /**
  * Bucket layout timezone
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#bucket_layout_timezone TransferEndpoint#bucket_layout_timezone}
  */
  readonly bucketLayoutTimezone?: string;
  /**
  * Buffer interval
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#buffer_interval TransferEndpoint#buffer_interval}
  */
  readonly bufferInterval?: string;
  /**
  * Buffer size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#buffer_size TransferEndpoint#buffer_size}
  */
  readonly bufferSize?: string;
  /**
  * Output encoding
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#output_encoding TransferEndpoint#output_encoding}
  */
  readonly outputEncoding?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#output_format TransferEndpoint#output_format}
  */
  readonly outputFormat?: string;
  /**
  * Service account ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#service_account_id TransferEndpoint#service_account_id}
  */
  readonly serviceAccountId?: string;
  /**
  * connection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection TransferEndpoint#connection}
  */
  readonly connection?: TransferEndpointSettingsObjectStorageTargetConnection;
  /**
  * serializer_config block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#serializer_config TransferEndpoint#serializer_config}
  */
  readonly serializerConfig?: TransferEndpointSettingsObjectStorageTargetSerializerConfig;
}

export function transferEndpointSettingsObjectStorageTargetToTerraform(struct?: TransferEndpointSettingsObjectStorageTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bucket: cdktf.stringToTerraform(struct!.bucket),
    bucket_layout: cdktf.stringToTerraform(struct!.bucketLayout),
    bucket_layout_column: cdktf.stringToTerraform(struct!.bucketLayoutColumn),
    bucket_layout_timezone: cdktf.stringToTerraform(struct!.bucketLayoutTimezone),
    buffer_interval: cdktf.stringToTerraform(struct!.bufferInterval),
    buffer_size: cdktf.stringToTerraform(struct!.bufferSize),
    output_encoding: cdktf.stringToTerraform(struct!.outputEncoding),
    output_format: cdktf.stringToTerraform(struct!.outputFormat),
    service_account_id: cdktf.stringToTerraform(struct!.serviceAccountId),
    connection: transferEndpointSettingsObjectStorageTargetConnectionToTerraform(struct!.connection),
    serializer_config: transferEndpointSettingsObjectStorageTargetSerializerConfigToTerraform(struct!.serializerConfig),
  }
}


export function transferEndpointSettingsObjectStorageTargetToHclTerraform(struct?: TransferEndpointSettingsObjectStorageTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket_layout: {
      value: cdktf.stringToHclTerraform(struct!.bucketLayout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket_layout_column: {
      value: cdktf.stringToHclTerraform(struct!.bucketLayoutColumn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket_layout_timezone: {
      value: cdktf.stringToHclTerraform(struct!.bucketLayoutTimezone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    buffer_interval: {
      value: cdktf.stringToHclTerraform(struct!.bufferInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    buffer_size: {
      value: cdktf.stringToHclTerraform(struct!.bufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    output_encoding: {
      value: cdktf.stringToHclTerraform(struct!.outputEncoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    output_format: {
      value: cdktf.stringToHclTerraform(struct!.outputFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_id: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection: {
      value: transferEndpointSettingsObjectStorageTargetConnectionToHclTerraform(struct!.connection),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageTargetConnection",
    },
    serializer_config: {
      value: transferEndpointSettingsObjectStorageTargetSerializerConfigToHclTerraform(struct!.serializerConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageTargetSerializerConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsObjectStorageTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsObjectStorageTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._bucketLayout !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucketLayout = this._bucketLayout;
    }
    if (this._bucketLayoutColumn !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucketLayoutColumn = this._bucketLayoutColumn;
    }
    if (this._bucketLayoutTimezone !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucketLayoutTimezone = this._bucketLayoutTimezone;
    }
    if (this._bufferInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.bufferInterval = this._bufferInterval;
    }
    if (this._bufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.bufferSize = this._bufferSize;
    }
    if (this._outputEncoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputEncoding = this._outputEncoding;
    }
    if (this._outputFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputFormat = this._outputFormat;
    }
    if (this._serviceAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountId = this._serviceAccountId;
    }
    if (this._connection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connection = this._connection?.internalValue;
    }
    if (this._serializerConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serializerConfig = this._serializerConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsObjectStorageTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bucket = undefined;
      this._bucketLayout = undefined;
      this._bucketLayoutColumn = undefined;
      this._bucketLayoutTimezone = undefined;
      this._bufferInterval = undefined;
      this._bufferSize = undefined;
      this._outputEncoding = undefined;
      this._outputFormat = undefined;
      this._serviceAccountId = undefined;
      this._connection.internalValue = undefined;
      this._serializerConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bucket = value.bucket;
      this._bucketLayout = value.bucketLayout;
      this._bucketLayoutColumn = value.bucketLayoutColumn;
      this._bucketLayoutTimezone = value.bucketLayoutTimezone;
      this._bufferInterval = value.bufferInterval;
      this._bufferSize = value.bufferSize;
      this._outputEncoding = value.outputEncoding;
      this._outputFormat = value.outputFormat;
      this._serviceAccountId = value.serviceAccountId;
      this._connection.internalValue = value.connection;
      this._serializerConfig.internalValue = value.serializerConfig;
    }
  }

  // bucket - computed: false, optional: true, required: false
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  public resetBucket() {
    this._bucket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // bucket_layout - computed: false, optional: true, required: false
  private _bucketLayout?: string; 
  public get bucketLayout() {
    return this.getStringAttribute('bucket_layout');
  }
  public set bucketLayout(value: string) {
    this._bucketLayout = value;
  }
  public resetBucketLayout() {
    this._bucketLayout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketLayoutInput() {
    return this._bucketLayout;
  }

  // bucket_layout_column - computed: false, optional: true, required: false
  private _bucketLayoutColumn?: string; 
  public get bucketLayoutColumn() {
    return this.getStringAttribute('bucket_layout_column');
  }
  public set bucketLayoutColumn(value: string) {
    this._bucketLayoutColumn = value;
  }
  public resetBucketLayoutColumn() {
    this._bucketLayoutColumn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketLayoutColumnInput() {
    return this._bucketLayoutColumn;
  }

  // bucket_layout_timezone - computed: false, optional: true, required: false
  private _bucketLayoutTimezone?: string; 
  public get bucketLayoutTimezone() {
    return this.getStringAttribute('bucket_layout_timezone');
  }
  public set bucketLayoutTimezone(value: string) {
    this._bucketLayoutTimezone = value;
  }
  public resetBucketLayoutTimezone() {
    this._bucketLayoutTimezone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketLayoutTimezoneInput() {
    return this._bucketLayoutTimezone;
  }

  // buffer_interval - computed: false, optional: true, required: false
  private _bufferInterval?: string; 
  public get bufferInterval() {
    return this.getStringAttribute('buffer_interval');
  }
  public set bufferInterval(value: string) {
    this._bufferInterval = value;
  }
  public resetBufferInterval() {
    this._bufferInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferIntervalInput() {
    return this._bufferInterval;
  }

  // buffer_size - computed: false, optional: true, required: false
  private _bufferSize?: string; 
  public get bufferSize() {
    return this.getStringAttribute('buffer_size');
  }
  public set bufferSize(value: string) {
    this._bufferSize = value;
  }
  public resetBufferSize() {
    this._bufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferSizeInput() {
    return this._bufferSize;
  }

  // output_encoding - computed: true, optional: true, required: false
  private _outputEncoding?: string; 
  public get outputEncoding() {
    return this.getStringAttribute('output_encoding');
  }
  public set outputEncoding(value: string) {
    this._outputEncoding = value;
  }
  public resetOutputEncoding() {
    this._outputEncoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputEncodingInput() {
    return this._outputEncoding;
  }

  // output_format - computed: true, optional: true, required: false
  private _outputFormat?: string; 
  public get outputFormat() {
    return this.getStringAttribute('output_format');
  }
  public set outputFormat(value: string) {
    this._outputFormat = value;
  }
  public resetOutputFormat() {
    this._outputFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputFormatInput() {
    return this._outputFormat;
  }

  // service_account_id - computed: false, optional: true, required: false
  private _serviceAccountId?: string; 
  public get serviceAccountId() {
    return this.getStringAttribute('service_account_id');
  }
  public set serviceAccountId(value: string) {
    this._serviceAccountId = value;
  }
  public resetServiceAccountId() {
    this._serviceAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountIdInput() {
    return this._serviceAccountId;
  }

  // connection - computed: false, optional: true, required: false
  private _connection = new TransferEndpointSettingsObjectStorageTargetConnectionOutputReference(this, "connection");
  public get connection() {
    return this._connection;
  }
  public putConnection(value: TransferEndpointSettingsObjectStorageTargetConnection) {
    this._connection.internalValue = value;
  }
  public resetConnection() {
    this._connection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionInput() {
    return this._connection.internalValue;
  }

  // serializer_config - computed: false, optional: true, required: false
  private _serializerConfig = new TransferEndpointSettingsObjectStorageTargetSerializerConfigOutputReference(this, "serializer_config");
  public get serializerConfig() {
    return this._serializerConfig;
  }
  public putSerializerConfig(value: TransferEndpointSettingsObjectStorageTargetSerializerConfig) {
    this._serializerConfig.internalValue = value;
  }
  public resetSerializerConfig() {
    this._serializerConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serializerConfigInput() {
    return this._serializerConfig.internalValue;
  }
}
export interface TransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode {
  /**
  * X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. When CA certificate is specified TLS is used to connect to the server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ca_certificate TransferEndpoint#ca_certificate}
  */
  readonly caCertificate?: string;
}

export function transferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeToTerraform(struct?: TransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificate: cdktf.stringToTerraform(struct!.caCertificate),
  }
}


export function transferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeToHclTerraform(struct?: TransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.caCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificate = this._caCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificate = value.caCertificate;
    }
  }

  // ca_certificate - computed: false, optional: true, required: false
  private _caCertificate?: string; 
  public get caCertificate() {
    return this.getStringAttribute('ca_certificate');
  }
  public set caCertificate(value: string) {
    this._caCertificate = value;
  }
  public resetCaCertificate() {
    this._caCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificateInput() {
    return this._caCertificate;
  }
}
export interface TransferEndpointSettingsPostgresSourceConnectionOnPremise {
  /**
  * List of PostgreSQL hosts
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#hosts TransferEndpoint#hosts}
  */
  readonly hosts?: string[];
  /**
  * Port of the PostgreSQL instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#port TransferEndpoint#port}
  */
  readonly port?: number;
  /**
  * tls_mode block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tls_mode TransferEndpoint#tls_mode}
  */
  readonly tlsMode?: TransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode;
}

export function transferEndpointSettingsPostgresSourceConnectionOnPremiseToTerraform(struct?: TransferEndpointSettingsPostgresSourceConnectionOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    port: cdktf.numberToTerraform(struct!.port),
    tls_mode: transferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeToTerraform(struct!.tlsMode),
  }
}


export function transferEndpointSettingsPostgresSourceConnectionOnPremiseToHclTerraform(struct?: TransferEndpointSettingsPostgresSourceConnectionOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls_mode: {
      value: transferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeToHclTerraform(struct!.tlsMode),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsPostgresSourceConnectionOnPremiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsPostgresSourceConnectionOnPremise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._tlsMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMode = this._tlsMode?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsPostgresSourceConnectionOnPremise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hosts = undefined;
      this._port = undefined;
      this._tlsMode.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hosts = value.hosts;
      this._port = value.port;
      this._tlsMode.internalValue = value.tlsMode;
    }
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  public resetHosts() {
    this._hosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // tls_mode - computed: false, optional: true, required: false
  private _tlsMode = new TransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeOutputReference(this, "tls_mode");
  public get tlsMode() {
    return this._tlsMode;
  }
  public putTlsMode(value: TransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode) {
    this._tlsMode.internalValue = value;
  }
  public resetTlsMode() {
    this._tlsMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsModeInput() {
    return this._tlsMode.internalValue;
  }
}
export interface TransferEndpointSettingsPostgresSourceConnection {
  /**
  * on_premise block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#on_premise TransferEndpoint#on_premise}
  */
  readonly onPremise?: TransferEndpointSettingsPostgresSourceConnectionOnPremise;
}

export function transferEndpointSettingsPostgresSourceConnectionToTerraform(struct?: TransferEndpointSettingsPostgresSourceConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    on_premise: transferEndpointSettingsPostgresSourceConnectionOnPremiseToTerraform(struct!.onPremise),
  }
}


export function transferEndpointSettingsPostgresSourceConnectionToHclTerraform(struct?: TransferEndpointSettingsPostgresSourceConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    on_premise: {
      value: transferEndpointSettingsPostgresSourceConnectionOnPremiseToHclTerraform(struct!.onPremise),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsPostgresSourceConnectionOnPremise",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsPostgresSourceConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsPostgresSourceConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._onPremise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.onPremise = this._onPremise?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsPostgresSourceConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._onPremise.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._onPremise.internalValue = value.onPremise;
    }
  }

  // on_premise - computed: false, optional: true, required: false
  private _onPremise = new TransferEndpointSettingsPostgresSourceConnectionOnPremiseOutputReference(this, "on_premise");
  public get onPremise() {
    return this._onPremise;
  }
  public putOnPremise(value: TransferEndpointSettingsPostgresSourceConnectionOnPremise) {
    this._onPremise.internalValue = value;
  }
  public resetOnPremise() {
    this._onPremise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onPremiseInput() {
    return this._onPremise.internalValue;
  }
}
export interface TransferEndpointSettingsPostgresSourceObjectTransferSettings {
  /**
  * CREATE CAST ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#cast TransferEndpoint#cast}
  */
  readonly cast?: string;
  /**
  * CREATE COLLATION ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#collation TransferEndpoint#collation}
  */
  readonly collation?: string;
  /**
  * ALTER TABLE ... ADD CONSTRAINT ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#constraint TransferEndpoint#constraint}
  */
  readonly constraint?: string;
  /**
  * ALTER TABLE ... ALTER COLUMN ... SET DEFAULT ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#default_values TransferEndpoint#default_values}
  */
  readonly defaultValues?: string;
  /**
  * ALTER TABLE ... ADD FOREIGN KEY ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#fk_constraint TransferEndpoint#fk_constraint}
  */
  readonly fkConstraint?: string;
  /**
  * CREATE FUNCTION ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#function TransferEndpoint#function}
  */
  readonly function?: string;
  /**
  * CREATE INDEX ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#index TransferEndpoint#index}
  */
  readonly index?: string;
  /**
  * CREATE MATERIALIZED VIEW ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#materialized_view TransferEndpoint#materialized_view}
  */
  readonly materializedView?: string;
  /**
  * CREATE POLICY ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#policy TransferEndpoint#policy}
  */
  readonly policy?: string;
  /**
  * ALTER TABLE ... ADD PRIMARY KEY ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#primary_key TransferEndpoint#primary_key}
  */
  readonly primaryKey?: string;
  /**
  * CREATE RULE ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#rule TransferEndpoint#rule}
  */
  readonly rule?: string;
  /**
  * CREATE SEQUENCE ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#sequence TransferEndpoint#sequence}
  */
  readonly sequence?: string;
  /**
  * CREATE SEQUENCE ... OWNED BY ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#sequence_owned_by TransferEndpoint#sequence_owned_by}
  */
  readonly sequenceOwnedBy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#sequence_set TransferEndpoint#sequence_set}
  */
  readonly sequenceSet?: string;
  /**
  * CREATE TABLE ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#table TransferEndpoint#table}
  */
  readonly table?: string;
  /**
  * CREATE TRIGGER ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#trigger TransferEndpoint#trigger}
  */
  readonly trigger?: string;
  /**
  * CREATE TYPE ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#type TransferEndpoint#type}
  */
  readonly type?: string;
  /**
  * CREATE VIEW ...
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#view TransferEndpoint#view}
  */
  readonly view?: string;
}

export function transferEndpointSettingsPostgresSourceObjectTransferSettingsToTerraform(struct?: TransferEndpointSettingsPostgresSourceObjectTransferSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cast: cdktf.stringToTerraform(struct!.cast),
    collation: cdktf.stringToTerraform(struct!.collation),
    constraint: cdktf.stringToTerraform(struct!.constraint),
    default_values: cdktf.stringToTerraform(struct!.defaultValues),
    fk_constraint: cdktf.stringToTerraform(struct!.fkConstraint),
    function: cdktf.stringToTerraform(struct!.function),
    index: cdktf.stringToTerraform(struct!.index),
    materialized_view: cdktf.stringToTerraform(struct!.materializedView),
    policy: cdktf.stringToTerraform(struct!.policy),
    primary_key: cdktf.stringToTerraform(struct!.primaryKey),
    rule: cdktf.stringToTerraform(struct!.rule),
    sequence: cdktf.stringToTerraform(struct!.sequence),
    sequence_owned_by: cdktf.stringToTerraform(struct!.sequenceOwnedBy),
    sequence_set: cdktf.stringToTerraform(struct!.sequenceSet),
    table: cdktf.stringToTerraform(struct!.table),
    trigger: cdktf.stringToTerraform(struct!.trigger),
    type: cdktf.stringToTerraform(struct!.type),
    view: cdktf.stringToTerraform(struct!.view),
  }
}


export function transferEndpointSettingsPostgresSourceObjectTransferSettingsToHclTerraform(struct?: TransferEndpointSettingsPostgresSourceObjectTransferSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cast: {
      value: cdktf.stringToHclTerraform(struct!.cast),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collation: {
      value: cdktf.stringToHclTerraform(struct!.collation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    constraint: {
      value: cdktf.stringToHclTerraform(struct!.constraint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_values: {
      value: cdktf.stringToHclTerraform(struct!.defaultValues),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    fk_constraint: {
      value: cdktf.stringToHclTerraform(struct!.fkConstraint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    function: {
      value: cdktf.stringToHclTerraform(struct!.function),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    index: {
      value: cdktf.stringToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    materialized_view: {
      value: cdktf.stringToHclTerraform(struct!.materializedView),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    policy: {
      value: cdktf.stringToHclTerraform(struct!.policy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    primary_key: {
      value: cdktf.stringToHclTerraform(struct!.primaryKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rule: {
      value: cdktf.stringToHclTerraform(struct!.rule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sequence: {
      value: cdktf.stringToHclTerraform(struct!.sequence),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sequence_owned_by: {
      value: cdktf.stringToHclTerraform(struct!.sequenceOwnedBy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sequence_set: {
      value: cdktf.stringToHclTerraform(struct!.sequenceSet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    table: {
      value: cdktf.stringToHclTerraform(struct!.table),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    trigger: {
      value: cdktf.stringToHclTerraform(struct!.trigger),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    view: {
      value: cdktf.stringToHclTerraform(struct!.view),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsPostgresSourceObjectTransferSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsPostgresSourceObjectTransferSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cast !== undefined) {
      hasAnyValues = true;
      internalValueResult.cast = this._cast;
    }
    if (this._collation !== undefined) {
      hasAnyValues = true;
      internalValueResult.collation = this._collation;
    }
    if (this._constraint !== undefined) {
      hasAnyValues = true;
      internalValueResult.constraint = this._constraint;
    }
    if (this._defaultValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValues = this._defaultValues;
    }
    if (this._fkConstraint !== undefined) {
      hasAnyValues = true;
      internalValueResult.fkConstraint = this._fkConstraint;
    }
    if (this._function !== undefined) {
      hasAnyValues = true;
      internalValueResult.function = this._function;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._materializedView !== undefined) {
      hasAnyValues = true;
      internalValueResult.materializedView = this._materializedView;
    }
    if (this._policy !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy;
    }
    if (this._primaryKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.primaryKey = this._primaryKey;
    }
    if (this._rule !== undefined) {
      hasAnyValues = true;
      internalValueResult.rule = this._rule;
    }
    if (this._sequence !== undefined) {
      hasAnyValues = true;
      internalValueResult.sequence = this._sequence;
    }
    if (this._sequenceOwnedBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.sequenceOwnedBy = this._sequenceOwnedBy;
    }
    if (this._sequenceSet !== undefined) {
      hasAnyValues = true;
      internalValueResult.sequenceSet = this._sequenceSet;
    }
    if (this._table !== undefined) {
      hasAnyValues = true;
      internalValueResult.table = this._table;
    }
    if (this._trigger !== undefined) {
      hasAnyValues = true;
      internalValueResult.trigger = this._trigger;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._view !== undefined) {
      hasAnyValues = true;
      internalValueResult.view = this._view;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsPostgresSourceObjectTransferSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cast = undefined;
      this._collation = undefined;
      this._constraint = undefined;
      this._defaultValues = undefined;
      this._fkConstraint = undefined;
      this._function = undefined;
      this._index = undefined;
      this._materializedView = undefined;
      this._policy = undefined;
      this._primaryKey = undefined;
      this._rule = undefined;
      this._sequence = undefined;
      this._sequenceOwnedBy = undefined;
      this._sequenceSet = undefined;
      this._table = undefined;
      this._trigger = undefined;
      this._type = undefined;
      this._view = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cast = value.cast;
      this._collation = value.collation;
      this._constraint = value.constraint;
      this._defaultValues = value.defaultValues;
      this._fkConstraint = value.fkConstraint;
      this._function = value.function;
      this._index = value.index;
      this._materializedView = value.materializedView;
      this._policy = value.policy;
      this._primaryKey = value.primaryKey;
      this._rule = value.rule;
      this._sequence = value.sequence;
      this._sequenceOwnedBy = value.sequenceOwnedBy;
      this._sequenceSet = value.sequenceSet;
      this._table = value.table;
      this._trigger = value.trigger;
      this._type = value.type;
      this._view = value.view;
    }
  }

  // cast - computed: true, optional: true, required: false
  private _cast?: string; 
  public get cast() {
    return this.getStringAttribute('cast');
  }
  public set cast(value: string) {
    this._cast = value;
  }
  public resetCast() {
    this._cast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get castInput() {
    return this._cast;
  }

  // collation - computed: true, optional: true, required: false
  private _collation?: string; 
  public get collation() {
    return this.getStringAttribute('collation');
  }
  public set collation(value: string) {
    this._collation = value;
  }
  public resetCollation() {
    this._collation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collationInput() {
    return this._collation;
  }

  // constraint - computed: true, optional: true, required: false
  private _constraint?: string; 
  public get constraint() {
    return this.getStringAttribute('constraint');
  }
  public set constraint(value: string) {
    this._constraint = value;
  }
  public resetConstraint() {
    this._constraint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get constraintInput() {
    return this._constraint;
  }

  // default_values - computed: true, optional: true, required: false
  private _defaultValues?: string; 
  public get defaultValues() {
    return this.getStringAttribute('default_values');
  }
  public set defaultValues(value: string) {
    this._defaultValues = value;
  }
  public resetDefaultValues() {
    this._defaultValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValuesInput() {
    return this._defaultValues;
  }

  // fk_constraint - computed: true, optional: true, required: false
  private _fkConstraint?: string; 
  public get fkConstraint() {
    return this.getStringAttribute('fk_constraint');
  }
  public set fkConstraint(value: string) {
    this._fkConstraint = value;
  }
  public resetFkConstraint() {
    this._fkConstraint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fkConstraintInput() {
    return this._fkConstraint;
  }

  // function - computed: true, optional: true, required: false
  private _function?: string; 
  public get function() {
    return this.getStringAttribute('function');
  }
  public set function(value: string) {
    this._function = value;
  }
  public resetFunction() {
    this._function = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionInput() {
    return this._function;
  }

  // index - computed: true, optional: true, required: false
  private _index?: string; 
  public get index() {
    return this.getStringAttribute('index');
  }
  public set index(value: string) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // materialized_view - computed: true, optional: true, required: false
  private _materializedView?: string; 
  public get materializedView() {
    return this.getStringAttribute('materialized_view');
  }
  public set materializedView(value: string) {
    this._materializedView = value;
  }
  public resetMaterializedView() {
    this._materializedView = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get materializedViewInput() {
    return this._materializedView;
  }

  // policy - computed: true, optional: true, required: false
  private _policy?: string; 
  public get policy() {
    return this.getStringAttribute('policy');
  }
  public set policy(value: string) {
    this._policy = value;
  }
  public resetPolicy() {
    this._policy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy;
  }

  // primary_key - computed: true, optional: true, required: false
  private _primaryKey?: string; 
  public get primaryKey() {
    return this.getStringAttribute('primary_key');
  }
  public set primaryKey(value: string) {
    this._primaryKey = value;
  }
  public resetPrimaryKey() {
    this._primaryKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get primaryKeyInput() {
    return this._primaryKey;
  }

  // rule - computed: true, optional: true, required: false
  private _rule?: string; 
  public get rule() {
    return this.getStringAttribute('rule');
  }
  public set rule(value: string) {
    this._rule = value;
  }
  public resetRule() {
    this._rule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ruleInput() {
    return this._rule;
  }

  // sequence - computed: true, optional: true, required: false
  private _sequence?: string; 
  public get sequence() {
    return this.getStringAttribute('sequence');
  }
  public set sequence(value: string) {
    this._sequence = value;
  }
  public resetSequence() {
    this._sequence = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sequenceInput() {
    return this._sequence;
  }

  // sequence_owned_by - computed: true, optional: true, required: false
  private _sequenceOwnedBy?: string; 
  public get sequenceOwnedBy() {
    return this.getStringAttribute('sequence_owned_by');
  }
  public set sequenceOwnedBy(value: string) {
    this._sequenceOwnedBy = value;
  }
  public resetSequenceOwnedBy() {
    this._sequenceOwnedBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sequenceOwnedByInput() {
    return this._sequenceOwnedBy;
  }

  // sequence_set - computed: true, optional: true, required: false
  private _sequenceSet?: string; 
  public get sequenceSet() {
    return this.getStringAttribute('sequence_set');
  }
  public set sequenceSet(value: string) {
    this._sequenceSet = value;
  }
  public resetSequenceSet() {
    this._sequenceSet = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sequenceSetInput() {
    return this._sequenceSet;
  }

  // table - computed: true, optional: true, required: false
  private _table?: string; 
  public get table() {
    return this.getStringAttribute('table');
  }
  public set table(value: string) {
    this._table = value;
  }
  public resetTable() {
    this._table = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tableInput() {
    return this._table;
  }

  // trigger - computed: true, optional: true, required: false
  private _trigger?: string; 
  public get trigger() {
    return this.getStringAttribute('trigger');
  }
  public set trigger(value: string) {
    this._trigger = value;
  }
  public resetTrigger() {
    this._trigger = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get triggerInput() {
    return this._trigger;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // view - computed: true, optional: true, required: false
  private _view?: string; 
  public get view() {
    return this.getStringAttribute('view');
  }
  public set view(value: string) {
    this._view = value;
  }
  public resetView() {
    this._view = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get viewInput() {
    return this._view;
  }
}
export interface TransferEndpointSettingsPostgresSource {
  /**
  * Database name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#database TransferEndpoint#database}
  */
  readonly database?: string;
  /**
  * List of tables to be excluded from replication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#exclude_tables TransferEndpoint#exclude_tables}
  */
  readonly excludeTables?: string[];
  /**
  * List of tables to be replicated. Table names must be full and contain schemas. Can contain `schema_name.*` patterns. If the setting isn't specified or contains an empty list, all tables are replicated
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#include_tables TransferEndpoint#include_tables}
  */
  readonly includeTables?: string[];
  /**
  * Database user password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * Database schema for service tables (`__consumer_keeper` and `__data_transfer_mole_finder`). Default is `public`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#service_schema TransferEndpoint#service_schema}
  */
  readonly serviceSchema?: string;
  /**
  * Maximum lag of replication slots (in bytes). When this limit is exceeded,replication is aborted
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#slot_byte_lag_limit TransferEndpoint#slot_byte_lag_limit}
  */
  readonly slotByteLagLimit?: number;
  /**
  * Database user
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#user TransferEndpoint#user}
  */
  readonly user?: string;
  /**
  * connection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection TransferEndpoint#connection}
  */
  readonly connection?: TransferEndpointSettingsPostgresSourceConnection;
  /**
  * object_transfer_settings block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#object_transfer_settings TransferEndpoint#object_transfer_settings}
  */
  readonly objectTransferSettings?: TransferEndpointSettingsPostgresSourceObjectTransferSettings;
}

export function transferEndpointSettingsPostgresSourceToTerraform(struct?: TransferEndpointSettingsPostgresSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    database: cdktf.stringToTerraform(struct!.database),
    exclude_tables: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeTables),
    include_tables: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.includeTables),
    password: cdktf.stringToTerraform(struct!.password),
    service_schema: cdktf.stringToTerraform(struct!.serviceSchema),
    slot_byte_lag_limit: cdktf.numberToTerraform(struct!.slotByteLagLimit),
    user: cdktf.stringToTerraform(struct!.user),
    connection: transferEndpointSettingsPostgresSourceConnectionToTerraform(struct!.connection),
    object_transfer_settings: transferEndpointSettingsPostgresSourceObjectTransferSettingsToTerraform(struct!.objectTransferSettings),
  }
}


export function transferEndpointSettingsPostgresSourceToHclTerraform(struct?: TransferEndpointSettingsPostgresSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_tables: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeTables),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    include_tables: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.includeTables),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_schema: {
      value: cdktf.stringToHclTerraform(struct!.serviceSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    slot_byte_lag_limit: {
      value: cdktf.numberToHclTerraform(struct!.slotByteLagLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection: {
      value: transferEndpointSettingsPostgresSourceConnectionToHclTerraform(struct!.connection),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsPostgresSourceConnection",
    },
    object_transfer_settings: {
      value: transferEndpointSettingsPostgresSourceObjectTransferSettingsToHclTerraform(struct!.objectTransferSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsPostgresSourceObjectTransferSettings",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsPostgresSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsPostgresSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._excludeTables !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeTables = this._excludeTables;
    }
    if (this._includeTables !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeTables = this._includeTables;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._serviceSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceSchema = this._serviceSchema;
    }
    if (this._slotByteLagLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.slotByteLagLimit = this._slotByteLagLimit;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._connection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connection = this._connection?.internalValue;
    }
    if (this._objectTransferSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectTransferSettings = this._objectTransferSettings?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsPostgresSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._database = undefined;
      this._excludeTables = undefined;
      this._includeTables = undefined;
      this._password = undefined;
      this._serviceSchema = undefined;
      this._slotByteLagLimit = undefined;
      this._user = undefined;
      this._connection.internalValue = undefined;
      this._objectTransferSettings.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._database = value.database;
      this._excludeTables = value.excludeTables;
      this._includeTables = value.includeTables;
      this._password = value.password;
      this._serviceSchema = value.serviceSchema;
      this._slotByteLagLimit = value.slotByteLagLimit;
      this._user = value.user;
      this._connection.internalValue = value.connection;
      this._objectTransferSettings.internalValue = value.objectTransferSettings;
    }
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // exclude_tables - computed: false, optional: true, required: false
  private _excludeTables?: string[]; 
  public get excludeTables() {
    return this.getListAttribute('exclude_tables');
  }
  public set excludeTables(value: string[]) {
    this._excludeTables = value;
  }
  public resetExcludeTables() {
    this._excludeTables = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeTablesInput() {
    return this._excludeTables;
  }

  // include_tables - computed: false, optional: true, required: false
  private _includeTables?: string[]; 
  public get includeTables() {
    return this.getListAttribute('include_tables');
  }
  public set includeTables(value: string[]) {
    this._includeTables = value;
  }
  public resetIncludeTables() {
    this._includeTables = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeTablesInput() {
    return this._includeTables;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // service_schema - computed: true, optional: true, required: false
  private _serviceSchema?: string; 
  public get serviceSchema() {
    return this.getStringAttribute('service_schema');
  }
  public set serviceSchema(value: string) {
    this._serviceSchema = value;
  }
  public resetServiceSchema() {
    this._serviceSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceSchemaInput() {
    return this._serviceSchema;
  }

  // slot_byte_lag_limit - computed: true, optional: true, required: false
  private _slotByteLagLimit?: number; 
  public get slotByteLagLimit() {
    return this.getNumberAttribute('slot_byte_lag_limit');
  }
  public set slotByteLagLimit(value: number) {
    this._slotByteLagLimit = value;
  }
  public resetSlotByteLagLimit() {
    this._slotByteLagLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slotByteLagLimitInput() {
    return this._slotByteLagLimit;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // connection - computed: false, optional: true, required: false
  private _connection = new TransferEndpointSettingsPostgresSourceConnectionOutputReference(this, "connection");
  public get connection() {
    return this._connection;
  }
  public putConnection(value: TransferEndpointSettingsPostgresSourceConnection) {
    this._connection.internalValue = value;
  }
  public resetConnection() {
    this._connection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionInput() {
    return this._connection.internalValue;
  }

  // object_transfer_settings - computed: false, optional: true, required: false
  private _objectTransferSettings = new TransferEndpointSettingsPostgresSourceObjectTransferSettingsOutputReference(this, "object_transfer_settings");
  public get objectTransferSettings() {
    return this._objectTransferSettings;
  }
  public putObjectTransferSettings(value: TransferEndpointSettingsPostgresSourceObjectTransferSettings) {
    this._objectTransferSettings.internalValue = value;
  }
  public resetObjectTransferSettings() {
    this._objectTransferSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectTransferSettingsInput() {
    return this._objectTransferSettings.internalValue;
  }
}
export interface TransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode {
  /**
  * X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. When CA certificate is specified TLS is used to connect to the server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#ca_certificate TransferEndpoint#ca_certificate}
  */
  readonly caCertificate?: string;
}

export function transferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeToTerraform(struct?: TransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificate: cdktf.stringToTerraform(struct!.caCertificate),
  }
}


export function transferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeToHclTerraform(struct?: TransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificate: {
      value: cdktf.stringToHclTerraform(struct!.caCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificate = this._caCertificate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificate = value.caCertificate;
    }
  }

  // ca_certificate - computed: false, optional: true, required: false
  private _caCertificate?: string; 
  public get caCertificate() {
    return this.getStringAttribute('ca_certificate');
  }
  public set caCertificate(value: string) {
    this._caCertificate = value;
  }
  public resetCaCertificate() {
    this._caCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificateInput() {
    return this._caCertificate;
  }
}
export interface TransferEndpointSettingsPostgresTargetConnectionOnPremise {
  /**
  * List of PostgreSQL hosts
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#hosts TransferEndpoint#hosts}
  */
  readonly hosts?: string[];
  /**
  * Port of the PostgreSQL instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#port TransferEndpoint#port}
  */
  readonly port?: number;
  /**
  * tls_mode block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#tls_mode TransferEndpoint#tls_mode}
  */
  readonly tlsMode?: TransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode;
}

export function transferEndpointSettingsPostgresTargetConnectionOnPremiseToTerraform(struct?: TransferEndpointSettingsPostgresTargetConnectionOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hosts),
    port: cdktf.numberToTerraform(struct!.port),
    tls_mode: transferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeToTerraform(struct!.tlsMode),
  }
}


export function transferEndpointSettingsPostgresTargetConnectionOnPremiseToHclTerraform(struct?: TransferEndpointSettingsPostgresTargetConnectionOnPremise | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls_mode: {
      value: transferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeToHclTerraform(struct!.tlsMode),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsPostgresTargetConnectionOnPremiseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsPostgresTargetConnectionOnPremise | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._tlsMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsMode = this._tlsMode?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsPostgresTargetConnectionOnPremise | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hosts = undefined;
      this._port = undefined;
      this._tlsMode.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hosts = value.hosts;
      this._port = value.port;
      this._tlsMode.internalValue = value.tlsMode;
    }
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts?: string[]; 
  public get hosts() {
    return this.getListAttribute('hosts');
  }
  public set hosts(value: string[]) {
    this._hosts = value;
  }
  public resetHosts() {
    this._hosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // tls_mode - computed: false, optional: true, required: false
  private _tlsMode = new TransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeOutputReference(this, "tls_mode");
  public get tlsMode() {
    return this._tlsMode;
  }
  public putTlsMode(value: TransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode) {
    this._tlsMode.internalValue = value;
  }
  public resetTlsMode() {
    this._tlsMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsModeInput() {
    return this._tlsMode.internalValue;
  }
}
export interface TransferEndpointSettingsPostgresTargetConnection {
  /**
  * on_premise block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#on_premise TransferEndpoint#on_premise}
  */
  readonly onPremise?: TransferEndpointSettingsPostgresTargetConnectionOnPremise;
}

export function transferEndpointSettingsPostgresTargetConnectionToTerraform(struct?: TransferEndpointSettingsPostgresTargetConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    on_premise: transferEndpointSettingsPostgresTargetConnectionOnPremiseToTerraform(struct!.onPremise),
  }
}


export function transferEndpointSettingsPostgresTargetConnectionToHclTerraform(struct?: TransferEndpointSettingsPostgresTargetConnection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    on_premise: {
      value: transferEndpointSettingsPostgresTargetConnectionOnPremiseToHclTerraform(struct!.onPremise),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsPostgresTargetConnectionOnPremise",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsPostgresTargetConnectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsPostgresTargetConnection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._onPremise?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.onPremise = this._onPremise?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsPostgresTargetConnection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._onPremise.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._onPremise.internalValue = value.onPremise;
    }
  }

  // on_premise - computed: false, optional: true, required: false
  private _onPremise = new TransferEndpointSettingsPostgresTargetConnectionOnPremiseOutputReference(this, "on_premise");
  public get onPremise() {
    return this._onPremise;
  }
  public putOnPremise(value: TransferEndpointSettingsPostgresTargetConnectionOnPremise) {
    this._onPremise.internalValue = value;
  }
  public resetOnPremise() {
    this._onPremise.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onPremiseInput() {
    return this._onPremise.internalValue;
  }
}
export interface TransferEndpointSettingsPostgresTarget {
  /**
  * Cleanup policy for activating, reactivating, and reuploading processes. Default is `truncate`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#cleanup_policy TransferEndpoint#cleanup_policy}
  */
  readonly cleanupPolicy?: string;
  /**
  * Database name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#database TransferEndpoint#database}
  */
  readonly database?: string;
  /**
  * Database user password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * Database user
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#user TransferEndpoint#user}
  */
  readonly user?: string;
  /**
  * connection block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#connection TransferEndpoint#connection}
  */
  readonly connection?: TransferEndpointSettingsPostgresTargetConnection;
}

export function transferEndpointSettingsPostgresTargetToTerraform(struct?: TransferEndpointSettingsPostgresTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cleanup_policy: cdktf.stringToTerraform(struct!.cleanupPolicy),
    database: cdktf.stringToTerraform(struct!.database),
    password: cdktf.stringToTerraform(struct!.password),
    user: cdktf.stringToTerraform(struct!.user),
    connection: transferEndpointSettingsPostgresTargetConnectionToTerraform(struct!.connection),
  }
}


export function transferEndpointSettingsPostgresTargetToHclTerraform(struct?: TransferEndpointSettingsPostgresTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cleanup_policy: {
      value: cdktf.stringToHclTerraform(struct!.cleanupPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection: {
      value: transferEndpointSettingsPostgresTargetConnectionToHclTerraform(struct!.connection),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsPostgresTargetConnection",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsPostgresTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsPostgresTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cleanupPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.cleanupPolicy = this._cleanupPolicy;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._connection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connection = this._connection?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsPostgresTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cleanupPolicy = undefined;
      this._database = undefined;
      this._password = undefined;
      this._user = undefined;
      this._connection.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cleanupPolicy = value.cleanupPolicy;
      this._database = value.database;
      this._password = value.password;
      this._user = value.user;
      this._connection.internalValue = value.connection;
    }
  }

  // cleanup_policy - computed: true, optional: true, required: false
  private _cleanupPolicy?: string; 
  public get cleanupPolicy() {
    return this.getStringAttribute('cleanup_policy');
  }
  public set cleanupPolicy(value: string) {
    this._cleanupPolicy = value;
  }
  public resetCleanupPolicy() {
    this._cleanupPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cleanupPolicyInput() {
    return this._cleanupPolicy;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // connection - computed: false, optional: true, required: false
  private _connection = new TransferEndpointSettingsPostgresTargetConnectionOutputReference(this, "connection");
  public get connection() {
    return this._connection;
  }
  public putConnection(value: TransferEndpointSettingsPostgresTargetConnection) {
    this._connection.internalValue = value;
  }
  public resetConnection() {
    this._connection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionInput() {
    return this._connection.internalValue;
  }
}
export interface TransferEndpointSettingsRedshiftSource {
  /**
  * The name of the database to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#database TransferEndpoint#database}
  */
  readonly database?: string;
  /**
  * The hostname of the Redshift cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#host TransferEndpoint#host}
  */
  readonly host?: string;
  /**
  * The password to use for connecting to the database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * The port number of the Redshift cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#port TransferEndpoint#port}
  */
  readonly port?: number;
  /**
  * A list of schemas to include in the transfer.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#schemas TransferEndpoint#schemas}
  */
  readonly schemas?: string[];
  /**
  * The username to use for connecting to the database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#username TransferEndpoint#username}
  */
  readonly username?: string;
}

export function transferEndpointSettingsRedshiftSourceToTerraform(struct?: TransferEndpointSettingsRedshiftSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    database: cdktf.stringToTerraform(struct!.database),
    host: cdktf.stringToTerraform(struct!.host),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    schemas: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.schemas),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function transferEndpointSettingsRedshiftSourceToHclTerraform(struct?: TransferEndpointSettingsRedshiftSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schemas: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.schemas),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsRedshiftSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsRedshiftSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._schemas !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemas = this._schemas;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsRedshiftSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._database = undefined;
      this._host = undefined;
      this._password = undefined;
      this._port = undefined;
      this._schemas = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._database = value.database;
      this._host = value.host;
      this._password = value.password;
      this._port = value.port;
      this._schemas = value.schemas;
      this._username = value.username;
    }
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // schemas - computed: false, optional: true, required: false
  private _schemas?: string[]; 
  public get schemas() {
    return this.getListAttribute('schemas');
  }
  public set schemas(value: string[]) {
    this._schemas = value;
  }
  public resetSchemas() {
    this._schemas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemasInput() {
    return this._schemas;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface TransferEndpointSettingsS3SourceFormatAvro {
}

export function transferEndpointSettingsS3SourceFormatAvroToTerraform(struct?: TransferEndpointSettingsS3SourceFormatAvro | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function transferEndpointSettingsS3SourceFormatAvroToHclTerraform(struct?: TransferEndpointSettingsS3SourceFormatAvro | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class TransferEndpointSettingsS3SourceFormatAvroOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsS3SourceFormatAvro | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsS3SourceFormatAvro | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface TransferEndpointSettingsS3SourceFormatCsv {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#additional_reader_options TransferEndpoint#additional_reader_options}
  */
  readonly additionalReaderOptions?: string;
  /**
  * Advanced options
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#advanced_options TransferEndpoint#advanced_options}
  */
  readonly advancedOptions?: string;
  /**
  * Block size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#block_size TransferEndpoint#block_size}
  */
  readonly blockSize?: number;
  /**
  * Delimiter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#delimiter TransferEndpoint#delimiter}
  */
  readonly delimiter?: string;
  /**
  * Replace double quotes with single quotes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#double_quote TransferEndpoint#double_quote}
  */
  readonly doubleQuote?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#encoding TransferEndpoint#encoding}
  */
  readonly encoding?: string;
  /**
  * Escape character
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#escape_char TransferEndpoint#escape_char}
  */
  readonly escapeChar?: string;
  /**
  * Allow newline characters in values
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#newlines_in_values TransferEndpoint#newlines_in_values}
  */
  readonly newlinesInValues?: boolean | cdktf.IResolvable;
  /**
  * Quote character
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#quote_char TransferEndpoint#quote_char}
  */
  readonly quoteChar?: string;
}

export function transferEndpointSettingsS3SourceFormatCsvToTerraform(struct?: TransferEndpointSettingsS3SourceFormatCsv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_reader_options: cdktf.stringToTerraform(struct!.additionalReaderOptions),
    advanced_options: cdktf.stringToTerraform(struct!.advancedOptions),
    block_size: cdktf.numberToTerraform(struct!.blockSize),
    delimiter: cdktf.stringToTerraform(struct!.delimiter),
    double_quote: cdktf.booleanToTerraform(struct!.doubleQuote),
    encoding: cdktf.stringToTerraform(struct!.encoding),
    escape_char: cdktf.stringToTerraform(struct!.escapeChar),
    newlines_in_values: cdktf.booleanToTerraform(struct!.newlinesInValues),
    quote_char: cdktf.stringToTerraform(struct!.quoteChar),
  }
}


export function transferEndpointSettingsS3SourceFormatCsvToHclTerraform(struct?: TransferEndpointSettingsS3SourceFormatCsv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_reader_options: {
      value: cdktf.stringToHclTerraform(struct!.additionalReaderOptions),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    advanced_options: {
      value: cdktf.stringToHclTerraform(struct!.advancedOptions),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    block_size: {
      value: cdktf.numberToHclTerraform(struct!.blockSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    delimiter: {
      value: cdktf.stringToHclTerraform(struct!.delimiter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    double_quote: {
      value: cdktf.booleanToHclTerraform(struct!.doubleQuote),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    encoding: {
      value: cdktf.stringToHclTerraform(struct!.encoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    escape_char: {
      value: cdktf.stringToHclTerraform(struct!.escapeChar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    newlines_in_values: {
      value: cdktf.booleanToHclTerraform(struct!.newlinesInValues),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    quote_char: {
      value: cdktf.stringToHclTerraform(struct!.quoteChar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsS3SourceFormatCsvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsS3SourceFormatCsv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalReaderOptions !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalReaderOptions = this._additionalReaderOptions;
    }
    if (this._advancedOptions !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedOptions = this._advancedOptions;
    }
    if (this._blockSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.blockSize = this._blockSize;
    }
    if (this._delimiter !== undefined) {
      hasAnyValues = true;
      internalValueResult.delimiter = this._delimiter;
    }
    if (this._doubleQuote !== undefined) {
      hasAnyValues = true;
      internalValueResult.doubleQuote = this._doubleQuote;
    }
    if (this._encoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.encoding = this._encoding;
    }
    if (this._escapeChar !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeChar = this._escapeChar;
    }
    if (this._newlinesInValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.newlinesInValues = this._newlinesInValues;
    }
    if (this._quoteChar !== undefined) {
      hasAnyValues = true;
      internalValueResult.quoteChar = this._quoteChar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsS3SourceFormatCsv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalReaderOptions = undefined;
      this._advancedOptions = undefined;
      this._blockSize = undefined;
      this._delimiter = undefined;
      this._doubleQuote = undefined;
      this._encoding = undefined;
      this._escapeChar = undefined;
      this._newlinesInValues = undefined;
      this._quoteChar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalReaderOptions = value.additionalReaderOptions;
      this._advancedOptions = value.advancedOptions;
      this._blockSize = value.blockSize;
      this._delimiter = value.delimiter;
      this._doubleQuote = value.doubleQuote;
      this._encoding = value.encoding;
      this._escapeChar = value.escapeChar;
      this._newlinesInValues = value.newlinesInValues;
      this._quoteChar = value.quoteChar;
    }
  }

  // additional_reader_options - computed: true, optional: true, required: false
  private _additionalReaderOptions?: string; 
  public get additionalReaderOptions() {
    return this.getStringAttribute('additional_reader_options');
  }
  public set additionalReaderOptions(value: string) {
    this._additionalReaderOptions = value;
  }
  public resetAdditionalReaderOptions() {
    this._additionalReaderOptions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalReaderOptionsInput() {
    return this._additionalReaderOptions;
  }

  // advanced_options - computed: true, optional: true, required: false
  private _advancedOptions?: string; 
  public get advancedOptions() {
    return this.getStringAttribute('advanced_options');
  }
  public set advancedOptions(value: string) {
    this._advancedOptions = value;
  }
  public resetAdvancedOptions() {
    this._advancedOptions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedOptionsInput() {
    return this._advancedOptions;
  }

  // block_size - computed: true, optional: true, required: false
  private _blockSize?: number; 
  public get blockSize() {
    return this.getNumberAttribute('block_size');
  }
  public set blockSize(value: number) {
    this._blockSize = value;
  }
  public resetBlockSize() {
    this._blockSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockSizeInput() {
    return this._blockSize;
  }

  // delimiter - computed: true, optional: true, required: false
  private _delimiter?: string; 
  public get delimiter() {
    return this.getStringAttribute('delimiter');
  }
  public set delimiter(value: string) {
    this._delimiter = value;
  }
  public resetDelimiter() {
    this._delimiter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get delimiterInput() {
    return this._delimiter;
  }

  // double_quote - computed: true, optional: true, required: false
  private _doubleQuote?: boolean | cdktf.IResolvable; 
  public get doubleQuote() {
    return this.getBooleanAttribute('double_quote');
  }
  public set doubleQuote(value: boolean | cdktf.IResolvable) {
    this._doubleQuote = value;
  }
  public resetDoubleQuote() {
    this._doubleQuote = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get doubleQuoteInput() {
    return this._doubleQuote;
  }

  // encoding - computed: true, optional: true, required: false
  private _encoding?: string; 
  public get encoding() {
    return this.getStringAttribute('encoding');
  }
  public set encoding(value: string) {
    this._encoding = value;
  }
  public resetEncoding() {
    this._encoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encodingInput() {
    return this._encoding;
  }

  // escape_char - computed: true, optional: true, required: false
  private _escapeChar?: string; 
  public get escapeChar() {
    return this.getStringAttribute('escape_char');
  }
  public set escapeChar(value: string) {
    this._escapeChar = value;
  }
  public resetEscapeChar() {
    this._escapeChar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharInput() {
    return this._escapeChar;
  }

  // newlines_in_values - computed: true, optional: true, required: false
  private _newlinesInValues?: boolean | cdktf.IResolvable; 
  public get newlinesInValues() {
    return this.getBooleanAttribute('newlines_in_values');
  }
  public set newlinesInValues(value: boolean | cdktf.IResolvable) {
    this._newlinesInValues = value;
  }
  public resetNewlinesInValues() {
    this._newlinesInValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get newlinesInValuesInput() {
    return this._newlinesInValues;
  }

  // quote_char - computed: true, optional: true, required: false
  private _quoteChar?: string; 
  public get quoteChar() {
    return this.getStringAttribute('quote_char');
  }
  public set quoteChar(value: string) {
    this._quoteChar = value;
  }
  public resetQuoteChar() {
    this._quoteChar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get quoteCharInput() {
    return this._quoteChar;
  }
}
export interface TransferEndpointSettingsS3SourceFormatJsonl {
  /**
  * Block size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#block_size TransferEndpoint#block_size}
  */
  readonly blockSize?: number;
  /**
  * Allow newline characters in values
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#newlines_in_values TransferEndpoint#newlines_in_values}
  */
  readonly newlinesInValues?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#unexpected_field_behavior TransferEndpoint#unexpected_field_behavior}
  */
  readonly unexpectedFieldBehavior?: string;
}

export function transferEndpointSettingsS3SourceFormatJsonlToTerraform(struct?: TransferEndpointSettingsS3SourceFormatJsonl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    block_size: cdktf.numberToTerraform(struct!.blockSize),
    newlines_in_values: cdktf.booleanToTerraform(struct!.newlinesInValues),
    unexpected_field_behavior: cdktf.stringToTerraform(struct!.unexpectedFieldBehavior),
  }
}


export function transferEndpointSettingsS3SourceFormatJsonlToHclTerraform(struct?: TransferEndpointSettingsS3SourceFormatJsonl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    block_size: {
      value: cdktf.numberToHclTerraform(struct!.blockSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    newlines_in_values: {
      value: cdktf.booleanToHclTerraform(struct!.newlinesInValues),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    unexpected_field_behavior: {
      value: cdktf.stringToHclTerraform(struct!.unexpectedFieldBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsS3SourceFormatJsonlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsS3SourceFormatJsonl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._blockSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.blockSize = this._blockSize;
    }
    if (this._newlinesInValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.newlinesInValues = this._newlinesInValues;
    }
    if (this._unexpectedFieldBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.unexpectedFieldBehavior = this._unexpectedFieldBehavior;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsS3SourceFormatJsonl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._blockSize = undefined;
      this._newlinesInValues = undefined;
      this._unexpectedFieldBehavior = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._blockSize = value.blockSize;
      this._newlinesInValues = value.newlinesInValues;
      this._unexpectedFieldBehavior = value.unexpectedFieldBehavior;
    }
  }

  // block_size - computed: true, optional: true, required: false
  private _blockSize?: number; 
  public get blockSize() {
    return this.getNumberAttribute('block_size');
  }
  public set blockSize(value: number) {
    this._blockSize = value;
  }
  public resetBlockSize() {
    this._blockSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockSizeInput() {
    return this._blockSize;
  }

  // newlines_in_values - computed: true, optional: true, required: false
  private _newlinesInValues?: boolean | cdktf.IResolvable; 
  public get newlinesInValues() {
    return this.getBooleanAttribute('newlines_in_values');
  }
  public set newlinesInValues(value: boolean | cdktf.IResolvable) {
    this._newlinesInValues = value;
  }
  public resetNewlinesInValues() {
    this._newlinesInValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get newlinesInValuesInput() {
    return this._newlinesInValues;
  }

  // unexpected_field_behavior - computed: true, optional: true, required: false
  private _unexpectedFieldBehavior?: string; 
  public get unexpectedFieldBehavior() {
    return this.getStringAttribute('unexpected_field_behavior');
  }
  public set unexpectedFieldBehavior(value: string) {
    this._unexpectedFieldBehavior = value;
  }
  public resetUnexpectedFieldBehavior() {
    this._unexpectedFieldBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unexpectedFieldBehaviorInput() {
    return this._unexpectedFieldBehavior;
  }
}
export interface TransferEndpointSettingsS3SourceFormatParquet {
  /**
  * Batch size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#batch_size TransferEndpoint#batch_size}
  */
  readonly batchSize?: number;
  /**
  * Buffer size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#buffer_size TransferEndpoint#buffer_size}
  */
  readonly bufferSize?: number;
  /**
  * List of columns
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#columns TransferEndpoint#columns}
  */
  readonly columns?: string[];
}

export function transferEndpointSettingsS3SourceFormatParquetToTerraform(struct?: TransferEndpointSettingsS3SourceFormatParquet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    batch_size: cdktf.numberToTerraform(struct!.batchSize),
    buffer_size: cdktf.numberToTerraform(struct!.bufferSize),
    columns: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.columns),
  }
}


export function transferEndpointSettingsS3SourceFormatParquetToHclTerraform(struct?: TransferEndpointSettingsS3SourceFormatParquet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    batch_size: {
      value: cdktf.numberToHclTerraform(struct!.batchSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.bufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    columns: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.columns),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsS3SourceFormatParquetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsS3SourceFormatParquet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._batchSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.batchSize = this._batchSize;
    }
    if (this._bufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.bufferSize = this._bufferSize;
    }
    if (this._columns !== undefined) {
      hasAnyValues = true;
      internalValueResult.columns = this._columns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsS3SourceFormatParquet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._batchSize = undefined;
      this._bufferSize = undefined;
      this._columns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._batchSize = value.batchSize;
      this._bufferSize = value.bufferSize;
      this._columns = value.columns;
    }
  }

  // batch_size - computed: true, optional: true, required: false
  private _batchSize?: number; 
  public get batchSize() {
    return this.getNumberAttribute('batch_size');
  }
  public set batchSize(value: number) {
    this._batchSize = value;
  }
  public resetBatchSize() {
    this._batchSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get batchSizeInput() {
    return this._batchSize;
  }

  // buffer_size - computed: true, optional: true, required: false
  private _bufferSize?: number; 
  public get bufferSize() {
    return this.getNumberAttribute('buffer_size');
  }
  public set bufferSize(value: number) {
    this._bufferSize = value;
  }
  public resetBufferSize() {
    this._bufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferSizeInput() {
    return this._bufferSize;
  }

  // columns - computed: false, optional: true, required: false
  private _columns?: string[]; 
  public get columns() {
    return this.getListAttribute('columns');
  }
  public set columns(value: string[]) {
    this._columns = value;
  }
  public resetColumns() {
    this._columns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get columnsInput() {
    return this._columns;
  }
}
export interface TransferEndpointSettingsS3SourceFormat {
  /**
  * avro block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#avro TransferEndpoint#avro}
  */
  readonly avro?: TransferEndpointSettingsS3SourceFormatAvro;
  /**
  * csv block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#csv TransferEndpoint#csv}
  */
  readonly csv?: TransferEndpointSettingsS3SourceFormatCsv;
  /**
  * jsonl block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#jsonl TransferEndpoint#jsonl}
  */
  readonly jsonl?: TransferEndpointSettingsS3SourceFormatJsonl;
  /**
  * parquet block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#parquet TransferEndpoint#parquet}
  */
  readonly parquet?: TransferEndpointSettingsS3SourceFormatParquet;
}

export function transferEndpointSettingsS3SourceFormatToTerraform(struct?: TransferEndpointSettingsS3SourceFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    avro: transferEndpointSettingsS3SourceFormatAvroToTerraform(struct!.avro),
    csv: transferEndpointSettingsS3SourceFormatCsvToTerraform(struct!.csv),
    jsonl: transferEndpointSettingsS3SourceFormatJsonlToTerraform(struct!.jsonl),
    parquet: transferEndpointSettingsS3SourceFormatParquetToTerraform(struct!.parquet),
  }
}


export function transferEndpointSettingsS3SourceFormatToHclTerraform(struct?: TransferEndpointSettingsS3SourceFormat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    avro: {
      value: transferEndpointSettingsS3SourceFormatAvroToHclTerraform(struct!.avro),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsS3SourceFormatAvro",
    },
    csv: {
      value: transferEndpointSettingsS3SourceFormatCsvToHclTerraform(struct!.csv),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsS3SourceFormatCsv",
    },
    jsonl: {
      value: transferEndpointSettingsS3SourceFormatJsonlToHclTerraform(struct!.jsonl),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsS3SourceFormatJsonl",
    },
    parquet: {
      value: transferEndpointSettingsS3SourceFormatParquetToHclTerraform(struct!.parquet),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsS3SourceFormatParquet",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsS3SourceFormatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsS3SourceFormat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._avro?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.avro = this._avro?.internalValue;
    }
    if (this._csv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.csv = this._csv?.internalValue;
    }
    if (this._jsonl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonl = this._jsonl?.internalValue;
    }
    if (this._parquet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquet = this._parquet?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsS3SourceFormat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._avro.internalValue = undefined;
      this._csv.internalValue = undefined;
      this._jsonl.internalValue = undefined;
      this._parquet.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._avro.internalValue = value.avro;
      this._csv.internalValue = value.csv;
      this._jsonl.internalValue = value.jsonl;
      this._parquet.internalValue = value.parquet;
    }
  }

  // avro - computed: false, optional: true, required: true
  private _avro = new TransferEndpointSettingsS3SourceFormatAvroOutputReference(this, "avro");
  public get avro() {
    return this._avro;
  }
  public putAvro(value: TransferEndpointSettingsS3SourceFormatAvro) {
    this._avro.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get avroInput() {
    return this._avro.internalValue;
  }

  // csv - computed: false, optional: true, required: false
  private _csv = new TransferEndpointSettingsS3SourceFormatCsvOutputReference(this, "csv");
  public get csv() {
    return this._csv;
  }
  public putCsv(value: TransferEndpointSettingsS3SourceFormatCsv) {
    this._csv.internalValue = value;
  }
  public resetCsv() {
    this._csv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get csvInput() {
    return this._csv.internalValue;
  }

  // jsonl - computed: false, optional: true, required: false
  private _jsonl = new TransferEndpointSettingsS3SourceFormatJsonlOutputReference(this, "jsonl");
  public get jsonl() {
    return this._jsonl;
  }
  public putJsonl(value: TransferEndpointSettingsS3SourceFormatJsonl) {
    this._jsonl.internalValue = value;
  }
  public resetJsonl() {
    this._jsonl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonlInput() {
    return this._jsonl.internalValue;
  }

  // parquet - computed: false, optional: true, required: false
  private _parquet = new TransferEndpointSettingsS3SourceFormatParquetOutputReference(this, "parquet");
  public get parquet() {
    return this._parquet;
  }
  public putParquet(value: TransferEndpointSettingsS3SourceFormatParquet) {
    this._parquet.internalValue = value;
  }
  public resetParquet() {
    this._parquet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetInput() {
    return this._parquet.internalValue;
  }
}
export interface TransferEndpointSettingsS3SourceProvider {
  /**
  * Access key ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#aws_access_key_id TransferEndpoint#aws_access_key_id}
  */
  readonly awsAccessKeyId?: string;
  /**
  * Secret access key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#aws_secret_access_key TransferEndpoint#aws_secret_access_key}
  */
  readonly awsSecretAccessKey?: string;
  /**
  * Bucket
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#bucket TransferEndpoint#bucket}
  */
  readonly bucket?: string;
  /**
  * Endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#endpoint TransferEndpoint#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Path prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#path_prefix TransferEndpoint#path_prefix}
  */
  readonly pathPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#use_ssl TransferEndpoint#use_ssl}
  */
  readonly useSsl?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#verify_ssl_cert TransferEndpoint#verify_ssl_cert}
  */
  readonly verifySslCert?: boolean | cdktf.IResolvable;
}

export function transferEndpointSettingsS3SourceProviderToTerraform(struct?: TransferEndpointSettingsS3SourceProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws_access_key_id: cdktf.stringToTerraform(struct!.awsAccessKeyId),
    aws_secret_access_key: cdktf.stringToTerraform(struct!.awsSecretAccessKey),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    path_prefix: cdktf.stringToTerraform(struct!.pathPrefix),
    use_ssl: cdktf.booleanToTerraform(struct!.useSsl),
    verify_ssl_cert: cdktf.booleanToTerraform(struct!.verifySslCert),
  }
}


export function transferEndpointSettingsS3SourceProviderToHclTerraform(struct?: TransferEndpointSettingsS3SourceProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws_access_key_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccessKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path_prefix: {
      value: cdktf.stringToHclTerraform(struct!.pathPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_ssl: {
      value: cdktf.booleanToHclTerraform(struct!.useSsl),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    verify_ssl_cert: {
      value: cdktf.booleanToHclTerraform(struct!.verifySslCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsS3SourceProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsS3SourceProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._awsAccessKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccessKeyId = this._awsAccessKeyId;
    }
    if (this._awsSecretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretAccessKey = this._awsSecretAccessKey;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._pathPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathPrefix = this._pathPrefix;
    }
    if (this._useSsl !== undefined) {
      hasAnyValues = true;
      internalValueResult.useSsl = this._useSsl;
    }
    if (this._verifySslCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifySslCert = this._verifySslCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsS3SourceProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._awsAccessKeyId = undefined;
      this._awsSecretAccessKey = undefined;
      this._bucket = undefined;
      this._endpoint = undefined;
      this._pathPrefix = undefined;
      this._useSsl = undefined;
      this._verifySslCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._awsAccessKeyId = value.awsAccessKeyId;
      this._awsSecretAccessKey = value.awsSecretAccessKey;
      this._bucket = value.bucket;
      this._endpoint = value.endpoint;
      this._pathPrefix = value.pathPrefix;
      this._useSsl = value.useSsl;
      this._verifySslCert = value.verifySslCert;
    }
  }

  // aws_access_key_id - computed: true, optional: true, required: false
  private _awsAccessKeyId?: string; 
  public get awsAccessKeyId() {
    return this.getStringAttribute('aws_access_key_id');
  }
  public set awsAccessKeyId(value: string) {
    this._awsAccessKeyId = value;
  }
  public resetAwsAccessKeyId() {
    this._awsAccessKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccessKeyIdInput() {
    return this._awsAccessKeyId;
  }

  // aws_secret_access_key - computed: true, optional: true, required: false
  private _awsSecretAccessKey?: string; 
  public get awsSecretAccessKey() {
    return this.getStringAttribute('aws_secret_access_key');
  }
  public set awsSecretAccessKey(value: string) {
    this._awsSecretAccessKey = value;
  }
  public resetAwsSecretAccessKey() {
    this._awsSecretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretAccessKeyInput() {
    return this._awsSecretAccessKey;
  }

  // bucket - computed: true, optional: true, required: false
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  public resetBucket() {
    this._bucket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // path_prefix - computed: true, optional: true, required: false
  private _pathPrefix?: string; 
  public get pathPrefix() {
    return this.getStringAttribute('path_prefix');
  }
  public set pathPrefix(value: string) {
    this._pathPrefix = value;
  }
  public resetPathPrefix() {
    this._pathPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathPrefixInput() {
    return this._pathPrefix;
  }

  // use_ssl - computed: true, optional: true, required: false
  private _useSsl?: boolean | cdktf.IResolvable; 
  public get useSsl() {
    return this.getBooleanAttribute('use_ssl');
  }
  public set useSsl(value: boolean | cdktf.IResolvable) {
    this._useSsl = value;
  }
  public resetUseSsl() {
    this._useSsl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useSslInput() {
    return this._useSsl;
  }

  // verify_ssl_cert - computed: true, optional: true, required: false
  private _verifySslCert?: boolean | cdktf.IResolvable; 
  public get verifySslCert() {
    return this.getBooleanAttribute('verify_ssl_cert');
  }
  public set verifySslCert(value: boolean | cdktf.IResolvable) {
    this._verifySslCert = value;
  }
  public resetVerifySslCert() {
    this._verifySslCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifySslCertInput() {
    return this._verifySslCert;
  }
}
export interface TransferEndpointSettingsS3Source {
  /**
  * Dataset
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#dataset TransferEndpoint#dataset}
  */
  readonly dataset?: string;
  /**
  * Path pattern
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#path_pattern TransferEndpoint#path_pattern}
  */
  readonly pathPattern?: string;
  /**
  * Schema
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#schema TransferEndpoint#schema}
  */
  readonly schema?: string;
  /**
  * format block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#format TransferEndpoint#format}
  */
  readonly format?: TransferEndpointSettingsS3SourceFormat;
  /**
  * provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#provider TransferEndpoint#provider}
  */
  readonly provider?: TransferEndpointSettingsS3SourceProvider;
}

export function transferEndpointSettingsS3SourceToTerraform(struct?: TransferEndpointSettingsS3Source | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dataset: cdktf.stringToTerraform(struct!.dataset),
    path_pattern: cdktf.stringToTerraform(struct!.pathPattern),
    schema: cdktf.stringToTerraform(struct!.schema),
    format: transferEndpointSettingsS3SourceFormatToTerraform(struct!.format),
    provider: transferEndpointSettingsS3SourceProviderToTerraform(struct!.provider),
  }
}


export function transferEndpointSettingsS3SourceToHclTerraform(struct?: TransferEndpointSettingsS3Source | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dataset: {
      value: cdktf.stringToHclTerraform(struct!.dataset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path_pattern: {
      value: cdktf.stringToHclTerraform(struct!.pathPattern),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    schema: {
      value: cdktf.stringToHclTerraform(struct!.schema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: transferEndpointSettingsS3SourceFormatToHclTerraform(struct!.format),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsS3SourceFormat",
    },
    provider: {
      value: transferEndpointSettingsS3SourceProviderToHclTerraform(struct!.provider),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsS3SourceProvider",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsS3SourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsS3Source | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dataset !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataset = this._dataset;
    }
    if (this._pathPattern !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathPattern = this._pathPattern;
    }
    if (this._schema !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema;
    }
    if (this._format?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format?.internalValue;
    }
    if (this._provider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.provider = this._provider?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsS3Source | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dataset = undefined;
      this._pathPattern = undefined;
      this._schema = undefined;
      this._format.internalValue = undefined;
      this._provider.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dataset = value.dataset;
      this._pathPattern = value.pathPattern;
      this._schema = value.schema;
      this._format.internalValue = value.format;
      this._provider.internalValue = value.provider;
    }
  }

  // dataset - computed: true, optional: true, required: false
  private _dataset?: string; 
  public get dataset() {
    return this.getStringAttribute('dataset');
  }
  public set dataset(value: string) {
    this._dataset = value;
  }
  public resetDataset() {
    this._dataset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datasetInput() {
    return this._dataset;
  }

  // path_pattern - computed: true, optional: true, required: false
  private _pathPattern?: string; 
  public get pathPattern() {
    return this.getStringAttribute('path_pattern');
  }
  public set pathPattern(value: string) {
    this._pathPattern = value;
  }
  public resetPathPattern() {
    this._pathPattern = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathPatternInput() {
    return this._pathPattern;
  }

  // schema - computed: true, optional: true, required: false
  private _schema?: string; 
  public get schema() {
    return this.getStringAttribute('schema');
  }
  public set schema(value: string) {
    this._schema = value;
  }
  public resetSchema() {
    this._schema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema;
  }

  // format - computed: false, optional: true, required: false
  private _format = new TransferEndpointSettingsS3SourceFormatOutputReference(this, "format");
  public get format() {
    return this._format;
  }
  public putFormat(value: TransferEndpointSettingsS3SourceFormat) {
    this._format.internalValue = value;
  }
  public resetFormat() {
    this._format.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format.internalValue;
  }

  // provider - computed: false, optional: true, required: false
  private _provider = new TransferEndpointSettingsS3SourceProviderOutputReference(this, "provider");
  public get provider() {
    return this._provider;
  }
  public putProvider(value: TransferEndpointSettingsS3SourceProvider) {
    this._provider.internalValue = value;
  }
  public resetProvider() {
    this._provider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerInput() {
    return this._provider.internalValue;
  }
}
export interface TransferEndpointSettingsSnowflakeSourceCredentialsBasicAuth {
  /**
  * Password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#password TransferEndpoint#password}
  */
  readonly password?: string;
  /**
  * Username
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#username TransferEndpoint#username}
  */
  readonly username?: string;
}

export function transferEndpointSettingsSnowflakeSourceCredentialsBasicAuthToTerraform(struct?: TransferEndpointSettingsSnowflakeSourceCredentialsBasicAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function transferEndpointSettingsSnowflakeSourceCredentialsBasicAuthToHclTerraform(struct?: TransferEndpointSettingsSnowflakeSourceCredentialsBasicAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsSnowflakeSourceCredentialsBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsSnowflakeSourceCredentialsBasicAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsSnowflakeSourceCredentialsBasicAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._password = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface TransferEndpointSettingsSnowflakeSourceCredentialsOauth {
  /**
  * Access token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#access_token TransferEndpoint#access_token}
  */
  readonly accessToken?: string;
  /**
  * Client ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#client_id TransferEndpoint#client_id}
  */
  readonly clientId?: string;
  /**
  * Client secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#client_secret TransferEndpoint#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Refresh token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#refresh_token TransferEndpoint#refresh_token}
  */
  readonly refreshToken?: string;
}

export function transferEndpointSettingsSnowflakeSourceCredentialsOauthToTerraform(struct?: TransferEndpointSettingsSnowflakeSourceCredentialsOauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: cdktf.stringToTerraform(struct!.accessToken),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    refresh_token: cdktf.stringToTerraform(struct!.refreshToken),
  }
}


export function transferEndpointSettingsSnowflakeSourceCredentialsOauthToHclTerraform(struct?: TransferEndpointSettingsSnowflakeSourceCredentialsOauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: cdktf.stringToHclTerraform(struct!.accessToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    refresh_token: {
      value: cdktf.stringToHclTerraform(struct!.refreshToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsSnowflakeSourceCredentialsOauthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsSnowflakeSourceCredentialsOauth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._refreshToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.refreshToken = this._refreshToken;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsSnowflakeSourceCredentialsOauth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken = undefined;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._refreshToken = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken = value.accessToken;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._refreshToken = value.refreshToken;
    }
  }

  // access_token - computed: false, optional: true, required: false
  private _accessToken?: string; 
  public get accessToken() {
    return this.getStringAttribute('access_token');
  }
  public set accessToken(value: string) {
    this._accessToken = value;
  }
  public resetAccessToken() {
    this._accessToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken;
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // refresh_token - computed: false, optional: true, required: false
  private _refreshToken?: string; 
  public get refreshToken() {
    return this.getStringAttribute('refresh_token');
  }
  public set refreshToken(value: string) {
    this._refreshToken = value;
  }
  public resetRefreshToken() {
    this._refreshToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refreshTokenInput() {
    return this._refreshToken;
  }
}
export interface TransferEndpointSettingsSnowflakeSourceCredentials {
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#basic_auth TransferEndpoint#basic_auth}
  */
  readonly basicAuth?: TransferEndpointSettingsSnowflakeSourceCredentialsBasicAuth;
  /**
  * oauth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#oauth TransferEndpoint#oauth}
  */
  readonly oauth?: TransferEndpointSettingsSnowflakeSourceCredentialsOauth;
}

export function transferEndpointSettingsSnowflakeSourceCredentialsToTerraform(struct?: TransferEndpointSettingsSnowflakeSourceCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    basic_auth: transferEndpointSettingsSnowflakeSourceCredentialsBasicAuthToTerraform(struct!.basicAuth),
    oauth: transferEndpointSettingsSnowflakeSourceCredentialsOauthToTerraform(struct!.oauth),
  }
}


export function transferEndpointSettingsSnowflakeSourceCredentialsToHclTerraform(struct?: TransferEndpointSettingsSnowflakeSourceCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    basic_auth: {
      value: transferEndpointSettingsSnowflakeSourceCredentialsBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsSnowflakeSourceCredentialsBasicAuth",
    },
    oauth: {
      value: transferEndpointSettingsSnowflakeSourceCredentialsOauthToHclTerraform(struct!.oauth),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsSnowflakeSourceCredentialsOauth",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsSnowflakeSourceCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsSnowflakeSourceCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    if (this._oauth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth = this._oauth?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsSnowflakeSourceCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._basicAuth.internalValue = undefined;
      this._oauth.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._basicAuth.internalValue = value.basicAuth;
      this._oauth.internalValue = value.oauth;
    }
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new TransferEndpointSettingsSnowflakeSourceCredentialsBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: TransferEndpointSettingsSnowflakeSourceCredentialsBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }

  // oauth - computed: false, optional: true, required: false
  private _oauth = new TransferEndpointSettingsSnowflakeSourceCredentialsOauthOutputReference(this, "oauth");
  public get oauth() {
    return this._oauth;
  }
  public putOauth(value: TransferEndpointSettingsSnowflakeSourceCredentialsOauth) {
    this._oauth.internalValue = value;
  }
  public resetOauth() {
    this._oauth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthInput() {
    return this._oauth.internalValue;
  }
}
export interface TransferEndpointSettingsSnowflakeSource {
  /**
  * Database
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#database TransferEndpoint#database}
  */
  readonly database?: string;
  /**
  * Host
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#host TransferEndpoint#host}
  */
  readonly host?: string;
  /**
  * JDBC URL parameters
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#jdbc_url_params TransferEndpoint#jdbc_url_params}
  */
  readonly jdbcUrlParams?: string;
  /**
  * Role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#role TransferEndpoint#role}
  */
  readonly role?: string;
  /**
  * Schema
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#schema TransferEndpoint#schema}
  */
  readonly schema?: string;
  /**
  * Warehouse
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#warehouse TransferEndpoint#warehouse}
  */
  readonly warehouse?: string;
  /**
  * credentials block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#credentials TransferEndpoint#credentials}
  */
  readonly credentials?: TransferEndpointSettingsSnowflakeSourceCredentials;
}

export function transferEndpointSettingsSnowflakeSourceToTerraform(struct?: TransferEndpointSettingsSnowflakeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    database: cdktf.stringToTerraform(struct!.database),
    host: cdktf.stringToTerraform(struct!.host),
    jdbc_url_params: cdktf.stringToTerraform(struct!.jdbcUrlParams),
    role: cdktf.stringToTerraform(struct!.role),
    schema: cdktf.stringToTerraform(struct!.schema),
    warehouse: cdktf.stringToTerraform(struct!.warehouse),
    credentials: transferEndpointSettingsSnowflakeSourceCredentialsToTerraform(struct!.credentials),
  }
}


export function transferEndpointSettingsSnowflakeSourceToHclTerraform(struct?: TransferEndpointSettingsSnowflakeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    jdbc_url_params: {
      value: cdktf.stringToHclTerraform(struct!.jdbcUrlParams),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    schema: {
      value: cdktf.stringToHclTerraform(struct!.schema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    warehouse: {
      value: cdktf.stringToHclTerraform(struct!.warehouse),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials: {
      value: transferEndpointSettingsSnowflakeSourceCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsSnowflakeSourceCredentials",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsSnowflakeSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettingsSnowflakeSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._jdbcUrlParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.jdbcUrlParams = this._jdbcUrlParams;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._schema !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema;
    }
    if (this._warehouse !== undefined) {
      hasAnyValues = true;
      internalValueResult.warehouse = this._warehouse;
    }
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettingsSnowflakeSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._database = undefined;
      this._host = undefined;
      this._jdbcUrlParams = undefined;
      this._role = undefined;
      this._schema = undefined;
      this._warehouse = undefined;
      this._credentials.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._database = value.database;
      this._host = value.host;
      this._jdbcUrlParams = value.jdbcUrlParams;
      this._role = value.role;
      this._schema = value.schema;
      this._warehouse = value.warehouse;
      this._credentials.internalValue = value.credentials;
    }
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // jdbc_url_params - computed: false, optional: true, required: false
  private _jdbcUrlParams?: string; 
  public get jdbcUrlParams() {
    return this.getStringAttribute('jdbc_url_params');
  }
  public set jdbcUrlParams(value: string) {
    this._jdbcUrlParams = value;
  }
  public resetJdbcUrlParams() {
    this._jdbcUrlParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jdbcUrlParamsInput() {
    return this._jdbcUrlParams;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // schema - computed: false, optional: true, required: false
  private _schema?: string; 
  public get schema() {
    return this.getStringAttribute('schema');
  }
  public set schema(value: string) {
    this._schema = value;
  }
  public resetSchema() {
    this._schema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema;
  }

  // warehouse - computed: false, optional: true, required: false
  private _warehouse?: string; 
  public get warehouse() {
    return this.getStringAttribute('warehouse');
  }
  public set warehouse(value: string) {
    this._warehouse = value;
  }
  public resetWarehouse() {
    this._warehouse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get warehouseInput() {
    return this._warehouse;
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new TransferEndpointSettingsSnowflakeSourceCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: TransferEndpointSettingsSnowflakeSourceCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }
}
export interface TransferEndpointSettings {
  /**
  * aws_cloudtrail_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#aws_cloudtrail_source TransferEndpoint#aws_cloudtrail_source}
  */
  readonly awsCloudtrailSource?: TransferEndpointSettingsAwsCloudtrailSource;
  /**
  * bigquery_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#bigquery_source TransferEndpoint#bigquery_source}
  */
  readonly bigquerySource?: TransferEndpointSettingsBigquerySource;
  /**
  * bigquery_target block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#bigquery_target TransferEndpoint#bigquery_target}
  */
  readonly bigqueryTarget?: TransferEndpointSettingsBigqueryTarget;
  /**
  * clickhouse_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#clickhouse_source TransferEndpoint#clickhouse_source}
  */
  readonly clickhouseSource?: TransferEndpointSettingsClickhouseSource;
  /**
  * clickhouse_target block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#clickhouse_target TransferEndpoint#clickhouse_target}
  */
  readonly clickhouseTarget?: TransferEndpointSettingsClickhouseTarget;
  /**
  * facebookmarketing_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#facebookmarketing_source TransferEndpoint#facebookmarketing_source}
  */
  readonly facebookmarketingSource?: TransferEndpointSettingsFacebookmarketingSource;
  /**
  * googleads_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#googleads_source TransferEndpoint#googleads_source}
  */
  readonly googleadsSource?: TransferEndpointSettingsGoogleadsSource;
  /**
  * hubspot_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#hubspot_source TransferEndpoint#hubspot_source}
  */
  readonly hubspotSource?: TransferEndpointSettingsHubspotSource;
  /**
  * instagram_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#instagram_source TransferEndpoint#instagram_source}
  */
  readonly instagramSource?: TransferEndpointSettingsInstagramSource;
  /**
  * jira_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#jira_source TransferEndpoint#jira_source}
  */
  readonly jiraSource?: TransferEndpointSettingsJiraSource;
  /**
  * kafka_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#kafka_source TransferEndpoint#kafka_source}
  */
  readonly kafkaSource?: TransferEndpointSettingsKafkaSource;
  /**
  * kafka_target block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#kafka_target TransferEndpoint#kafka_target}
  */
  readonly kafkaTarget?: TransferEndpointSettingsKafkaTarget;
  /**
  * kinesis_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#kinesis_source TransferEndpoint#kinesis_source}
  */
  readonly kinesisSource?: TransferEndpointSettingsKinesisSource;
  /**
  * linkedinads_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#linkedinads_source TransferEndpoint#linkedinads_source}
  */
  readonly linkedinadsSource?: TransferEndpointSettingsLinkedinadsSource;
  /**
  * metrica_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#metrica_source TransferEndpoint#metrica_source}
  */
  readonly metricaSource?: TransferEndpointSettingsMetricaSource;
  /**
  * mongo_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#mongo_source TransferEndpoint#mongo_source}
  */
  readonly mongoSource?: TransferEndpointSettingsMongoSource;
  /**
  * mongo_target block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#mongo_target TransferEndpoint#mongo_target}
  */
  readonly mongoTarget?: TransferEndpointSettingsMongoTarget;
  /**
  * mssql_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#mssql_source TransferEndpoint#mssql_source}
  */
  readonly mssqlSource?: TransferEndpointSettingsMssqlSource;
  /**
  * mysql_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#mysql_source TransferEndpoint#mysql_source}
  */
  readonly mysqlSource?: TransferEndpointSettingsMysqlSource;
  /**
  * mysql_target block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#mysql_target TransferEndpoint#mysql_target}
  */
  readonly mysqlTarget?: TransferEndpointSettingsMysqlTarget;
  /**
  * object_storage_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#object_storage_source TransferEndpoint#object_storage_source}
  */
  readonly objectStorageSource?: TransferEndpointSettingsObjectStorageSource;
  /**
  * object_storage_target block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#object_storage_target TransferEndpoint#object_storage_target}
  */
  readonly objectStorageTarget?: TransferEndpointSettingsObjectStorageTarget;
  /**
  * postgres_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#postgres_source TransferEndpoint#postgres_source}
  */
  readonly postgresSource?: TransferEndpointSettingsPostgresSource;
  /**
  * postgres_target block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#postgres_target TransferEndpoint#postgres_target}
  */
  readonly postgresTarget?: TransferEndpointSettingsPostgresTarget;
  /**
  * redshift_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#redshift_source TransferEndpoint#redshift_source}
  */
  readonly redshiftSource?: TransferEndpointSettingsRedshiftSource;
  /**
  * s3_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#s3_source TransferEndpoint#s3_source}
  */
  readonly s3Source?: TransferEndpointSettingsS3Source;
  /**
  * snowflake_source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#snowflake_source TransferEndpoint#snowflake_source}
  */
  readonly snowflakeSource?: TransferEndpointSettingsSnowflakeSource;
}

export function transferEndpointSettingsToTerraform(struct?: TransferEndpointSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws_cloudtrail_source: transferEndpointSettingsAwsCloudtrailSourceToTerraform(struct!.awsCloudtrailSource),
    bigquery_source: transferEndpointSettingsBigquerySourceToTerraform(struct!.bigquerySource),
    bigquery_target: transferEndpointSettingsBigqueryTargetToTerraform(struct!.bigqueryTarget),
    clickhouse_source: transferEndpointSettingsClickhouseSourceToTerraform(struct!.clickhouseSource),
    clickhouse_target: transferEndpointSettingsClickhouseTargetToTerraform(struct!.clickhouseTarget),
    facebookmarketing_source: transferEndpointSettingsFacebookmarketingSourceToTerraform(struct!.facebookmarketingSource),
    googleads_source: transferEndpointSettingsGoogleadsSourceToTerraform(struct!.googleadsSource),
    hubspot_source: transferEndpointSettingsHubspotSourceToTerraform(struct!.hubspotSource),
    instagram_source: transferEndpointSettingsInstagramSourceToTerraform(struct!.instagramSource),
    jira_source: transferEndpointSettingsJiraSourceToTerraform(struct!.jiraSource),
    kafka_source: transferEndpointSettingsKafkaSourceToTerraform(struct!.kafkaSource),
    kafka_target: transferEndpointSettingsKafkaTargetToTerraform(struct!.kafkaTarget),
    kinesis_source: transferEndpointSettingsKinesisSourceToTerraform(struct!.kinesisSource),
    linkedinads_source: transferEndpointSettingsLinkedinadsSourceToTerraform(struct!.linkedinadsSource),
    metrica_source: transferEndpointSettingsMetricaSourceToTerraform(struct!.metricaSource),
    mongo_source: transferEndpointSettingsMongoSourceToTerraform(struct!.mongoSource),
    mongo_target: transferEndpointSettingsMongoTargetToTerraform(struct!.mongoTarget),
    mssql_source: transferEndpointSettingsMssqlSourceToTerraform(struct!.mssqlSource),
    mysql_source: transferEndpointSettingsMysqlSourceToTerraform(struct!.mysqlSource),
    mysql_target: transferEndpointSettingsMysqlTargetToTerraform(struct!.mysqlTarget),
    object_storage_source: transferEndpointSettingsObjectStorageSourceToTerraform(struct!.objectStorageSource),
    object_storage_target: transferEndpointSettingsObjectStorageTargetToTerraform(struct!.objectStorageTarget),
    postgres_source: transferEndpointSettingsPostgresSourceToTerraform(struct!.postgresSource),
    postgres_target: transferEndpointSettingsPostgresTargetToTerraform(struct!.postgresTarget),
    redshift_source: transferEndpointSettingsRedshiftSourceToTerraform(struct!.redshiftSource),
    s3_source: transferEndpointSettingsS3SourceToTerraform(struct!.s3Source),
    snowflake_source: transferEndpointSettingsSnowflakeSourceToTerraform(struct!.snowflakeSource),
  }
}


export function transferEndpointSettingsToHclTerraform(struct?: TransferEndpointSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws_cloudtrail_source: {
      value: transferEndpointSettingsAwsCloudtrailSourceToHclTerraform(struct!.awsCloudtrailSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsAwsCloudtrailSource",
    },
    bigquery_source: {
      value: transferEndpointSettingsBigquerySourceToHclTerraform(struct!.bigquerySource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsBigquerySource",
    },
    bigquery_target: {
      value: transferEndpointSettingsBigqueryTargetToHclTerraform(struct!.bigqueryTarget),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsBigqueryTarget",
    },
    clickhouse_source: {
      value: transferEndpointSettingsClickhouseSourceToHclTerraform(struct!.clickhouseSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsClickhouseSource",
    },
    clickhouse_target: {
      value: transferEndpointSettingsClickhouseTargetToHclTerraform(struct!.clickhouseTarget),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsClickhouseTarget",
    },
    facebookmarketing_source: {
      value: transferEndpointSettingsFacebookmarketingSourceToHclTerraform(struct!.facebookmarketingSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsFacebookmarketingSource",
    },
    googleads_source: {
      value: transferEndpointSettingsGoogleadsSourceToHclTerraform(struct!.googleadsSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsGoogleadsSource",
    },
    hubspot_source: {
      value: transferEndpointSettingsHubspotSourceToHclTerraform(struct!.hubspotSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsHubspotSource",
    },
    instagram_source: {
      value: transferEndpointSettingsInstagramSourceToHclTerraform(struct!.instagramSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsInstagramSource",
    },
    jira_source: {
      value: transferEndpointSettingsJiraSourceToHclTerraform(struct!.jiraSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsJiraSource",
    },
    kafka_source: {
      value: transferEndpointSettingsKafkaSourceToHclTerraform(struct!.kafkaSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaSource",
    },
    kafka_target: {
      value: transferEndpointSettingsKafkaTargetToHclTerraform(struct!.kafkaTarget),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKafkaTarget",
    },
    kinesis_source: {
      value: transferEndpointSettingsKinesisSourceToHclTerraform(struct!.kinesisSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsKinesisSource",
    },
    linkedinads_source: {
      value: transferEndpointSettingsLinkedinadsSourceToHclTerraform(struct!.linkedinadsSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsLinkedinadsSource",
    },
    metrica_source: {
      value: transferEndpointSettingsMetricaSourceToHclTerraform(struct!.metricaSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMetricaSource",
    },
    mongo_source: {
      value: transferEndpointSettingsMongoSourceToHclTerraform(struct!.mongoSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMongoSource",
    },
    mongo_target: {
      value: transferEndpointSettingsMongoTargetToHclTerraform(struct!.mongoTarget),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMongoTarget",
    },
    mssql_source: {
      value: transferEndpointSettingsMssqlSourceToHclTerraform(struct!.mssqlSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMssqlSource",
    },
    mysql_source: {
      value: transferEndpointSettingsMysqlSourceToHclTerraform(struct!.mysqlSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMysqlSource",
    },
    mysql_target: {
      value: transferEndpointSettingsMysqlTargetToHclTerraform(struct!.mysqlTarget),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsMysqlTarget",
    },
    object_storage_source: {
      value: transferEndpointSettingsObjectStorageSourceToHclTerraform(struct!.objectStorageSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageSource",
    },
    object_storage_target: {
      value: transferEndpointSettingsObjectStorageTargetToHclTerraform(struct!.objectStorageTarget),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsObjectStorageTarget",
    },
    postgres_source: {
      value: transferEndpointSettingsPostgresSourceToHclTerraform(struct!.postgresSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsPostgresSource",
    },
    postgres_target: {
      value: transferEndpointSettingsPostgresTargetToHclTerraform(struct!.postgresTarget),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsPostgresTarget",
    },
    redshift_source: {
      value: transferEndpointSettingsRedshiftSourceToHclTerraform(struct!.redshiftSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsRedshiftSource",
    },
    s3_source: {
      value: transferEndpointSettingsS3SourceToHclTerraform(struct!.s3Source),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsS3Source",
    },
    snowflake_source: {
      value: transferEndpointSettingsSnowflakeSourceToHclTerraform(struct!.snowflakeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "TransferEndpointSettingsSnowflakeSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class TransferEndpointSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): TransferEndpointSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._awsCloudtrailSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsCloudtrailSource = this._awsCloudtrailSource?.internalValue;
    }
    if (this._bigquerySource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bigquerySource = this._bigquerySource?.internalValue;
    }
    if (this._bigqueryTarget?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bigqueryTarget = this._bigqueryTarget?.internalValue;
    }
    if (this._clickhouseSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clickhouseSource = this._clickhouseSource?.internalValue;
    }
    if (this._clickhouseTarget?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clickhouseTarget = this._clickhouseTarget?.internalValue;
    }
    if (this._facebookmarketingSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.facebookmarketingSource = this._facebookmarketingSource?.internalValue;
    }
    if (this._googleadsSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleadsSource = this._googleadsSource?.internalValue;
    }
    if (this._hubspotSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hubspotSource = this._hubspotSource?.internalValue;
    }
    if (this._instagramSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.instagramSource = this._instagramSource?.internalValue;
    }
    if (this._jiraSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jiraSource = this._jiraSource?.internalValue;
    }
    if (this._kafkaSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaSource = this._kafkaSource?.internalValue;
    }
    if (this._kafkaTarget?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaTarget = this._kafkaTarget?.internalValue;
    }
    if (this._kinesisSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kinesisSource = this._kinesisSource?.internalValue;
    }
    if (this._linkedinadsSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.linkedinadsSource = this._linkedinadsSource?.internalValue;
    }
    if (this._metricaSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricaSource = this._metricaSource?.internalValue;
    }
    if (this._mongoSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mongoSource = this._mongoSource?.internalValue;
    }
    if (this._mongoTarget?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mongoTarget = this._mongoTarget?.internalValue;
    }
    if (this._mssqlSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mssqlSource = this._mssqlSource?.internalValue;
    }
    if (this._mysqlSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mysqlSource = this._mysqlSource?.internalValue;
    }
    if (this._mysqlTarget?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mysqlTarget = this._mysqlTarget?.internalValue;
    }
    if (this._objectStorageSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectStorageSource = this._objectStorageSource?.internalValue;
    }
    if (this._objectStorageTarget?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectStorageTarget = this._objectStorageTarget?.internalValue;
    }
    if (this._postgresSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresSource = this._postgresSource?.internalValue;
    }
    if (this._postgresTarget?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresTarget = this._postgresTarget?.internalValue;
    }
    if (this._redshiftSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.redshiftSource = this._redshiftSource?.internalValue;
    }
    if (this._s3Source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.s3Source = this._s3Source?.internalValue;
    }
    if (this._snowflakeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.snowflakeSource = this._snowflakeSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: TransferEndpointSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._awsCloudtrailSource.internalValue = undefined;
      this._bigquerySource.internalValue = undefined;
      this._bigqueryTarget.internalValue = undefined;
      this._clickhouseSource.internalValue = undefined;
      this._clickhouseTarget.internalValue = undefined;
      this._facebookmarketingSource.internalValue = undefined;
      this._googleadsSource.internalValue = undefined;
      this._hubspotSource.internalValue = undefined;
      this._instagramSource.internalValue = undefined;
      this._jiraSource.internalValue = undefined;
      this._kafkaSource.internalValue = undefined;
      this._kafkaTarget.internalValue = undefined;
      this._kinesisSource.internalValue = undefined;
      this._linkedinadsSource.internalValue = undefined;
      this._metricaSource.internalValue = undefined;
      this._mongoSource.internalValue = undefined;
      this._mongoTarget.internalValue = undefined;
      this._mssqlSource.internalValue = undefined;
      this._mysqlSource.internalValue = undefined;
      this._mysqlTarget.internalValue = undefined;
      this._objectStorageSource.internalValue = undefined;
      this._objectStorageTarget.internalValue = undefined;
      this._postgresSource.internalValue = undefined;
      this._postgresTarget.internalValue = undefined;
      this._redshiftSource.internalValue = undefined;
      this._s3Source.internalValue = undefined;
      this._snowflakeSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._awsCloudtrailSource.internalValue = value.awsCloudtrailSource;
      this._bigquerySource.internalValue = value.bigquerySource;
      this._bigqueryTarget.internalValue = value.bigqueryTarget;
      this._clickhouseSource.internalValue = value.clickhouseSource;
      this._clickhouseTarget.internalValue = value.clickhouseTarget;
      this._facebookmarketingSource.internalValue = value.facebookmarketingSource;
      this._googleadsSource.internalValue = value.googleadsSource;
      this._hubspotSource.internalValue = value.hubspotSource;
      this._instagramSource.internalValue = value.instagramSource;
      this._jiraSource.internalValue = value.jiraSource;
      this._kafkaSource.internalValue = value.kafkaSource;
      this._kafkaTarget.internalValue = value.kafkaTarget;
      this._kinesisSource.internalValue = value.kinesisSource;
      this._linkedinadsSource.internalValue = value.linkedinadsSource;
      this._metricaSource.internalValue = value.metricaSource;
      this._mongoSource.internalValue = value.mongoSource;
      this._mongoTarget.internalValue = value.mongoTarget;
      this._mssqlSource.internalValue = value.mssqlSource;
      this._mysqlSource.internalValue = value.mysqlSource;
      this._mysqlTarget.internalValue = value.mysqlTarget;
      this._objectStorageSource.internalValue = value.objectStorageSource;
      this._objectStorageTarget.internalValue = value.objectStorageTarget;
      this._postgresSource.internalValue = value.postgresSource;
      this._postgresTarget.internalValue = value.postgresTarget;
      this._redshiftSource.internalValue = value.redshiftSource;
      this._s3Source.internalValue = value.s3Source;
      this._snowflakeSource.internalValue = value.snowflakeSource;
    }
  }

  // aws_cloudtrail_source - computed: false, optional: true, required: false
  private _awsCloudtrailSource = new TransferEndpointSettingsAwsCloudtrailSourceOutputReference(this, "aws_cloudtrail_source");
  public get awsCloudtrailSource() {
    return this._awsCloudtrailSource;
  }
  public putAwsCloudtrailSource(value: TransferEndpointSettingsAwsCloudtrailSource) {
    this._awsCloudtrailSource.internalValue = value;
  }
  public resetAwsCloudtrailSource() {
    this._awsCloudtrailSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsCloudtrailSourceInput() {
    return this._awsCloudtrailSource.internalValue;
  }

  // bigquery_source - computed: false, optional: true, required: false
  private _bigquerySource = new TransferEndpointSettingsBigquerySourceOutputReference(this, "bigquery_source");
  public get bigquerySource() {
    return this._bigquerySource;
  }
  public putBigquerySource(value: TransferEndpointSettingsBigquerySource) {
    this._bigquerySource.internalValue = value;
  }
  public resetBigquerySource() {
    this._bigquerySource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bigquerySourceInput() {
    return this._bigquerySource.internalValue;
  }

  // bigquery_target - computed: false, optional: true, required: false
  private _bigqueryTarget = new TransferEndpointSettingsBigqueryTargetOutputReference(this, "bigquery_target");
  public get bigqueryTarget() {
    return this._bigqueryTarget;
  }
  public putBigqueryTarget(value: TransferEndpointSettingsBigqueryTarget) {
    this._bigqueryTarget.internalValue = value;
  }
  public resetBigqueryTarget() {
    this._bigqueryTarget.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bigqueryTargetInput() {
    return this._bigqueryTarget.internalValue;
  }

  // clickhouse_source - computed: false, optional: true, required: false
  private _clickhouseSource = new TransferEndpointSettingsClickhouseSourceOutputReference(this, "clickhouse_source");
  public get clickhouseSource() {
    return this._clickhouseSource;
  }
  public putClickhouseSource(value: TransferEndpointSettingsClickhouseSource) {
    this._clickhouseSource.internalValue = value;
  }
  public resetClickhouseSource() {
    this._clickhouseSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clickhouseSourceInput() {
    return this._clickhouseSource.internalValue;
  }

  // clickhouse_target - computed: false, optional: true, required: false
  private _clickhouseTarget = new TransferEndpointSettingsClickhouseTargetOutputReference(this, "clickhouse_target");
  public get clickhouseTarget() {
    return this._clickhouseTarget;
  }
  public putClickhouseTarget(value: TransferEndpointSettingsClickhouseTarget) {
    this._clickhouseTarget.internalValue = value;
  }
  public resetClickhouseTarget() {
    this._clickhouseTarget.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clickhouseTargetInput() {
    return this._clickhouseTarget.internalValue;
  }

  // facebookmarketing_source - computed: false, optional: true, required: false
  private _facebookmarketingSource = new TransferEndpointSettingsFacebookmarketingSourceOutputReference(this, "facebookmarketing_source");
  public get facebookmarketingSource() {
    return this._facebookmarketingSource;
  }
  public putFacebookmarketingSource(value: TransferEndpointSettingsFacebookmarketingSource) {
    this._facebookmarketingSource.internalValue = value;
  }
  public resetFacebookmarketingSource() {
    this._facebookmarketingSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get facebookmarketingSourceInput() {
    return this._facebookmarketingSource.internalValue;
  }

  // googleads_source - computed: false, optional: true, required: false
  private _googleadsSource = new TransferEndpointSettingsGoogleadsSourceOutputReference(this, "googleads_source");
  public get googleadsSource() {
    return this._googleadsSource;
  }
  public putGoogleadsSource(value: TransferEndpointSettingsGoogleadsSource) {
    this._googleadsSource.internalValue = value;
  }
  public resetGoogleadsSource() {
    this._googleadsSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleadsSourceInput() {
    return this._googleadsSource.internalValue;
  }

  // hubspot_source - computed: false, optional: true, required: false
  private _hubspotSource = new TransferEndpointSettingsHubspotSourceOutputReference(this, "hubspot_source");
  public get hubspotSource() {
    return this._hubspotSource;
  }
  public putHubspotSource(value: TransferEndpointSettingsHubspotSource) {
    this._hubspotSource.internalValue = value;
  }
  public resetHubspotSource() {
    this._hubspotSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hubspotSourceInput() {
    return this._hubspotSource.internalValue;
  }

  // instagram_source - computed: false, optional: true, required: false
  private _instagramSource = new TransferEndpointSettingsInstagramSourceOutputReference(this, "instagram_source");
  public get instagramSource() {
    return this._instagramSource;
  }
  public putInstagramSource(value: TransferEndpointSettingsInstagramSource) {
    this._instagramSource.internalValue = value;
  }
  public resetInstagramSource() {
    this._instagramSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get instagramSourceInput() {
    return this._instagramSource.internalValue;
  }

  // jira_source - computed: false, optional: true, required: false
  private _jiraSource = new TransferEndpointSettingsJiraSourceOutputReference(this, "jira_source");
  public get jiraSource() {
    return this._jiraSource;
  }
  public putJiraSource(value: TransferEndpointSettingsJiraSource) {
    this._jiraSource.internalValue = value;
  }
  public resetJiraSource() {
    this._jiraSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jiraSourceInput() {
    return this._jiraSource.internalValue;
  }

  // kafka_source - computed: false, optional: true, required: false
  private _kafkaSource = new TransferEndpointSettingsKafkaSourceOutputReference(this, "kafka_source");
  public get kafkaSource() {
    return this._kafkaSource;
  }
  public putKafkaSource(value: TransferEndpointSettingsKafkaSource) {
    this._kafkaSource.internalValue = value;
  }
  public resetKafkaSource() {
    this._kafkaSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaSourceInput() {
    return this._kafkaSource.internalValue;
  }

  // kafka_target - computed: false, optional: true, required: false
  private _kafkaTarget = new TransferEndpointSettingsKafkaTargetOutputReference(this, "kafka_target");
  public get kafkaTarget() {
    return this._kafkaTarget;
  }
  public putKafkaTarget(value: TransferEndpointSettingsKafkaTarget) {
    this._kafkaTarget.internalValue = value;
  }
  public resetKafkaTarget() {
    this._kafkaTarget.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaTargetInput() {
    return this._kafkaTarget.internalValue;
  }

  // kinesis_source - computed: false, optional: true, required: false
  private _kinesisSource = new TransferEndpointSettingsKinesisSourceOutputReference(this, "kinesis_source");
  public get kinesisSource() {
    return this._kinesisSource;
  }
  public putKinesisSource(value: TransferEndpointSettingsKinesisSource) {
    this._kinesisSource.internalValue = value;
  }
  public resetKinesisSource() {
    this._kinesisSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kinesisSourceInput() {
    return this._kinesisSource.internalValue;
  }

  // linkedinads_source - computed: false, optional: true, required: false
  private _linkedinadsSource = new TransferEndpointSettingsLinkedinadsSourceOutputReference(this, "linkedinads_source");
  public get linkedinadsSource() {
    return this._linkedinadsSource;
  }
  public putLinkedinadsSource(value: TransferEndpointSettingsLinkedinadsSource) {
    this._linkedinadsSource.internalValue = value;
  }
  public resetLinkedinadsSource() {
    this._linkedinadsSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get linkedinadsSourceInput() {
    return this._linkedinadsSource.internalValue;
  }

  // metrica_source - computed: false, optional: true, required: false
  private _metricaSource = new TransferEndpointSettingsMetricaSourceOutputReference(this, "metrica_source");
  public get metricaSource() {
    return this._metricaSource;
  }
  public putMetricaSource(value: TransferEndpointSettingsMetricaSource) {
    this._metricaSource.internalValue = value;
  }
  public resetMetricaSource() {
    this._metricaSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricaSourceInput() {
    return this._metricaSource.internalValue;
  }

  // mongo_source - computed: false, optional: true, required: false
  private _mongoSource = new TransferEndpointSettingsMongoSourceOutputReference(this, "mongo_source");
  public get mongoSource() {
    return this._mongoSource;
  }
  public putMongoSource(value: TransferEndpointSettingsMongoSource) {
    this._mongoSource.internalValue = value;
  }
  public resetMongoSource() {
    this._mongoSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mongoSourceInput() {
    return this._mongoSource.internalValue;
  }

  // mongo_target - computed: false, optional: true, required: false
  private _mongoTarget = new TransferEndpointSettingsMongoTargetOutputReference(this, "mongo_target");
  public get mongoTarget() {
    return this._mongoTarget;
  }
  public putMongoTarget(value: TransferEndpointSettingsMongoTarget) {
    this._mongoTarget.internalValue = value;
  }
  public resetMongoTarget() {
    this._mongoTarget.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mongoTargetInput() {
    return this._mongoTarget.internalValue;
  }

  // mssql_source - computed: false, optional: true, required: false
  private _mssqlSource = new TransferEndpointSettingsMssqlSourceOutputReference(this, "mssql_source");
  public get mssqlSource() {
    return this._mssqlSource;
  }
  public putMssqlSource(value: TransferEndpointSettingsMssqlSource) {
    this._mssqlSource.internalValue = value;
  }
  public resetMssqlSource() {
    this._mssqlSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mssqlSourceInput() {
    return this._mssqlSource.internalValue;
  }

  // mysql_source - computed: false, optional: true, required: false
  private _mysqlSource = new TransferEndpointSettingsMysqlSourceOutputReference(this, "mysql_source");
  public get mysqlSource() {
    return this._mysqlSource;
  }
  public putMysqlSource(value: TransferEndpointSettingsMysqlSource) {
    this._mysqlSource.internalValue = value;
  }
  public resetMysqlSource() {
    this._mysqlSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mysqlSourceInput() {
    return this._mysqlSource.internalValue;
  }

  // mysql_target - computed: false, optional: true, required: false
  private _mysqlTarget = new TransferEndpointSettingsMysqlTargetOutputReference(this, "mysql_target");
  public get mysqlTarget() {
    return this._mysqlTarget;
  }
  public putMysqlTarget(value: TransferEndpointSettingsMysqlTarget) {
    this._mysqlTarget.internalValue = value;
  }
  public resetMysqlTarget() {
    this._mysqlTarget.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mysqlTargetInput() {
    return this._mysqlTarget.internalValue;
  }

  // object_storage_source - computed: false, optional: true, required: false
  private _objectStorageSource = new TransferEndpointSettingsObjectStorageSourceOutputReference(this, "object_storage_source");
  public get objectStorageSource() {
    return this._objectStorageSource;
  }
  public putObjectStorageSource(value: TransferEndpointSettingsObjectStorageSource) {
    this._objectStorageSource.internalValue = value;
  }
  public resetObjectStorageSource() {
    this._objectStorageSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectStorageSourceInput() {
    return this._objectStorageSource.internalValue;
  }

  // object_storage_target - computed: false, optional: true, required: false
  private _objectStorageTarget = new TransferEndpointSettingsObjectStorageTargetOutputReference(this, "object_storage_target");
  public get objectStorageTarget() {
    return this._objectStorageTarget;
  }
  public putObjectStorageTarget(value: TransferEndpointSettingsObjectStorageTarget) {
    this._objectStorageTarget.internalValue = value;
  }
  public resetObjectStorageTarget() {
    this._objectStorageTarget.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectStorageTargetInput() {
    return this._objectStorageTarget.internalValue;
  }

  // postgres_source - computed: false, optional: true, required: false
  private _postgresSource = new TransferEndpointSettingsPostgresSourceOutputReference(this, "postgres_source");
  public get postgresSource() {
    return this._postgresSource;
  }
  public putPostgresSource(value: TransferEndpointSettingsPostgresSource) {
    this._postgresSource.internalValue = value;
  }
  public resetPostgresSource() {
    this._postgresSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresSourceInput() {
    return this._postgresSource.internalValue;
  }

  // postgres_target - computed: false, optional: true, required: false
  private _postgresTarget = new TransferEndpointSettingsPostgresTargetOutputReference(this, "postgres_target");
  public get postgresTarget() {
    return this._postgresTarget;
  }
  public putPostgresTarget(value: TransferEndpointSettingsPostgresTarget) {
    this._postgresTarget.internalValue = value;
  }
  public resetPostgresTarget() {
    this._postgresTarget.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresTargetInput() {
    return this._postgresTarget.internalValue;
  }

  // redshift_source - computed: false, optional: true, required: false
  private _redshiftSource = new TransferEndpointSettingsRedshiftSourceOutputReference(this, "redshift_source");
  public get redshiftSource() {
    return this._redshiftSource;
  }
  public putRedshiftSource(value: TransferEndpointSettingsRedshiftSource) {
    this._redshiftSource.internalValue = value;
  }
  public resetRedshiftSource() {
    this._redshiftSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redshiftSourceInput() {
    return this._redshiftSource.internalValue;
  }

  // s3_source - computed: false, optional: true, required: false
  private _s3Source = new TransferEndpointSettingsS3SourceOutputReference(this, "s3_source");
  public get s3Source() {
    return this._s3Source;
  }
  public putS3Source(value: TransferEndpointSettingsS3Source) {
    this._s3Source.internalValue = value;
  }
  public resetS3Source() {
    this._s3Source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get s3SourceInput() {
    return this._s3Source.internalValue;
  }

  // snowflake_source - computed: false, optional: true, required: false
  private _snowflakeSource = new TransferEndpointSettingsSnowflakeSourceOutputReference(this, "snowflake_source");
  public get snowflakeSource() {
    return this._snowflakeSource;
  }
  public putSnowflakeSource(value: TransferEndpointSettingsSnowflakeSource) {
    this._snowflakeSource.internalValue = value;
  }
  public resetSnowflakeSource() {
    this._snowflakeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snowflakeSourceInput() {
    return this._snowflakeSource.internalValue;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint doublecloud_transfer_endpoint}
*/
export class TransferEndpoint extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "doublecloud_transfer_endpoint";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a TransferEndpoint resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the TransferEndpoint to import
  * @param importFromId The id of the existing TransferEndpoint that should be imported. Refer to the {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the TransferEndpoint to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "doublecloud_transfer_endpoint", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/doublecloud/doublecloud/0.1.26/docs/resources/transfer_endpoint doublecloud_transfer_endpoint} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options TransferEndpointConfig
  */
  public constructor(scope: Construct, id: string, config: TransferEndpointConfig) {
    super(scope, id, {
      terraformResourceType: 'doublecloud_transfer_endpoint',
      terraformGeneratorMetadata: {
        providerName: 'doublecloud',
        providerVersion: '0.1.26'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._description = config.description;
    this._name = config.name;
    this._projectId = config.projectId;
    this._settings.internalValue = config.settings;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // project_id - computed: false, optional: false, required: true
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }

  // settings - computed: false, optional: true, required: false
  private _settings = new TransferEndpointSettingsOutputReference(this, "settings");
  public get settings() {
    return this._settings;
  }
  public putSettings(value: TransferEndpointSettings) {
    this._settings.internalValue = value;
  }
  public resetSettings() {
    this._settings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get settingsInput() {
    return this._settings.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      description: cdktf.stringToTerraform(this._description),
      name: cdktf.stringToTerraform(this._name),
      project_id: cdktf.stringToTerraform(this._projectId),
      settings: transferEndpointSettingsToTerraform(this._settings.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      description: {
        value: cdktf.stringToHclTerraform(this._description),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      name: {
        value: cdktf.stringToHclTerraform(this._name),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      project_id: {
        value: cdktf.stringToHclTerraform(this._projectId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      settings: {
        value: transferEndpointSettingsToHclTerraform(this._settings.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "TransferEndpointSettings",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
