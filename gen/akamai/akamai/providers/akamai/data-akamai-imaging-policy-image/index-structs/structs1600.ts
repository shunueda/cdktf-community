import * as cdktf from 'cdktf';
import { DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundTransformations,
dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundTransformationsToTerraform,
dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundTransformationsToHclTerraform,
DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundTransformationsList,
DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBackgroundColor,
dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBackgroundColorToTerraform,
dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBackgroundColorToHclTerraform,
DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBackgroundColorList,
DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBlur,
dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBlurToTerraform,
dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBlurToHclTerraform,
DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBlurList,
DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultChromaKey,
dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultChromaKeyToTerraform,
dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultChromaKeyToHclTerraform,
DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultChromaKeyList,
DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultComposite,
dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompositeToTerraform,
dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompositeToHclTerraform,
DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompositeList } from './structs1200'
import { DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimension,
dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionToTerraform,
dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionToHclTerraform,
DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionList } from './structs3600'
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompound {
  /**
  * transformations block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#transformations DataAkamaiImagingPolicyImage#transformations}
  */
  readonly transformations?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundTransformations[] | cdktf.IResolvable;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompound | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    transformations: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundTransformationsToTerraform, true)(struct!.transformations),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompound | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    transformations: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundTransformationsToHclTerraform, true)(struct!.transformations),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundTransformationsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompound | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._transformations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformations = this._transformations?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompound | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._transformations.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._transformations.internalValue = value.transformations;
    }
  }

  // transformations - computed: false, optional: true, required: false
  private _transformations = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundTransformationsList(this, "transformations", false);
  public get transformations() {
    return this._transformations;
  }
  public putTransformations(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundTransformations[] | cdktf.IResolvable) {
    this._transformations.internalValue = value;
  }
  public resetTransformations() {
    this._transformations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationsInput() {
    return this._transformations.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompound[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrast {
  /**
  * Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#brightness DataAkamaiImagingPolicyImage#brightness}
  */
  readonly brightness?: string;
  /**
  * Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#brightness_var DataAkamaiImagingPolicyImage#brightness_var}
  */
  readonly brightnessVar?: string;
  /**
  * Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#contrast DataAkamaiImagingPolicyImage#contrast}
  */
  readonly contrast?: string;
  /**
  * Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#contrast_var DataAkamaiImagingPolicyImage#contrast_var}
  */
  readonly contrastVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrastToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    brightness: cdktf.stringToTerraform(struct!.brightness),
    brightness_var: cdktf.stringToTerraform(struct!.brightnessVar),
    contrast: cdktf.stringToTerraform(struct!.contrast),
    contrast_var: cdktf.stringToTerraform(struct!.contrastVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrastToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    brightness: {
      value: cdktf.stringToHclTerraform(struct!.brightness),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    brightness_var: {
      value: cdktf.stringToHclTerraform(struct!.brightnessVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    contrast: {
      value: cdktf.stringToHclTerraform(struct!.contrast),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    contrast_var: {
      value: cdktf.stringToHclTerraform(struct!.contrastVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._brightness !== undefined) {
      hasAnyValues = true;
      internalValueResult.brightness = this._brightness;
    }
    if (this._brightnessVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.brightnessVar = this._brightnessVar;
    }
    if (this._contrast !== undefined) {
      hasAnyValues = true;
      internalValueResult.contrast = this._contrast;
    }
    if (this._contrastVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.contrastVar = this._contrastVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._brightness = undefined;
      this._brightnessVar = undefined;
      this._contrast = undefined;
      this._contrastVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._brightness = value.brightness;
      this._brightnessVar = value.brightnessVar;
      this._contrast = value.contrast;
      this._contrastVar = value.contrastVar;
    }
  }

  // brightness - computed: false, optional: true, required: false
  private _brightness?: string; 
  public get brightness() {
    return this.getStringAttribute('brightness');
  }
  public set brightness(value: string) {
    this._brightness = value;
  }
  public resetBrightness() {
    this._brightness = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brightnessInput() {
    return this._brightness;
  }

  // brightness_var - computed: false, optional: true, required: false
  private _brightnessVar?: string; 
  public get brightnessVar() {
    return this.getStringAttribute('brightness_var');
  }
  public set brightnessVar(value: string) {
    this._brightnessVar = value;
  }
  public resetBrightnessVar() {
    this._brightnessVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brightnessVarInput() {
    return this._brightnessVar;
  }

  // contrast - computed: false, optional: true, required: false
  private _contrast?: string; 
  public get contrast() {
    return this.getStringAttribute('contrast');
  }
  public set contrast(value: string) {
    this._contrast = value;
  }
  public resetContrast() {
    this._contrast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contrastInput() {
    return this._contrast;
  }

  // contrast_var - computed: false, optional: true, required: false
  private _contrastVar?: string; 
  public get contrastVar() {
    return this.getStringAttribute('contrast_var');
  }
  public set contrastVar(value: string) {
    this._contrastVar = value;
  }
  public resetContrastVar() {
    this._contrastVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contrastVarInput() {
    return this._contrastVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrastList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrast[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrastOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrastOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoop {
  /**
  * Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#chaos DataAkamaiImagingPolicyImage#chaos}
  */
  readonly chaos?: string;
  /**
  * Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#chaos_var DataAkamaiImagingPolicyImage#chaos_var}
  */
  readonly chaosVar?: string;
  /**
  * Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#density DataAkamaiImagingPolicyImage#density}
  */
  readonly density?: string;
  /**
  * Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#density_var DataAkamaiImagingPolicyImage#density_var}
  */
  readonly densityVar?: string;
  /**
  * By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#power DataAkamaiImagingPolicyImage#power}
  */
  readonly power?: string;
  /**
  * By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#power_var DataAkamaiImagingPolicyImage#power_var}
  */
  readonly powerVar?: string;
  /**
  * Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#seed DataAkamaiImagingPolicyImage#seed}
  */
  readonly seed?: string;
  /**
  * Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#seed_var DataAkamaiImagingPolicyImage#seed_var}
  */
  readonly seedVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoopToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    chaos: cdktf.stringToTerraform(struct!.chaos),
    chaos_var: cdktf.stringToTerraform(struct!.chaosVar),
    density: cdktf.stringToTerraform(struct!.density),
    density_var: cdktf.stringToTerraform(struct!.densityVar),
    power: cdktf.stringToTerraform(struct!.power),
    power_var: cdktf.stringToTerraform(struct!.powerVar),
    seed: cdktf.stringToTerraform(struct!.seed),
    seed_var: cdktf.stringToTerraform(struct!.seedVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoopToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    chaos: {
      value: cdktf.stringToHclTerraform(struct!.chaos),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    chaos_var: {
      value: cdktf.stringToHclTerraform(struct!.chaosVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    density: {
      value: cdktf.stringToHclTerraform(struct!.density),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    density_var: {
      value: cdktf.stringToHclTerraform(struct!.densityVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    power: {
      value: cdktf.stringToHclTerraform(struct!.power),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    power_var: {
      value: cdktf.stringToHclTerraform(struct!.powerVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seed: {
      value: cdktf.stringToHclTerraform(struct!.seed),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seed_var: {
      value: cdktf.stringToHclTerraform(struct!.seedVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chaos !== undefined) {
      hasAnyValues = true;
      internalValueResult.chaos = this._chaos;
    }
    if (this._chaosVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.chaosVar = this._chaosVar;
    }
    if (this._density !== undefined) {
      hasAnyValues = true;
      internalValueResult.density = this._density;
    }
    if (this._densityVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.densityVar = this._densityVar;
    }
    if (this._power !== undefined) {
      hasAnyValues = true;
      internalValueResult.power = this._power;
    }
    if (this._powerVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.powerVar = this._powerVar;
    }
    if (this._seed !== undefined) {
      hasAnyValues = true;
      internalValueResult.seed = this._seed;
    }
    if (this._seedVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.seedVar = this._seedVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chaos = undefined;
      this._chaosVar = undefined;
      this._density = undefined;
      this._densityVar = undefined;
      this._power = undefined;
      this._powerVar = undefined;
      this._seed = undefined;
      this._seedVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chaos = value.chaos;
      this._chaosVar = value.chaosVar;
      this._density = value.density;
      this._densityVar = value.densityVar;
      this._power = value.power;
      this._powerVar = value.powerVar;
      this._seed = value.seed;
      this._seedVar = value.seedVar;
    }
  }

  // chaos - computed: false, optional: true, required: false
  private _chaos?: string; 
  public get chaos() {
    return this.getStringAttribute('chaos');
  }
  public set chaos(value: string) {
    this._chaos = value;
  }
  public resetChaos() {
    this._chaos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chaosInput() {
    return this._chaos;
  }

  // chaos_var - computed: false, optional: true, required: false
  private _chaosVar?: string; 
  public get chaosVar() {
    return this.getStringAttribute('chaos_var');
  }
  public set chaosVar(value: string) {
    this._chaosVar = value;
  }
  public resetChaosVar() {
    this._chaosVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chaosVarInput() {
    return this._chaosVar;
  }

  // density - computed: false, optional: true, required: false
  private _density?: string; 
  public get density() {
    return this.getStringAttribute('density');
  }
  public set density(value: string) {
    this._density = value;
  }
  public resetDensity() {
    this._density = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get densityInput() {
    return this._density;
  }

  // density_var - computed: false, optional: true, required: false
  private _densityVar?: string; 
  public get densityVar() {
    return this.getStringAttribute('density_var');
  }
  public set densityVar(value: string) {
    this._densityVar = value;
  }
  public resetDensityVar() {
    this._densityVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get densityVarInput() {
    return this._densityVar;
  }

  // power - computed: false, optional: true, required: false
  private _power?: string; 
  public get power() {
    return this.getStringAttribute('power');
  }
  public set power(value: string) {
    this._power = value;
  }
  public resetPower() {
    this._power = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get powerInput() {
    return this._power;
  }

  // power_var - computed: false, optional: true, required: false
  private _powerVar?: string; 
  public get powerVar() {
    return this.getStringAttribute('power_var');
  }
  public set powerVar(value: string) {
    this._powerVar = value;
  }
  public resetPowerVar() {
    this._powerVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get powerVarInput() {
    return this._powerVar;
  }

  // seed - computed: false, optional: true, required: false
  private _seed?: string; 
  public get seed() {
    return this.getStringAttribute('seed');
  }
  public set seed(value: string) {
    this._seed = value;
  }
  public resetSeed() {
    this._seed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seedInput() {
    return this._seed;
  }

  // seed_var - computed: false, optional: true, required: false
  private _seedVar?: string; 
  public get seedVar() {
    return this.getStringAttribute('seed_var');
  }
  public set seedVar(value: string) {
    this._seedVar = value;
  }
  public resetSeedVar() {
    this._seedVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seedVarInput() {
    return this._seedVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoopList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoop[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoopOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoopOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscale {
  /**
  * The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#type DataAkamaiImagingPolicyImage#type}
  */
  readonly type?: string;
  /**
  * The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#type_var DataAkamaiImagingPolicyImage#type_var}
  */
  readonly typeVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscaleToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscale | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    type_var: cdktf.stringToTerraform(struct!.typeVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscaleToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscale | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type_var: {
      value: cdktf.stringToHclTerraform(struct!.typeVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscaleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscale | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._typeVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.typeVar = this._typeVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscale | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._typeVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._typeVar = value.typeVar;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // type_var - computed: false, optional: true, required: false
  private _typeVar?: string; 
  public get typeVar() {
    return this.getStringAttribute('type_var');
  }
  public set typeVar(value: string) {
    this._typeVar = value;
  }
  public resetTypeVar() {
    this._typeVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeVarInput() {
    return this._typeVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscaleList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscale[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscaleOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscaleOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsl {
  /**
  * The number of degrees to rotate colors around the color wheel, `0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * The number of degrees to rotate colors around the color wheel, `0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
  /**
  * A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness DataAkamaiImagingPolicyImage#lightness}
  */
  readonly lightness?: string;
  /**
  * A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_var DataAkamaiImagingPolicyImage#lightness_var}
  */
  readonly lightnessVar?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation DataAkamaiImagingPolicyImage#saturation}
  */
  readonly saturation?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_var DataAkamaiImagingPolicyImage#saturation_var}
  */
  readonly saturationVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHslToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
    lightness: cdktf.stringToTerraform(struct!.lightness),
    lightness_var: cdktf.stringToTerraform(struct!.lightnessVar),
    saturation: cdktf.stringToTerraform(struct!.saturation),
    saturation_var: cdktf.stringToTerraform(struct!.saturationVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHslToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness: {
      value: cdktf.stringToHclTerraform(struct!.lightness),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_var: {
      value: cdktf.stringToHclTerraform(struct!.lightnessVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation: {
      value: cdktf.stringToHclTerraform(struct!.saturation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    if (this._lightness !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightness = this._lightness;
    }
    if (this._lightnessVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessVar = this._lightnessVar;
    }
    if (this._saturation !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturation = this._saturation;
    }
    if (this._saturationVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationVar = this._saturationVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueVar = undefined;
      this._lightness = undefined;
      this._lightnessVar = undefined;
      this._saturation = undefined;
      this._saturationVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueVar = value.hueVar;
      this._lightness = value.lightness;
      this._lightnessVar = value.lightnessVar;
      this._saturation = value.saturation;
      this._saturationVar = value.saturationVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }

  // lightness - computed: false, optional: true, required: false
  private _lightness?: string; 
  public get lightness() {
    return this.getStringAttribute('lightness');
  }
  public set lightness(value: string) {
    this._lightness = value;
  }
  public resetLightness() {
    this._lightness = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessInput() {
    return this._lightness;
  }

  // lightness_var - computed: false, optional: true, required: false
  private _lightnessVar?: string; 
  public get lightnessVar() {
    return this.getStringAttribute('lightness_var');
  }
  public set lightnessVar(value: string) {
    this._lightnessVar = value;
  }
  public resetLightnessVar() {
    this._lightnessVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessVarInput() {
    return this._lightnessVar;
  }

  // saturation - computed: false, optional: true, required: false
  private _saturation?: string; 
  public get saturation() {
    return this.getStringAttribute('saturation');
  }
  public set saturation(value: string) {
    this._saturation = value;
  }
  public resetSaturation() {
    this._saturation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationInput() {
    return this._saturation;
  }

  // saturation_var - computed: false, optional: true, required: false
  private _saturationVar?: string; 
  public get saturationVar() {
    return this.getStringAttribute('saturation_var');
  }
  public set saturationVar(value: string) {
    this._saturationVar = value;
  }
  public resetSaturationVar() {
    this._saturationVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationVarInput() {
    return this._saturationVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHslList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsl[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHslOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHslOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsv {
  /**
  * The number of degrees to rotate colors around the color wheel, `0.0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * The number of degrees to rotate colors around the color wheel, `0.0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation DataAkamaiImagingPolicyImage#saturation}
  */
  readonly saturation?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_var DataAkamaiImagingPolicyImage#saturation_var}
  */
  readonly saturationVar?: string;
  /**
  * A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value DataAkamaiImagingPolicyImage#value}
  */
  readonly value?: string;
  /**
  * A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value_var DataAkamaiImagingPolicyImage#value_var}
  */
  readonly valueVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsvToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
    saturation: cdktf.stringToTerraform(struct!.saturation),
    saturation_var: cdktf.stringToTerraform(struct!.saturationVar),
    value: cdktf.stringToTerraform(struct!.value),
    value_var: cdktf.stringToTerraform(struct!.valueVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsvToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation: {
      value: cdktf.stringToHclTerraform(struct!.saturation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_var: {
      value: cdktf.stringToHclTerraform(struct!.valueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    if (this._saturation !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturation = this._saturation;
    }
    if (this._saturationVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationVar = this._saturationVar;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueVar = this._valueVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueVar = undefined;
      this._saturation = undefined;
      this._saturationVar = undefined;
      this._value = undefined;
      this._valueVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueVar = value.hueVar;
      this._saturation = value.saturation;
      this._saturationVar = value.saturationVar;
      this._value = value.value;
      this._valueVar = value.valueVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }

  // saturation - computed: false, optional: true, required: false
  private _saturation?: string; 
  public get saturation() {
    return this.getStringAttribute('saturation');
  }
  public set saturation(value: string) {
    this._saturation = value;
  }
  public resetSaturation() {
    this._saturation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationInput() {
    return this._saturation;
  }

  // saturation_var - computed: false, optional: true, required: false
  private _saturationVar?: string; 
  public get saturationVar() {
    return this.getStringAttribute('saturation_var');
  }
  public set saturationVar(value: string) {
    this._saturationVar = value;
  }
  public resetSaturationVar() {
    this._saturationVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationVarInput() {
    return this._saturationVar;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_var - computed: false, optional: true, required: false
  private _valueVar?: string; 
  public get valueVar() {
    return this.getStringAttribute('value_var');
  }
  public set valueVar(value: string) {
    this._valueVar = value;
  }
  public resetValueVar() {
    this._valueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueVarInput() {
    return this._valueVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsvList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsvOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColor {
  /**
  * The hexadecimal CSS color value for the background.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color DataAkamaiImagingPolicyImage#color}
  */
  readonly color?: string;
  /**
  * The hexadecimal CSS color value for the background.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color_var DataAkamaiImagingPolicyImage#color_var}
  */
  readonly colorVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColorToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    color: cdktf.stringToTerraform(struct!.color),
    color_var: cdktf.stringToTerraform(struct!.colorVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColorToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    color_var: {
      value: cdktf.stringToHclTerraform(struct!.colorVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._colorVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorVar = this._colorVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._color = undefined;
      this._colorVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._color = value.color;
      this._colorVar = value.colorVar;
    }
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // color_var - computed: false, optional: true, required: false
  private _colorVar?: string; 
  public get colorVar() {
    return this.getStringAttribute('color_var');
  }
  public set colorVar(value: string) {
    this._colorVar = value;
  }
  public resetColorVar() {
    this._colorVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorVarInput() {
    return this._colorVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColorList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColor[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColorOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlur {
  /**
  * The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma DataAkamaiImagingPolicyImage#sigma}
  */
  readonly sigma?: string;
  /**
  * The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma_var DataAkamaiImagingPolicyImage#sigma_var}
  */
  readonly sigmaVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlurToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlur | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sigma: cdktf.stringToTerraform(struct!.sigma),
    sigma_var: cdktf.stringToTerraform(struct!.sigmaVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlurToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlur | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sigma: {
      value: cdktf.stringToHclTerraform(struct!.sigma),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sigma_var: {
      value: cdktf.stringToHclTerraform(struct!.sigmaVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlurOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlur | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sigma !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigma = this._sigma;
    }
    if (this._sigmaVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigmaVar = this._sigmaVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlur | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sigma = undefined;
      this._sigmaVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sigma = value.sigma;
      this._sigmaVar = value.sigmaVar;
    }
  }

  // sigma - computed: false, optional: true, required: false
  private _sigma?: string; 
  public get sigma() {
    return this.getStringAttribute('sigma');
  }
  public set sigma(value: string) {
    this._sigma = value;
  }
  public resetSigma() {
    this._sigma = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaInput() {
    return this._sigma;
  }

  // sigma_var - computed: false, optional: true, required: false
  private _sigmaVar?: string; 
  public get sigmaVar() {
    return this.getStringAttribute('sigma_var');
  }
  public set sigmaVar(value: string) {
    this._sigmaVar = value;
  }
  public resetSigmaVar() {
    this._sigmaVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaVarInput() {
    return this._sigmaVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlurList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlur[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlurOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlurOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKey {
  /**
  * The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_feather DataAkamaiImagingPolicyImage#hue_feather}
  */
  readonly hueFeather?: string;
  /**
  * How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_feather_var DataAkamaiImagingPolicyImage#hue_feather_var}
  */
  readonly hueFeatherVar?: string;
  /**
  * How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_tolerance DataAkamaiImagingPolicyImage#hue_tolerance}
  */
  readonly hueTolerance?: string;
  /**
  * How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_tolerance_var DataAkamaiImagingPolicyImage#hue_tolerance_var}
  */
  readonly hueToleranceVar?: string;
  /**
  * The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
  /**
  * How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_feather DataAkamaiImagingPolicyImage#lightness_feather}
  */
  readonly lightnessFeather?: string;
  /**
  * How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_feather_var DataAkamaiImagingPolicyImage#lightness_feather_var}
  */
  readonly lightnessFeatherVar?: string;
  /**
  * How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_tolerance DataAkamaiImagingPolicyImage#lightness_tolerance}
  */
  readonly lightnessTolerance?: string;
  /**
  * How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_tolerance_var DataAkamaiImagingPolicyImage#lightness_tolerance_var}
  */
  readonly lightnessToleranceVar?: string;
  /**
  * How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_feather DataAkamaiImagingPolicyImage#saturation_feather}
  */
  readonly saturationFeather?: string;
  /**
  * How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_feather_var DataAkamaiImagingPolicyImage#saturation_feather_var}
  */
  readonly saturationFeatherVar?: string;
  /**
  * How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_tolerance DataAkamaiImagingPolicyImage#saturation_tolerance}
  */
  readonly saturationTolerance?: string;
  /**
  * How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_tolerance_var DataAkamaiImagingPolicyImage#saturation_tolerance_var}
  */
  readonly saturationToleranceVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKeyToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_feather: cdktf.stringToTerraform(struct!.hueFeather),
    hue_feather_var: cdktf.stringToTerraform(struct!.hueFeatherVar),
    hue_tolerance: cdktf.stringToTerraform(struct!.hueTolerance),
    hue_tolerance_var: cdktf.stringToTerraform(struct!.hueToleranceVar),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
    lightness_feather: cdktf.stringToTerraform(struct!.lightnessFeather),
    lightness_feather_var: cdktf.stringToTerraform(struct!.lightnessFeatherVar),
    lightness_tolerance: cdktf.stringToTerraform(struct!.lightnessTolerance),
    lightness_tolerance_var: cdktf.stringToTerraform(struct!.lightnessToleranceVar),
    saturation_feather: cdktf.stringToTerraform(struct!.saturationFeather),
    saturation_feather_var: cdktf.stringToTerraform(struct!.saturationFeatherVar),
    saturation_tolerance: cdktf.stringToTerraform(struct!.saturationTolerance),
    saturation_tolerance_var: cdktf.stringToTerraform(struct!.saturationToleranceVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKeyToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_feather: {
      value: cdktf.stringToHclTerraform(struct!.hueFeather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_feather_var: {
      value: cdktf.stringToHclTerraform(struct!.hueFeatherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.hueTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.hueToleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_feather: {
      value: cdktf.stringToHclTerraform(struct!.lightnessFeather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_feather_var: {
      value: cdktf.stringToHclTerraform(struct!.lightnessFeatherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.lightnessTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.lightnessToleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_feather: {
      value: cdktf.stringToHclTerraform(struct!.saturationFeather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_feather_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationFeatherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.saturationTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationToleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueFeather !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueFeather = this._hueFeather;
    }
    if (this._hueFeatherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueFeatherVar = this._hueFeatherVar;
    }
    if (this._hueTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueTolerance = this._hueTolerance;
    }
    if (this._hueToleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueToleranceVar = this._hueToleranceVar;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    if (this._lightnessFeather !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessFeather = this._lightnessFeather;
    }
    if (this._lightnessFeatherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessFeatherVar = this._lightnessFeatherVar;
    }
    if (this._lightnessTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessTolerance = this._lightnessTolerance;
    }
    if (this._lightnessToleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessToleranceVar = this._lightnessToleranceVar;
    }
    if (this._saturationFeather !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationFeather = this._saturationFeather;
    }
    if (this._saturationFeatherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationFeatherVar = this._saturationFeatherVar;
    }
    if (this._saturationTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationTolerance = this._saturationTolerance;
    }
    if (this._saturationToleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationToleranceVar = this._saturationToleranceVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueFeather = undefined;
      this._hueFeatherVar = undefined;
      this._hueTolerance = undefined;
      this._hueToleranceVar = undefined;
      this._hueVar = undefined;
      this._lightnessFeather = undefined;
      this._lightnessFeatherVar = undefined;
      this._lightnessTolerance = undefined;
      this._lightnessToleranceVar = undefined;
      this._saturationFeather = undefined;
      this._saturationFeatherVar = undefined;
      this._saturationTolerance = undefined;
      this._saturationToleranceVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueFeather = value.hueFeather;
      this._hueFeatherVar = value.hueFeatherVar;
      this._hueTolerance = value.hueTolerance;
      this._hueToleranceVar = value.hueToleranceVar;
      this._hueVar = value.hueVar;
      this._lightnessFeather = value.lightnessFeather;
      this._lightnessFeatherVar = value.lightnessFeatherVar;
      this._lightnessTolerance = value.lightnessTolerance;
      this._lightnessToleranceVar = value.lightnessToleranceVar;
      this._saturationFeather = value.saturationFeather;
      this._saturationFeatherVar = value.saturationFeatherVar;
      this._saturationTolerance = value.saturationTolerance;
      this._saturationToleranceVar = value.saturationToleranceVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_feather - computed: false, optional: true, required: false
  private _hueFeather?: string; 
  public get hueFeather() {
    return this.getStringAttribute('hue_feather');
  }
  public set hueFeather(value: string) {
    this._hueFeather = value;
  }
  public resetHueFeather() {
    this._hueFeather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueFeatherInput() {
    return this._hueFeather;
  }

  // hue_feather_var - computed: false, optional: true, required: false
  private _hueFeatherVar?: string; 
  public get hueFeatherVar() {
    return this.getStringAttribute('hue_feather_var');
  }
  public set hueFeatherVar(value: string) {
    this._hueFeatherVar = value;
  }
  public resetHueFeatherVar() {
    this._hueFeatherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueFeatherVarInput() {
    return this._hueFeatherVar;
  }

  // hue_tolerance - computed: false, optional: true, required: false
  private _hueTolerance?: string; 
  public get hueTolerance() {
    return this.getStringAttribute('hue_tolerance');
  }
  public set hueTolerance(value: string) {
    this._hueTolerance = value;
  }
  public resetHueTolerance() {
    this._hueTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueToleranceInput() {
    return this._hueTolerance;
  }

  // hue_tolerance_var - computed: false, optional: true, required: false
  private _hueToleranceVar?: string; 
  public get hueToleranceVar() {
    return this.getStringAttribute('hue_tolerance_var');
  }
  public set hueToleranceVar(value: string) {
    this._hueToleranceVar = value;
  }
  public resetHueToleranceVar() {
    this._hueToleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueToleranceVarInput() {
    return this._hueToleranceVar;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }

  // lightness_feather - computed: false, optional: true, required: false
  private _lightnessFeather?: string; 
  public get lightnessFeather() {
    return this.getStringAttribute('lightness_feather');
  }
  public set lightnessFeather(value: string) {
    this._lightnessFeather = value;
  }
  public resetLightnessFeather() {
    this._lightnessFeather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessFeatherInput() {
    return this._lightnessFeather;
  }

  // lightness_feather_var - computed: false, optional: true, required: false
  private _lightnessFeatherVar?: string; 
  public get lightnessFeatherVar() {
    return this.getStringAttribute('lightness_feather_var');
  }
  public set lightnessFeatherVar(value: string) {
    this._lightnessFeatherVar = value;
  }
  public resetLightnessFeatherVar() {
    this._lightnessFeatherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessFeatherVarInput() {
    return this._lightnessFeatherVar;
  }

  // lightness_tolerance - computed: false, optional: true, required: false
  private _lightnessTolerance?: string; 
  public get lightnessTolerance() {
    return this.getStringAttribute('lightness_tolerance');
  }
  public set lightnessTolerance(value: string) {
    this._lightnessTolerance = value;
  }
  public resetLightnessTolerance() {
    this._lightnessTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessToleranceInput() {
    return this._lightnessTolerance;
  }

  // lightness_tolerance_var - computed: false, optional: true, required: false
  private _lightnessToleranceVar?: string; 
  public get lightnessToleranceVar() {
    return this.getStringAttribute('lightness_tolerance_var');
  }
  public set lightnessToleranceVar(value: string) {
    this._lightnessToleranceVar = value;
  }
  public resetLightnessToleranceVar() {
    this._lightnessToleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessToleranceVarInput() {
    return this._lightnessToleranceVar;
  }

  // saturation_feather - computed: false, optional: true, required: false
  private _saturationFeather?: string; 
  public get saturationFeather() {
    return this.getStringAttribute('saturation_feather');
  }
  public set saturationFeather(value: string) {
    this._saturationFeather = value;
  }
  public resetSaturationFeather() {
    this._saturationFeather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationFeatherInput() {
    return this._saturationFeather;
  }

  // saturation_feather_var - computed: false, optional: true, required: false
  private _saturationFeatherVar?: string; 
  public get saturationFeatherVar() {
    return this.getStringAttribute('saturation_feather_var');
  }
  public set saturationFeatherVar(value: string) {
    this._saturationFeatherVar = value;
  }
  public resetSaturationFeatherVar() {
    this._saturationFeatherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationFeatherVarInput() {
    return this._saturationFeatherVar;
  }

  // saturation_tolerance - computed: false, optional: true, required: false
  private _saturationTolerance?: string; 
  public get saturationTolerance() {
    return this.getStringAttribute('saturation_tolerance');
  }
  public set saturationTolerance(value: string) {
    this._saturationTolerance = value;
  }
  public resetSaturationTolerance() {
    this._saturationTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationToleranceInput() {
    return this._saturationTolerance;
  }

  // saturation_tolerance_var - computed: false, optional: true, required: false
  private _saturationToleranceVar?: string; 
  public get saturationToleranceVar() {
    return this.getStringAttribute('saturation_tolerance_var');
  }
  public set saturationToleranceVar(value: string) {
    this._saturationToleranceVar = value;
  }
  public resetSaturationToleranceVar() {
    this._saturationToleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationToleranceVarInput() {
    return this._saturationToleranceVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKeyList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKey[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKeyOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKeyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImage {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImageToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImageOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImage): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImageToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImageOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImage): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImage | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImage | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeComposite {
  /**
  * Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gravity DataAkamaiImagingPolicyImage#gravity}
  */
  readonly gravity?: string;
  /**
  * Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gravity_var DataAkamaiImagingPolicyImage#gravity_var}
  */
  readonly gravityVar?: string;
  /**
  * Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#placement DataAkamaiImagingPolicyImage#placement}
  */
  readonly placement?: string;
  /**
  * Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#placement_var DataAkamaiImagingPolicyImage#placement_var}
  */
  readonly placementVar?: string;
  /**
  * A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#scale DataAkamaiImagingPolicyImage#scale}
  */
  readonly scale?: string;
  /**
  * The dimension, either `width` or `height`, of the source image to scale.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#scale_dimension DataAkamaiImagingPolicyImage#scale_dimension}
  */
  readonly scaleDimension?: string;
  /**
  * The dimension, either `width` or `height`, of the source image to scale.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#scale_dimension_var DataAkamaiImagingPolicyImage#scale_dimension_var}
  */
  readonly scaleDimensionVar?: string;
  /**
  * A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#scale_var DataAkamaiImagingPolicyImage#scale_var}
  */
  readonly scaleVar?: string;
  /**
  * The x-axis position of the image to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#x_position DataAkamaiImagingPolicyImage#x_position}
  */
  readonly xPosition?: string;
  /**
  * The x-axis position of the image to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#x_position_var DataAkamaiImagingPolicyImage#x_position_var}
  */
  readonly xPositionVar?: string;
  /**
  * The y-axis position of the image to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#y_position DataAkamaiImagingPolicyImage#y_position}
  */
  readonly yPosition?: string;
  /**
  * The y-axis position of the image to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#y_position_var DataAkamaiImagingPolicyImage#y_position_var}
  */
  readonly yPositionVar?: string;
  /**
  * image block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#image DataAkamaiImagingPolicyImage#image}
  */
  readonly image: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImage;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeComposite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gravity: cdktf.stringToTerraform(struct!.gravity),
    gravity_var: cdktf.stringToTerraform(struct!.gravityVar),
    placement: cdktf.stringToTerraform(struct!.placement),
    placement_var: cdktf.stringToTerraform(struct!.placementVar),
    scale: cdktf.stringToTerraform(struct!.scale),
    scale_dimension: cdktf.stringToTerraform(struct!.scaleDimension),
    scale_dimension_var: cdktf.stringToTerraform(struct!.scaleDimensionVar),
    scale_var: cdktf.stringToTerraform(struct!.scaleVar),
    x_position: cdktf.stringToTerraform(struct!.xPosition),
    x_position_var: cdktf.stringToTerraform(struct!.xPositionVar),
    y_position: cdktf.stringToTerraform(struct!.yPosition),
    y_position_var: cdktf.stringToTerraform(struct!.yPositionVar),
    image: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImageToTerraform(struct!.image),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeComposite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gravity: {
      value: cdktf.stringToHclTerraform(struct!.gravity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gravity_var: {
      value: cdktf.stringToHclTerraform(struct!.gravityVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    placement: {
      value: cdktf.stringToHclTerraform(struct!.placement),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    placement_var: {
      value: cdktf.stringToHclTerraform(struct!.placementVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale: {
      value: cdktf.stringToHclTerraform(struct!.scale),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale_dimension: {
      value: cdktf.stringToHclTerraform(struct!.scaleDimension),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale_dimension_var: {
      value: cdktf.stringToHclTerraform(struct!.scaleDimensionVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale_var: {
      value: cdktf.stringToHclTerraform(struct!.scaleVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    x_position: {
      value: cdktf.stringToHclTerraform(struct!.xPosition),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    x_position_var: {
      value: cdktf.stringToHclTerraform(struct!.xPositionVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    y_position: {
      value: cdktf.stringToHclTerraform(struct!.yPosition),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    y_position_var: {
      value: cdktf.stringToHclTerraform(struct!.yPositionVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImageToHclTerraform(struct!.image),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImageList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeComposite | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gravity !== undefined) {
      hasAnyValues = true;
      internalValueResult.gravity = this._gravity;
    }
    if (this._gravityVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.gravityVar = this._gravityVar;
    }
    if (this._placement !== undefined) {
      hasAnyValues = true;
      internalValueResult.placement = this._placement;
    }
    if (this._placementVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.placementVar = this._placementVar;
    }
    if (this._scale !== undefined) {
      hasAnyValues = true;
      internalValueResult.scale = this._scale;
    }
    if (this._scaleDimension !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleDimension = this._scaleDimension;
    }
    if (this._scaleDimensionVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleDimensionVar = this._scaleDimensionVar;
    }
    if (this._scaleVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleVar = this._scaleVar;
    }
    if (this._xPosition !== undefined) {
      hasAnyValues = true;
      internalValueResult.xPosition = this._xPosition;
    }
    if (this._xPositionVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.xPositionVar = this._xPositionVar;
    }
    if (this._yPosition !== undefined) {
      hasAnyValues = true;
      internalValueResult.yPosition = this._yPosition;
    }
    if (this._yPositionVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.yPositionVar = this._yPositionVar;
    }
    if (this._image?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeComposite | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gravity = undefined;
      this._gravityVar = undefined;
      this._placement = undefined;
      this._placementVar = undefined;
      this._scale = undefined;
      this._scaleDimension = undefined;
      this._scaleDimensionVar = undefined;
      this._scaleVar = undefined;
      this._xPosition = undefined;
      this._xPositionVar = undefined;
      this._yPosition = undefined;
      this._yPositionVar = undefined;
      this._image.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gravity = value.gravity;
      this._gravityVar = value.gravityVar;
      this._placement = value.placement;
      this._placementVar = value.placementVar;
      this._scale = value.scale;
      this._scaleDimension = value.scaleDimension;
      this._scaleDimensionVar = value.scaleDimensionVar;
      this._scaleVar = value.scaleVar;
      this._xPosition = value.xPosition;
      this._xPositionVar = value.xPositionVar;
      this._yPosition = value.yPosition;
      this._yPositionVar = value.yPositionVar;
      this._image.internalValue = value.image;
    }
  }

  // gravity - computed: false, optional: true, required: false
  private _gravity?: string; 
  public get gravity() {
    return this.getStringAttribute('gravity');
  }
  public set gravity(value: string) {
    this._gravity = value;
  }
  public resetGravity() {
    this._gravity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gravityInput() {
    return this._gravity;
  }

  // gravity_var - computed: false, optional: true, required: false
  private _gravityVar?: string; 
  public get gravityVar() {
    return this.getStringAttribute('gravity_var');
  }
  public set gravityVar(value: string) {
    this._gravityVar = value;
  }
  public resetGravityVar() {
    this._gravityVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gravityVarInput() {
    return this._gravityVar;
  }

  // placement - computed: false, optional: true, required: false
  private _placement?: string; 
  public get placement() {
    return this.getStringAttribute('placement');
  }
  public set placement(value: string) {
    this._placement = value;
  }
  public resetPlacement() {
    this._placement = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get placementInput() {
    return this._placement;
  }

  // placement_var - computed: false, optional: true, required: false
  private _placementVar?: string; 
  public get placementVar() {
    return this.getStringAttribute('placement_var');
  }
  public set placementVar(value: string) {
    this._placementVar = value;
  }
  public resetPlacementVar() {
    this._placementVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get placementVarInput() {
    return this._placementVar;
  }

  // scale - computed: false, optional: true, required: false
  private _scale?: string; 
  public get scale() {
    return this.getStringAttribute('scale');
  }
  public set scale(value: string) {
    this._scale = value;
  }
  public resetScale() {
    this._scale = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleInput() {
    return this._scale;
  }

  // scale_dimension - computed: false, optional: true, required: false
  private _scaleDimension?: string; 
  public get scaleDimension() {
    return this.getStringAttribute('scale_dimension');
  }
  public set scaleDimension(value: string) {
    this._scaleDimension = value;
  }
  public resetScaleDimension() {
    this._scaleDimension = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleDimensionInput() {
    return this._scaleDimension;
  }

  // scale_dimension_var - computed: false, optional: true, required: false
  private _scaleDimensionVar?: string; 
  public get scaleDimensionVar() {
    return this.getStringAttribute('scale_dimension_var');
  }
  public set scaleDimensionVar(value: string) {
    this._scaleDimensionVar = value;
  }
  public resetScaleDimensionVar() {
    this._scaleDimensionVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleDimensionVarInput() {
    return this._scaleDimensionVar;
  }

  // scale_var - computed: false, optional: true, required: false
  private _scaleVar?: string; 
  public get scaleVar() {
    return this.getStringAttribute('scale_var');
  }
  public set scaleVar(value: string) {
    this._scaleVar = value;
  }
  public resetScaleVar() {
    this._scaleVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleVarInput() {
    return this._scaleVar;
  }

  // x_position - computed: false, optional: true, required: false
  private _xPosition?: string; 
  public get xPosition() {
    return this.getStringAttribute('x_position');
  }
  public set xPosition(value: string) {
    this._xPosition = value;
  }
  public resetXPosition() {
    this._xPosition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xPositionInput() {
    return this._xPosition;
  }

  // x_position_var - computed: false, optional: true, required: false
  private _xPositionVar?: string; 
  public get xPositionVar() {
    return this.getStringAttribute('x_position_var');
  }
  public set xPositionVar(value: string) {
    this._xPositionVar = value;
  }
  public resetXPositionVar() {
    this._xPositionVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xPositionVarInput() {
    return this._xPositionVar;
  }

  // y_position - computed: false, optional: true, required: false
  private _yPosition?: string; 
  public get yPosition() {
    return this.getStringAttribute('y_position');
  }
  public set yPosition(value: string) {
    this._yPosition = value;
  }
  public resetYPosition() {
    this._yPosition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get yPositionInput() {
    return this._yPosition;
  }

  // y_position_var - computed: false, optional: true, required: false
  private _yPositionVar?: string; 
  public get yPositionVar() {
    return this.getStringAttribute('y_position_var');
  }
  public set yPositionVar(value: string) {
    this._yPositionVar = value;
  }
  public resetYPositionVar() {
    this._yPositionVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get yPositionVarInput() {
    return this._yPositionVar;
  }

  // image - computed: false, optional: false, required: true
  private _image = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImageOutputReference(this, "image");
  public get image() {
    return this._image;
  }
  public putImage(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeImage) {
    this._image.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeComposite[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformations {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformationsToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformationsToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformationsList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformationsOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompound {
  /**
  * transformations block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#transformations DataAkamaiImagingPolicyImage#transformations}
  */
  readonly transformations?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformations[] | cdktf.IResolvable;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompound | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    transformations: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformationsToTerraform, true)(struct!.transformations),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompound | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    transformations: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformationsToHclTerraform, true)(struct!.transformations),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformationsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompound | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._transformations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformations = this._transformations?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompound | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._transformations.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._transformations.internalValue = value.transformations;
    }
  }

  // transformations - computed: false, optional: true, required: false
  private _transformations = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformationsList(this, "transformations", false);
  public get transformations() {
    return this._transformations;
  }
  public putTransformations(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundTransformations[] | cdktf.IResolvable) {
    this._transformations.internalValue = value;
  }
  public resetTransformations() {
    this._transformations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationsInput() {
    return this._transformations.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompound[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrast {
  /**
  * Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#brightness DataAkamaiImagingPolicyImage#brightness}
  */
  readonly brightness?: string;
  /**
  * Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#brightness_var DataAkamaiImagingPolicyImage#brightness_var}
  */
  readonly brightnessVar?: string;
  /**
  * Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#contrast DataAkamaiImagingPolicyImage#contrast}
  */
  readonly contrast?: string;
  /**
  * Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#contrast_var DataAkamaiImagingPolicyImage#contrast_var}
  */
  readonly contrastVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrastToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    brightness: cdktf.stringToTerraform(struct!.brightness),
    brightness_var: cdktf.stringToTerraform(struct!.brightnessVar),
    contrast: cdktf.stringToTerraform(struct!.contrast),
    contrast_var: cdktf.stringToTerraform(struct!.contrastVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrastToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    brightness: {
      value: cdktf.stringToHclTerraform(struct!.brightness),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    brightness_var: {
      value: cdktf.stringToHclTerraform(struct!.brightnessVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    contrast: {
      value: cdktf.stringToHclTerraform(struct!.contrast),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    contrast_var: {
      value: cdktf.stringToHclTerraform(struct!.contrastVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._brightness !== undefined) {
      hasAnyValues = true;
      internalValueResult.brightness = this._brightness;
    }
    if (this._brightnessVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.brightnessVar = this._brightnessVar;
    }
    if (this._contrast !== undefined) {
      hasAnyValues = true;
      internalValueResult.contrast = this._contrast;
    }
    if (this._contrastVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.contrastVar = this._contrastVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._brightness = undefined;
      this._brightnessVar = undefined;
      this._contrast = undefined;
      this._contrastVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._brightness = value.brightness;
      this._brightnessVar = value.brightnessVar;
      this._contrast = value.contrast;
      this._contrastVar = value.contrastVar;
    }
  }

  // brightness - computed: false, optional: true, required: false
  private _brightness?: string; 
  public get brightness() {
    return this.getStringAttribute('brightness');
  }
  public set brightness(value: string) {
    this._brightness = value;
  }
  public resetBrightness() {
    this._brightness = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brightnessInput() {
    return this._brightness;
  }

  // brightness_var - computed: false, optional: true, required: false
  private _brightnessVar?: string; 
  public get brightnessVar() {
    return this.getStringAttribute('brightness_var');
  }
  public set brightnessVar(value: string) {
    this._brightnessVar = value;
  }
  public resetBrightnessVar() {
    this._brightnessVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brightnessVarInput() {
    return this._brightnessVar;
  }

  // contrast - computed: false, optional: true, required: false
  private _contrast?: string; 
  public get contrast() {
    return this.getStringAttribute('contrast');
  }
  public set contrast(value: string) {
    this._contrast = value;
  }
  public resetContrast() {
    this._contrast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contrastInput() {
    return this._contrast;
  }

  // contrast_var - computed: false, optional: true, required: false
  private _contrastVar?: string; 
  public get contrastVar() {
    return this.getStringAttribute('contrast_var');
  }
  public set contrastVar(value: string) {
    this._contrastVar = value;
  }
  public resetContrastVar() {
    this._contrastVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contrastVarInput() {
    return this._contrastVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrastList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrast[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrastOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrastOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoop {
  /**
  * Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#chaos DataAkamaiImagingPolicyImage#chaos}
  */
  readonly chaos?: string;
  /**
  * Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#chaos_var DataAkamaiImagingPolicyImage#chaos_var}
  */
  readonly chaosVar?: string;
  /**
  * Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#density DataAkamaiImagingPolicyImage#density}
  */
  readonly density?: string;
  /**
  * Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#density_var DataAkamaiImagingPolicyImage#density_var}
  */
  readonly densityVar?: string;
  /**
  * By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#power DataAkamaiImagingPolicyImage#power}
  */
  readonly power?: string;
  /**
  * By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#power_var DataAkamaiImagingPolicyImage#power_var}
  */
  readonly powerVar?: string;
  /**
  * Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#seed DataAkamaiImagingPolicyImage#seed}
  */
  readonly seed?: string;
  /**
  * Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#seed_var DataAkamaiImagingPolicyImage#seed_var}
  */
  readonly seedVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoopToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    chaos: cdktf.stringToTerraform(struct!.chaos),
    chaos_var: cdktf.stringToTerraform(struct!.chaosVar),
    density: cdktf.stringToTerraform(struct!.density),
    density_var: cdktf.stringToTerraform(struct!.densityVar),
    power: cdktf.stringToTerraform(struct!.power),
    power_var: cdktf.stringToTerraform(struct!.powerVar),
    seed: cdktf.stringToTerraform(struct!.seed),
    seed_var: cdktf.stringToTerraform(struct!.seedVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoopToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    chaos: {
      value: cdktf.stringToHclTerraform(struct!.chaos),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    chaos_var: {
      value: cdktf.stringToHclTerraform(struct!.chaosVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    density: {
      value: cdktf.stringToHclTerraform(struct!.density),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    density_var: {
      value: cdktf.stringToHclTerraform(struct!.densityVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    power: {
      value: cdktf.stringToHclTerraform(struct!.power),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    power_var: {
      value: cdktf.stringToHclTerraform(struct!.powerVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seed: {
      value: cdktf.stringToHclTerraform(struct!.seed),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seed_var: {
      value: cdktf.stringToHclTerraform(struct!.seedVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chaos !== undefined) {
      hasAnyValues = true;
      internalValueResult.chaos = this._chaos;
    }
    if (this._chaosVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.chaosVar = this._chaosVar;
    }
    if (this._density !== undefined) {
      hasAnyValues = true;
      internalValueResult.density = this._density;
    }
    if (this._densityVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.densityVar = this._densityVar;
    }
    if (this._power !== undefined) {
      hasAnyValues = true;
      internalValueResult.power = this._power;
    }
    if (this._powerVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.powerVar = this._powerVar;
    }
    if (this._seed !== undefined) {
      hasAnyValues = true;
      internalValueResult.seed = this._seed;
    }
    if (this._seedVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.seedVar = this._seedVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chaos = undefined;
      this._chaosVar = undefined;
      this._density = undefined;
      this._densityVar = undefined;
      this._power = undefined;
      this._powerVar = undefined;
      this._seed = undefined;
      this._seedVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chaos = value.chaos;
      this._chaosVar = value.chaosVar;
      this._density = value.density;
      this._densityVar = value.densityVar;
      this._power = value.power;
      this._powerVar = value.powerVar;
      this._seed = value.seed;
      this._seedVar = value.seedVar;
    }
  }

  // chaos - computed: false, optional: true, required: false
  private _chaos?: string; 
  public get chaos() {
    return this.getStringAttribute('chaos');
  }
  public set chaos(value: string) {
    this._chaos = value;
  }
  public resetChaos() {
    this._chaos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chaosInput() {
    return this._chaos;
  }

  // chaos_var - computed: false, optional: true, required: false
  private _chaosVar?: string; 
  public get chaosVar() {
    return this.getStringAttribute('chaos_var');
  }
  public set chaosVar(value: string) {
    this._chaosVar = value;
  }
  public resetChaosVar() {
    this._chaosVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chaosVarInput() {
    return this._chaosVar;
  }

  // density - computed: false, optional: true, required: false
  private _density?: string; 
  public get density() {
    return this.getStringAttribute('density');
  }
  public set density(value: string) {
    this._density = value;
  }
  public resetDensity() {
    this._density = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get densityInput() {
    return this._density;
  }

  // density_var - computed: false, optional: true, required: false
  private _densityVar?: string; 
  public get densityVar() {
    return this.getStringAttribute('density_var');
  }
  public set densityVar(value: string) {
    this._densityVar = value;
  }
  public resetDensityVar() {
    this._densityVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get densityVarInput() {
    return this._densityVar;
  }

  // power - computed: false, optional: true, required: false
  private _power?: string; 
  public get power() {
    return this.getStringAttribute('power');
  }
  public set power(value: string) {
    this._power = value;
  }
  public resetPower() {
    this._power = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get powerInput() {
    return this._power;
  }

  // power_var - computed: false, optional: true, required: false
  private _powerVar?: string; 
  public get powerVar() {
    return this.getStringAttribute('power_var');
  }
  public set powerVar(value: string) {
    this._powerVar = value;
  }
  public resetPowerVar() {
    this._powerVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get powerVarInput() {
    return this._powerVar;
  }

  // seed - computed: false, optional: true, required: false
  private _seed?: string; 
  public get seed() {
    return this.getStringAttribute('seed');
  }
  public set seed(value: string) {
    this._seed = value;
  }
  public resetSeed() {
    this._seed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seedInput() {
    return this._seed;
  }

  // seed_var - computed: false, optional: true, required: false
  private _seedVar?: string; 
  public get seedVar() {
    return this.getStringAttribute('seed_var');
  }
  public set seedVar(value: string) {
    this._seedVar = value;
  }
  public resetSeedVar() {
    this._seedVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seedVarInput() {
    return this._seedVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoopList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoop[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoopOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoopOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscale {
  /**
  * The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#type DataAkamaiImagingPolicyImage#type}
  */
  readonly type?: string;
  /**
  * The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#type_var DataAkamaiImagingPolicyImage#type_var}
  */
  readonly typeVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscaleToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscale | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    type_var: cdktf.stringToTerraform(struct!.typeVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscaleToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscale | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type_var: {
      value: cdktf.stringToHclTerraform(struct!.typeVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscaleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscale | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._typeVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.typeVar = this._typeVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscale | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._typeVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._typeVar = value.typeVar;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // type_var - computed: false, optional: true, required: false
  private _typeVar?: string; 
  public get typeVar() {
    return this.getStringAttribute('type_var');
  }
  public set typeVar(value: string) {
    this._typeVar = value;
  }
  public resetTypeVar() {
    this._typeVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeVarInput() {
    return this._typeVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscaleList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscale[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscaleOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscaleOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsl {
  /**
  * The number of degrees to rotate colors around the color wheel, `0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * The number of degrees to rotate colors around the color wheel, `0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
  /**
  * A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness DataAkamaiImagingPolicyImage#lightness}
  */
  readonly lightness?: string;
  /**
  * A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_var DataAkamaiImagingPolicyImage#lightness_var}
  */
  readonly lightnessVar?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation DataAkamaiImagingPolicyImage#saturation}
  */
  readonly saturation?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_var DataAkamaiImagingPolicyImage#saturation_var}
  */
  readonly saturationVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHslToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
    lightness: cdktf.stringToTerraform(struct!.lightness),
    lightness_var: cdktf.stringToTerraform(struct!.lightnessVar),
    saturation: cdktf.stringToTerraform(struct!.saturation),
    saturation_var: cdktf.stringToTerraform(struct!.saturationVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHslToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness: {
      value: cdktf.stringToHclTerraform(struct!.lightness),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_var: {
      value: cdktf.stringToHclTerraform(struct!.lightnessVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation: {
      value: cdktf.stringToHclTerraform(struct!.saturation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    if (this._lightness !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightness = this._lightness;
    }
    if (this._lightnessVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessVar = this._lightnessVar;
    }
    if (this._saturation !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturation = this._saturation;
    }
    if (this._saturationVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationVar = this._saturationVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueVar = undefined;
      this._lightness = undefined;
      this._lightnessVar = undefined;
      this._saturation = undefined;
      this._saturationVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueVar = value.hueVar;
      this._lightness = value.lightness;
      this._lightnessVar = value.lightnessVar;
      this._saturation = value.saturation;
      this._saturationVar = value.saturationVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }

  // lightness - computed: false, optional: true, required: false
  private _lightness?: string; 
  public get lightness() {
    return this.getStringAttribute('lightness');
  }
  public set lightness(value: string) {
    this._lightness = value;
  }
  public resetLightness() {
    this._lightness = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessInput() {
    return this._lightness;
  }

  // lightness_var - computed: false, optional: true, required: false
  private _lightnessVar?: string; 
  public get lightnessVar() {
    return this.getStringAttribute('lightness_var');
  }
  public set lightnessVar(value: string) {
    this._lightnessVar = value;
  }
  public resetLightnessVar() {
    this._lightnessVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessVarInput() {
    return this._lightnessVar;
  }

  // saturation - computed: false, optional: true, required: false
  private _saturation?: string; 
  public get saturation() {
    return this.getStringAttribute('saturation');
  }
  public set saturation(value: string) {
    this._saturation = value;
  }
  public resetSaturation() {
    this._saturation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationInput() {
    return this._saturation;
  }

  // saturation_var - computed: false, optional: true, required: false
  private _saturationVar?: string; 
  public get saturationVar() {
    return this.getStringAttribute('saturation_var');
  }
  public set saturationVar(value: string) {
    this._saturationVar = value;
  }
  public resetSaturationVar() {
    this._saturationVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationVarInput() {
    return this._saturationVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHslList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsl[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHslOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHslOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsv {
  /**
  * The number of degrees to rotate colors around the color wheel, `0.0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * The number of degrees to rotate colors around the color wheel, `0.0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation DataAkamaiImagingPolicyImage#saturation}
  */
  readonly saturation?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_var DataAkamaiImagingPolicyImage#saturation_var}
  */
  readonly saturationVar?: string;
  /**
  * A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value DataAkamaiImagingPolicyImage#value}
  */
  readonly value?: string;
  /**
  * A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value_var DataAkamaiImagingPolicyImage#value_var}
  */
  readonly valueVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsvToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
    saturation: cdktf.stringToTerraform(struct!.saturation),
    saturation_var: cdktf.stringToTerraform(struct!.saturationVar),
    value: cdktf.stringToTerraform(struct!.value),
    value_var: cdktf.stringToTerraform(struct!.valueVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsvToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation: {
      value: cdktf.stringToHclTerraform(struct!.saturation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_var: {
      value: cdktf.stringToHclTerraform(struct!.valueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    if (this._saturation !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturation = this._saturation;
    }
    if (this._saturationVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationVar = this._saturationVar;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueVar = this._valueVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueVar = undefined;
      this._saturation = undefined;
      this._saturationVar = undefined;
      this._value = undefined;
      this._valueVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueVar = value.hueVar;
      this._saturation = value.saturation;
      this._saturationVar = value.saturationVar;
      this._value = value.value;
      this._valueVar = value.valueVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }

  // saturation - computed: false, optional: true, required: false
  private _saturation?: string; 
  public get saturation() {
    return this.getStringAttribute('saturation');
  }
  public set saturation(value: string) {
    this._saturation = value;
  }
  public resetSaturation() {
    this._saturation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationInput() {
    return this._saturation;
  }

  // saturation_var - computed: false, optional: true, required: false
  private _saturationVar?: string; 
  public get saturationVar() {
    return this.getStringAttribute('saturation_var');
  }
  public set saturationVar(value: string) {
    this._saturationVar = value;
  }
  public resetSaturationVar() {
    this._saturationVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationVarInput() {
    return this._saturationVar;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_var - computed: false, optional: true, required: false
  private _valueVar?: string; 
  public get valueVar() {
    return this.getStringAttribute('value_var');
  }
  public set valueVar(value: string) {
    this._valueVar = value;
  }
  public resetValueVar() {
    this._valueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueVarInput() {
    return this._valueVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsvList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsvOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefault {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefaultToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefaultToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefaultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefault | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefault | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqual {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqualToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqualOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqual): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqualToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqualOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqual): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqualOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqual | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqual | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThan {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThanToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThanOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThan): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThanToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThanOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThan): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThanOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThan | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThan | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThan {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThanToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThanOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThan): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThanToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThanOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThan): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThanOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThan | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThan | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimension {
  /**
  * The dimension to use to select the transformation, either `height`, `width`, or `both`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#dimension DataAkamaiImagingPolicyImage#dimension}
  */
  readonly dimension?: string;
  /**
  * The dimension to use to select the transformation, either `height`, `width`, or `both`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#dimension_var DataAkamaiImagingPolicyImage#dimension_var}
  */
  readonly dimensionVar?: string;
  /**
  * The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value DataAkamaiImagingPolicyImage#value}
  */
  readonly value?: string;
  /**
  * The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value_var DataAkamaiImagingPolicyImage#value_var}
  */
  readonly valueVar?: string;
  /**
  * default block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#default DataAkamaiImagingPolicyImage#default}
  */
  readonly default?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefault;
  /**
  * equal block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#equal DataAkamaiImagingPolicyImage#equal}
  */
  readonly equal?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqual;
  /**
  * greater_than block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#greater_than DataAkamaiImagingPolicyImage#greater_than}
  */
  readonly greaterThan?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThan;
  /**
  * less_than block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#less_than DataAkamaiImagingPolicyImage#less_than}
  */
  readonly lessThan?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThan;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimension | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dimension: cdktf.stringToTerraform(struct!.dimension),
    dimension_var: cdktf.stringToTerraform(struct!.dimensionVar),
    value: cdktf.stringToTerraform(struct!.value),
    value_var: cdktf.stringToTerraform(struct!.valueVar),
    default: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefaultToTerraform(struct!.default),
    equal: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqualToTerraform(struct!.equal),
    greater_than: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThanToTerraform(struct!.greaterThan),
    less_than: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThanToTerraform(struct!.lessThan),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimension | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dimension: {
      value: cdktf.stringToHclTerraform(struct!.dimension),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dimension_var: {
      value: cdktf.stringToHclTerraform(struct!.dimensionVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_var: {
      value: cdktf.stringToHclTerraform(struct!.valueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefaultToHclTerraform(struct!.default),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefaultList",
    },
    equal: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqualToHclTerraform(struct!.equal),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqualList",
    },
    greater_than: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThanToHclTerraform(struct!.greaterThan),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThanList",
    },
    less_than: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThanToHclTerraform(struct!.lessThan),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThanList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimension | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dimension !== undefined) {
      hasAnyValues = true;
      internalValueResult.dimension = this._dimension;
    }
    if (this._dimensionVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.dimensionVar = this._dimensionVar;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueVar = this._valueVar;
    }
    if (this._default?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default?.internalValue;
    }
    if (this._equal?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.equal = this._equal?.internalValue;
    }
    if (this._greaterThan?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.greaterThan = this._greaterThan?.internalValue;
    }
    if (this._lessThan?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lessThan = this._lessThan?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimension | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dimension = undefined;
      this._dimensionVar = undefined;
      this._value = undefined;
      this._valueVar = undefined;
      this._default.internalValue = undefined;
      this._equal.internalValue = undefined;
      this._greaterThan.internalValue = undefined;
      this._lessThan.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dimension = value.dimension;
      this._dimensionVar = value.dimensionVar;
      this._value = value.value;
      this._valueVar = value.valueVar;
      this._default.internalValue = value.default;
      this._equal.internalValue = value.equal;
      this._greaterThan.internalValue = value.greaterThan;
      this._lessThan.internalValue = value.lessThan;
    }
  }

  // dimension - computed: false, optional: true, required: false
  private _dimension?: string; 
  public get dimension() {
    return this.getStringAttribute('dimension');
  }
  public set dimension(value: string) {
    this._dimension = value;
  }
  public resetDimension() {
    this._dimension = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dimensionInput() {
    return this._dimension;
  }

  // dimension_var - computed: false, optional: true, required: false
  private _dimensionVar?: string; 
  public get dimensionVar() {
    return this.getStringAttribute('dimension_var');
  }
  public set dimensionVar(value: string) {
    this._dimensionVar = value;
  }
  public resetDimensionVar() {
    this._dimensionVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dimensionVarInput() {
    return this._dimensionVar;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_var - computed: false, optional: true, required: false
  private _valueVar?: string; 
  public get valueVar() {
    return this.getStringAttribute('value_var');
  }
  public set valueVar(value: string) {
    this._valueVar = value;
  }
  public resetValueVar() {
    this._valueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueVarInput() {
    return this._valueVar;
  }

  // default - computed: false, optional: true, required: false
  private _default = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefaultOutputReference(this, "default");
  public get default() {
    return this._default;
  }
  public putDefault(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionDefault) {
    this._default.internalValue = value;
  }
  public resetDefault() {
    this._default.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default.internalValue;
  }

  // equal - computed: false, optional: true, required: false
  private _equal = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqualOutputReference(this, "equal");
  public get equal() {
    return this._equal;
  }
  public putEqual(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionEqual) {
    this._equal.internalValue = value;
  }
  public resetEqual() {
    this._equal.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get equalInput() {
    return this._equal.internalValue;
  }

  // greater_than - computed: false, optional: true, required: false
  private _greaterThan = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThanOutputReference(this, "greater_than");
  public get greaterThan() {
    return this._greaterThan;
  }
  public putGreaterThan(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionGreaterThan) {
    this._greaterThan.internalValue = value;
  }
  public resetGreaterThan() {
    this._greaterThan.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get greaterThanInput() {
    return this._greaterThan.internalValue;
  }

  // less_than - computed: false, optional: true, required: false
  private _lessThan = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThanOutputReference(this, "less_than");
  public get lessThan() {
    return this._lessThan;
  }
  public putLessThan(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionLessThan) {
    this._lessThan.internalValue = value;
  }
  public resetLessThan() {
    this._lessThan.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lessThanInput() {
    return this._lessThan.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimension[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefault {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefaultToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefaultToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefaultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefault | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefault | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscape {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscapeToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscapeOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscape): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscapeToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscapeOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscape): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscapeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscape | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscape | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortrait {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortraitToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortraitOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortrait): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortraitToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortraitOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortrait): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortraitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortrait | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortrait | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquare {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquareToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquareOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquare): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquareToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquareOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquare): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquareOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquare | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquare | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientation {
  /**
  * default block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#default DataAkamaiImagingPolicyImage#default}
  */
  readonly default?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefault;
  /**
  * landscape block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#landscape DataAkamaiImagingPolicyImage#landscape}
  */
  readonly landscape?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscape;
  /**
  * portrait block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#portrait DataAkamaiImagingPolicyImage#portrait}
  */
  readonly portrait?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortrait;
  /**
  * square block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#square DataAkamaiImagingPolicyImage#square}
  */
  readonly square?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquare;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefaultToTerraform(struct!.default),
    landscape: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscapeToTerraform(struct!.landscape),
    portrait: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortraitToTerraform(struct!.portrait),
    square: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquareToTerraform(struct!.square),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefaultToHclTerraform(struct!.default),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefaultList",
    },
    landscape: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscapeToHclTerraform(struct!.landscape),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscapeList",
    },
    portrait: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortraitToHclTerraform(struct!.portrait),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortraitList",
    },
    square: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquareToHclTerraform(struct!.square),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquareList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._default?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default?.internalValue;
    }
    if (this._landscape?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.landscape = this._landscape?.internalValue;
    }
    if (this._portrait?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.portrait = this._portrait?.internalValue;
    }
    if (this._square?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.square = this._square?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._default.internalValue = undefined;
      this._landscape.internalValue = undefined;
      this._portrait.internalValue = undefined;
      this._square.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._default.internalValue = value.default;
      this._landscape.internalValue = value.landscape;
      this._portrait.internalValue = value.portrait;
      this._square.internalValue = value.square;
    }
  }

  // default - computed: false, optional: true, required: false
  private _default = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefaultOutputReference(this, "default");
  public get default() {
    return this._default;
  }
  public putDefault(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationDefault) {
    this._default.internalValue = value;
  }
  public resetDefault() {
    this._default.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default.internalValue;
  }

  // landscape - computed: false, optional: true, required: false
  private _landscape = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscapeOutputReference(this, "landscape");
  public get landscape() {
    return this._landscape;
  }
  public putLandscape(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationLandscape) {
    this._landscape.internalValue = value;
  }
  public resetLandscape() {
    this._landscape.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get landscapeInput() {
    return this._landscape.internalValue;
  }

  // portrait - computed: false, optional: true, required: false
  private _portrait = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortraitOutputReference(this, "portrait");
  public get portrait() {
    return this._portrait;
  }
  public putPortrait(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationPortrait) {
    this._portrait.internalValue = value;
  }
  public resetPortrait() {
    this._portrait.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portraitInput() {
    return this._portrait.internalValue;
  }

  // square - computed: false, optional: true, required: false
  private _square = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquareOutputReference(this, "square");
  public get square() {
    return this._square;
  }
  public putSquare(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationSquare) {
    this._square.internalValue = value;
  }
  public resetSquare() {
    this._square.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get squareInput() {
    return this._square.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientation[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColors {
  /**
  * The value representing the maximum number of colors to use with the source image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#colors DataAkamaiImagingPolicyImage#colors}
  */
  readonly colors?: string;
  /**
  * The value representing the maximum number of colors to use with the source image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#colors_var DataAkamaiImagingPolicyImage#colors_var}
  */
  readonly colorsVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColorsToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    colors: cdktf.stringToTerraform(struct!.colors),
    colors_var: cdktf.stringToTerraform(struct!.colorsVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColorsToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    colors: {
      value: cdktf.stringToHclTerraform(struct!.colors),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    colors_var: {
      value: cdktf.stringToHclTerraform(struct!.colorsVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._colors !== undefined) {
      hasAnyValues = true;
      internalValueResult.colors = this._colors;
    }
    if (this._colorsVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorsVar = this._colorsVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._colors = undefined;
      this._colorsVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._colors = value.colors;
      this._colorsVar = value.colorsVar;
    }
  }

  // colors - computed: false, optional: true, required: false
  private _colors?: string; 
  public get colors() {
    return this.getStringAttribute('colors');
  }
  public set colors(value: string) {
    this._colors = value;
  }
  public resetColors() {
    this._colors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorsInput() {
    return this._colors;
  }

  // colors_var - computed: false, optional: true, required: false
  private _colorsVar?: string; 
  public get colorsVar() {
    return this.getStringAttribute('colors_var');
  }
  public set colorsVar(value: string) {
    this._colorsVar = value;
  }
  public resetColorsVar() {
    this._colorsVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorsVarInput() {
    return this._colorsVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColorsList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColorsOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirror {
  /**
  * Flips the image horizontally.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#horizontal DataAkamaiImagingPolicyImage#horizontal}
  */
  readonly horizontal?: string;
  /**
  * Flips the image horizontally.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#horizontal_var DataAkamaiImagingPolicyImage#horizontal_var}
  */
  readonly horizontalVar?: string;
  /**
  * Flips the image vertically.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#vertical DataAkamaiImagingPolicyImage#vertical}
  */
  readonly vertical?: string;
  /**
  * Flips the image vertically.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#vertical_var DataAkamaiImagingPolicyImage#vertical_var}
  */
  readonly verticalVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirrorToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirror | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    horizontal: cdktf.stringToTerraform(struct!.horizontal),
    horizontal_var: cdktf.stringToTerraform(struct!.horizontalVar),
    vertical: cdktf.stringToTerraform(struct!.vertical),
    vertical_var: cdktf.stringToTerraform(struct!.verticalVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirrorToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirror | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    horizontal: {
      value: cdktf.stringToHclTerraform(struct!.horizontal),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    horizontal_var: {
      value: cdktf.stringToHclTerraform(struct!.horizontalVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vertical: {
      value: cdktf.stringToHclTerraform(struct!.vertical),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vertical_var: {
      value: cdktf.stringToHclTerraform(struct!.verticalVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirrorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirror | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._horizontal !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontal = this._horizontal;
    }
    if (this._horizontalVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalVar = this._horizontalVar;
    }
    if (this._vertical !== undefined) {
      hasAnyValues = true;
      internalValueResult.vertical = this._vertical;
    }
    if (this._verticalVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.verticalVar = this._verticalVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirror | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._horizontal = undefined;
      this._horizontalVar = undefined;
      this._vertical = undefined;
      this._verticalVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._horizontal = value.horizontal;
      this._horizontalVar = value.horizontalVar;
      this._vertical = value.vertical;
      this._verticalVar = value.verticalVar;
    }
  }

  // horizontal - computed: false, optional: true, required: false
  private _horizontal?: string; 
  public get horizontal() {
    return this.getStringAttribute('horizontal');
  }
  public set horizontal(value: string) {
    this._horizontal = value;
  }
  public resetHorizontal() {
    this._horizontal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalInput() {
    return this._horizontal;
  }

  // horizontal_var - computed: false, optional: true, required: false
  private _horizontalVar?: string; 
  public get horizontalVar() {
    return this.getStringAttribute('horizontal_var');
  }
  public set horizontalVar(value: string) {
    this._horizontalVar = value;
  }
  public resetHorizontalVar() {
    this._horizontalVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalVarInput() {
    return this._horizontalVar;
  }

  // vertical - computed: false, optional: true, required: false
  private _vertical?: string; 
  public get vertical() {
    return this.getStringAttribute('vertical');
  }
  public set vertical(value: string) {
    this._vertical = value;
  }
  public resetVertical() {
    this._vertical = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verticalInput() {
    return this._vertical;
  }

  // vertical_var - computed: false, optional: true, required: false
  private _verticalVar?: string; 
  public get verticalVar() {
    return this.getStringAttribute('vertical_var');
  }
  public set verticalVar(value: string) {
    this._verticalVar = value;
  }
  public resetVerticalVar() {
    this._verticalVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verticalVarInput() {
    return this._verticalVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirrorList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirror[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirrorOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirrorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHue {
  /**
  * Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHueToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHueToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueVar = value.hueVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHueList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHue[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHueOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHueOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacity {
  /**
  * Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#opacity DataAkamaiImagingPolicyImage#opacity}
  */
  readonly opacity?: string;
  /**
  * Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#opacity_var DataAkamaiImagingPolicyImage#opacity_var}
  */
  readonly opacityVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacityToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    opacity: cdktf.stringToTerraform(struct!.opacity),
    opacity_var: cdktf.stringToTerraform(struct!.opacityVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacityToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    opacity: {
      value: cdktf.stringToHclTerraform(struct!.opacity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    opacity_var: {
      value: cdktf.stringToHclTerraform(struct!.opacityVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._opacity !== undefined) {
      hasAnyValues = true;
      internalValueResult.opacity = this._opacity;
    }
    if (this._opacityVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.opacityVar = this._opacityVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._opacity = undefined;
      this._opacityVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._opacity = value.opacity;
      this._opacityVar = value.opacityVar;
    }
  }

  // opacity - computed: false, optional: true, required: false
  private _opacity?: string; 
  public get opacity() {
    return this.getStringAttribute('opacity');
  }
  public set opacity(value: string) {
    this._opacity = value;
  }
  public resetOpacity() {
    this._opacity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opacityInput() {
    return this._opacity;
  }

  // opacity_var - computed: false, optional: true, required: false
  private _opacityVar?: string; 
  public get opacityVar() {
    return this.getStringAttribute('opacity_var');
  }
  public set opacityVar(value: string) {
    this._opacityVar = value;
  }
  public resetOpacityVar() {
    this._opacityVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opacityVarInput() {
    return this._opacityVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacityList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacity[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacityOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacityOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColor {
  /**
  * The hexadecimal CSS color value to remove.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color DataAkamaiImagingPolicyImage#color}
  */
  readonly color?: string;
  /**
  * The hexadecimal CSS color value to remove.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color_var DataAkamaiImagingPolicyImage#color_var}
  */
  readonly colorVar?: string;
  /**
  * The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#feather DataAkamaiImagingPolicyImage#feather}
  */
  readonly feather?: string;
  /**
  * The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#feather_var DataAkamaiImagingPolicyImage#feather_var}
  */
  readonly featherVar?: string;
  /**
  * The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#tolerance DataAkamaiImagingPolicyImage#tolerance}
  */
  readonly tolerance?: string;
  /**
  * The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#tolerance_var DataAkamaiImagingPolicyImage#tolerance_var}
  */
  readonly toleranceVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColorToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    color: cdktf.stringToTerraform(struct!.color),
    color_var: cdktf.stringToTerraform(struct!.colorVar),
    feather: cdktf.stringToTerraform(struct!.feather),
    feather_var: cdktf.stringToTerraform(struct!.featherVar),
    tolerance: cdktf.stringToTerraform(struct!.tolerance),
    tolerance_var: cdktf.stringToTerraform(struct!.toleranceVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColorToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    color_var: {
      value: cdktf.stringToHclTerraform(struct!.colorVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    feather: {
      value: cdktf.stringToHclTerraform(struct!.feather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    feather_var: {
      value: cdktf.stringToHclTerraform(struct!.featherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tolerance: {
      value: cdktf.stringToHclTerraform(struct!.tolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.toleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._colorVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorVar = this._colorVar;
    }
    if (this._feather !== undefined) {
      hasAnyValues = true;
      internalValueResult.feather = this._feather;
    }
    if (this._featherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.featherVar = this._featherVar;
    }
    if (this._tolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerance = this._tolerance;
    }
    if (this._toleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.toleranceVar = this._toleranceVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._color = undefined;
      this._colorVar = undefined;
      this._feather = undefined;
      this._featherVar = undefined;
      this._tolerance = undefined;
      this._toleranceVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._color = value.color;
      this._colorVar = value.colorVar;
      this._feather = value.feather;
      this._featherVar = value.featherVar;
      this._tolerance = value.tolerance;
      this._toleranceVar = value.toleranceVar;
    }
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // color_var - computed: false, optional: true, required: false
  private _colorVar?: string; 
  public get colorVar() {
    return this.getStringAttribute('color_var');
  }
  public set colorVar(value: string) {
    this._colorVar = value;
  }
  public resetColorVar() {
    this._colorVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorVarInput() {
    return this._colorVar;
  }

  // feather - computed: false, optional: true, required: false
  private _feather?: string; 
  public get feather() {
    return this.getStringAttribute('feather');
  }
  public set feather(value: string) {
    this._feather = value;
  }
  public resetFeather() {
    this._feather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featherInput() {
    return this._feather;
  }

  // feather_var - computed: false, optional: true, required: false
  private _featherVar?: string; 
  public get featherVar() {
    return this.getStringAttribute('feather_var');
  }
  public set featherVar(value: string) {
    this._featherVar = value;
  }
  public resetFeatherVar() {
    this._featherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featherVarInput() {
    return this._featherVar;
  }

  // tolerance - computed: false, optional: true, required: false
  private _tolerance?: string; 
  public get tolerance() {
    return this.getStringAttribute('tolerance');
  }
  public set tolerance(value: string) {
    this._tolerance = value;
  }
  public resetTolerance() {
    this._tolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toleranceInput() {
    return this._tolerance;
  }

  // tolerance_var - computed: false, optional: true, required: false
  private _toleranceVar?: string; 
  public get toleranceVar() {
    return this.getStringAttribute('tolerance_var');
  }
  public set toleranceVar(value: string) {
    this._toleranceVar = value;
  }
  public resetToleranceVar() {
    this._toleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toleranceVarInput() {
    return this._toleranceVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColorList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColor[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColorOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMask {
  /**
  * Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gain DataAkamaiImagingPolicyImage#gain}
  */
  readonly gain?: string;
  /**
  * Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gain_var DataAkamaiImagingPolicyImage#gain_var}
  */
  readonly gainVar?: string;
  /**
  * The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma DataAkamaiImagingPolicyImage#sigma}
  */
  readonly sigma?: string;
  /**
  * The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma_var DataAkamaiImagingPolicyImage#sigma_var}
  */
  readonly sigmaVar?: string;
  /**
  * Set the minimum change required to include a detail in the filter. Higher values discard more changes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#threshold DataAkamaiImagingPolicyImage#threshold}
  */
  readonly threshold?: string;
  /**
  * Set the minimum change required to include a detail in the filter. Higher values discard more changes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#threshold_var DataAkamaiImagingPolicyImage#threshold_var}
  */
  readonly thresholdVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMaskToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMask | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gain: cdktf.stringToTerraform(struct!.gain),
    gain_var: cdktf.stringToTerraform(struct!.gainVar),
    sigma: cdktf.stringToTerraform(struct!.sigma),
    sigma_var: cdktf.stringToTerraform(struct!.sigmaVar),
    threshold: cdktf.stringToTerraform(struct!.threshold),
    threshold_var: cdktf.stringToTerraform(struct!.thresholdVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMaskToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMask | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gain: {
      value: cdktf.stringToHclTerraform(struct!.gain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gain_var: {
      value: cdktf.stringToHclTerraform(struct!.gainVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sigma: {
      value: cdktf.stringToHclTerraform(struct!.sigma),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sigma_var: {
      value: cdktf.stringToHclTerraform(struct!.sigmaVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threshold: {
      value: cdktf.stringToHclTerraform(struct!.threshold),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threshold_var: {
      value: cdktf.stringToHclTerraform(struct!.thresholdVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMaskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMask | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gain !== undefined) {
      hasAnyValues = true;
      internalValueResult.gain = this._gain;
    }
    if (this._gainVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.gainVar = this._gainVar;
    }
    if (this._sigma !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigma = this._sigma;
    }
    if (this._sigmaVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigmaVar = this._sigmaVar;
    }
    if (this._threshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.threshold = this._threshold;
    }
    if (this._thresholdVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.thresholdVar = this._thresholdVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMask | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gain = undefined;
      this._gainVar = undefined;
      this._sigma = undefined;
      this._sigmaVar = undefined;
      this._threshold = undefined;
      this._thresholdVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gain = value.gain;
      this._gainVar = value.gainVar;
      this._sigma = value.sigma;
      this._sigmaVar = value.sigmaVar;
      this._threshold = value.threshold;
      this._thresholdVar = value.thresholdVar;
    }
  }

  // gain - computed: false, optional: true, required: false
  private _gain?: string; 
  public get gain() {
    return this.getStringAttribute('gain');
  }
  public set gain(value: string) {
    this._gain = value;
  }
  public resetGain() {
    this._gain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gainInput() {
    return this._gain;
  }

  // gain_var - computed: false, optional: true, required: false
  private _gainVar?: string; 
  public get gainVar() {
    return this.getStringAttribute('gain_var');
  }
  public set gainVar(value: string) {
    this._gainVar = value;
  }
  public resetGainVar() {
    this._gainVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gainVarInput() {
    return this._gainVar;
  }

  // sigma - computed: false, optional: true, required: false
  private _sigma?: string; 
  public get sigma() {
    return this.getStringAttribute('sigma');
  }
  public set sigma(value: string) {
    this._sigma = value;
  }
  public resetSigma() {
    this._sigma = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaInput() {
    return this._sigma;
  }

  // sigma_var - computed: false, optional: true, required: false
  private _sigmaVar?: string; 
  public get sigmaVar() {
    return this.getStringAttribute('sigma_var');
  }
  public set sigmaVar(value: string) {
    this._sigmaVar = value;
  }
  public resetSigmaVar() {
    this._sigmaVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaVarInput() {
    return this._sigmaVar;
  }

  // threshold - computed: false, optional: true, required: false
  private _threshold?: string; 
  public get threshold() {
    return this.getStringAttribute('threshold');
  }
  public set threshold(value: string) {
    this._threshold = value;
  }
  public resetThreshold() {
    this._threshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdInput() {
    return this._threshold;
  }

  // threshold_var - computed: false, optional: true, required: false
  private _thresholdVar?: string; 
  public get thresholdVar() {
    return this.getStringAttribute('threshold_var');
  }
  public set thresholdVar(value: string) {
    this._thresholdVar = value;
  }
  public resetThresholdVar() {
    this._thresholdVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdVarInput() {
    return this._thresholdVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMaskList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMask[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMaskOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMaskOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscape {
  /**
  * background_color block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#background_color DataAkamaiImagingPolicyImage#background_color}
  */
  readonly backgroundColor?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColor[] | cdktf.IResolvable;
  /**
  * blur block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#blur DataAkamaiImagingPolicyImage#blur}
  */
  readonly blur?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlur[] | cdktf.IResolvable;
  /**
  * chroma_key block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#chroma_key DataAkamaiImagingPolicyImage#chroma_key}
  */
  readonly chromaKey?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKey[] | cdktf.IResolvable;
  /**
  * composite block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#composite DataAkamaiImagingPolicyImage#composite}
  */
  readonly composite?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeComposite[] | cdktf.IResolvable;
  /**
  * compound block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#compound DataAkamaiImagingPolicyImage#compound}
  */
  readonly compound?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompound[] | cdktf.IResolvable;
  /**
  * contrast block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#contrast DataAkamaiImagingPolicyImage#contrast}
  */
  readonly contrast?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrast[] | cdktf.IResolvable;
  /**
  * goop block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#goop DataAkamaiImagingPolicyImage#goop}
  */
  readonly goop?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoop[] | cdktf.IResolvable;
  /**
  * grayscale block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#grayscale DataAkamaiImagingPolicyImage#grayscale}
  */
  readonly grayscale?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscale[] | cdktf.IResolvable;
  /**
  * hsl block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hsl DataAkamaiImagingPolicyImage#hsl}
  */
  readonly hsl?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsl[] | cdktf.IResolvable;
  /**
  * hsv block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hsv DataAkamaiImagingPolicyImage#hsv}
  */
  readonly hsv?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsv[] | cdktf.IResolvable;
  /**
  * if_dimension block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#if_dimension DataAkamaiImagingPolicyImage#if_dimension}
  */
  readonly ifDimension?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimension[] | cdktf.IResolvable;
  /**
  * if_orientation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#if_orientation DataAkamaiImagingPolicyImage#if_orientation}
  */
  readonly ifOrientation?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientation[] | cdktf.IResolvable;
  /**
  * max_colors block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#max_colors DataAkamaiImagingPolicyImage#max_colors}
  */
  readonly maxColors?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColors[] | cdktf.IResolvable;
  /**
  * mirror block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#mirror DataAkamaiImagingPolicyImage#mirror}
  */
  readonly mirror?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirror[] | cdktf.IResolvable;
  /**
  * mono_hue block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#mono_hue DataAkamaiImagingPolicyImage#mono_hue}
  */
  readonly monoHue?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHue[] | cdktf.IResolvable;
  /**
  * opacity block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#opacity DataAkamaiImagingPolicyImage#opacity}
  */
  readonly opacity?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacity[] | cdktf.IResolvable;
  /**
  * remove_color block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#remove_color DataAkamaiImagingPolicyImage#remove_color}
  */
  readonly removeColor?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColor[] | cdktf.IResolvable;
  /**
  * unsharp_mask block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#unsharp_mask DataAkamaiImagingPolicyImage#unsharp_mask}
  */
  readonly unsharpMask?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMask[] | cdktf.IResolvable;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscape): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    background_color: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColorToTerraform, true)(struct!.backgroundColor),
    blur: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlurToTerraform, true)(struct!.blur),
    chroma_key: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKeyToTerraform, true)(struct!.chromaKey),
    composite: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeToTerraform, true)(struct!.composite),
    compound: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundToTerraform, true)(struct!.compound),
    contrast: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrastToTerraform, true)(struct!.contrast),
    goop: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoopToTerraform, true)(struct!.goop),
    grayscale: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscaleToTerraform, true)(struct!.grayscale),
    hsl: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHslToTerraform, true)(struct!.hsl),
    hsv: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsvToTerraform, true)(struct!.hsv),
    if_dimension: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionToTerraform, true)(struct!.ifDimension),
    if_orientation: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationToTerraform, true)(struct!.ifOrientation),
    max_colors: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColorsToTerraform, true)(struct!.maxColors),
    mirror: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirrorToTerraform, true)(struct!.mirror),
    mono_hue: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHueToTerraform, true)(struct!.monoHue),
    opacity: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacityToTerraform, true)(struct!.opacity),
    remove_color: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColorToTerraform, true)(struct!.removeColor),
    unsharp_mask: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMaskToTerraform, true)(struct!.unsharpMask),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscape): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    background_color: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColorToHclTerraform, true)(struct!.backgroundColor),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColorList",
    },
    blur: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlurToHclTerraform, true)(struct!.blur),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlurList",
    },
    chroma_key: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKeyToHclTerraform, true)(struct!.chromaKey),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKeyList",
    },
    composite: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeToHclTerraform, true)(struct!.composite),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeList",
    },
    compound: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundToHclTerraform, true)(struct!.compound),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundList",
    },
    contrast: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrastToHclTerraform, true)(struct!.contrast),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrastList",
    },
    goop: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoopToHclTerraform, true)(struct!.goop),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoopList",
    },
    grayscale: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscaleToHclTerraform, true)(struct!.grayscale),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscaleList",
    },
    hsl: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHslToHclTerraform, true)(struct!.hsl),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHslList",
    },
    hsv: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsvToHclTerraform, true)(struct!.hsv),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsvList",
    },
    if_dimension: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionToHclTerraform, true)(struct!.ifDimension),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionList",
    },
    if_orientation: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationToHclTerraform, true)(struct!.ifOrientation),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationList",
    },
    max_colors: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColorsToHclTerraform, true)(struct!.maxColors),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColorsList",
    },
    mirror: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirrorToHclTerraform, true)(struct!.mirror),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirrorList",
    },
    mono_hue: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHueToHclTerraform, true)(struct!.monoHue),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHueList",
    },
    opacity: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacityToHclTerraform, true)(struct!.opacity),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacityList",
    },
    remove_color: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColorToHclTerraform, true)(struct!.removeColor),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColorList",
    },
    unsharp_mask: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMaskToHclTerraform, true)(struct!.unsharpMask),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMaskList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscape | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backgroundColor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backgroundColor = this._backgroundColor?.internalValue;
    }
    if (this._blur?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.blur = this._blur?.internalValue;
    }
    if (this._chromaKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.chromaKey = this._chromaKey?.internalValue;
    }
    if (this._composite?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.composite = this._composite?.internalValue;
    }
    if (this._compound?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.compound = this._compound?.internalValue;
    }
    if (this._contrast?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.contrast = this._contrast?.internalValue;
    }
    if (this._goop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.goop = this._goop?.internalValue;
    }
    if (this._grayscale?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grayscale = this._grayscale?.internalValue;
    }
    if (this._hsl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hsl = this._hsl?.internalValue;
    }
    if (this._hsv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hsv = this._hsv?.internalValue;
    }
    if (this._ifDimension?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ifDimension = this._ifDimension?.internalValue;
    }
    if (this._ifOrientation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ifOrientation = this._ifOrientation?.internalValue;
    }
    if (this._maxColors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxColors = this._maxColors?.internalValue;
    }
    if (this._mirror?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mirror = this._mirror?.internalValue;
    }
    if (this._monoHue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.monoHue = this._monoHue?.internalValue;
    }
    if (this._opacity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.opacity = this._opacity?.internalValue;
    }
    if (this._removeColor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeColor = this._removeColor?.internalValue;
    }
    if (this._unsharpMask?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unsharpMask = this._unsharpMask?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscape | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._backgroundColor.internalValue = undefined;
      this._blur.internalValue = undefined;
      this._chromaKey.internalValue = undefined;
      this._composite.internalValue = undefined;
      this._compound.internalValue = undefined;
      this._contrast.internalValue = undefined;
      this._goop.internalValue = undefined;
      this._grayscale.internalValue = undefined;
      this._hsl.internalValue = undefined;
      this._hsv.internalValue = undefined;
      this._ifDimension.internalValue = undefined;
      this._ifOrientation.internalValue = undefined;
      this._maxColors.internalValue = undefined;
      this._mirror.internalValue = undefined;
      this._monoHue.internalValue = undefined;
      this._opacity.internalValue = undefined;
      this._removeColor.internalValue = undefined;
      this._unsharpMask.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._backgroundColor.internalValue = value.backgroundColor;
      this._blur.internalValue = value.blur;
      this._chromaKey.internalValue = value.chromaKey;
      this._composite.internalValue = value.composite;
      this._compound.internalValue = value.compound;
      this._contrast.internalValue = value.contrast;
      this._goop.internalValue = value.goop;
      this._grayscale.internalValue = value.grayscale;
      this._hsl.internalValue = value.hsl;
      this._hsv.internalValue = value.hsv;
      this._ifDimension.internalValue = value.ifDimension;
      this._ifOrientation.internalValue = value.ifOrientation;
      this._maxColors.internalValue = value.maxColors;
      this._mirror.internalValue = value.mirror;
      this._monoHue.internalValue = value.monoHue;
      this._opacity.internalValue = value.opacity;
      this._removeColor.internalValue = value.removeColor;
      this._unsharpMask.internalValue = value.unsharpMask;
    }
  }

  // background_color - computed: false, optional: true, required: false
  private _backgroundColor = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColorList(this, "background_color", false);
  public get backgroundColor() {
    return this._backgroundColor;
  }
  public putBackgroundColor(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBackgroundColor[] | cdktf.IResolvable) {
    this._backgroundColor.internalValue = value;
  }
  public resetBackgroundColor() {
    this._backgroundColor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backgroundColorInput() {
    return this._backgroundColor.internalValue;
  }

  // blur - computed: false, optional: true, required: false
  private _blur = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlurList(this, "blur", false);
  public get blur() {
    return this._blur;
  }
  public putBlur(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeBlur[] | cdktf.IResolvable) {
    this._blur.internalValue = value;
  }
  public resetBlur() {
    this._blur.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blurInput() {
    return this._blur.internalValue;
  }

  // chroma_key - computed: false, optional: true, required: false
  private _chromaKey = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKeyList(this, "chroma_key", false);
  public get chromaKey() {
    return this._chromaKey;
  }
  public putChromaKey(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeChromaKey[] | cdktf.IResolvable) {
    this._chromaKey.internalValue = value;
  }
  public resetChromaKey() {
    this._chromaKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chromaKeyInput() {
    return this._chromaKey.internalValue;
  }

  // composite - computed: false, optional: true, required: false
  private _composite = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompositeList(this, "composite", false);
  public get composite() {
    return this._composite;
  }
  public putComposite(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeComposite[] | cdktf.IResolvable) {
    this._composite.internalValue = value;
  }
  public resetComposite() {
    this._composite.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compositeInput() {
    return this._composite.internalValue;
  }

  // compound - computed: false, optional: true, required: false
  private _compound = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompoundList(this, "compound", false);
  public get compound() {
    return this._compound;
  }
  public putCompound(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeCompound[] | cdktf.IResolvable) {
    this._compound.internalValue = value;
  }
  public resetCompound() {
    this._compound.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compoundInput() {
    return this._compound.internalValue;
  }

  // contrast - computed: false, optional: true, required: false
  private _contrast = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrastList(this, "contrast", false);
  public get contrast() {
    return this._contrast;
  }
  public putContrast(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeContrast[] | cdktf.IResolvable) {
    this._contrast.internalValue = value;
  }
  public resetContrast() {
    this._contrast.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contrastInput() {
    return this._contrast.internalValue;
  }

  // goop - computed: false, optional: true, required: false
  private _goop = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoopList(this, "goop", false);
  public get goop() {
    return this._goop;
  }
  public putGoop(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGoop[] | cdktf.IResolvable) {
    this._goop.internalValue = value;
  }
  public resetGoop() {
    this._goop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get goopInput() {
    return this._goop.internalValue;
  }

  // grayscale - computed: false, optional: true, required: false
  private _grayscale = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscaleList(this, "grayscale", false);
  public get grayscale() {
    return this._grayscale;
  }
  public putGrayscale(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeGrayscale[] | cdktf.IResolvable) {
    this._grayscale.internalValue = value;
  }
  public resetGrayscale() {
    this._grayscale.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grayscaleInput() {
    return this._grayscale.internalValue;
  }

  // hsl - computed: false, optional: true, required: false
  private _hsl = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHslList(this, "hsl", false);
  public get hsl() {
    return this._hsl;
  }
  public putHsl(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsl[] | cdktf.IResolvable) {
    this._hsl.internalValue = value;
  }
  public resetHsl() {
    this._hsl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hslInput() {
    return this._hsl.internalValue;
  }

  // hsv - computed: false, optional: true, required: false
  private _hsv = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsvList(this, "hsv", false);
  public get hsv() {
    return this._hsv;
  }
  public putHsv(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeHsv[] | cdktf.IResolvable) {
    this._hsv.internalValue = value;
  }
  public resetHsv() {
    this._hsv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hsvInput() {
    return this._hsv.internalValue;
  }

  // if_dimension - computed: false, optional: true, required: false
  private _ifDimension = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimensionList(this, "if_dimension", false);
  public get ifDimension() {
    return this._ifDimension;
  }
  public putIfDimension(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfDimension[] | cdktf.IResolvable) {
    this._ifDimension.internalValue = value;
  }
  public resetIfDimension() {
    this._ifDimension.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ifDimensionInput() {
    return this._ifDimension.internalValue;
  }

  // if_orientation - computed: false, optional: true, required: false
  private _ifOrientation = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientationList(this, "if_orientation", false);
  public get ifOrientation() {
    return this._ifOrientation;
  }
  public putIfOrientation(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeIfOrientation[] | cdktf.IResolvable) {
    this._ifOrientation.internalValue = value;
  }
  public resetIfOrientation() {
    this._ifOrientation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ifOrientationInput() {
    return this._ifOrientation.internalValue;
  }

  // max_colors - computed: false, optional: true, required: false
  private _maxColors = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColorsList(this, "max_colors", false);
  public get maxColors() {
    return this._maxColors;
  }
  public putMaxColors(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMaxColors[] | cdktf.IResolvable) {
    this._maxColors.internalValue = value;
  }
  public resetMaxColors() {
    this._maxColors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxColorsInput() {
    return this._maxColors.internalValue;
  }

  // mirror - computed: false, optional: true, required: false
  private _mirror = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirrorList(this, "mirror", false);
  public get mirror() {
    return this._mirror;
  }
  public putMirror(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMirror[] | cdktf.IResolvable) {
    this._mirror.internalValue = value;
  }
  public resetMirror() {
    this._mirror.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mirrorInput() {
    return this._mirror.internalValue;
  }

  // mono_hue - computed: false, optional: true, required: false
  private _monoHue = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHueList(this, "mono_hue", false);
  public get monoHue() {
    return this._monoHue;
  }
  public putMonoHue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeMonoHue[] | cdktf.IResolvable) {
    this._monoHue.internalValue = value;
  }
  public resetMonoHue() {
    this._monoHue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monoHueInput() {
    return this._monoHue.internalValue;
  }

  // opacity - computed: false, optional: true, required: false
  private _opacity = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacityList(this, "opacity", false);
  public get opacity() {
    return this._opacity;
  }
  public putOpacity(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOpacity[] | cdktf.IResolvable) {
    this._opacity.internalValue = value;
  }
  public resetOpacity() {
    this._opacity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opacityInput() {
    return this._opacity.internalValue;
  }

  // remove_color - computed: false, optional: true, required: false
  private _removeColor = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColorList(this, "remove_color", false);
  public get removeColor() {
    return this._removeColor;
  }
  public putRemoveColor(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeRemoveColor[] | cdktf.IResolvable) {
    this._removeColor.internalValue = value;
  }
  public resetRemoveColor() {
    this._removeColor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeColorInput() {
    return this._removeColor.internalValue;
  }

  // unsharp_mask - computed: false, optional: true, required: false
  private _unsharpMask = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMaskList(this, "unsharp_mask", false);
  public get unsharpMask() {
    return this._unsharpMask;
  }
  public putUnsharpMask(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeUnsharpMask[] | cdktf.IResolvable) {
    this._unsharpMask.internalValue = value;
  }
  public resetUnsharpMask() {
    this._unsharpMask.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unsharpMaskInput() {
    return this._unsharpMask.internalValue;
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColor {
  /**
  * The hexadecimal CSS color value for the background.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color DataAkamaiImagingPolicyImage#color}
  */
  readonly color?: string;
  /**
  * The hexadecimal CSS color value for the background.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color_var DataAkamaiImagingPolicyImage#color_var}
  */
  readonly colorVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColorToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    color: cdktf.stringToTerraform(struct!.color),
    color_var: cdktf.stringToTerraform(struct!.colorVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColorToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    color_var: {
      value: cdktf.stringToHclTerraform(struct!.colorVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._colorVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorVar = this._colorVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._color = undefined;
      this._colorVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._color = value.color;
      this._colorVar = value.colorVar;
    }
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // color_var - computed: false, optional: true, required: false
  private _colorVar?: string; 
  public get colorVar() {
    return this.getStringAttribute('color_var');
  }
  public set colorVar(value: string) {
    this._colorVar = value;
  }
  public resetColorVar() {
    this._colorVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorVarInput() {
    return this._colorVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColorList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColor[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColorOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlur {
  /**
  * The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma DataAkamaiImagingPolicyImage#sigma}
  */
  readonly sigma?: string;
  /**
  * The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma_var DataAkamaiImagingPolicyImage#sigma_var}
  */
  readonly sigmaVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlurToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlur | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sigma: cdktf.stringToTerraform(struct!.sigma),
    sigma_var: cdktf.stringToTerraform(struct!.sigmaVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlurToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlur | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sigma: {
      value: cdktf.stringToHclTerraform(struct!.sigma),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sigma_var: {
      value: cdktf.stringToHclTerraform(struct!.sigmaVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlurOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlur | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sigma !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigma = this._sigma;
    }
    if (this._sigmaVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigmaVar = this._sigmaVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlur | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sigma = undefined;
      this._sigmaVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sigma = value.sigma;
      this._sigmaVar = value.sigmaVar;
    }
  }

  // sigma - computed: false, optional: true, required: false
  private _sigma?: string; 
  public get sigma() {
    return this.getStringAttribute('sigma');
  }
  public set sigma(value: string) {
    this._sigma = value;
  }
  public resetSigma() {
    this._sigma = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaInput() {
    return this._sigma;
  }

  // sigma_var - computed: false, optional: true, required: false
  private _sigmaVar?: string; 
  public get sigmaVar() {
    return this.getStringAttribute('sigma_var');
  }
  public set sigmaVar(value: string) {
    this._sigmaVar = value;
  }
  public resetSigmaVar() {
    this._sigmaVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaVarInput() {
    return this._sigmaVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlurList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlur[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlurOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlurOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKey {
  /**
  * The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_feather DataAkamaiImagingPolicyImage#hue_feather}
  */
  readonly hueFeather?: string;
  /**
  * How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_feather_var DataAkamaiImagingPolicyImage#hue_feather_var}
  */
  readonly hueFeatherVar?: string;
  /**
  * How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_tolerance DataAkamaiImagingPolicyImage#hue_tolerance}
  */
  readonly hueTolerance?: string;
  /**
  * How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_tolerance_var DataAkamaiImagingPolicyImage#hue_tolerance_var}
  */
  readonly hueToleranceVar?: string;
  /**
  * The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
  /**
  * How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_feather DataAkamaiImagingPolicyImage#lightness_feather}
  */
  readonly lightnessFeather?: string;
  /**
  * How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_feather_var DataAkamaiImagingPolicyImage#lightness_feather_var}
  */
  readonly lightnessFeatherVar?: string;
  /**
  * How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_tolerance DataAkamaiImagingPolicyImage#lightness_tolerance}
  */
  readonly lightnessTolerance?: string;
  /**
  * How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_tolerance_var DataAkamaiImagingPolicyImage#lightness_tolerance_var}
  */
  readonly lightnessToleranceVar?: string;
  /**
  * How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_feather DataAkamaiImagingPolicyImage#saturation_feather}
  */
  readonly saturationFeather?: string;
  /**
  * How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_feather_var DataAkamaiImagingPolicyImage#saturation_feather_var}
  */
  readonly saturationFeatherVar?: string;
  /**
  * How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_tolerance DataAkamaiImagingPolicyImage#saturation_tolerance}
  */
  readonly saturationTolerance?: string;
  /**
  * How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_tolerance_var DataAkamaiImagingPolicyImage#saturation_tolerance_var}
  */
  readonly saturationToleranceVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKeyToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_feather: cdktf.stringToTerraform(struct!.hueFeather),
    hue_feather_var: cdktf.stringToTerraform(struct!.hueFeatherVar),
    hue_tolerance: cdktf.stringToTerraform(struct!.hueTolerance),
    hue_tolerance_var: cdktf.stringToTerraform(struct!.hueToleranceVar),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
    lightness_feather: cdktf.stringToTerraform(struct!.lightnessFeather),
    lightness_feather_var: cdktf.stringToTerraform(struct!.lightnessFeatherVar),
    lightness_tolerance: cdktf.stringToTerraform(struct!.lightnessTolerance),
    lightness_tolerance_var: cdktf.stringToTerraform(struct!.lightnessToleranceVar),
    saturation_feather: cdktf.stringToTerraform(struct!.saturationFeather),
    saturation_feather_var: cdktf.stringToTerraform(struct!.saturationFeatherVar),
    saturation_tolerance: cdktf.stringToTerraform(struct!.saturationTolerance),
    saturation_tolerance_var: cdktf.stringToTerraform(struct!.saturationToleranceVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKeyToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_feather: {
      value: cdktf.stringToHclTerraform(struct!.hueFeather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_feather_var: {
      value: cdktf.stringToHclTerraform(struct!.hueFeatherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.hueTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.hueToleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_feather: {
      value: cdktf.stringToHclTerraform(struct!.lightnessFeather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_feather_var: {
      value: cdktf.stringToHclTerraform(struct!.lightnessFeatherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.lightnessTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.lightnessToleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_feather: {
      value: cdktf.stringToHclTerraform(struct!.saturationFeather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_feather_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationFeatherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.saturationTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationToleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueFeather !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueFeather = this._hueFeather;
    }
    if (this._hueFeatherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueFeatherVar = this._hueFeatherVar;
    }
    if (this._hueTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueTolerance = this._hueTolerance;
    }
    if (this._hueToleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueToleranceVar = this._hueToleranceVar;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    if (this._lightnessFeather !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessFeather = this._lightnessFeather;
    }
    if (this._lightnessFeatherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessFeatherVar = this._lightnessFeatherVar;
    }
    if (this._lightnessTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessTolerance = this._lightnessTolerance;
    }
    if (this._lightnessToleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessToleranceVar = this._lightnessToleranceVar;
    }
    if (this._saturationFeather !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationFeather = this._saturationFeather;
    }
    if (this._saturationFeatherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationFeatherVar = this._saturationFeatherVar;
    }
    if (this._saturationTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationTolerance = this._saturationTolerance;
    }
    if (this._saturationToleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationToleranceVar = this._saturationToleranceVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueFeather = undefined;
      this._hueFeatherVar = undefined;
      this._hueTolerance = undefined;
      this._hueToleranceVar = undefined;
      this._hueVar = undefined;
      this._lightnessFeather = undefined;
      this._lightnessFeatherVar = undefined;
      this._lightnessTolerance = undefined;
      this._lightnessToleranceVar = undefined;
      this._saturationFeather = undefined;
      this._saturationFeatherVar = undefined;
      this._saturationTolerance = undefined;
      this._saturationToleranceVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueFeather = value.hueFeather;
      this._hueFeatherVar = value.hueFeatherVar;
      this._hueTolerance = value.hueTolerance;
      this._hueToleranceVar = value.hueToleranceVar;
      this._hueVar = value.hueVar;
      this._lightnessFeather = value.lightnessFeather;
      this._lightnessFeatherVar = value.lightnessFeatherVar;
      this._lightnessTolerance = value.lightnessTolerance;
      this._lightnessToleranceVar = value.lightnessToleranceVar;
      this._saturationFeather = value.saturationFeather;
      this._saturationFeatherVar = value.saturationFeatherVar;
      this._saturationTolerance = value.saturationTolerance;
      this._saturationToleranceVar = value.saturationToleranceVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_feather - computed: false, optional: true, required: false
  private _hueFeather?: string; 
  public get hueFeather() {
    return this.getStringAttribute('hue_feather');
  }
  public set hueFeather(value: string) {
    this._hueFeather = value;
  }
  public resetHueFeather() {
    this._hueFeather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueFeatherInput() {
    return this._hueFeather;
  }

  // hue_feather_var - computed: false, optional: true, required: false
  private _hueFeatherVar?: string; 
  public get hueFeatherVar() {
    return this.getStringAttribute('hue_feather_var');
  }
  public set hueFeatherVar(value: string) {
    this._hueFeatherVar = value;
  }
  public resetHueFeatherVar() {
    this._hueFeatherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueFeatherVarInput() {
    return this._hueFeatherVar;
  }

  // hue_tolerance - computed: false, optional: true, required: false
  private _hueTolerance?: string; 
  public get hueTolerance() {
    return this.getStringAttribute('hue_tolerance');
  }
  public set hueTolerance(value: string) {
    this._hueTolerance = value;
  }
  public resetHueTolerance() {
    this._hueTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueToleranceInput() {
    return this._hueTolerance;
  }

  // hue_tolerance_var - computed: false, optional: true, required: false
  private _hueToleranceVar?: string; 
  public get hueToleranceVar() {
    return this.getStringAttribute('hue_tolerance_var');
  }
  public set hueToleranceVar(value: string) {
    this._hueToleranceVar = value;
  }
  public resetHueToleranceVar() {
    this._hueToleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueToleranceVarInput() {
    return this._hueToleranceVar;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }

  // lightness_feather - computed: false, optional: true, required: false
  private _lightnessFeather?: string; 
  public get lightnessFeather() {
    return this.getStringAttribute('lightness_feather');
  }
  public set lightnessFeather(value: string) {
    this._lightnessFeather = value;
  }
  public resetLightnessFeather() {
    this._lightnessFeather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessFeatherInput() {
    return this._lightnessFeather;
  }

  // lightness_feather_var - computed: false, optional: true, required: false
  private _lightnessFeatherVar?: string; 
  public get lightnessFeatherVar() {
    return this.getStringAttribute('lightness_feather_var');
  }
  public set lightnessFeatherVar(value: string) {
    this._lightnessFeatherVar = value;
  }
  public resetLightnessFeatherVar() {
    this._lightnessFeatherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessFeatherVarInput() {
    return this._lightnessFeatherVar;
  }

  // lightness_tolerance - computed: false, optional: true, required: false
  private _lightnessTolerance?: string; 
  public get lightnessTolerance() {
    return this.getStringAttribute('lightness_tolerance');
  }
  public set lightnessTolerance(value: string) {
    this._lightnessTolerance = value;
  }
  public resetLightnessTolerance() {
    this._lightnessTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessToleranceInput() {
    return this._lightnessTolerance;
  }

  // lightness_tolerance_var - computed: false, optional: true, required: false
  private _lightnessToleranceVar?: string; 
  public get lightnessToleranceVar() {
    return this.getStringAttribute('lightness_tolerance_var');
  }
  public set lightnessToleranceVar(value: string) {
    this._lightnessToleranceVar = value;
  }
  public resetLightnessToleranceVar() {
    this._lightnessToleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessToleranceVarInput() {
    return this._lightnessToleranceVar;
  }

  // saturation_feather - computed: false, optional: true, required: false
  private _saturationFeather?: string; 
  public get saturationFeather() {
    return this.getStringAttribute('saturation_feather');
  }
  public set saturationFeather(value: string) {
    this._saturationFeather = value;
  }
  public resetSaturationFeather() {
    this._saturationFeather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationFeatherInput() {
    return this._saturationFeather;
  }

  // saturation_feather_var - computed: false, optional: true, required: false
  private _saturationFeatherVar?: string; 
  public get saturationFeatherVar() {
    return this.getStringAttribute('saturation_feather_var');
  }
  public set saturationFeatherVar(value: string) {
    this._saturationFeatherVar = value;
  }
  public resetSaturationFeatherVar() {
    this._saturationFeatherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationFeatherVarInput() {
    return this._saturationFeatherVar;
  }

  // saturation_tolerance - computed: false, optional: true, required: false
  private _saturationTolerance?: string; 
  public get saturationTolerance() {
    return this.getStringAttribute('saturation_tolerance');
  }
  public set saturationTolerance(value: string) {
    this._saturationTolerance = value;
  }
  public resetSaturationTolerance() {
    this._saturationTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationToleranceInput() {
    return this._saturationTolerance;
  }

  // saturation_tolerance_var - computed: false, optional: true, required: false
  private _saturationToleranceVar?: string; 
  public get saturationToleranceVar() {
    return this.getStringAttribute('saturation_tolerance_var');
  }
  public set saturationToleranceVar(value: string) {
    this._saturationToleranceVar = value;
  }
  public resetSaturationToleranceVar() {
    this._saturationToleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationToleranceVarInput() {
    return this._saturationToleranceVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKeyList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKey[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKeyOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKeyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImage {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImageToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImageOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImage): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImageToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImageOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImage): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImage | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImage | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitComposite {
  /**
  * Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gravity DataAkamaiImagingPolicyImage#gravity}
  */
  readonly gravity?: string;
  /**
  * Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gravity_var DataAkamaiImagingPolicyImage#gravity_var}
  */
  readonly gravityVar?: string;
  /**
  * Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#placement DataAkamaiImagingPolicyImage#placement}
  */
  readonly placement?: string;
  /**
  * Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#placement_var DataAkamaiImagingPolicyImage#placement_var}
  */
  readonly placementVar?: string;
  /**
  * A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#scale DataAkamaiImagingPolicyImage#scale}
  */
  readonly scale?: string;
  /**
  * The dimension, either `width` or `height`, of the source image to scale.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#scale_dimension DataAkamaiImagingPolicyImage#scale_dimension}
  */
  readonly scaleDimension?: string;
  /**
  * The dimension, either `width` or `height`, of the source image to scale.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#scale_dimension_var DataAkamaiImagingPolicyImage#scale_dimension_var}
  */
  readonly scaleDimensionVar?: string;
  /**
  * A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#scale_var DataAkamaiImagingPolicyImage#scale_var}
  */
  readonly scaleVar?: string;
  /**
  * The x-axis position of the image to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#x_position DataAkamaiImagingPolicyImage#x_position}
  */
  readonly xPosition?: string;
  /**
  * The x-axis position of the image to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#x_position_var DataAkamaiImagingPolicyImage#x_position_var}
  */
  readonly xPositionVar?: string;
  /**
  * The y-axis position of the image to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#y_position DataAkamaiImagingPolicyImage#y_position}
  */
  readonly yPosition?: string;
  /**
  * The y-axis position of the image to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#y_position_var DataAkamaiImagingPolicyImage#y_position_var}
  */
  readonly yPositionVar?: string;
  /**
  * image block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#image DataAkamaiImagingPolicyImage#image}
  */
  readonly image: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImage;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitComposite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gravity: cdktf.stringToTerraform(struct!.gravity),
    gravity_var: cdktf.stringToTerraform(struct!.gravityVar),
    placement: cdktf.stringToTerraform(struct!.placement),
    placement_var: cdktf.stringToTerraform(struct!.placementVar),
    scale: cdktf.stringToTerraform(struct!.scale),
    scale_dimension: cdktf.stringToTerraform(struct!.scaleDimension),
    scale_dimension_var: cdktf.stringToTerraform(struct!.scaleDimensionVar),
    scale_var: cdktf.stringToTerraform(struct!.scaleVar),
    x_position: cdktf.stringToTerraform(struct!.xPosition),
    x_position_var: cdktf.stringToTerraform(struct!.xPositionVar),
    y_position: cdktf.stringToTerraform(struct!.yPosition),
    y_position_var: cdktf.stringToTerraform(struct!.yPositionVar),
    image: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImageToTerraform(struct!.image),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitComposite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gravity: {
      value: cdktf.stringToHclTerraform(struct!.gravity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gravity_var: {
      value: cdktf.stringToHclTerraform(struct!.gravityVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    placement: {
      value: cdktf.stringToHclTerraform(struct!.placement),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    placement_var: {
      value: cdktf.stringToHclTerraform(struct!.placementVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale: {
      value: cdktf.stringToHclTerraform(struct!.scale),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale_dimension: {
      value: cdktf.stringToHclTerraform(struct!.scaleDimension),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale_dimension_var: {
      value: cdktf.stringToHclTerraform(struct!.scaleDimensionVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale_var: {
      value: cdktf.stringToHclTerraform(struct!.scaleVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    x_position: {
      value: cdktf.stringToHclTerraform(struct!.xPosition),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    x_position_var: {
      value: cdktf.stringToHclTerraform(struct!.xPositionVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    y_position: {
      value: cdktf.stringToHclTerraform(struct!.yPosition),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    y_position_var: {
      value: cdktf.stringToHclTerraform(struct!.yPositionVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImageToHclTerraform(struct!.image),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImageList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitComposite | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gravity !== undefined) {
      hasAnyValues = true;
      internalValueResult.gravity = this._gravity;
    }
    if (this._gravityVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.gravityVar = this._gravityVar;
    }
    if (this._placement !== undefined) {
      hasAnyValues = true;
      internalValueResult.placement = this._placement;
    }
    if (this._placementVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.placementVar = this._placementVar;
    }
    if (this._scale !== undefined) {
      hasAnyValues = true;
      internalValueResult.scale = this._scale;
    }
    if (this._scaleDimension !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleDimension = this._scaleDimension;
    }
    if (this._scaleDimensionVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleDimensionVar = this._scaleDimensionVar;
    }
    if (this._scaleVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleVar = this._scaleVar;
    }
    if (this._xPosition !== undefined) {
      hasAnyValues = true;
      internalValueResult.xPosition = this._xPosition;
    }
    if (this._xPositionVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.xPositionVar = this._xPositionVar;
    }
    if (this._yPosition !== undefined) {
      hasAnyValues = true;
      internalValueResult.yPosition = this._yPosition;
    }
    if (this._yPositionVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.yPositionVar = this._yPositionVar;
    }
    if (this._image?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitComposite | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gravity = undefined;
      this._gravityVar = undefined;
      this._placement = undefined;
      this._placementVar = undefined;
      this._scale = undefined;
      this._scaleDimension = undefined;
      this._scaleDimensionVar = undefined;
      this._scaleVar = undefined;
      this._xPosition = undefined;
      this._xPositionVar = undefined;
      this._yPosition = undefined;
      this._yPositionVar = undefined;
      this._image.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gravity = value.gravity;
      this._gravityVar = value.gravityVar;
      this._placement = value.placement;
      this._placementVar = value.placementVar;
      this._scale = value.scale;
      this._scaleDimension = value.scaleDimension;
      this._scaleDimensionVar = value.scaleDimensionVar;
      this._scaleVar = value.scaleVar;
      this._xPosition = value.xPosition;
      this._xPositionVar = value.xPositionVar;
      this._yPosition = value.yPosition;
      this._yPositionVar = value.yPositionVar;
      this._image.internalValue = value.image;
    }
  }

  // gravity - computed: false, optional: true, required: false
  private _gravity?: string; 
  public get gravity() {
    return this.getStringAttribute('gravity');
  }
  public set gravity(value: string) {
    this._gravity = value;
  }
  public resetGravity() {
    this._gravity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gravityInput() {
    return this._gravity;
  }

  // gravity_var - computed: false, optional: true, required: false
  private _gravityVar?: string; 
  public get gravityVar() {
    return this.getStringAttribute('gravity_var');
  }
  public set gravityVar(value: string) {
    this._gravityVar = value;
  }
  public resetGravityVar() {
    this._gravityVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gravityVarInput() {
    return this._gravityVar;
  }

  // placement - computed: false, optional: true, required: false
  private _placement?: string; 
  public get placement() {
    return this.getStringAttribute('placement');
  }
  public set placement(value: string) {
    this._placement = value;
  }
  public resetPlacement() {
    this._placement = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get placementInput() {
    return this._placement;
  }

  // placement_var - computed: false, optional: true, required: false
  private _placementVar?: string; 
  public get placementVar() {
    return this.getStringAttribute('placement_var');
  }
  public set placementVar(value: string) {
    this._placementVar = value;
  }
  public resetPlacementVar() {
    this._placementVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get placementVarInput() {
    return this._placementVar;
  }

  // scale - computed: false, optional: true, required: false
  private _scale?: string; 
  public get scale() {
    return this.getStringAttribute('scale');
  }
  public set scale(value: string) {
    this._scale = value;
  }
  public resetScale() {
    this._scale = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleInput() {
    return this._scale;
  }

  // scale_dimension - computed: false, optional: true, required: false
  private _scaleDimension?: string; 
  public get scaleDimension() {
    return this.getStringAttribute('scale_dimension');
  }
  public set scaleDimension(value: string) {
    this._scaleDimension = value;
  }
  public resetScaleDimension() {
    this._scaleDimension = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleDimensionInput() {
    return this._scaleDimension;
  }

  // scale_dimension_var - computed: false, optional: true, required: false
  private _scaleDimensionVar?: string; 
  public get scaleDimensionVar() {
    return this.getStringAttribute('scale_dimension_var');
  }
  public set scaleDimensionVar(value: string) {
    this._scaleDimensionVar = value;
  }
  public resetScaleDimensionVar() {
    this._scaleDimensionVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleDimensionVarInput() {
    return this._scaleDimensionVar;
  }

  // scale_var - computed: false, optional: true, required: false
  private _scaleVar?: string; 
  public get scaleVar() {
    return this.getStringAttribute('scale_var');
  }
  public set scaleVar(value: string) {
    this._scaleVar = value;
  }
  public resetScaleVar() {
    this._scaleVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleVarInput() {
    return this._scaleVar;
  }

  // x_position - computed: false, optional: true, required: false
  private _xPosition?: string; 
  public get xPosition() {
    return this.getStringAttribute('x_position');
  }
  public set xPosition(value: string) {
    this._xPosition = value;
  }
  public resetXPosition() {
    this._xPosition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xPositionInput() {
    return this._xPosition;
  }

  // x_position_var - computed: false, optional: true, required: false
  private _xPositionVar?: string; 
  public get xPositionVar() {
    return this.getStringAttribute('x_position_var');
  }
  public set xPositionVar(value: string) {
    this._xPositionVar = value;
  }
  public resetXPositionVar() {
    this._xPositionVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xPositionVarInput() {
    return this._xPositionVar;
  }

  // y_position - computed: false, optional: true, required: false
  private _yPosition?: string; 
  public get yPosition() {
    return this.getStringAttribute('y_position');
  }
  public set yPosition(value: string) {
    this._yPosition = value;
  }
  public resetYPosition() {
    this._yPosition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get yPositionInput() {
    return this._yPosition;
  }

  // y_position_var - computed: false, optional: true, required: false
  private _yPositionVar?: string; 
  public get yPositionVar() {
    return this.getStringAttribute('y_position_var');
  }
  public set yPositionVar(value: string) {
    this._yPositionVar = value;
  }
  public resetYPositionVar() {
    this._yPositionVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get yPositionVarInput() {
    return this._yPositionVar;
  }

  // image - computed: false, optional: false, required: true
  private _image = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImageOutputReference(this, "image");
  public get image() {
    return this._image;
  }
  public putImage(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeImage) {
    this._image.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitComposite[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformations {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformationsToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformationsToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformationsList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformationsOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompound {
  /**
  * transformations block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#transformations DataAkamaiImagingPolicyImage#transformations}
  */
  readonly transformations?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformations[] | cdktf.IResolvable;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompound | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    transformations: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformationsToTerraform, true)(struct!.transformations),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompound | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    transformations: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformationsToHclTerraform, true)(struct!.transformations),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformationsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompound | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._transformations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformations = this._transformations?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompound | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._transformations.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._transformations.internalValue = value.transformations;
    }
  }

  // transformations - computed: false, optional: true, required: false
  private _transformations = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformationsList(this, "transformations", false);
  public get transformations() {
    return this._transformations;
  }
  public putTransformations(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundTransformations[] | cdktf.IResolvable) {
    this._transformations.internalValue = value;
  }
  public resetTransformations() {
    this._transformations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationsInput() {
    return this._transformations.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompound[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrast {
  /**
  * Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#brightness DataAkamaiImagingPolicyImage#brightness}
  */
  readonly brightness?: string;
  /**
  * Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#brightness_var DataAkamaiImagingPolicyImage#brightness_var}
  */
  readonly brightnessVar?: string;
  /**
  * Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#contrast DataAkamaiImagingPolicyImage#contrast}
  */
  readonly contrast?: string;
  /**
  * Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#contrast_var DataAkamaiImagingPolicyImage#contrast_var}
  */
  readonly contrastVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrastToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    brightness: cdktf.stringToTerraform(struct!.brightness),
    brightness_var: cdktf.stringToTerraform(struct!.brightnessVar),
    contrast: cdktf.stringToTerraform(struct!.contrast),
    contrast_var: cdktf.stringToTerraform(struct!.contrastVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrastToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    brightness: {
      value: cdktf.stringToHclTerraform(struct!.brightness),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    brightness_var: {
      value: cdktf.stringToHclTerraform(struct!.brightnessVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    contrast: {
      value: cdktf.stringToHclTerraform(struct!.contrast),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    contrast_var: {
      value: cdktf.stringToHclTerraform(struct!.contrastVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._brightness !== undefined) {
      hasAnyValues = true;
      internalValueResult.brightness = this._brightness;
    }
    if (this._brightnessVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.brightnessVar = this._brightnessVar;
    }
    if (this._contrast !== undefined) {
      hasAnyValues = true;
      internalValueResult.contrast = this._contrast;
    }
    if (this._contrastVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.contrastVar = this._contrastVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._brightness = undefined;
      this._brightnessVar = undefined;
      this._contrast = undefined;
      this._contrastVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._brightness = value.brightness;
      this._brightnessVar = value.brightnessVar;
      this._contrast = value.contrast;
      this._contrastVar = value.contrastVar;
    }
  }

  // brightness - computed: false, optional: true, required: false
  private _brightness?: string; 
  public get brightness() {
    return this.getStringAttribute('brightness');
  }
  public set brightness(value: string) {
    this._brightness = value;
  }
  public resetBrightness() {
    this._brightness = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brightnessInput() {
    return this._brightness;
  }

  // brightness_var - computed: false, optional: true, required: false
  private _brightnessVar?: string; 
  public get brightnessVar() {
    return this.getStringAttribute('brightness_var');
  }
  public set brightnessVar(value: string) {
    this._brightnessVar = value;
  }
  public resetBrightnessVar() {
    this._brightnessVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brightnessVarInput() {
    return this._brightnessVar;
  }

  // contrast - computed: false, optional: true, required: false
  private _contrast?: string; 
  public get contrast() {
    return this.getStringAttribute('contrast');
  }
  public set contrast(value: string) {
    this._contrast = value;
  }
  public resetContrast() {
    this._contrast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contrastInput() {
    return this._contrast;
  }

  // contrast_var - computed: false, optional: true, required: false
  private _contrastVar?: string; 
  public get contrastVar() {
    return this.getStringAttribute('contrast_var');
  }
  public set contrastVar(value: string) {
    this._contrastVar = value;
  }
  public resetContrastVar() {
    this._contrastVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contrastVarInput() {
    return this._contrastVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrastList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrast[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrastOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrastOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoop {
  /**
  * Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#chaos DataAkamaiImagingPolicyImage#chaos}
  */
  readonly chaos?: string;
  /**
  * Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#chaos_var DataAkamaiImagingPolicyImage#chaos_var}
  */
  readonly chaosVar?: string;
  /**
  * Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#density DataAkamaiImagingPolicyImage#density}
  */
  readonly density?: string;
  /**
  * Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#density_var DataAkamaiImagingPolicyImage#density_var}
  */
  readonly densityVar?: string;
  /**
  * By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#power DataAkamaiImagingPolicyImage#power}
  */
  readonly power?: string;
  /**
  * By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#power_var DataAkamaiImagingPolicyImage#power_var}
  */
  readonly powerVar?: string;
  /**
  * Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#seed DataAkamaiImagingPolicyImage#seed}
  */
  readonly seed?: string;
  /**
  * Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#seed_var DataAkamaiImagingPolicyImage#seed_var}
  */
  readonly seedVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoopToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    chaos: cdktf.stringToTerraform(struct!.chaos),
    chaos_var: cdktf.stringToTerraform(struct!.chaosVar),
    density: cdktf.stringToTerraform(struct!.density),
    density_var: cdktf.stringToTerraform(struct!.densityVar),
    power: cdktf.stringToTerraform(struct!.power),
    power_var: cdktf.stringToTerraform(struct!.powerVar),
    seed: cdktf.stringToTerraform(struct!.seed),
    seed_var: cdktf.stringToTerraform(struct!.seedVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoopToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    chaos: {
      value: cdktf.stringToHclTerraform(struct!.chaos),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    chaos_var: {
      value: cdktf.stringToHclTerraform(struct!.chaosVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    density: {
      value: cdktf.stringToHclTerraform(struct!.density),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    density_var: {
      value: cdktf.stringToHclTerraform(struct!.densityVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    power: {
      value: cdktf.stringToHclTerraform(struct!.power),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    power_var: {
      value: cdktf.stringToHclTerraform(struct!.powerVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seed: {
      value: cdktf.stringToHclTerraform(struct!.seed),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seed_var: {
      value: cdktf.stringToHclTerraform(struct!.seedVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chaos !== undefined) {
      hasAnyValues = true;
      internalValueResult.chaos = this._chaos;
    }
    if (this._chaosVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.chaosVar = this._chaosVar;
    }
    if (this._density !== undefined) {
      hasAnyValues = true;
      internalValueResult.density = this._density;
    }
    if (this._densityVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.densityVar = this._densityVar;
    }
    if (this._power !== undefined) {
      hasAnyValues = true;
      internalValueResult.power = this._power;
    }
    if (this._powerVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.powerVar = this._powerVar;
    }
    if (this._seed !== undefined) {
      hasAnyValues = true;
      internalValueResult.seed = this._seed;
    }
    if (this._seedVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.seedVar = this._seedVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chaos = undefined;
      this._chaosVar = undefined;
      this._density = undefined;
      this._densityVar = undefined;
      this._power = undefined;
      this._powerVar = undefined;
      this._seed = undefined;
      this._seedVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chaos = value.chaos;
      this._chaosVar = value.chaosVar;
      this._density = value.density;
      this._densityVar = value.densityVar;
      this._power = value.power;
      this._powerVar = value.powerVar;
      this._seed = value.seed;
      this._seedVar = value.seedVar;
    }
  }

  // chaos - computed: false, optional: true, required: false
  private _chaos?: string; 
  public get chaos() {
    return this.getStringAttribute('chaos');
  }
  public set chaos(value: string) {
    this._chaos = value;
  }
  public resetChaos() {
    this._chaos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chaosInput() {
    return this._chaos;
  }

  // chaos_var - computed: false, optional: true, required: false
  private _chaosVar?: string; 
  public get chaosVar() {
    return this.getStringAttribute('chaos_var');
  }
  public set chaosVar(value: string) {
    this._chaosVar = value;
  }
  public resetChaosVar() {
    this._chaosVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chaosVarInput() {
    return this._chaosVar;
  }

  // density - computed: false, optional: true, required: false
  private _density?: string; 
  public get density() {
    return this.getStringAttribute('density');
  }
  public set density(value: string) {
    this._density = value;
  }
  public resetDensity() {
    this._density = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get densityInput() {
    return this._density;
  }

  // density_var - computed: false, optional: true, required: false
  private _densityVar?: string; 
  public get densityVar() {
    return this.getStringAttribute('density_var');
  }
  public set densityVar(value: string) {
    this._densityVar = value;
  }
  public resetDensityVar() {
    this._densityVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get densityVarInput() {
    return this._densityVar;
  }

  // power - computed: false, optional: true, required: false
  private _power?: string; 
  public get power() {
    return this.getStringAttribute('power');
  }
  public set power(value: string) {
    this._power = value;
  }
  public resetPower() {
    this._power = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get powerInput() {
    return this._power;
  }

  // power_var - computed: false, optional: true, required: false
  private _powerVar?: string; 
  public get powerVar() {
    return this.getStringAttribute('power_var');
  }
  public set powerVar(value: string) {
    this._powerVar = value;
  }
  public resetPowerVar() {
    this._powerVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get powerVarInput() {
    return this._powerVar;
  }

  // seed - computed: false, optional: true, required: false
  private _seed?: string; 
  public get seed() {
    return this.getStringAttribute('seed');
  }
  public set seed(value: string) {
    this._seed = value;
  }
  public resetSeed() {
    this._seed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seedInput() {
    return this._seed;
  }

  // seed_var - computed: false, optional: true, required: false
  private _seedVar?: string; 
  public get seedVar() {
    return this.getStringAttribute('seed_var');
  }
  public set seedVar(value: string) {
    this._seedVar = value;
  }
  public resetSeedVar() {
    this._seedVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seedVarInput() {
    return this._seedVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoopList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoop[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoopOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoopOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscale {
  /**
  * The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#type DataAkamaiImagingPolicyImage#type}
  */
  readonly type?: string;
  /**
  * The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#type_var DataAkamaiImagingPolicyImage#type_var}
  */
  readonly typeVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscaleToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscale | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    type_var: cdktf.stringToTerraform(struct!.typeVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscaleToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscale | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type_var: {
      value: cdktf.stringToHclTerraform(struct!.typeVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscaleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscale | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._typeVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.typeVar = this._typeVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscale | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._typeVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._typeVar = value.typeVar;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // type_var - computed: false, optional: true, required: false
  private _typeVar?: string; 
  public get typeVar() {
    return this.getStringAttribute('type_var');
  }
  public set typeVar(value: string) {
    this._typeVar = value;
  }
  public resetTypeVar() {
    this._typeVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeVarInput() {
    return this._typeVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscaleList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscale[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscaleOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscaleOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsl {
  /**
  * The number of degrees to rotate colors around the color wheel, `0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * The number of degrees to rotate colors around the color wheel, `0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
  /**
  * A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness DataAkamaiImagingPolicyImage#lightness}
  */
  readonly lightness?: string;
  /**
  * A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_var DataAkamaiImagingPolicyImage#lightness_var}
  */
  readonly lightnessVar?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation DataAkamaiImagingPolicyImage#saturation}
  */
  readonly saturation?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_var DataAkamaiImagingPolicyImage#saturation_var}
  */
  readonly saturationVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHslToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
    lightness: cdktf.stringToTerraform(struct!.lightness),
    lightness_var: cdktf.stringToTerraform(struct!.lightnessVar),
    saturation: cdktf.stringToTerraform(struct!.saturation),
    saturation_var: cdktf.stringToTerraform(struct!.saturationVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHslToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness: {
      value: cdktf.stringToHclTerraform(struct!.lightness),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_var: {
      value: cdktf.stringToHclTerraform(struct!.lightnessVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation: {
      value: cdktf.stringToHclTerraform(struct!.saturation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    if (this._lightness !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightness = this._lightness;
    }
    if (this._lightnessVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessVar = this._lightnessVar;
    }
    if (this._saturation !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturation = this._saturation;
    }
    if (this._saturationVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationVar = this._saturationVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueVar = undefined;
      this._lightness = undefined;
      this._lightnessVar = undefined;
      this._saturation = undefined;
      this._saturationVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueVar = value.hueVar;
      this._lightness = value.lightness;
      this._lightnessVar = value.lightnessVar;
      this._saturation = value.saturation;
      this._saturationVar = value.saturationVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }

  // lightness - computed: false, optional: true, required: false
  private _lightness?: string; 
  public get lightness() {
    return this.getStringAttribute('lightness');
  }
  public set lightness(value: string) {
    this._lightness = value;
  }
  public resetLightness() {
    this._lightness = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessInput() {
    return this._lightness;
  }

  // lightness_var - computed: false, optional: true, required: false
  private _lightnessVar?: string; 
  public get lightnessVar() {
    return this.getStringAttribute('lightness_var');
  }
  public set lightnessVar(value: string) {
    this._lightnessVar = value;
  }
  public resetLightnessVar() {
    this._lightnessVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessVarInput() {
    return this._lightnessVar;
  }

  // saturation - computed: false, optional: true, required: false
  private _saturation?: string; 
  public get saturation() {
    return this.getStringAttribute('saturation');
  }
  public set saturation(value: string) {
    this._saturation = value;
  }
  public resetSaturation() {
    this._saturation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationInput() {
    return this._saturation;
  }

  // saturation_var - computed: false, optional: true, required: false
  private _saturationVar?: string; 
  public get saturationVar() {
    return this.getStringAttribute('saturation_var');
  }
  public set saturationVar(value: string) {
    this._saturationVar = value;
  }
  public resetSaturationVar() {
    this._saturationVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationVarInput() {
    return this._saturationVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHslList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsl[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHslOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHslOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsv {
  /**
  * The number of degrees to rotate colors around the color wheel, `0.0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * The number of degrees to rotate colors around the color wheel, `0.0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation DataAkamaiImagingPolicyImage#saturation}
  */
  readonly saturation?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_var DataAkamaiImagingPolicyImage#saturation_var}
  */
  readonly saturationVar?: string;
  /**
  * A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value DataAkamaiImagingPolicyImage#value}
  */
  readonly value?: string;
  /**
  * A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value_var DataAkamaiImagingPolicyImage#value_var}
  */
  readonly valueVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsvToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
    saturation: cdktf.stringToTerraform(struct!.saturation),
    saturation_var: cdktf.stringToTerraform(struct!.saturationVar),
    value: cdktf.stringToTerraform(struct!.value),
    value_var: cdktf.stringToTerraform(struct!.valueVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsvToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation: {
      value: cdktf.stringToHclTerraform(struct!.saturation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_var: {
      value: cdktf.stringToHclTerraform(struct!.valueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    if (this._saturation !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturation = this._saturation;
    }
    if (this._saturationVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationVar = this._saturationVar;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueVar = this._valueVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueVar = undefined;
      this._saturation = undefined;
      this._saturationVar = undefined;
      this._value = undefined;
      this._valueVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueVar = value.hueVar;
      this._saturation = value.saturation;
      this._saturationVar = value.saturationVar;
      this._value = value.value;
      this._valueVar = value.valueVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }

  // saturation - computed: false, optional: true, required: false
  private _saturation?: string; 
  public get saturation() {
    return this.getStringAttribute('saturation');
  }
  public set saturation(value: string) {
    this._saturation = value;
  }
  public resetSaturation() {
    this._saturation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationInput() {
    return this._saturation;
  }

  // saturation_var - computed: false, optional: true, required: false
  private _saturationVar?: string; 
  public get saturationVar() {
    return this.getStringAttribute('saturation_var');
  }
  public set saturationVar(value: string) {
    this._saturationVar = value;
  }
  public resetSaturationVar() {
    this._saturationVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationVarInput() {
    return this._saturationVar;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_var - computed: false, optional: true, required: false
  private _valueVar?: string; 
  public get valueVar() {
    return this.getStringAttribute('value_var');
  }
  public set valueVar(value: string) {
    this._valueVar = value;
  }
  public resetValueVar() {
    this._valueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueVarInput() {
    return this._valueVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsvList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsvOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefault {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefaultToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefaultToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefaultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefault | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefault | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqual {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqualToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqualOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqual): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqualToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqualOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqual): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqualOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqual | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqual | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThan {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThanToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThanOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThan): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThanToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThanOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThan): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThanOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThan | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThan | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThan {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThanToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThanOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThan): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThanToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThanOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThan): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThanOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThan | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThan | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimension {
  /**
  * The dimension to use to select the transformation, either `height`, `width`, or `both`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#dimension DataAkamaiImagingPolicyImage#dimension}
  */
  readonly dimension?: string;
  /**
  * The dimension to use to select the transformation, either `height`, `width`, or `both`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#dimension_var DataAkamaiImagingPolicyImage#dimension_var}
  */
  readonly dimensionVar?: string;
  /**
  * The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value DataAkamaiImagingPolicyImage#value}
  */
  readonly value?: string;
  /**
  * The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value_var DataAkamaiImagingPolicyImage#value_var}
  */
  readonly valueVar?: string;
  /**
  * default block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#default DataAkamaiImagingPolicyImage#default}
  */
  readonly default?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefault;
  /**
  * equal block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#equal DataAkamaiImagingPolicyImage#equal}
  */
  readonly equal?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqual;
  /**
  * greater_than block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#greater_than DataAkamaiImagingPolicyImage#greater_than}
  */
  readonly greaterThan?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThan;
  /**
  * less_than block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#less_than DataAkamaiImagingPolicyImage#less_than}
  */
  readonly lessThan?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThan;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimension | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dimension: cdktf.stringToTerraform(struct!.dimension),
    dimension_var: cdktf.stringToTerraform(struct!.dimensionVar),
    value: cdktf.stringToTerraform(struct!.value),
    value_var: cdktf.stringToTerraform(struct!.valueVar),
    default: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefaultToTerraform(struct!.default),
    equal: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqualToTerraform(struct!.equal),
    greater_than: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThanToTerraform(struct!.greaterThan),
    less_than: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThanToTerraform(struct!.lessThan),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimension | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dimension: {
      value: cdktf.stringToHclTerraform(struct!.dimension),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dimension_var: {
      value: cdktf.stringToHclTerraform(struct!.dimensionVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_var: {
      value: cdktf.stringToHclTerraform(struct!.valueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefaultToHclTerraform(struct!.default),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefaultList",
    },
    equal: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqualToHclTerraform(struct!.equal),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqualList",
    },
    greater_than: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThanToHclTerraform(struct!.greaterThan),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThanList",
    },
    less_than: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThanToHclTerraform(struct!.lessThan),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThanList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimension | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dimension !== undefined) {
      hasAnyValues = true;
      internalValueResult.dimension = this._dimension;
    }
    if (this._dimensionVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.dimensionVar = this._dimensionVar;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueVar = this._valueVar;
    }
    if (this._default?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default?.internalValue;
    }
    if (this._equal?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.equal = this._equal?.internalValue;
    }
    if (this._greaterThan?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.greaterThan = this._greaterThan?.internalValue;
    }
    if (this._lessThan?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lessThan = this._lessThan?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimension | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dimension = undefined;
      this._dimensionVar = undefined;
      this._value = undefined;
      this._valueVar = undefined;
      this._default.internalValue = undefined;
      this._equal.internalValue = undefined;
      this._greaterThan.internalValue = undefined;
      this._lessThan.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dimension = value.dimension;
      this._dimensionVar = value.dimensionVar;
      this._value = value.value;
      this._valueVar = value.valueVar;
      this._default.internalValue = value.default;
      this._equal.internalValue = value.equal;
      this._greaterThan.internalValue = value.greaterThan;
      this._lessThan.internalValue = value.lessThan;
    }
  }

  // dimension - computed: false, optional: true, required: false
  private _dimension?: string; 
  public get dimension() {
    return this.getStringAttribute('dimension');
  }
  public set dimension(value: string) {
    this._dimension = value;
  }
  public resetDimension() {
    this._dimension = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dimensionInput() {
    return this._dimension;
  }

  // dimension_var - computed: false, optional: true, required: false
  private _dimensionVar?: string; 
  public get dimensionVar() {
    return this.getStringAttribute('dimension_var');
  }
  public set dimensionVar(value: string) {
    this._dimensionVar = value;
  }
  public resetDimensionVar() {
    this._dimensionVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dimensionVarInput() {
    return this._dimensionVar;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_var - computed: false, optional: true, required: false
  private _valueVar?: string; 
  public get valueVar() {
    return this.getStringAttribute('value_var');
  }
  public set valueVar(value: string) {
    this._valueVar = value;
  }
  public resetValueVar() {
    this._valueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueVarInput() {
    return this._valueVar;
  }

  // default - computed: false, optional: true, required: false
  private _default = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefaultOutputReference(this, "default");
  public get default() {
    return this._default;
  }
  public putDefault(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionDefault) {
    this._default.internalValue = value;
  }
  public resetDefault() {
    this._default.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default.internalValue;
  }

  // equal - computed: false, optional: true, required: false
  private _equal = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqualOutputReference(this, "equal");
  public get equal() {
    return this._equal;
  }
  public putEqual(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionEqual) {
    this._equal.internalValue = value;
  }
  public resetEqual() {
    this._equal.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get equalInput() {
    return this._equal.internalValue;
  }

  // greater_than - computed: false, optional: true, required: false
  private _greaterThan = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThanOutputReference(this, "greater_than");
  public get greaterThan() {
    return this._greaterThan;
  }
  public putGreaterThan(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionGreaterThan) {
    this._greaterThan.internalValue = value;
  }
  public resetGreaterThan() {
    this._greaterThan.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get greaterThanInput() {
    return this._greaterThan.internalValue;
  }

  // less_than - computed: false, optional: true, required: false
  private _lessThan = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThanOutputReference(this, "less_than");
  public get lessThan() {
    return this._lessThan;
  }
  public putLessThan(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionLessThan) {
    this._lessThan.internalValue = value;
  }
  public resetLessThan() {
    this._lessThan.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lessThanInput() {
    return this._lessThan.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimension[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefault {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefaultToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefaultToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefaultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefault | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefault | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscape {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscapeToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscapeOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscape): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscapeToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscapeOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscape): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscapeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscape | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscape | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortrait {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortraitToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortraitOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortrait): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortraitToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortraitOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortrait): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortraitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortrait | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortrait | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquare {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquareToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquareOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquare): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquareToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquareOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquare): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquareOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquare | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquare | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientation {
  /**
  * default block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#default DataAkamaiImagingPolicyImage#default}
  */
  readonly default?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefault;
  /**
  * landscape block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#landscape DataAkamaiImagingPolicyImage#landscape}
  */
  readonly landscape?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscape;
  /**
  * portrait block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#portrait DataAkamaiImagingPolicyImage#portrait}
  */
  readonly portrait?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortrait;
  /**
  * square block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#square DataAkamaiImagingPolicyImage#square}
  */
  readonly square?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquare;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefaultToTerraform(struct!.default),
    landscape: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscapeToTerraform(struct!.landscape),
    portrait: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortraitToTerraform(struct!.portrait),
    square: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquareToTerraform(struct!.square),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefaultToHclTerraform(struct!.default),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefaultList",
    },
    landscape: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscapeToHclTerraform(struct!.landscape),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscapeList",
    },
    portrait: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortraitToHclTerraform(struct!.portrait),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortraitList",
    },
    square: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquareToHclTerraform(struct!.square),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquareList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._default?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default?.internalValue;
    }
    if (this._landscape?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.landscape = this._landscape?.internalValue;
    }
    if (this._portrait?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.portrait = this._portrait?.internalValue;
    }
    if (this._square?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.square = this._square?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._default.internalValue = undefined;
      this._landscape.internalValue = undefined;
      this._portrait.internalValue = undefined;
      this._square.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._default.internalValue = value.default;
      this._landscape.internalValue = value.landscape;
      this._portrait.internalValue = value.portrait;
      this._square.internalValue = value.square;
    }
  }

  // default - computed: false, optional: true, required: false
  private _default = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefaultOutputReference(this, "default");
  public get default() {
    return this._default;
  }
  public putDefault(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationDefault) {
    this._default.internalValue = value;
  }
  public resetDefault() {
    this._default.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default.internalValue;
  }

  // landscape - computed: false, optional: true, required: false
  private _landscape = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscapeOutputReference(this, "landscape");
  public get landscape() {
    return this._landscape;
  }
  public putLandscape(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationLandscape) {
    this._landscape.internalValue = value;
  }
  public resetLandscape() {
    this._landscape.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get landscapeInput() {
    return this._landscape.internalValue;
  }

  // portrait - computed: false, optional: true, required: false
  private _portrait = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortraitOutputReference(this, "portrait");
  public get portrait() {
    return this._portrait;
  }
  public putPortrait(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationPortrait) {
    this._portrait.internalValue = value;
  }
  public resetPortrait() {
    this._portrait.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portraitInput() {
    return this._portrait.internalValue;
  }

  // square - computed: false, optional: true, required: false
  private _square = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquareOutputReference(this, "square");
  public get square() {
    return this._square;
  }
  public putSquare(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationSquare) {
    this._square.internalValue = value;
  }
  public resetSquare() {
    this._square.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get squareInput() {
    return this._square.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientation[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColors {
  /**
  * The value representing the maximum number of colors to use with the source image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#colors DataAkamaiImagingPolicyImage#colors}
  */
  readonly colors?: string;
  /**
  * The value representing the maximum number of colors to use with the source image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#colors_var DataAkamaiImagingPolicyImage#colors_var}
  */
  readonly colorsVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColorsToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    colors: cdktf.stringToTerraform(struct!.colors),
    colors_var: cdktf.stringToTerraform(struct!.colorsVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColorsToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    colors: {
      value: cdktf.stringToHclTerraform(struct!.colors),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    colors_var: {
      value: cdktf.stringToHclTerraform(struct!.colorsVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._colors !== undefined) {
      hasAnyValues = true;
      internalValueResult.colors = this._colors;
    }
    if (this._colorsVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorsVar = this._colorsVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._colors = undefined;
      this._colorsVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._colors = value.colors;
      this._colorsVar = value.colorsVar;
    }
  }

  // colors - computed: false, optional: true, required: false
  private _colors?: string; 
  public get colors() {
    return this.getStringAttribute('colors');
  }
  public set colors(value: string) {
    this._colors = value;
  }
  public resetColors() {
    this._colors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorsInput() {
    return this._colors;
  }

  // colors_var - computed: false, optional: true, required: false
  private _colorsVar?: string; 
  public get colorsVar() {
    return this.getStringAttribute('colors_var');
  }
  public set colorsVar(value: string) {
    this._colorsVar = value;
  }
  public resetColorsVar() {
    this._colorsVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorsVarInput() {
    return this._colorsVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColorsList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColorsOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirror {
  /**
  * Flips the image horizontally.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#horizontal DataAkamaiImagingPolicyImage#horizontal}
  */
  readonly horizontal?: string;
  /**
  * Flips the image horizontally.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#horizontal_var DataAkamaiImagingPolicyImage#horizontal_var}
  */
  readonly horizontalVar?: string;
  /**
  * Flips the image vertically.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#vertical DataAkamaiImagingPolicyImage#vertical}
  */
  readonly vertical?: string;
  /**
  * Flips the image vertically.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#vertical_var DataAkamaiImagingPolicyImage#vertical_var}
  */
  readonly verticalVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirrorToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirror | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    horizontal: cdktf.stringToTerraform(struct!.horizontal),
    horizontal_var: cdktf.stringToTerraform(struct!.horizontalVar),
    vertical: cdktf.stringToTerraform(struct!.vertical),
    vertical_var: cdktf.stringToTerraform(struct!.verticalVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirrorToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirror | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    horizontal: {
      value: cdktf.stringToHclTerraform(struct!.horizontal),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    horizontal_var: {
      value: cdktf.stringToHclTerraform(struct!.horizontalVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vertical: {
      value: cdktf.stringToHclTerraform(struct!.vertical),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vertical_var: {
      value: cdktf.stringToHclTerraform(struct!.verticalVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirrorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirror | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._horizontal !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontal = this._horizontal;
    }
    if (this._horizontalVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalVar = this._horizontalVar;
    }
    if (this._vertical !== undefined) {
      hasAnyValues = true;
      internalValueResult.vertical = this._vertical;
    }
    if (this._verticalVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.verticalVar = this._verticalVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirror | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._horizontal = undefined;
      this._horizontalVar = undefined;
      this._vertical = undefined;
      this._verticalVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._horizontal = value.horizontal;
      this._horizontalVar = value.horizontalVar;
      this._vertical = value.vertical;
      this._verticalVar = value.verticalVar;
    }
  }

  // horizontal - computed: false, optional: true, required: false
  private _horizontal?: string; 
  public get horizontal() {
    return this.getStringAttribute('horizontal');
  }
  public set horizontal(value: string) {
    this._horizontal = value;
  }
  public resetHorizontal() {
    this._horizontal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalInput() {
    return this._horizontal;
  }

  // horizontal_var - computed: false, optional: true, required: false
  private _horizontalVar?: string; 
  public get horizontalVar() {
    return this.getStringAttribute('horizontal_var');
  }
  public set horizontalVar(value: string) {
    this._horizontalVar = value;
  }
  public resetHorizontalVar() {
    this._horizontalVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalVarInput() {
    return this._horizontalVar;
  }

  // vertical - computed: false, optional: true, required: false
  private _vertical?: string; 
  public get vertical() {
    return this.getStringAttribute('vertical');
  }
  public set vertical(value: string) {
    this._vertical = value;
  }
  public resetVertical() {
    this._vertical = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verticalInput() {
    return this._vertical;
  }

  // vertical_var - computed: false, optional: true, required: false
  private _verticalVar?: string; 
  public get verticalVar() {
    return this.getStringAttribute('vertical_var');
  }
  public set verticalVar(value: string) {
    this._verticalVar = value;
  }
  public resetVerticalVar() {
    this._verticalVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verticalVarInput() {
    return this._verticalVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirrorList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirror[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirrorOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirrorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHue {
  /**
  * Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHueToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHueToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueVar = value.hueVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHueList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHue[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHueOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHueOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacity {
  /**
  * Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#opacity DataAkamaiImagingPolicyImage#opacity}
  */
  readonly opacity?: string;
  /**
  * Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#opacity_var DataAkamaiImagingPolicyImage#opacity_var}
  */
  readonly opacityVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacityToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    opacity: cdktf.stringToTerraform(struct!.opacity),
    opacity_var: cdktf.stringToTerraform(struct!.opacityVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacityToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    opacity: {
      value: cdktf.stringToHclTerraform(struct!.opacity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    opacity_var: {
      value: cdktf.stringToHclTerraform(struct!.opacityVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._opacity !== undefined) {
      hasAnyValues = true;
      internalValueResult.opacity = this._opacity;
    }
    if (this._opacityVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.opacityVar = this._opacityVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._opacity = undefined;
      this._opacityVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._opacity = value.opacity;
      this._opacityVar = value.opacityVar;
    }
  }

  // opacity - computed: false, optional: true, required: false
  private _opacity?: string; 
  public get opacity() {
    return this.getStringAttribute('opacity');
  }
  public set opacity(value: string) {
    this._opacity = value;
  }
  public resetOpacity() {
    this._opacity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opacityInput() {
    return this._opacity;
  }

  // opacity_var - computed: false, optional: true, required: false
  private _opacityVar?: string; 
  public get opacityVar() {
    return this.getStringAttribute('opacity_var');
  }
  public set opacityVar(value: string) {
    this._opacityVar = value;
  }
  public resetOpacityVar() {
    this._opacityVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opacityVarInput() {
    return this._opacityVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacityList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacity[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacityOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacityOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColor {
  /**
  * The hexadecimal CSS color value to remove.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color DataAkamaiImagingPolicyImage#color}
  */
  readonly color?: string;
  /**
  * The hexadecimal CSS color value to remove.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color_var DataAkamaiImagingPolicyImage#color_var}
  */
  readonly colorVar?: string;
  /**
  * The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#feather DataAkamaiImagingPolicyImage#feather}
  */
  readonly feather?: string;
  /**
  * The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#feather_var DataAkamaiImagingPolicyImage#feather_var}
  */
  readonly featherVar?: string;
  /**
  * The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#tolerance DataAkamaiImagingPolicyImage#tolerance}
  */
  readonly tolerance?: string;
  /**
  * The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#tolerance_var DataAkamaiImagingPolicyImage#tolerance_var}
  */
  readonly toleranceVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColorToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    color: cdktf.stringToTerraform(struct!.color),
    color_var: cdktf.stringToTerraform(struct!.colorVar),
    feather: cdktf.stringToTerraform(struct!.feather),
    feather_var: cdktf.stringToTerraform(struct!.featherVar),
    tolerance: cdktf.stringToTerraform(struct!.tolerance),
    tolerance_var: cdktf.stringToTerraform(struct!.toleranceVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColorToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    color_var: {
      value: cdktf.stringToHclTerraform(struct!.colorVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    feather: {
      value: cdktf.stringToHclTerraform(struct!.feather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    feather_var: {
      value: cdktf.stringToHclTerraform(struct!.featherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tolerance: {
      value: cdktf.stringToHclTerraform(struct!.tolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.toleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._colorVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorVar = this._colorVar;
    }
    if (this._feather !== undefined) {
      hasAnyValues = true;
      internalValueResult.feather = this._feather;
    }
    if (this._featherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.featherVar = this._featherVar;
    }
    if (this._tolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerance = this._tolerance;
    }
    if (this._toleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.toleranceVar = this._toleranceVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._color = undefined;
      this._colorVar = undefined;
      this._feather = undefined;
      this._featherVar = undefined;
      this._tolerance = undefined;
      this._toleranceVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._color = value.color;
      this._colorVar = value.colorVar;
      this._feather = value.feather;
      this._featherVar = value.featherVar;
      this._tolerance = value.tolerance;
      this._toleranceVar = value.toleranceVar;
    }
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // color_var - computed: false, optional: true, required: false
  private _colorVar?: string; 
  public get colorVar() {
    return this.getStringAttribute('color_var');
  }
  public set colorVar(value: string) {
    this._colorVar = value;
  }
  public resetColorVar() {
    this._colorVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorVarInput() {
    return this._colorVar;
  }

  // feather - computed: false, optional: true, required: false
  private _feather?: string; 
  public get feather() {
    return this.getStringAttribute('feather');
  }
  public set feather(value: string) {
    this._feather = value;
  }
  public resetFeather() {
    this._feather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featherInput() {
    return this._feather;
  }

  // feather_var - computed: false, optional: true, required: false
  private _featherVar?: string; 
  public get featherVar() {
    return this.getStringAttribute('feather_var');
  }
  public set featherVar(value: string) {
    this._featherVar = value;
  }
  public resetFeatherVar() {
    this._featherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featherVarInput() {
    return this._featherVar;
  }

  // tolerance - computed: false, optional: true, required: false
  private _tolerance?: string; 
  public get tolerance() {
    return this.getStringAttribute('tolerance');
  }
  public set tolerance(value: string) {
    this._tolerance = value;
  }
  public resetTolerance() {
    this._tolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toleranceInput() {
    return this._tolerance;
  }

  // tolerance_var - computed: false, optional: true, required: false
  private _toleranceVar?: string; 
  public get toleranceVar() {
    return this.getStringAttribute('tolerance_var');
  }
  public set toleranceVar(value: string) {
    this._toleranceVar = value;
  }
  public resetToleranceVar() {
    this._toleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toleranceVarInput() {
    return this._toleranceVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColorList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColor[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColorOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMask {
  /**
  * Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gain DataAkamaiImagingPolicyImage#gain}
  */
  readonly gain?: string;
  /**
  * Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gain_var DataAkamaiImagingPolicyImage#gain_var}
  */
  readonly gainVar?: string;
  /**
  * The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma DataAkamaiImagingPolicyImage#sigma}
  */
  readonly sigma?: string;
  /**
  * The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma_var DataAkamaiImagingPolicyImage#sigma_var}
  */
  readonly sigmaVar?: string;
  /**
  * Set the minimum change required to include a detail in the filter. Higher values discard more changes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#threshold DataAkamaiImagingPolicyImage#threshold}
  */
  readonly threshold?: string;
  /**
  * Set the minimum change required to include a detail in the filter. Higher values discard more changes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#threshold_var DataAkamaiImagingPolicyImage#threshold_var}
  */
  readonly thresholdVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMaskToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMask | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gain: cdktf.stringToTerraform(struct!.gain),
    gain_var: cdktf.stringToTerraform(struct!.gainVar),
    sigma: cdktf.stringToTerraform(struct!.sigma),
    sigma_var: cdktf.stringToTerraform(struct!.sigmaVar),
    threshold: cdktf.stringToTerraform(struct!.threshold),
    threshold_var: cdktf.stringToTerraform(struct!.thresholdVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMaskToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMask | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gain: {
      value: cdktf.stringToHclTerraform(struct!.gain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gain_var: {
      value: cdktf.stringToHclTerraform(struct!.gainVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sigma: {
      value: cdktf.stringToHclTerraform(struct!.sigma),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sigma_var: {
      value: cdktf.stringToHclTerraform(struct!.sigmaVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threshold: {
      value: cdktf.stringToHclTerraform(struct!.threshold),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threshold_var: {
      value: cdktf.stringToHclTerraform(struct!.thresholdVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMaskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMask | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gain !== undefined) {
      hasAnyValues = true;
      internalValueResult.gain = this._gain;
    }
    if (this._gainVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.gainVar = this._gainVar;
    }
    if (this._sigma !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigma = this._sigma;
    }
    if (this._sigmaVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigmaVar = this._sigmaVar;
    }
    if (this._threshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.threshold = this._threshold;
    }
    if (this._thresholdVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.thresholdVar = this._thresholdVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMask | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gain = undefined;
      this._gainVar = undefined;
      this._sigma = undefined;
      this._sigmaVar = undefined;
      this._threshold = undefined;
      this._thresholdVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gain = value.gain;
      this._gainVar = value.gainVar;
      this._sigma = value.sigma;
      this._sigmaVar = value.sigmaVar;
      this._threshold = value.threshold;
      this._thresholdVar = value.thresholdVar;
    }
  }

  // gain - computed: false, optional: true, required: false
  private _gain?: string; 
  public get gain() {
    return this.getStringAttribute('gain');
  }
  public set gain(value: string) {
    this._gain = value;
  }
  public resetGain() {
    this._gain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gainInput() {
    return this._gain;
  }

  // gain_var - computed: false, optional: true, required: false
  private _gainVar?: string; 
  public get gainVar() {
    return this.getStringAttribute('gain_var');
  }
  public set gainVar(value: string) {
    this._gainVar = value;
  }
  public resetGainVar() {
    this._gainVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gainVarInput() {
    return this._gainVar;
  }

  // sigma - computed: false, optional: true, required: false
  private _sigma?: string; 
  public get sigma() {
    return this.getStringAttribute('sigma');
  }
  public set sigma(value: string) {
    this._sigma = value;
  }
  public resetSigma() {
    this._sigma = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaInput() {
    return this._sigma;
  }

  // sigma_var - computed: false, optional: true, required: false
  private _sigmaVar?: string; 
  public get sigmaVar() {
    return this.getStringAttribute('sigma_var');
  }
  public set sigmaVar(value: string) {
    this._sigmaVar = value;
  }
  public resetSigmaVar() {
    this._sigmaVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaVarInput() {
    return this._sigmaVar;
  }

  // threshold - computed: false, optional: true, required: false
  private _threshold?: string; 
  public get threshold() {
    return this.getStringAttribute('threshold');
  }
  public set threshold(value: string) {
    this._threshold = value;
  }
  public resetThreshold() {
    this._threshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdInput() {
    return this._threshold;
  }

  // threshold_var - computed: false, optional: true, required: false
  private _thresholdVar?: string; 
  public get thresholdVar() {
    return this.getStringAttribute('threshold_var');
  }
  public set thresholdVar(value: string) {
    this._thresholdVar = value;
  }
  public resetThresholdVar() {
    this._thresholdVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdVarInput() {
    return this._thresholdVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMaskList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMask[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMaskOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMaskOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortrait {
  /**
  * background_color block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#background_color DataAkamaiImagingPolicyImage#background_color}
  */
  readonly backgroundColor?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColor[] | cdktf.IResolvable;
  /**
  * blur block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#blur DataAkamaiImagingPolicyImage#blur}
  */
  readonly blur?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlur[] | cdktf.IResolvable;
  /**
  * chroma_key block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#chroma_key DataAkamaiImagingPolicyImage#chroma_key}
  */
  readonly chromaKey?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKey[] | cdktf.IResolvable;
  /**
  * composite block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#composite DataAkamaiImagingPolicyImage#composite}
  */
  readonly composite?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitComposite[] | cdktf.IResolvable;
  /**
  * compound block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#compound DataAkamaiImagingPolicyImage#compound}
  */
  readonly compound?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompound[] | cdktf.IResolvable;
  /**
  * contrast block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#contrast DataAkamaiImagingPolicyImage#contrast}
  */
  readonly contrast?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrast[] | cdktf.IResolvable;
  /**
  * goop block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#goop DataAkamaiImagingPolicyImage#goop}
  */
  readonly goop?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoop[] | cdktf.IResolvable;
  /**
  * grayscale block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#grayscale DataAkamaiImagingPolicyImage#grayscale}
  */
  readonly grayscale?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscale[] | cdktf.IResolvable;
  /**
  * hsl block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hsl DataAkamaiImagingPolicyImage#hsl}
  */
  readonly hsl?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsl[] | cdktf.IResolvable;
  /**
  * hsv block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hsv DataAkamaiImagingPolicyImage#hsv}
  */
  readonly hsv?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsv[] | cdktf.IResolvable;
  /**
  * if_dimension block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#if_dimension DataAkamaiImagingPolicyImage#if_dimension}
  */
  readonly ifDimension?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimension[] | cdktf.IResolvable;
  /**
  * if_orientation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#if_orientation DataAkamaiImagingPolicyImage#if_orientation}
  */
  readonly ifOrientation?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientation[] | cdktf.IResolvable;
  /**
  * max_colors block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#max_colors DataAkamaiImagingPolicyImage#max_colors}
  */
  readonly maxColors?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColors[] | cdktf.IResolvable;
  /**
  * mirror block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#mirror DataAkamaiImagingPolicyImage#mirror}
  */
  readonly mirror?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirror[] | cdktf.IResolvable;
  /**
  * mono_hue block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#mono_hue DataAkamaiImagingPolicyImage#mono_hue}
  */
  readonly monoHue?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHue[] | cdktf.IResolvable;
  /**
  * opacity block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#opacity DataAkamaiImagingPolicyImage#opacity}
  */
  readonly opacity?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacity[] | cdktf.IResolvable;
  /**
  * remove_color block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#remove_color DataAkamaiImagingPolicyImage#remove_color}
  */
  readonly removeColor?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColor[] | cdktf.IResolvable;
  /**
  * unsharp_mask block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#unsharp_mask DataAkamaiImagingPolicyImage#unsharp_mask}
  */
  readonly unsharpMask?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMask[] | cdktf.IResolvable;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortrait): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    background_color: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColorToTerraform, true)(struct!.backgroundColor),
    blur: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlurToTerraform, true)(struct!.blur),
    chroma_key: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKeyToTerraform, true)(struct!.chromaKey),
    composite: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeToTerraform, true)(struct!.composite),
    compound: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundToTerraform, true)(struct!.compound),
    contrast: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrastToTerraform, true)(struct!.contrast),
    goop: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoopToTerraform, true)(struct!.goop),
    grayscale: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscaleToTerraform, true)(struct!.grayscale),
    hsl: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHslToTerraform, true)(struct!.hsl),
    hsv: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsvToTerraform, true)(struct!.hsv),
    if_dimension: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionToTerraform, true)(struct!.ifDimension),
    if_orientation: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationToTerraform, true)(struct!.ifOrientation),
    max_colors: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColorsToTerraform, true)(struct!.maxColors),
    mirror: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirrorToTerraform, true)(struct!.mirror),
    mono_hue: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHueToTerraform, true)(struct!.monoHue),
    opacity: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacityToTerraform, true)(struct!.opacity),
    remove_color: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColorToTerraform, true)(struct!.removeColor),
    unsharp_mask: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMaskToTerraform, true)(struct!.unsharpMask),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortrait): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    background_color: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColorToHclTerraform, true)(struct!.backgroundColor),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColorList",
    },
    blur: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlurToHclTerraform, true)(struct!.blur),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlurList",
    },
    chroma_key: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKeyToHclTerraform, true)(struct!.chromaKey),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKeyList",
    },
    composite: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeToHclTerraform, true)(struct!.composite),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeList",
    },
    compound: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundToHclTerraform, true)(struct!.compound),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundList",
    },
    contrast: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrastToHclTerraform, true)(struct!.contrast),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrastList",
    },
    goop: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoopToHclTerraform, true)(struct!.goop),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoopList",
    },
    grayscale: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscaleToHclTerraform, true)(struct!.grayscale),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscaleList",
    },
    hsl: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHslToHclTerraform, true)(struct!.hsl),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHslList",
    },
    hsv: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsvToHclTerraform, true)(struct!.hsv),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsvList",
    },
    if_dimension: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionToHclTerraform, true)(struct!.ifDimension),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionList",
    },
    if_orientation: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationToHclTerraform, true)(struct!.ifOrientation),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationList",
    },
    max_colors: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColorsToHclTerraform, true)(struct!.maxColors),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColorsList",
    },
    mirror: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirrorToHclTerraform, true)(struct!.mirror),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirrorList",
    },
    mono_hue: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHueToHclTerraform, true)(struct!.monoHue),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHueList",
    },
    opacity: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacityToHclTerraform, true)(struct!.opacity),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacityList",
    },
    remove_color: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColorToHclTerraform, true)(struct!.removeColor),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColorList",
    },
    unsharp_mask: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMaskToHclTerraform, true)(struct!.unsharpMask),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMaskList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortrait | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backgroundColor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backgroundColor = this._backgroundColor?.internalValue;
    }
    if (this._blur?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.blur = this._blur?.internalValue;
    }
    if (this._chromaKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.chromaKey = this._chromaKey?.internalValue;
    }
    if (this._composite?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.composite = this._composite?.internalValue;
    }
    if (this._compound?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.compound = this._compound?.internalValue;
    }
    if (this._contrast?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.contrast = this._contrast?.internalValue;
    }
    if (this._goop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.goop = this._goop?.internalValue;
    }
    if (this._grayscale?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grayscale = this._grayscale?.internalValue;
    }
    if (this._hsl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hsl = this._hsl?.internalValue;
    }
    if (this._hsv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hsv = this._hsv?.internalValue;
    }
    if (this._ifDimension?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ifDimension = this._ifDimension?.internalValue;
    }
    if (this._ifOrientation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ifOrientation = this._ifOrientation?.internalValue;
    }
    if (this._maxColors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxColors = this._maxColors?.internalValue;
    }
    if (this._mirror?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mirror = this._mirror?.internalValue;
    }
    if (this._monoHue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.monoHue = this._monoHue?.internalValue;
    }
    if (this._opacity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.opacity = this._opacity?.internalValue;
    }
    if (this._removeColor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeColor = this._removeColor?.internalValue;
    }
    if (this._unsharpMask?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unsharpMask = this._unsharpMask?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortrait | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._backgroundColor.internalValue = undefined;
      this._blur.internalValue = undefined;
      this._chromaKey.internalValue = undefined;
      this._composite.internalValue = undefined;
      this._compound.internalValue = undefined;
      this._contrast.internalValue = undefined;
      this._goop.internalValue = undefined;
      this._grayscale.internalValue = undefined;
      this._hsl.internalValue = undefined;
      this._hsv.internalValue = undefined;
      this._ifDimension.internalValue = undefined;
      this._ifOrientation.internalValue = undefined;
      this._maxColors.internalValue = undefined;
      this._mirror.internalValue = undefined;
      this._monoHue.internalValue = undefined;
      this._opacity.internalValue = undefined;
      this._removeColor.internalValue = undefined;
      this._unsharpMask.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._backgroundColor.internalValue = value.backgroundColor;
      this._blur.internalValue = value.blur;
      this._chromaKey.internalValue = value.chromaKey;
      this._composite.internalValue = value.composite;
      this._compound.internalValue = value.compound;
      this._contrast.internalValue = value.contrast;
      this._goop.internalValue = value.goop;
      this._grayscale.internalValue = value.grayscale;
      this._hsl.internalValue = value.hsl;
      this._hsv.internalValue = value.hsv;
      this._ifDimension.internalValue = value.ifDimension;
      this._ifOrientation.internalValue = value.ifOrientation;
      this._maxColors.internalValue = value.maxColors;
      this._mirror.internalValue = value.mirror;
      this._monoHue.internalValue = value.monoHue;
      this._opacity.internalValue = value.opacity;
      this._removeColor.internalValue = value.removeColor;
      this._unsharpMask.internalValue = value.unsharpMask;
    }
  }

  // background_color - computed: false, optional: true, required: false
  private _backgroundColor = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColorList(this, "background_color", false);
  public get backgroundColor() {
    return this._backgroundColor;
  }
  public putBackgroundColor(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBackgroundColor[] | cdktf.IResolvable) {
    this._backgroundColor.internalValue = value;
  }
  public resetBackgroundColor() {
    this._backgroundColor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backgroundColorInput() {
    return this._backgroundColor.internalValue;
  }

  // blur - computed: false, optional: true, required: false
  private _blur = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlurList(this, "blur", false);
  public get blur() {
    return this._blur;
  }
  public putBlur(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitBlur[] | cdktf.IResolvable) {
    this._blur.internalValue = value;
  }
  public resetBlur() {
    this._blur.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blurInput() {
    return this._blur.internalValue;
  }

  // chroma_key - computed: false, optional: true, required: false
  private _chromaKey = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKeyList(this, "chroma_key", false);
  public get chromaKey() {
    return this._chromaKey;
  }
  public putChromaKey(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitChromaKey[] | cdktf.IResolvable) {
    this._chromaKey.internalValue = value;
  }
  public resetChromaKey() {
    this._chromaKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chromaKeyInput() {
    return this._chromaKey.internalValue;
  }

  // composite - computed: false, optional: true, required: false
  private _composite = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompositeList(this, "composite", false);
  public get composite() {
    return this._composite;
  }
  public putComposite(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitComposite[] | cdktf.IResolvable) {
    this._composite.internalValue = value;
  }
  public resetComposite() {
    this._composite.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compositeInput() {
    return this._composite.internalValue;
  }

  // compound - computed: false, optional: true, required: false
  private _compound = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompoundList(this, "compound", false);
  public get compound() {
    return this._compound;
  }
  public putCompound(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitCompound[] | cdktf.IResolvable) {
    this._compound.internalValue = value;
  }
  public resetCompound() {
    this._compound.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compoundInput() {
    return this._compound.internalValue;
  }

  // contrast - computed: false, optional: true, required: false
  private _contrast = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrastList(this, "contrast", false);
  public get contrast() {
    return this._contrast;
  }
  public putContrast(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitContrast[] | cdktf.IResolvable) {
    this._contrast.internalValue = value;
  }
  public resetContrast() {
    this._contrast.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contrastInput() {
    return this._contrast.internalValue;
  }

  // goop - computed: false, optional: true, required: false
  private _goop = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoopList(this, "goop", false);
  public get goop() {
    return this._goop;
  }
  public putGoop(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGoop[] | cdktf.IResolvable) {
    this._goop.internalValue = value;
  }
  public resetGoop() {
    this._goop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get goopInput() {
    return this._goop.internalValue;
  }

  // grayscale - computed: false, optional: true, required: false
  private _grayscale = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscaleList(this, "grayscale", false);
  public get grayscale() {
    return this._grayscale;
  }
  public putGrayscale(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitGrayscale[] | cdktf.IResolvable) {
    this._grayscale.internalValue = value;
  }
  public resetGrayscale() {
    this._grayscale.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grayscaleInput() {
    return this._grayscale.internalValue;
  }

  // hsl - computed: false, optional: true, required: false
  private _hsl = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHslList(this, "hsl", false);
  public get hsl() {
    return this._hsl;
  }
  public putHsl(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsl[] | cdktf.IResolvable) {
    this._hsl.internalValue = value;
  }
  public resetHsl() {
    this._hsl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hslInput() {
    return this._hsl.internalValue;
  }

  // hsv - computed: false, optional: true, required: false
  private _hsv = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsvList(this, "hsv", false);
  public get hsv() {
    return this._hsv;
  }
  public putHsv(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitHsv[] | cdktf.IResolvable) {
    this._hsv.internalValue = value;
  }
  public resetHsv() {
    this._hsv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hsvInput() {
    return this._hsv.internalValue;
  }

  // if_dimension - computed: false, optional: true, required: false
  private _ifDimension = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimensionList(this, "if_dimension", false);
  public get ifDimension() {
    return this._ifDimension;
  }
  public putIfDimension(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfDimension[] | cdktf.IResolvable) {
    this._ifDimension.internalValue = value;
  }
  public resetIfDimension() {
    this._ifDimension.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ifDimensionInput() {
    return this._ifDimension.internalValue;
  }

  // if_orientation - computed: false, optional: true, required: false
  private _ifOrientation = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientationList(this, "if_orientation", false);
  public get ifOrientation() {
    return this._ifOrientation;
  }
  public putIfOrientation(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitIfOrientation[] | cdktf.IResolvable) {
    this._ifOrientation.internalValue = value;
  }
  public resetIfOrientation() {
    this._ifOrientation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ifOrientationInput() {
    return this._ifOrientation.internalValue;
  }

  // max_colors - computed: false, optional: true, required: false
  private _maxColors = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColorsList(this, "max_colors", false);
  public get maxColors() {
    return this._maxColors;
  }
  public putMaxColors(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMaxColors[] | cdktf.IResolvable) {
    this._maxColors.internalValue = value;
  }
  public resetMaxColors() {
    this._maxColors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxColorsInput() {
    return this._maxColors.internalValue;
  }

  // mirror - computed: false, optional: true, required: false
  private _mirror = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirrorList(this, "mirror", false);
  public get mirror() {
    return this._mirror;
  }
  public putMirror(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMirror[] | cdktf.IResolvable) {
    this._mirror.internalValue = value;
  }
  public resetMirror() {
    this._mirror.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mirrorInput() {
    return this._mirror.internalValue;
  }

  // mono_hue - computed: false, optional: true, required: false
  private _monoHue = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHueList(this, "mono_hue", false);
  public get monoHue() {
    return this._monoHue;
  }
  public putMonoHue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitMonoHue[] | cdktf.IResolvable) {
    this._monoHue.internalValue = value;
  }
  public resetMonoHue() {
    this._monoHue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monoHueInput() {
    return this._monoHue.internalValue;
  }

  // opacity - computed: false, optional: true, required: false
  private _opacity = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacityList(this, "opacity", false);
  public get opacity() {
    return this._opacity;
  }
  public putOpacity(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOpacity[] | cdktf.IResolvable) {
    this._opacity.internalValue = value;
  }
  public resetOpacity() {
    this._opacity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opacityInput() {
    return this._opacity.internalValue;
  }

  // remove_color - computed: false, optional: true, required: false
  private _removeColor = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColorList(this, "remove_color", false);
  public get removeColor() {
    return this._removeColor;
  }
  public putRemoveColor(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitRemoveColor[] | cdktf.IResolvable) {
    this._removeColor.internalValue = value;
  }
  public resetRemoveColor() {
    this._removeColor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeColorInput() {
    return this._removeColor.internalValue;
  }

  // unsharp_mask - computed: false, optional: true, required: false
  private _unsharpMask = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMaskList(this, "unsharp_mask", false);
  public get unsharpMask() {
    return this._unsharpMask;
  }
  public putUnsharpMask(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitUnsharpMask[] | cdktf.IResolvable) {
    this._unsharpMask.internalValue = value;
  }
  public resetUnsharpMask() {
    this._unsharpMask.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unsharpMaskInput() {
    return this._unsharpMask.internalValue;
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColor {
  /**
  * The hexadecimal CSS color value for the background.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color DataAkamaiImagingPolicyImage#color}
  */
  readonly color?: string;
  /**
  * The hexadecimal CSS color value for the background.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color_var DataAkamaiImagingPolicyImage#color_var}
  */
  readonly colorVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColorToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    color: cdktf.stringToTerraform(struct!.color),
    color_var: cdktf.stringToTerraform(struct!.colorVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColorToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    color_var: {
      value: cdktf.stringToHclTerraform(struct!.colorVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._colorVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorVar = this._colorVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._color = undefined;
      this._colorVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._color = value.color;
      this._colorVar = value.colorVar;
    }
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // color_var - computed: false, optional: true, required: false
  private _colorVar?: string; 
  public get colorVar() {
    return this.getStringAttribute('color_var');
  }
  public set colorVar(value: string) {
    this._colorVar = value;
  }
  public resetColorVar() {
    this._colorVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorVarInput() {
    return this._colorVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColorList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColor[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColorOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlur {
  /**
  * The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma DataAkamaiImagingPolicyImage#sigma}
  */
  readonly sigma?: string;
  /**
  * The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma_var DataAkamaiImagingPolicyImage#sigma_var}
  */
  readonly sigmaVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlurToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlur | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sigma: cdktf.stringToTerraform(struct!.sigma),
    sigma_var: cdktf.stringToTerraform(struct!.sigmaVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlurToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlur | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sigma: {
      value: cdktf.stringToHclTerraform(struct!.sigma),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sigma_var: {
      value: cdktf.stringToHclTerraform(struct!.sigmaVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlurOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlur | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sigma !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigma = this._sigma;
    }
    if (this._sigmaVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigmaVar = this._sigmaVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlur | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sigma = undefined;
      this._sigmaVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sigma = value.sigma;
      this._sigmaVar = value.sigmaVar;
    }
  }

  // sigma - computed: false, optional: true, required: false
  private _sigma?: string; 
  public get sigma() {
    return this.getStringAttribute('sigma');
  }
  public set sigma(value: string) {
    this._sigma = value;
  }
  public resetSigma() {
    this._sigma = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaInput() {
    return this._sigma;
  }

  // sigma_var - computed: false, optional: true, required: false
  private _sigmaVar?: string; 
  public get sigmaVar() {
    return this.getStringAttribute('sigma_var');
  }
  public set sigmaVar(value: string) {
    this._sigmaVar = value;
  }
  public resetSigmaVar() {
    this._sigmaVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaVarInput() {
    return this._sigmaVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlurList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlur[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlurOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlurOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKey {
  /**
  * The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_feather DataAkamaiImagingPolicyImage#hue_feather}
  */
  readonly hueFeather?: string;
  /**
  * How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_feather_var DataAkamaiImagingPolicyImage#hue_feather_var}
  */
  readonly hueFeatherVar?: string;
  /**
  * How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_tolerance DataAkamaiImagingPolicyImage#hue_tolerance}
  */
  readonly hueTolerance?: string;
  /**
  * How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_tolerance_var DataAkamaiImagingPolicyImage#hue_tolerance_var}
  */
  readonly hueToleranceVar?: string;
  /**
  * The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
  /**
  * How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_feather DataAkamaiImagingPolicyImage#lightness_feather}
  */
  readonly lightnessFeather?: string;
  /**
  * How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_feather_var DataAkamaiImagingPolicyImage#lightness_feather_var}
  */
  readonly lightnessFeatherVar?: string;
  /**
  * How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_tolerance DataAkamaiImagingPolicyImage#lightness_tolerance}
  */
  readonly lightnessTolerance?: string;
  /**
  * How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_tolerance_var DataAkamaiImagingPolicyImage#lightness_tolerance_var}
  */
  readonly lightnessToleranceVar?: string;
  /**
  * How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_feather DataAkamaiImagingPolicyImage#saturation_feather}
  */
  readonly saturationFeather?: string;
  /**
  * How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_feather_var DataAkamaiImagingPolicyImage#saturation_feather_var}
  */
  readonly saturationFeatherVar?: string;
  /**
  * How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_tolerance DataAkamaiImagingPolicyImage#saturation_tolerance}
  */
  readonly saturationTolerance?: string;
  /**
  * How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_tolerance_var DataAkamaiImagingPolicyImage#saturation_tolerance_var}
  */
  readonly saturationToleranceVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKeyToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_feather: cdktf.stringToTerraform(struct!.hueFeather),
    hue_feather_var: cdktf.stringToTerraform(struct!.hueFeatherVar),
    hue_tolerance: cdktf.stringToTerraform(struct!.hueTolerance),
    hue_tolerance_var: cdktf.stringToTerraform(struct!.hueToleranceVar),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
    lightness_feather: cdktf.stringToTerraform(struct!.lightnessFeather),
    lightness_feather_var: cdktf.stringToTerraform(struct!.lightnessFeatherVar),
    lightness_tolerance: cdktf.stringToTerraform(struct!.lightnessTolerance),
    lightness_tolerance_var: cdktf.stringToTerraform(struct!.lightnessToleranceVar),
    saturation_feather: cdktf.stringToTerraform(struct!.saturationFeather),
    saturation_feather_var: cdktf.stringToTerraform(struct!.saturationFeatherVar),
    saturation_tolerance: cdktf.stringToTerraform(struct!.saturationTolerance),
    saturation_tolerance_var: cdktf.stringToTerraform(struct!.saturationToleranceVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKeyToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_feather: {
      value: cdktf.stringToHclTerraform(struct!.hueFeather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_feather_var: {
      value: cdktf.stringToHclTerraform(struct!.hueFeatherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.hueTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.hueToleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_feather: {
      value: cdktf.stringToHclTerraform(struct!.lightnessFeather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_feather_var: {
      value: cdktf.stringToHclTerraform(struct!.lightnessFeatherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.lightnessTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.lightnessToleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_feather: {
      value: cdktf.stringToHclTerraform(struct!.saturationFeather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_feather_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationFeatherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.saturationTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationToleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueFeather !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueFeather = this._hueFeather;
    }
    if (this._hueFeatherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueFeatherVar = this._hueFeatherVar;
    }
    if (this._hueTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueTolerance = this._hueTolerance;
    }
    if (this._hueToleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueToleranceVar = this._hueToleranceVar;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    if (this._lightnessFeather !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessFeather = this._lightnessFeather;
    }
    if (this._lightnessFeatherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessFeatherVar = this._lightnessFeatherVar;
    }
    if (this._lightnessTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessTolerance = this._lightnessTolerance;
    }
    if (this._lightnessToleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessToleranceVar = this._lightnessToleranceVar;
    }
    if (this._saturationFeather !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationFeather = this._saturationFeather;
    }
    if (this._saturationFeatherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationFeatherVar = this._saturationFeatherVar;
    }
    if (this._saturationTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationTolerance = this._saturationTolerance;
    }
    if (this._saturationToleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationToleranceVar = this._saturationToleranceVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueFeather = undefined;
      this._hueFeatherVar = undefined;
      this._hueTolerance = undefined;
      this._hueToleranceVar = undefined;
      this._hueVar = undefined;
      this._lightnessFeather = undefined;
      this._lightnessFeatherVar = undefined;
      this._lightnessTolerance = undefined;
      this._lightnessToleranceVar = undefined;
      this._saturationFeather = undefined;
      this._saturationFeatherVar = undefined;
      this._saturationTolerance = undefined;
      this._saturationToleranceVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueFeather = value.hueFeather;
      this._hueFeatherVar = value.hueFeatherVar;
      this._hueTolerance = value.hueTolerance;
      this._hueToleranceVar = value.hueToleranceVar;
      this._hueVar = value.hueVar;
      this._lightnessFeather = value.lightnessFeather;
      this._lightnessFeatherVar = value.lightnessFeatherVar;
      this._lightnessTolerance = value.lightnessTolerance;
      this._lightnessToleranceVar = value.lightnessToleranceVar;
      this._saturationFeather = value.saturationFeather;
      this._saturationFeatherVar = value.saturationFeatherVar;
      this._saturationTolerance = value.saturationTolerance;
      this._saturationToleranceVar = value.saturationToleranceVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_feather - computed: false, optional: true, required: false
  private _hueFeather?: string; 
  public get hueFeather() {
    return this.getStringAttribute('hue_feather');
  }
  public set hueFeather(value: string) {
    this._hueFeather = value;
  }
  public resetHueFeather() {
    this._hueFeather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueFeatherInput() {
    return this._hueFeather;
  }

  // hue_feather_var - computed: false, optional: true, required: false
  private _hueFeatherVar?: string; 
  public get hueFeatherVar() {
    return this.getStringAttribute('hue_feather_var');
  }
  public set hueFeatherVar(value: string) {
    this._hueFeatherVar = value;
  }
  public resetHueFeatherVar() {
    this._hueFeatherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueFeatherVarInput() {
    return this._hueFeatherVar;
  }

  // hue_tolerance - computed: false, optional: true, required: false
  private _hueTolerance?: string; 
  public get hueTolerance() {
    return this.getStringAttribute('hue_tolerance');
  }
  public set hueTolerance(value: string) {
    this._hueTolerance = value;
  }
  public resetHueTolerance() {
    this._hueTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueToleranceInput() {
    return this._hueTolerance;
  }

  // hue_tolerance_var - computed: false, optional: true, required: false
  private _hueToleranceVar?: string; 
  public get hueToleranceVar() {
    return this.getStringAttribute('hue_tolerance_var');
  }
  public set hueToleranceVar(value: string) {
    this._hueToleranceVar = value;
  }
  public resetHueToleranceVar() {
    this._hueToleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueToleranceVarInput() {
    return this._hueToleranceVar;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }

  // lightness_feather - computed: false, optional: true, required: false
  private _lightnessFeather?: string; 
  public get lightnessFeather() {
    return this.getStringAttribute('lightness_feather');
  }
  public set lightnessFeather(value: string) {
    this._lightnessFeather = value;
  }
  public resetLightnessFeather() {
    this._lightnessFeather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessFeatherInput() {
    return this._lightnessFeather;
  }

  // lightness_feather_var - computed: false, optional: true, required: false
  private _lightnessFeatherVar?: string; 
  public get lightnessFeatherVar() {
    return this.getStringAttribute('lightness_feather_var');
  }
  public set lightnessFeatherVar(value: string) {
    this._lightnessFeatherVar = value;
  }
  public resetLightnessFeatherVar() {
    this._lightnessFeatherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessFeatherVarInput() {
    return this._lightnessFeatherVar;
  }

  // lightness_tolerance - computed: false, optional: true, required: false
  private _lightnessTolerance?: string; 
  public get lightnessTolerance() {
    return this.getStringAttribute('lightness_tolerance');
  }
  public set lightnessTolerance(value: string) {
    this._lightnessTolerance = value;
  }
  public resetLightnessTolerance() {
    this._lightnessTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessToleranceInput() {
    return this._lightnessTolerance;
  }

  // lightness_tolerance_var - computed: false, optional: true, required: false
  private _lightnessToleranceVar?: string; 
  public get lightnessToleranceVar() {
    return this.getStringAttribute('lightness_tolerance_var');
  }
  public set lightnessToleranceVar(value: string) {
    this._lightnessToleranceVar = value;
  }
  public resetLightnessToleranceVar() {
    this._lightnessToleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessToleranceVarInput() {
    return this._lightnessToleranceVar;
  }

  // saturation_feather - computed: false, optional: true, required: false
  private _saturationFeather?: string; 
  public get saturationFeather() {
    return this.getStringAttribute('saturation_feather');
  }
  public set saturationFeather(value: string) {
    this._saturationFeather = value;
  }
  public resetSaturationFeather() {
    this._saturationFeather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationFeatherInput() {
    return this._saturationFeather;
  }

  // saturation_feather_var - computed: false, optional: true, required: false
  private _saturationFeatherVar?: string; 
  public get saturationFeatherVar() {
    return this.getStringAttribute('saturation_feather_var');
  }
  public set saturationFeatherVar(value: string) {
    this._saturationFeatherVar = value;
  }
  public resetSaturationFeatherVar() {
    this._saturationFeatherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationFeatherVarInput() {
    return this._saturationFeatherVar;
  }

  // saturation_tolerance - computed: false, optional: true, required: false
  private _saturationTolerance?: string; 
  public get saturationTolerance() {
    return this.getStringAttribute('saturation_tolerance');
  }
  public set saturationTolerance(value: string) {
    this._saturationTolerance = value;
  }
  public resetSaturationTolerance() {
    this._saturationTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationToleranceInput() {
    return this._saturationTolerance;
  }

  // saturation_tolerance_var - computed: false, optional: true, required: false
  private _saturationToleranceVar?: string; 
  public get saturationToleranceVar() {
    return this.getStringAttribute('saturation_tolerance_var');
  }
  public set saturationToleranceVar(value: string) {
    this._saturationToleranceVar = value;
  }
  public resetSaturationToleranceVar() {
    this._saturationToleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationToleranceVarInput() {
    return this._saturationToleranceVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKeyList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKey[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKeyOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKeyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImage {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImageToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImageOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImage): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImageToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImageOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImage): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImage | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImage | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareComposite {
  /**
  * Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gravity DataAkamaiImagingPolicyImage#gravity}
  */
  readonly gravity?: string;
  /**
  * Compass direction indicating the corner or edge of the base image to place the applied image. Use Horizontal and Vertical Offset to adjust the applied image's gravity position
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gravity_var DataAkamaiImagingPolicyImage#gravity_var}
  */
  readonly gravityVar?: string;
  /**
  * Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#placement DataAkamaiImagingPolicyImage#placement}
  */
  readonly placement?: string;
  /**
  * Place applied image on top of or underneath the base image. Watermarks are usually applied over. Backgrounds are usually applied under.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#placement_var DataAkamaiImagingPolicyImage#placement_var}
  */
  readonly placementVar?: string;
  /**
  * A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#scale DataAkamaiImagingPolicyImage#scale}
  */
  readonly scale?: string;
  /**
  * The dimension, either `width` or `height`, of the source image to scale.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#scale_dimension DataAkamaiImagingPolicyImage#scale_dimension}
  */
  readonly scaleDimension?: string;
  /**
  * The dimension, either `width` or `height`, of the source image to scale.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#scale_dimension_var DataAkamaiImagingPolicyImage#scale_dimension_var}
  */
  readonly scaleDimensionVar?: string;
  /**
  * A multiplier to resize the applied image relative to the source image and preserve aspect ratio, 1 by default. Set the `scaleDimension` to calculate the `scale` from the source image's width or height.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#scale_var DataAkamaiImagingPolicyImage#scale_var}
  */
  readonly scaleVar?: string;
  /**
  * The x-axis position of the image to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#x_position DataAkamaiImagingPolicyImage#x_position}
  */
  readonly xPosition?: string;
  /**
  * The x-axis position of the image to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#x_position_var DataAkamaiImagingPolicyImage#x_position_var}
  */
  readonly xPositionVar?: string;
  /**
  * The y-axis position of the image to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#y_position DataAkamaiImagingPolicyImage#y_position}
  */
  readonly yPosition?: string;
  /**
  * The y-axis position of the image to apply.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#y_position_var DataAkamaiImagingPolicyImage#y_position_var}
  */
  readonly yPositionVar?: string;
  /**
  * image block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#image DataAkamaiImagingPolicyImage#image}
  */
  readonly image: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImage;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareComposite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gravity: cdktf.stringToTerraform(struct!.gravity),
    gravity_var: cdktf.stringToTerraform(struct!.gravityVar),
    placement: cdktf.stringToTerraform(struct!.placement),
    placement_var: cdktf.stringToTerraform(struct!.placementVar),
    scale: cdktf.stringToTerraform(struct!.scale),
    scale_dimension: cdktf.stringToTerraform(struct!.scaleDimension),
    scale_dimension_var: cdktf.stringToTerraform(struct!.scaleDimensionVar),
    scale_var: cdktf.stringToTerraform(struct!.scaleVar),
    x_position: cdktf.stringToTerraform(struct!.xPosition),
    x_position_var: cdktf.stringToTerraform(struct!.xPositionVar),
    y_position: cdktf.stringToTerraform(struct!.yPosition),
    y_position_var: cdktf.stringToTerraform(struct!.yPositionVar),
    image: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImageToTerraform(struct!.image),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareComposite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gravity: {
      value: cdktf.stringToHclTerraform(struct!.gravity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gravity_var: {
      value: cdktf.stringToHclTerraform(struct!.gravityVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    placement: {
      value: cdktf.stringToHclTerraform(struct!.placement),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    placement_var: {
      value: cdktf.stringToHclTerraform(struct!.placementVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale: {
      value: cdktf.stringToHclTerraform(struct!.scale),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale_dimension: {
      value: cdktf.stringToHclTerraform(struct!.scaleDimension),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale_dimension_var: {
      value: cdktf.stringToHclTerraform(struct!.scaleDimensionVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scale_var: {
      value: cdktf.stringToHclTerraform(struct!.scaleVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    x_position: {
      value: cdktf.stringToHclTerraform(struct!.xPosition),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    x_position_var: {
      value: cdktf.stringToHclTerraform(struct!.xPositionVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    y_position: {
      value: cdktf.stringToHclTerraform(struct!.yPosition),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    y_position_var: {
      value: cdktf.stringToHclTerraform(struct!.yPositionVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImageToHclTerraform(struct!.image),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImageList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareComposite | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gravity !== undefined) {
      hasAnyValues = true;
      internalValueResult.gravity = this._gravity;
    }
    if (this._gravityVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.gravityVar = this._gravityVar;
    }
    if (this._placement !== undefined) {
      hasAnyValues = true;
      internalValueResult.placement = this._placement;
    }
    if (this._placementVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.placementVar = this._placementVar;
    }
    if (this._scale !== undefined) {
      hasAnyValues = true;
      internalValueResult.scale = this._scale;
    }
    if (this._scaleDimension !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleDimension = this._scaleDimension;
    }
    if (this._scaleDimensionVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleDimensionVar = this._scaleDimensionVar;
    }
    if (this._scaleVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.scaleVar = this._scaleVar;
    }
    if (this._xPosition !== undefined) {
      hasAnyValues = true;
      internalValueResult.xPosition = this._xPosition;
    }
    if (this._xPositionVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.xPositionVar = this._xPositionVar;
    }
    if (this._yPosition !== undefined) {
      hasAnyValues = true;
      internalValueResult.yPosition = this._yPosition;
    }
    if (this._yPositionVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.yPositionVar = this._yPositionVar;
    }
    if (this._image?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareComposite | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gravity = undefined;
      this._gravityVar = undefined;
      this._placement = undefined;
      this._placementVar = undefined;
      this._scale = undefined;
      this._scaleDimension = undefined;
      this._scaleDimensionVar = undefined;
      this._scaleVar = undefined;
      this._xPosition = undefined;
      this._xPositionVar = undefined;
      this._yPosition = undefined;
      this._yPositionVar = undefined;
      this._image.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gravity = value.gravity;
      this._gravityVar = value.gravityVar;
      this._placement = value.placement;
      this._placementVar = value.placementVar;
      this._scale = value.scale;
      this._scaleDimension = value.scaleDimension;
      this._scaleDimensionVar = value.scaleDimensionVar;
      this._scaleVar = value.scaleVar;
      this._xPosition = value.xPosition;
      this._xPositionVar = value.xPositionVar;
      this._yPosition = value.yPosition;
      this._yPositionVar = value.yPositionVar;
      this._image.internalValue = value.image;
    }
  }

  // gravity - computed: false, optional: true, required: false
  private _gravity?: string; 
  public get gravity() {
    return this.getStringAttribute('gravity');
  }
  public set gravity(value: string) {
    this._gravity = value;
  }
  public resetGravity() {
    this._gravity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gravityInput() {
    return this._gravity;
  }

  // gravity_var - computed: false, optional: true, required: false
  private _gravityVar?: string; 
  public get gravityVar() {
    return this.getStringAttribute('gravity_var');
  }
  public set gravityVar(value: string) {
    this._gravityVar = value;
  }
  public resetGravityVar() {
    this._gravityVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gravityVarInput() {
    return this._gravityVar;
  }

  // placement - computed: false, optional: true, required: false
  private _placement?: string; 
  public get placement() {
    return this.getStringAttribute('placement');
  }
  public set placement(value: string) {
    this._placement = value;
  }
  public resetPlacement() {
    this._placement = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get placementInput() {
    return this._placement;
  }

  // placement_var - computed: false, optional: true, required: false
  private _placementVar?: string; 
  public get placementVar() {
    return this.getStringAttribute('placement_var');
  }
  public set placementVar(value: string) {
    this._placementVar = value;
  }
  public resetPlacementVar() {
    this._placementVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get placementVarInput() {
    return this._placementVar;
  }

  // scale - computed: false, optional: true, required: false
  private _scale?: string; 
  public get scale() {
    return this.getStringAttribute('scale');
  }
  public set scale(value: string) {
    this._scale = value;
  }
  public resetScale() {
    this._scale = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleInput() {
    return this._scale;
  }

  // scale_dimension - computed: false, optional: true, required: false
  private _scaleDimension?: string; 
  public get scaleDimension() {
    return this.getStringAttribute('scale_dimension');
  }
  public set scaleDimension(value: string) {
    this._scaleDimension = value;
  }
  public resetScaleDimension() {
    this._scaleDimension = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleDimensionInput() {
    return this._scaleDimension;
  }

  // scale_dimension_var - computed: false, optional: true, required: false
  private _scaleDimensionVar?: string; 
  public get scaleDimensionVar() {
    return this.getStringAttribute('scale_dimension_var');
  }
  public set scaleDimensionVar(value: string) {
    this._scaleDimensionVar = value;
  }
  public resetScaleDimensionVar() {
    this._scaleDimensionVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleDimensionVarInput() {
    return this._scaleDimensionVar;
  }

  // scale_var - computed: false, optional: true, required: false
  private _scaleVar?: string; 
  public get scaleVar() {
    return this.getStringAttribute('scale_var');
  }
  public set scaleVar(value: string) {
    this._scaleVar = value;
  }
  public resetScaleVar() {
    this._scaleVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scaleVarInput() {
    return this._scaleVar;
  }

  // x_position - computed: false, optional: true, required: false
  private _xPosition?: string; 
  public get xPosition() {
    return this.getStringAttribute('x_position');
  }
  public set xPosition(value: string) {
    this._xPosition = value;
  }
  public resetXPosition() {
    this._xPosition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xPositionInput() {
    return this._xPosition;
  }

  // x_position_var - computed: false, optional: true, required: false
  private _xPositionVar?: string; 
  public get xPositionVar() {
    return this.getStringAttribute('x_position_var');
  }
  public set xPositionVar(value: string) {
    this._xPositionVar = value;
  }
  public resetXPositionVar() {
    this._xPositionVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xPositionVarInput() {
    return this._xPositionVar;
  }

  // y_position - computed: false, optional: true, required: false
  private _yPosition?: string; 
  public get yPosition() {
    return this.getStringAttribute('y_position');
  }
  public set yPosition(value: string) {
    this._yPosition = value;
  }
  public resetYPosition() {
    this._yPosition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get yPositionInput() {
    return this._yPosition;
  }

  // y_position_var - computed: false, optional: true, required: false
  private _yPositionVar?: string; 
  public get yPositionVar() {
    return this.getStringAttribute('y_position_var');
  }
  public set yPositionVar(value: string) {
    this._yPositionVar = value;
  }
  public resetYPositionVar() {
    this._yPositionVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get yPositionVarInput() {
    return this._yPositionVar;
  }

  // image - computed: false, optional: false, required: true
  private _image = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImageOutputReference(this, "image");
  public get image() {
    return this._image;
  }
  public putImage(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeImage) {
    this._image.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareComposite[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformations {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformationsToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformationsToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformationsList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformationsOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompound {
  /**
  * transformations block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#transformations DataAkamaiImagingPolicyImage#transformations}
  */
  readonly transformations?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformations[] | cdktf.IResolvable;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompound | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    transformations: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformationsToTerraform, true)(struct!.transformations),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompound | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    transformations: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformationsToHclTerraform, true)(struct!.transformations),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformationsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompound | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._transformations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformations = this._transformations?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompound | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._transformations.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._transformations.internalValue = value.transformations;
    }
  }

  // transformations - computed: false, optional: true, required: false
  private _transformations = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformationsList(this, "transformations", false);
  public get transformations() {
    return this._transformations;
  }
  public putTransformations(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundTransformations[] | cdktf.IResolvable) {
    this._transformations.internalValue = value;
  }
  public resetTransformations() {
    this._transformations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationsInput() {
    return this._transformations.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompound[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrast {
  /**
  * Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#brightness DataAkamaiImagingPolicyImage#brightness}
  */
  readonly brightness?: string;
  /**
  * Adjusts the brightness of the image. Positive values increase brightness and negative values decrease brightness. A value of  `1` produces a white image. A value of  `-1` produces a black image. The default value is `0`, which leaves the image unchanged. The acceptable value range is `-1.0` to `1.0`. Values outside of the acceptable range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#brightness_var DataAkamaiImagingPolicyImage#brightness_var}
  */
  readonly brightnessVar?: string;
  /**
  * Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#contrast DataAkamaiImagingPolicyImage#contrast}
  */
  readonly contrast?: string;
  /**
  * Adjusts the contrast of the image. Expressed as a range from `-1` to `1`, positive values increase contrast, negative values decrease it, while `0` leaves the image unchanged. Values outside of the `-1` to `1` range clamp to this range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#contrast_var DataAkamaiImagingPolicyImage#contrast_var}
  */
  readonly contrastVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrastToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    brightness: cdktf.stringToTerraform(struct!.brightness),
    brightness_var: cdktf.stringToTerraform(struct!.brightnessVar),
    contrast: cdktf.stringToTerraform(struct!.contrast),
    contrast_var: cdktf.stringToTerraform(struct!.contrastVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrastToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrast | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    brightness: {
      value: cdktf.stringToHclTerraform(struct!.brightness),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    brightness_var: {
      value: cdktf.stringToHclTerraform(struct!.brightnessVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    contrast: {
      value: cdktf.stringToHclTerraform(struct!.contrast),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    contrast_var: {
      value: cdktf.stringToHclTerraform(struct!.contrastVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrastOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrast | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._brightness !== undefined) {
      hasAnyValues = true;
      internalValueResult.brightness = this._brightness;
    }
    if (this._brightnessVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.brightnessVar = this._brightnessVar;
    }
    if (this._contrast !== undefined) {
      hasAnyValues = true;
      internalValueResult.contrast = this._contrast;
    }
    if (this._contrastVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.contrastVar = this._contrastVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrast | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._brightness = undefined;
      this._brightnessVar = undefined;
      this._contrast = undefined;
      this._contrastVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._brightness = value.brightness;
      this._brightnessVar = value.brightnessVar;
      this._contrast = value.contrast;
      this._contrastVar = value.contrastVar;
    }
  }

  // brightness - computed: false, optional: true, required: false
  private _brightness?: string; 
  public get brightness() {
    return this.getStringAttribute('brightness');
  }
  public set brightness(value: string) {
    this._brightness = value;
  }
  public resetBrightness() {
    this._brightness = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brightnessInput() {
    return this._brightness;
  }

  // brightness_var - computed: false, optional: true, required: false
  private _brightnessVar?: string; 
  public get brightnessVar() {
    return this.getStringAttribute('brightness_var');
  }
  public set brightnessVar(value: string) {
    this._brightnessVar = value;
  }
  public resetBrightnessVar() {
    this._brightnessVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brightnessVarInput() {
    return this._brightnessVar;
  }

  // contrast - computed: false, optional: true, required: false
  private _contrast?: string; 
  public get contrast() {
    return this.getStringAttribute('contrast');
  }
  public set contrast(value: string) {
    this._contrast = value;
  }
  public resetContrast() {
    this._contrast = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contrastInput() {
    return this._contrast;
  }

  // contrast_var - computed: false, optional: true, required: false
  private _contrastVar?: string; 
  public get contrastVar() {
    return this.getStringAttribute('contrast_var');
  }
  public set contrastVar(value: string) {
    this._contrastVar = value;
  }
  public resetContrastVar() {
    this._contrastVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contrastVarInput() {
    return this._contrastVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrastList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrast[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrastOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrastOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoop {
  /**
  * Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#chaos DataAkamaiImagingPolicyImage#chaos}
  */
  readonly chaos?: string;
  /**
  * Specifies the greatest distance control points may move from their original position. A value of `1.0` shifts control points over as far as the next one in the original grid. A value of `0.0` leaves the image unchanged. Values under `0.5` work better for subtle distortions, otherwise control points may pass each other and cause a twisting effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#chaos_var DataAkamaiImagingPolicyImage#chaos_var}
  */
  readonly chaosVar?: string;
  /**
  * Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#density DataAkamaiImagingPolicyImage#density}
  */
  readonly density?: string;
  /**
  * Controls the density of control points used to distort the image. The largest dimension of the input image is divided up to fit this number of control points. A grid of points is extended on the smaller dimension such that each row and column of control points is equidistant from each adjacent row or column. This parameter strongly affects transformation performance. Be careful choosing values above the default if you expect to transform medium to large size images.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#density_var DataAkamaiImagingPolicyImage#density_var}
  */
  readonly densityVar?: string;
  /**
  * By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#power DataAkamaiImagingPolicyImage#power}
  */
  readonly power?: string;
  /**
  * By default, the distortion algorithm relies on inverse squares to calculate distance but this allows you to change the exponent. You shouldnt need to vary the default value of `2.0`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#power_var DataAkamaiImagingPolicyImage#power_var}
  */
  readonly powerVar?: string;
  /**
  * Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#seed DataAkamaiImagingPolicyImage#seed}
  */
  readonly seed?: string;
  /**
  * Specifies your own `seed` value as an alternative to the default, which is subject to variability. This allows for reproducible and deterministic distortions. If all parameters are kept equal and a constant seed is used, `Goop` distorts an input image consistently over many transformations. By default, this value is set to the current Epoch Time measured in milliseconds, which provides inconsistent transformation output.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#seed_var DataAkamaiImagingPolicyImage#seed_var}
  */
  readonly seedVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoopToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    chaos: cdktf.stringToTerraform(struct!.chaos),
    chaos_var: cdktf.stringToTerraform(struct!.chaosVar),
    density: cdktf.stringToTerraform(struct!.density),
    density_var: cdktf.stringToTerraform(struct!.densityVar),
    power: cdktf.stringToTerraform(struct!.power),
    power_var: cdktf.stringToTerraform(struct!.powerVar),
    seed: cdktf.stringToTerraform(struct!.seed),
    seed_var: cdktf.stringToTerraform(struct!.seedVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoopToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoop | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    chaos: {
      value: cdktf.stringToHclTerraform(struct!.chaos),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    chaos_var: {
      value: cdktf.stringToHclTerraform(struct!.chaosVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    density: {
      value: cdktf.stringToHclTerraform(struct!.density),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    density_var: {
      value: cdktf.stringToHclTerraform(struct!.densityVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    power: {
      value: cdktf.stringToHclTerraform(struct!.power),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    power_var: {
      value: cdktf.stringToHclTerraform(struct!.powerVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seed: {
      value: cdktf.stringToHclTerraform(struct!.seed),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seed_var: {
      value: cdktf.stringToHclTerraform(struct!.seedVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoopOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoop | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chaos !== undefined) {
      hasAnyValues = true;
      internalValueResult.chaos = this._chaos;
    }
    if (this._chaosVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.chaosVar = this._chaosVar;
    }
    if (this._density !== undefined) {
      hasAnyValues = true;
      internalValueResult.density = this._density;
    }
    if (this._densityVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.densityVar = this._densityVar;
    }
    if (this._power !== undefined) {
      hasAnyValues = true;
      internalValueResult.power = this._power;
    }
    if (this._powerVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.powerVar = this._powerVar;
    }
    if (this._seed !== undefined) {
      hasAnyValues = true;
      internalValueResult.seed = this._seed;
    }
    if (this._seedVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.seedVar = this._seedVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoop | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chaos = undefined;
      this._chaosVar = undefined;
      this._density = undefined;
      this._densityVar = undefined;
      this._power = undefined;
      this._powerVar = undefined;
      this._seed = undefined;
      this._seedVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chaos = value.chaos;
      this._chaosVar = value.chaosVar;
      this._density = value.density;
      this._densityVar = value.densityVar;
      this._power = value.power;
      this._powerVar = value.powerVar;
      this._seed = value.seed;
      this._seedVar = value.seedVar;
    }
  }

  // chaos - computed: false, optional: true, required: false
  private _chaos?: string; 
  public get chaos() {
    return this.getStringAttribute('chaos');
  }
  public set chaos(value: string) {
    this._chaos = value;
  }
  public resetChaos() {
    this._chaos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chaosInput() {
    return this._chaos;
  }

  // chaos_var - computed: false, optional: true, required: false
  private _chaosVar?: string; 
  public get chaosVar() {
    return this.getStringAttribute('chaos_var');
  }
  public set chaosVar(value: string) {
    this._chaosVar = value;
  }
  public resetChaosVar() {
    this._chaosVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chaosVarInput() {
    return this._chaosVar;
  }

  // density - computed: false, optional: true, required: false
  private _density?: string; 
  public get density() {
    return this.getStringAttribute('density');
  }
  public set density(value: string) {
    this._density = value;
  }
  public resetDensity() {
    this._density = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get densityInput() {
    return this._density;
  }

  // density_var - computed: false, optional: true, required: false
  private _densityVar?: string; 
  public get densityVar() {
    return this.getStringAttribute('density_var');
  }
  public set densityVar(value: string) {
    this._densityVar = value;
  }
  public resetDensityVar() {
    this._densityVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get densityVarInput() {
    return this._densityVar;
  }

  // power - computed: false, optional: true, required: false
  private _power?: string; 
  public get power() {
    return this.getStringAttribute('power');
  }
  public set power(value: string) {
    this._power = value;
  }
  public resetPower() {
    this._power = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get powerInput() {
    return this._power;
  }

  // power_var - computed: false, optional: true, required: false
  private _powerVar?: string; 
  public get powerVar() {
    return this.getStringAttribute('power_var');
  }
  public set powerVar(value: string) {
    this._powerVar = value;
  }
  public resetPowerVar() {
    this._powerVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get powerVarInput() {
    return this._powerVar;
  }

  // seed - computed: false, optional: true, required: false
  private _seed?: string; 
  public get seed() {
    return this.getStringAttribute('seed');
  }
  public set seed(value: string) {
    this._seed = value;
  }
  public resetSeed() {
    this._seed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seedInput() {
    return this._seed;
  }

  // seed_var - computed: false, optional: true, required: false
  private _seedVar?: string; 
  public get seedVar() {
    return this.getStringAttribute('seed_var');
  }
  public set seedVar(value: string) {
    this._seedVar = value;
  }
  public resetSeedVar() {
    this._seedVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seedVarInput() {
    return this._seedVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoopList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoop[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoopOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoopOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscale {
  /**
  * The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#type DataAkamaiImagingPolicyImage#type}
  */
  readonly type?: string;
  /**
  * The algorithm used to transform colors to grays, either `Brightness`, `Lightness`, `Rec601`, or the default `Rec709`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#type_var DataAkamaiImagingPolicyImage#type_var}
  */
  readonly typeVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscaleToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscale | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    type_var: cdktf.stringToTerraform(struct!.typeVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscaleToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscale | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type_var: {
      value: cdktf.stringToHclTerraform(struct!.typeVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscaleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscale | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._typeVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.typeVar = this._typeVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscale | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._typeVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._typeVar = value.typeVar;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // type_var - computed: false, optional: true, required: false
  private _typeVar?: string; 
  public get typeVar() {
    return this.getStringAttribute('type_var');
  }
  public set typeVar(value: string) {
    this._typeVar = value;
  }
  public resetTypeVar() {
    this._typeVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeVarInput() {
    return this._typeVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscaleList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscale[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscaleOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscaleOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsl {
  /**
  * The number of degrees to rotate colors around the color wheel, `0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * The number of degrees to rotate colors around the color wheel, `0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
  /**
  * A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness DataAkamaiImagingPolicyImage#lightness}
  */
  readonly lightness?: string;
  /**
  * A multiplier to adjust the lightness of colors in the image. Note that lightness is distinct from brightness. For example, reducing the lightness of a light green might give you a lime green whereas reducing the brightness of a light green might give you a darker shade of the same green. Values less than `1.0` decrease the lightness of colors in the image. Values greater than `1.0` increase the lightness of colors in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_var DataAkamaiImagingPolicyImage#lightness_var}
  */
  readonly lightnessVar?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation DataAkamaiImagingPolicyImage#saturation}
  */
  readonly saturation?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_var DataAkamaiImagingPolicyImage#saturation_var}
  */
  readonly saturationVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHslToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
    lightness: cdktf.stringToTerraform(struct!.lightness),
    lightness_var: cdktf.stringToTerraform(struct!.lightnessVar),
    saturation: cdktf.stringToTerraform(struct!.saturation),
    saturation_var: cdktf.stringToTerraform(struct!.saturationVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHslToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness: {
      value: cdktf.stringToHclTerraform(struct!.lightness),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_var: {
      value: cdktf.stringToHclTerraform(struct!.lightnessVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation: {
      value: cdktf.stringToHclTerraform(struct!.saturation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    if (this._lightness !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightness = this._lightness;
    }
    if (this._lightnessVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessVar = this._lightnessVar;
    }
    if (this._saturation !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturation = this._saturation;
    }
    if (this._saturationVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationVar = this._saturationVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueVar = undefined;
      this._lightness = undefined;
      this._lightnessVar = undefined;
      this._saturation = undefined;
      this._saturationVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueVar = value.hueVar;
      this._lightness = value.lightness;
      this._lightnessVar = value.lightnessVar;
      this._saturation = value.saturation;
      this._saturationVar = value.saturationVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }

  // lightness - computed: false, optional: true, required: false
  private _lightness?: string; 
  public get lightness() {
    return this.getStringAttribute('lightness');
  }
  public set lightness(value: string) {
    this._lightness = value;
  }
  public resetLightness() {
    this._lightness = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessInput() {
    return this._lightness;
  }

  // lightness_var - computed: false, optional: true, required: false
  private _lightnessVar?: string; 
  public get lightnessVar() {
    return this.getStringAttribute('lightness_var');
  }
  public set lightnessVar(value: string) {
    this._lightnessVar = value;
  }
  public resetLightnessVar() {
    this._lightnessVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessVarInput() {
    return this._lightnessVar;
  }

  // saturation - computed: false, optional: true, required: false
  private _saturation?: string; 
  public get saturation() {
    return this.getStringAttribute('saturation');
  }
  public set saturation(value: string) {
    this._saturation = value;
  }
  public resetSaturation() {
    this._saturation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationInput() {
    return this._saturation;
  }

  // saturation_var - computed: false, optional: true, required: false
  private _saturationVar?: string; 
  public get saturationVar() {
    return this.getStringAttribute('saturation_var');
  }
  public set saturationVar(value: string) {
    this._saturationVar = value;
  }
  public resetSaturationVar() {
    this._saturationVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationVarInput() {
    return this._saturationVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHslList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsl[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHslOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHslOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsv {
  /**
  * The number of degrees to rotate colors around the color wheel, `0.0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * The number of degrees to rotate colors around the color wheel, `0.0` by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation DataAkamaiImagingPolicyImage#saturation}
  */
  readonly saturation?: string;
  /**
  * A multiplier to adjust the saturation of colors in the image. Values less than `1.0` decrease saturation and values greater than `1.0` increase the saturation. A value of `0.0` removes all color from the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_var DataAkamaiImagingPolicyImage#saturation_var}
  */
  readonly saturationVar?: string;
  /**
  * A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value DataAkamaiImagingPolicyImage#value}
  */
  readonly value?: string;
  /**
  * A multiplier to adjust the lightness or darkness of the images base color. Values less than 1.0 decrease the base colors in the image, making them appear darker. Values greater than 1.0 increase the base colors in the image, making them appear lighter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value_var DataAkamaiImagingPolicyImage#value_var}
  */
  readonly valueVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsvToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
    saturation: cdktf.stringToTerraform(struct!.saturation),
    saturation_var: cdktf.stringToTerraform(struct!.saturationVar),
    value: cdktf.stringToTerraform(struct!.value),
    value_var: cdktf.stringToTerraform(struct!.valueVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsvToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation: {
      value: cdktf.stringToHclTerraform(struct!.saturation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_var: {
      value: cdktf.stringToHclTerraform(struct!.valueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    if (this._saturation !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturation = this._saturation;
    }
    if (this._saturationVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationVar = this._saturationVar;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueVar = this._valueVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueVar = undefined;
      this._saturation = undefined;
      this._saturationVar = undefined;
      this._value = undefined;
      this._valueVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueVar = value.hueVar;
      this._saturation = value.saturation;
      this._saturationVar = value.saturationVar;
      this._value = value.value;
      this._valueVar = value.valueVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }

  // saturation - computed: false, optional: true, required: false
  private _saturation?: string; 
  public get saturation() {
    return this.getStringAttribute('saturation');
  }
  public set saturation(value: string) {
    this._saturation = value;
  }
  public resetSaturation() {
    this._saturation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationInput() {
    return this._saturation;
  }

  // saturation_var - computed: false, optional: true, required: false
  private _saturationVar?: string; 
  public get saturationVar() {
    return this.getStringAttribute('saturation_var');
  }
  public set saturationVar(value: string) {
    this._saturationVar = value;
  }
  public resetSaturationVar() {
    this._saturationVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationVarInput() {
    return this._saturationVar;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_var - computed: false, optional: true, required: false
  private _valueVar?: string; 
  public get valueVar() {
    return this.getStringAttribute('value_var');
  }
  public set valueVar(value: string) {
    this._valueVar = value;
  }
  public resetValueVar() {
    this._valueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueVarInput() {
    return this._valueVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsvList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsvOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefault {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefaultToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefaultToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefaultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefault | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefault | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqual {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqualToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqualOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqual): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqualToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqualOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqual): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqualOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqual | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqual | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThan {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThanToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThanOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThan): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThanToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThanOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThan): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThanOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThan | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThan | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThan {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThanToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThanOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThan): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThanToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThanOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThan): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThanOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThan | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThan | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimension {
  /**
  * The dimension to use to select the transformation, either `height`, `width`, or `both`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#dimension DataAkamaiImagingPolicyImage#dimension}
  */
  readonly dimension?: string;
  /**
  * The dimension to use to select the transformation, either `height`, `width`, or `both`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#dimension_var DataAkamaiImagingPolicyImage#dimension_var}
  */
  readonly dimensionVar?: string;
  /**
  * The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value DataAkamaiImagingPolicyImage#value}
  */
  readonly value?: string;
  /**
  * The value to compare against the source image dimension. For example, if the image dimension is less than the value the lessThan transformation is applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#value_var DataAkamaiImagingPolicyImage#value_var}
  */
  readonly valueVar?: string;
  /**
  * default block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#default DataAkamaiImagingPolicyImage#default}
  */
  readonly default?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefault;
  /**
  * equal block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#equal DataAkamaiImagingPolicyImage#equal}
  */
  readonly equal?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqual;
  /**
  * greater_than block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#greater_than DataAkamaiImagingPolicyImage#greater_than}
  */
  readonly greaterThan?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThan;
  /**
  * less_than block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#less_than DataAkamaiImagingPolicyImage#less_than}
  */
  readonly lessThan?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThan;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimension | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dimension: cdktf.stringToTerraform(struct!.dimension),
    dimension_var: cdktf.stringToTerraform(struct!.dimensionVar),
    value: cdktf.stringToTerraform(struct!.value),
    value_var: cdktf.stringToTerraform(struct!.valueVar),
    default: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefaultToTerraform(struct!.default),
    equal: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqualToTerraform(struct!.equal),
    greater_than: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThanToTerraform(struct!.greaterThan),
    less_than: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThanToTerraform(struct!.lessThan),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimension | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dimension: {
      value: cdktf.stringToHclTerraform(struct!.dimension),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dimension_var: {
      value: cdktf.stringToHclTerraform(struct!.dimensionVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_var: {
      value: cdktf.stringToHclTerraform(struct!.valueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefaultToHclTerraform(struct!.default),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefaultList",
    },
    equal: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqualToHclTerraform(struct!.equal),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqualList",
    },
    greater_than: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThanToHclTerraform(struct!.greaterThan),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThanList",
    },
    less_than: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThanToHclTerraform(struct!.lessThan),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThanList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimension | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dimension !== undefined) {
      hasAnyValues = true;
      internalValueResult.dimension = this._dimension;
    }
    if (this._dimensionVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.dimensionVar = this._dimensionVar;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueVar = this._valueVar;
    }
    if (this._default?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default?.internalValue;
    }
    if (this._equal?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.equal = this._equal?.internalValue;
    }
    if (this._greaterThan?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.greaterThan = this._greaterThan?.internalValue;
    }
    if (this._lessThan?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lessThan = this._lessThan?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimension | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dimension = undefined;
      this._dimensionVar = undefined;
      this._value = undefined;
      this._valueVar = undefined;
      this._default.internalValue = undefined;
      this._equal.internalValue = undefined;
      this._greaterThan.internalValue = undefined;
      this._lessThan.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dimension = value.dimension;
      this._dimensionVar = value.dimensionVar;
      this._value = value.value;
      this._valueVar = value.valueVar;
      this._default.internalValue = value.default;
      this._equal.internalValue = value.equal;
      this._greaterThan.internalValue = value.greaterThan;
      this._lessThan.internalValue = value.lessThan;
    }
  }

  // dimension - computed: false, optional: true, required: false
  private _dimension?: string; 
  public get dimension() {
    return this.getStringAttribute('dimension');
  }
  public set dimension(value: string) {
    this._dimension = value;
  }
  public resetDimension() {
    this._dimension = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dimensionInput() {
    return this._dimension;
  }

  // dimension_var - computed: false, optional: true, required: false
  private _dimensionVar?: string; 
  public get dimensionVar() {
    return this.getStringAttribute('dimension_var');
  }
  public set dimensionVar(value: string) {
    this._dimensionVar = value;
  }
  public resetDimensionVar() {
    this._dimensionVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dimensionVarInput() {
    return this._dimensionVar;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_var - computed: false, optional: true, required: false
  private _valueVar?: string; 
  public get valueVar() {
    return this.getStringAttribute('value_var');
  }
  public set valueVar(value: string) {
    this._valueVar = value;
  }
  public resetValueVar() {
    this._valueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueVarInput() {
    return this._valueVar;
  }

  // default - computed: false, optional: true, required: false
  private _default = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefaultOutputReference(this, "default");
  public get default() {
    return this._default;
  }
  public putDefault(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionDefault) {
    this._default.internalValue = value;
  }
  public resetDefault() {
    this._default.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default.internalValue;
  }

  // equal - computed: false, optional: true, required: false
  private _equal = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqualOutputReference(this, "equal");
  public get equal() {
    return this._equal;
  }
  public putEqual(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionEqual) {
    this._equal.internalValue = value;
  }
  public resetEqual() {
    this._equal.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get equalInput() {
    return this._equal.internalValue;
  }

  // greater_than - computed: false, optional: true, required: false
  private _greaterThan = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThanOutputReference(this, "greater_than");
  public get greaterThan() {
    return this._greaterThan;
  }
  public putGreaterThan(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionGreaterThan) {
    this._greaterThan.internalValue = value;
  }
  public resetGreaterThan() {
    this._greaterThan.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get greaterThanInput() {
    return this._greaterThan.internalValue;
  }

  // less_than - computed: false, optional: true, required: false
  private _lessThan = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThanOutputReference(this, "less_than");
  public get lessThan() {
    return this._lessThan;
  }
  public putLessThan(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionLessThan) {
    this._lessThan.internalValue = value;
  }
  public resetLessThan() {
    this._lessThan.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lessThanInput() {
    return this._lessThan.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimension[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefault {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefaultToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefaultToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefaultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefault | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefault | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscape {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscapeToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscapeOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscape): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscapeToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscapeOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscape): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscapeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscape | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscape | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortrait {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortraitToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortraitOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortrait): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortraitToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortraitOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortrait): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortraitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortrait | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortrait | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquare {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquareToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquareOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquare): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquareToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquareOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquare): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquareOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquare | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquare | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientation {
  /**
  * default block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#default DataAkamaiImagingPolicyImage#default}
  */
  readonly default?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefault;
  /**
  * landscape block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#landscape DataAkamaiImagingPolicyImage#landscape}
  */
  readonly landscape?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscape;
  /**
  * portrait block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#portrait DataAkamaiImagingPolicyImage#portrait}
  */
  readonly portrait?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortrait;
  /**
  * square block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#square DataAkamaiImagingPolicyImage#square}
  */
  readonly square?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquare;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefaultToTerraform(struct!.default),
    landscape: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscapeToTerraform(struct!.landscape),
    portrait: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortraitToTerraform(struct!.portrait),
    square: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquareToTerraform(struct!.square),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefaultToHclTerraform(struct!.default),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefaultList",
    },
    landscape: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscapeToHclTerraform(struct!.landscape),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscapeList",
    },
    portrait: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortraitToHclTerraform(struct!.portrait),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortraitList",
    },
    square: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquareToHclTerraform(struct!.square),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquareList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._default?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default?.internalValue;
    }
    if (this._landscape?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.landscape = this._landscape?.internalValue;
    }
    if (this._portrait?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.portrait = this._portrait?.internalValue;
    }
    if (this._square?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.square = this._square?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._default.internalValue = undefined;
      this._landscape.internalValue = undefined;
      this._portrait.internalValue = undefined;
      this._square.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._default.internalValue = value.default;
      this._landscape.internalValue = value.landscape;
      this._portrait.internalValue = value.portrait;
      this._square.internalValue = value.square;
    }
  }

  // default - computed: false, optional: true, required: false
  private _default = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefaultOutputReference(this, "default");
  public get default() {
    return this._default;
  }
  public putDefault(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationDefault) {
    this._default.internalValue = value;
  }
  public resetDefault() {
    this._default.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default.internalValue;
  }

  // landscape - computed: false, optional: true, required: false
  private _landscape = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscapeOutputReference(this, "landscape");
  public get landscape() {
    return this._landscape;
  }
  public putLandscape(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationLandscape) {
    this._landscape.internalValue = value;
  }
  public resetLandscape() {
    this._landscape.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get landscapeInput() {
    return this._landscape.internalValue;
  }

  // portrait - computed: false, optional: true, required: false
  private _portrait = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortraitOutputReference(this, "portrait");
  public get portrait() {
    return this._portrait;
  }
  public putPortrait(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationPortrait) {
    this._portrait.internalValue = value;
  }
  public resetPortrait() {
    this._portrait.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portraitInput() {
    return this._portrait.internalValue;
  }

  // square - computed: false, optional: true, required: false
  private _square = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquareOutputReference(this, "square");
  public get square() {
    return this._square;
  }
  public putSquare(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationSquare) {
    this._square.internalValue = value;
  }
  public resetSquare() {
    this._square.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get squareInput() {
    return this._square.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientation[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColors {
  /**
  * The value representing the maximum number of colors to use with the source image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#colors DataAkamaiImagingPolicyImage#colors}
  */
  readonly colors?: string;
  /**
  * The value representing the maximum number of colors to use with the source image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#colors_var DataAkamaiImagingPolicyImage#colors_var}
  */
  readonly colorsVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColorsToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    colors: cdktf.stringToTerraform(struct!.colors),
    colors_var: cdktf.stringToTerraform(struct!.colorsVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColorsToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    colors: {
      value: cdktf.stringToHclTerraform(struct!.colors),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    colors_var: {
      value: cdktf.stringToHclTerraform(struct!.colorsVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._colors !== undefined) {
      hasAnyValues = true;
      internalValueResult.colors = this._colors;
    }
    if (this._colorsVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorsVar = this._colorsVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._colors = undefined;
      this._colorsVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._colors = value.colors;
      this._colorsVar = value.colorsVar;
    }
  }

  // colors - computed: false, optional: true, required: false
  private _colors?: string; 
  public get colors() {
    return this.getStringAttribute('colors');
  }
  public set colors(value: string) {
    this._colors = value;
  }
  public resetColors() {
    this._colors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorsInput() {
    return this._colors;
  }

  // colors_var - computed: false, optional: true, required: false
  private _colorsVar?: string; 
  public get colorsVar() {
    return this.getStringAttribute('colors_var');
  }
  public set colorsVar(value: string) {
    this._colorsVar = value;
  }
  public resetColorsVar() {
    this._colorsVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorsVarInput() {
    return this._colorsVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColorsList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColorsOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirror {
  /**
  * Flips the image horizontally.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#horizontal DataAkamaiImagingPolicyImage#horizontal}
  */
  readonly horizontal?: string;
  /**
  * Flips the image horizontally.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#horizontal_var DataAkamaiImagingPolicyImage#horizontal_var}
  */
  readonly horizontalVar?: string;
  /**
  * Flips the image vertically.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#vertical DataAkamaiImagingPolicyImage#vertical}
  */
  readonly vertical?: string;
  /**
  * Flips the image vertically.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#vertical_var DataAkamaiImagingPolicyImage#vertical_var}
  */
  readonly verticalVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirrorToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirror | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    horizontal: cdktf.stringToTerraform(struct!.horizontal),
    horizontal_var: cdktf.stringToTerraform(struct!.horizontalVar),
    vertical: cdktf.stringToTerraform(struct!.vertical),
    vertical_var: cdktf.stringToTerraform(struct!.verticalVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirrorToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirror | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    horizontal: {
      value: cdktf.stringToHclTerraform(struct!.horizontal),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    horizontal_var: {
      value: cdktf.stringToHclTerraform(struct!.horizontalVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vertical: {
      value: cdktf.stringToHclTerraform(struct!.vertical),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vertical_var: {
      value: cdktf.stringToHclTerraform(struct!.verticalVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirrorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirror | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._horizontal !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontal = this._horizontal;
    }
    if (this._horizontalVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalVar = this._horizontalVar;
    }
    if (this._vertical !== undefined) {
      hasAnyValues = true;
      internalValueResult.vertical = this._vertical;
    }
    if (this._verticalVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.verticalVar = this._verticalVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirror | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._horizontal = undefined;
      this._horizontalVar = undefined;
      this._vertical = undefined;
      this._verticalVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._horizontal = value.horizontal;
      this._horizontalVar = value.horizontalVar;
      this._vertical = value.vertical;
      this._verticalVar = value.verticalVar;
    }
  }

  // horizontal - computed: false, optional: true, required: false
  private _horizontal?: string; 
  public get horizontal() {
    return this.getStringAttribute('horizontal');
  }
  public set horizontal(value: string) {
    this._horizontal = value;
  }
  public resetHorizontal() {
    this._horizontal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalInput() {
    return this._horizontal;
  }

  // horizontal_var - computed: false, optional: true, required: false
  private _horizontalVar?: string; 
  public get horizontalVar() {
    return this.getStringAttribute('horizontal_var');
  }
  public set horizontalVar(value: string) {
    this._horizontalVar = value;
  }
  public resetHorizontalVar() {
    this._horizontalVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalVarInput() {
    return this._horizontalVar;
  }

  // vertical - computed: false, optional: true, required: false
  private _vertical?: string; 
  public get vertical() {
    return this.getStringAttribute('vertical');
  }
  public set vertical(value: string) {
    this._vertical = value;
  }
  public resetVertical() {
    this._vertical = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verticalInput() {
    return this._vertical;
  }

  // vertical_var - computed: false, optional: true, required: false
  private _verticalVar?: string; 
  public get verticalVar() {
    return this.getStringAttribute('vertical_var');
  }
  public set verticalVar(value: string) {
    this._verticalVar = value;
  }
  public resetVerticalVar() {
    this._verticalVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verticalVarInput() {
    return this._verticalVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirrorList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirror[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirrorOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirrorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHue {
  /**
  * Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHueToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHueToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueVar = value.hueVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHueList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHue[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHueOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHueOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacity {
  /**
  * Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#opacity DataAkamaiImagingPolicyImage#opacity}
  */
  readonly opacity?: string;
  /**
  * Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#opacity_var DataAkamaiImagingPolicyImage#opacity_var}
  */
  readonly opacityVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacityToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    opacity: cdktf.stringToTerraform(struct!.opacity),
    opacity_var: cdktf.stringToTerraform(struct!.opacityVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacityToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    opacity: {
      value: cdktf.stringToHclTerraform(struct!.opacity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    opacity_var: {
      value: cdktf.stringToHclTerraform(struct!.opacityVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._opacity !== undefined) {
      hasAnyValues = true;
      internalValueResult.opacity = this._opacity;
    }
    if (this._opacityVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.opacityVar = this._opacityVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._opacity = undefined;
      this._opacityVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._opacity = value.opacity;
      this._opacityVar = value.opacityVar;
    }
  }

  // opacity - computed: false, optional: true, required: false
  private _opacity?: string; 
  public get opacity() {
    return this.getStringAttribute('opacity');
  }
  public set opacity(value: string) {
    this._opacity = value;
  }
  public resetOpacity() {
    this._opacity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opacityInput() {
    return this._opacity;
  }

  // opacity_var - computed: false, optional: true, required: false
  private _opacityVar?: string; 
  public get opacityVar() {
    return this.getStringAttribute('opacity_var');
  }
  public set opacityVar(value: string) {
    this._opacityVar = value;
  }
  public resetOpacityVar() {
    this._opacityVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opacityVarInput() {
    return this._opacityVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacityList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacity[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacityOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacityOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColor {
  /**
  * The hexadecimal CSS color value to remove.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color DataAkamaiImagingPolicyImage#color}
  */
  readonly color?: string;
  /**
  * The hexadecimal CSS color value to remove.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color_var DataAkamaiImagingPolicyImage#color_var}
  */
  readonly colorVar?: string;
  /**
  * The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#feather DataAkamaiImagingPolicyImage#feather}
  */
  readonly feather?: string;
  /**
  * The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#feather_var DataAkamaiImagingPolicyImage#feather_var}
  */
  readonly featherVar?: string;
  /**
  * The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#tolerance DataAkamaiImagingPolicyImage#tolerance}
  */
  readonly tolerance?: string;
  /**
  * The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#tolerance_var DataAkamaiImagingPolicyImage#tolerance_var}
  */
  readonly toleranceVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColorToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    color: cdktf.stringToTerraform(struct!.color),
    color_var: cdktf.stringToTerraform(struct!.colorVar),
    feather: cdktf.stringToTerraform(struct!.feather),
    feather_var: cdktf.stringToTerraform(struct!.featherVar),
    tolerance: cdktf.stringToTerraform(struct!.tolerance),
    tolerance_var: cdktf.stringToTerraform(struct!.toleranceVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColorToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    color_var: {
      value: cdktf.stringToHclTerraform(struct!.colorVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    feather: {
      value: cdktf.stringToHclTerraform(struct!.feather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    feather_var: {
      value: cdktf.stringToHclTerraform(struct!.featherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tolerance: {
      value: cdktf.stringToHclTerraform(struct!.tolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.toleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._colorVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorVar = this._colorVar;
    }
    if (this._feather !== undefined) {
      hasAnyValues = true;
      internalValueResult.feather = this._feather;
    }
    if (this._featherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.featherVar = this._featherVar;
    }
    if (this._tolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerance = this._tolerance;
    }
    if (this._toleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.toleranceVar = this._toleranceVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._color = undefined;
      this._colorVar = undefined;
      this._feather = undefined;
      this._featherVar = undefined;
      this._tolerance = undefined;
      this._toleranceVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._color = value.color;
      this._colorVar = value.colorVar;
      this._feather = value.feather;
      this._featherVar = value.featherVar;
      this._tolerance = value.tolerance;
      this._toleranceVar = value.toleranceVar;
    }
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // color_var - computed: false, optional: true, required: false
  private _colorVar?: string; 
  public get colorVar() {
    return this.getStringAttribute('color_var');
  }
  public set colorVar(value: string) {
    this._colorVar = value;
  }
  public resetColorVar() {
    this._colorVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorVarInput() {
    return this._colorVar;
  }

  // feather - computed: false, optional: true, required: false
  private _feather?: string; 
  public get feather() {
    return this.getStringAttribute('feather');
  }
  public set feather(value: string) {
    this._feather = value;
  }
  public resetFeather() {
    this._feather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featherInput() {
    return this._feather;
  }

  // feather_var - computed: false, optional: true, required: false
  private _featherVar?: string; 
  public get featherVar() {
    return this.getStringAttribute('feather_var');
  }
  public set featherVar(value: string) {
    this._featherVar = value;
  }
  public resetFeatherVar() {
    this._featherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featherVarInput() {
    return this._featherVar;
  }

  // tolerance - computed: false, optional: true, required: false
  private _tolerance?: string; 
  public get tolerance() {
    return this.getStringAttribute('tolerance');
  }
  public set tolerance(value: string) {
    this._tolerance = value;
  }
  public resetTolerance() {
    this._tolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toleranceInput() {
    return this._tolerance;
  }

  // tolerance_var - computed: false, optional: true, required: false
  private _toleranceVar?: string; 
  public get toleranceVar() {
    return this.getStringAttribute('tolerance_var');
  }
  public set toleranceVar(value: string) {
    this._toleranceVar = value;
  }
  public resetToleranceVar() {
    this._toleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toleranceVarInput() {
    return this._toleranceVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColorList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColor[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColorOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMask {
  /**
  * Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gain DataAkamaiImagingPolicyImage#gain}
  */
  readonly gain?: string;
  /**
  * Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gain_var DataAkamaiImagingPolicyImage#gain_var}
  */
  readonly gainVar?: string;
  /**
  * The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma DataAkamaiImagingPolicyImage#sigma}
  */
  readonly sigma?: string;
  /**
  * The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma_var DataAkamaiImagingPolicyImage#sigma_var}
  */
  readonly sigmaVar?: string;
  /**
  * Set the minimum change required to include a detail in the filter. Higher values discard more changes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#threshold DataAkamaiImagingPolicyImage#threshold}
  */
  readonly threshold?: string;
  /**
  * Set the minimum change required to include a detail in the filter. Higher values discard more changes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#threshold_var DataAkamaiImagingPolicyImage#threshold_var}
  */
  readonly thresholdVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMaskToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMask | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gain: cdktf.stringToTerraform(struct!.gain),
    gain_var: cdktf.stringToTerraform(struct!.gainVar),
    sigma: cdktf.stringToTerraform(struct!.sigma),
    sigma_var: cdktf.stringToTerraform(struct!.sigmaVar),
    threshold: cdktf.stringToTerraform(struct!.threshold),
    threshold_var: cdktf.stringToTerraform(struct!.thresholdVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMaskToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMask | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gain: {
      value: cdktf.stringToHclTerraform(struct!.gain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gain_var: {
      value: cdktf.stringToHclTerraform(struct!.gainVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sigma: {
      value: cdktf.stringToHclTerraform(struct!.sigma),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sigma_var: {
      value: cdktf.stringToHclTerraform(struct!.sigmaVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threshold: {
      value: cdktf.stringToHclTerraform(struct!.threshold),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threshold_var: {
      value: cdktf.stringToHclTerraform(struct!.thresholdVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMaskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMask | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gain !== undefined) {
      hasAnyValues = true;
      internalValueResult.gain = this._gain;
    }
    if (this._gainVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.gainVar = this._gainVar;
    }
    if (this._sigma !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigma = this._sigma;
    }
    if (this._sigmaVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigmaVar = this._sigmaVar;
    }
    if (this._threshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.threshold = this._threshold;
    }
    if (this._thresholdVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.thresholdVar = this._thresholdVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMask | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gain = undefined;
      this._gainVar = undefined;
      this._sigma = undefined;
      this._sigmaVar = undefined;
      this._threshold = undefined;
      this._thresholdVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gain = value.gain;
      this._gainVar = value.gainVar;
      this._sigma = value.sigma;
      this._sigmaVar = value.sigmaVar;
      this._threshold = value.threshold;
      this._thresholdVar = value.thresholdVar;
    }
  }

  // gain - computed: false, optional: true, required: false
  private _gain?: string; 
  public get gain() {
    return this.getStringAttribute('gain');
  }
  public set gain(value: string) {
    this._gain = value;
  }
  public resetGain() {
    this._gain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gainInput() {
    return this._gain;
  }

  // gain_var - computed: false, optional: true, required: false
  private _gainVar?: string; 
  public get gainVar() {
    return this.getStringAttribute('gain_var');
  }
  public set gainVar(value: string) {
    this._gainVar = value;
  }
  public resetGainVar() {
    this._gainVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gainVarInput() {
    return this._gainVar;
  }

  // sigma - computed: false, optional: true, required: false
  private _sigma?: string; 
  public get sigma() {
    return this.getStringAttribute('sigma');
  }
  public set sigma(value: string) {
    this._sigma = value;
  }
  public resetSigma() {
    this._sigma = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaInput() {
    return this._sigma;
  }

  // sigma_var - computed: false, optional: true, required: false
  private _sigmaVar?: string; 
  public get sigmaVar() {
    return this.getStringAttribute('sigma_var');
  }
  public set sigmaVar(value: string) {
    this._sigmaVar = value;
  }
  public resetSigmaVar() {
    this._sigmaVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaVarInput() {
    return this._sigmaVar;
  }

  // threshold - computed: false, optional: true, required: false
  private _threshold?: string; 
  public get threshold() {
    return this.getStringAttribute('threshold');
  }
  public set threshold(value: string) {
    this._threshold = value;
  }
  public resetThreshold() {
    this._threshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdInput() {
    return this._threshold;
  }

  // threshold_var - computed: false, optional: true, required: false
  private _thresholdVar?: string; 
  public get thresholdVar() {
    return this.getStringAttribute('threshold_var');
  }
  public set thresholdVar(value: string) {
    this._thresholdVar = value;
  }
  public resetThresholdVar() {
    this._thresholdVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdVarInput() {
    return this._thresholdVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMaskList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMask[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMaskOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMaskOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquare {
  /**
  * background_color block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#background_color DataAkamaiImagingPolicyImage#background_color}
  */
  readonly backgroundColor?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColor[] | cdktf.IResolvable;
  /**
  * blur block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#blur DataAkamaiImagingPolicyImage#blur}
  */
  readonly blur?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlur[] | cdktf.IResolvable;
  /**
  * chroma_key block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#chroma_key DataAkamaiImagingPolicyImage#chroma_key}
  */
  readonly chromaKey?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKey[] | cdktf.IResolvable;
  /**
  * composite block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#composite DataAkamaiImagingPolicyImage#composite}
  */
  readonly composite?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareComposite[] | cdktf.IResolvable;
  /**
  * compound block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#compound DataAkamaiImagingPolicyImage#compound}
  */
  readonly compound?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompound[] | cdktf.IResolvable;
  /**
  * contrast block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#contrast DataAkamaiImagingPolicyImage#contrast}
  */
  readonly contrast?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrast[] | cdktf.IResolvable;
  /**
  * goop block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#goop DataAkamaiImagingPolicyImage#goop}
  */
  readonly goop?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoop[] | cdktf.IResolvable;
  /**
  * grayscale block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#grayscale DataAkamaiImagingPolicyImage#grayscale}
  */
  readonly grayscale?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscale[] | cdktf.IResolvable;
  /**
  * hsl block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hsl DataAkamaiImagingPolicyImage#hsl}
  */
  readonly hsl?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsl[] | cdktf.IResolvable;
  /**
  * hsv block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hsv DataAkamaiImagingPolicyImage#hsv}
  */
  readonly hsv?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsv[] | cdktf.IResolvable;
  /**
  * if_dimension block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#if_dimension DataAkamaiImagingPolicyImage#if_dimension}
  */
  readonly ifDimension?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimension[] | cdktf.IResolvable;
  /**
  * if_orientation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#if_orientation DataAkamaiImagingPolicyImage#if_orientation}
  */
  readonly ifOrientation?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientation[] | cdktf.IResolvable;
  /**
  * max_colors block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#max_colors DataAkamaiImagingPolicyImage#max_colors}
  */
  readonly maxColors?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColors[] | cdktf.IResolvable;
  /**
  * mirror block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#mirror DataAkamaiImagingPolicyImage#mirror}
  */
  readonly mirror?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirror[] | cdktf.IResolvable;
  /**
  * mono_hue block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#mono_hue DataAkamaiImagingPolicyImage#mono_hue}
  */
  readonly monoHue?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHue[] | cdktf.IResolvable;
  /**
  * opacity block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#opacity DataAkamaiImagingPolicyImage#opacity}
  */
  readonly opacity?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacity[] | cdktf.IResolvable;
  /**
  * remove_color block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#remove_color DataAkamaiImagingPolicyImage#remove_color}
  */
  readonly removeColor?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColor[] | cdktf.IResolvable;
  /**
  * unsharp_mask block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#unsharp_mask DataAkamaiImagingPolicyImage#unsharp_mask}
  */
  readonly unsharpMask?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMask[] | cdktf.IResolvable;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquare): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    background_color: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColorToTerraform, true)(struct!.backgroundColor),
    blur: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlurToTerraform, true)(struct!.blur),
    chroma_key: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKeyToTerraform, true)(struct!.chromaKey),
    composite: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeToTerraform, true)(struct!.composite),
    compound: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundToTerraform, true)(struct!.compound),
    contrast: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrastToTerraform, true)(struct!.contrast),
    goop: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoopToTerraform, true)(struct!.goop),
    grayscale: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscaleToTerraform, true)(struct!.grayscale),
    hsl: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHslToTerraform, true)(struct!.hsl),
    hsv: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsvToTerraform, true)(struct!.hsv),
    if_dimension: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionToTerraform, true)(struct!.ifDimension),
    if_orientation: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationToTerraform, true)(struct!.ifOrientation),
    max_colors: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColorsToTerraform, true)(struct!.maxColors),
    mirror: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirrorToTerraform, true)(struct!.mirror),
    mono_hue: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHueToTerraform, true)(struct!.monoHue),
    opacity: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacityToTerraform, true)(struct!.opacity),
    remove_color: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColorToTerraform, true)(struct!.removeColor),
    unsharp_mask: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMaskToTerraform, true)(struct!.unsharpMask),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquare): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    background_color: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColorToHclTerraform, true)(struct!.backgroundColor),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColorList",
    },
    blur: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlurToHclTerraform, true)(struct!.blur),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlurList",
    },
    chroma_key: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKeyToHclTerraform, true)(struct!.chromaKey),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKeyList",
    },
    composite: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeToHclTerraform, true)(struct!.composite),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeList",
    },
    compound: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundToHclTerraform, true)(struct!.compound),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundList",
    },
    contrast: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrastToHclTerraform, true)(struct!.contrast),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrastList",
    },
    goop: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoopToHclTerraform, true)(struct!.goop),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoopList",
    },
    grayscale: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscaleToHclTerraform, true)(struct!.grayscale),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscaleList",
    },
    hsl: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHslToHclTerraform, true)(struct!.hsl),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHslList",
    },
    hsv: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsvToHclTerraform, true)(struct!.hsv),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsvList",
    },
    if_dimension: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionToHclTerraform, true)(struct!.ifDimension),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionList",
    },
    if_orientation: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationToHclTerraform, true)(struct!.ifOrientation),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationList",
    },
    max_colors: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColorsToHclTerraform, true)(struct!.maxColors),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColorsList",
    },
    mirror: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirrorToHclTerraform, true)(struct!.mirror),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirrorList",
    },
    mono_hue: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHueToHclTerraform, true)(struct!.monoHue),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHueList",
    },
    opacity: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacityToHclTerraform, true)(struct!.opacity),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacityList",
    },
    remove_color: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColorToHclTerraform, true)(struct!.removeColor),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColorList",
    },
    unsharp_mask: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMaskToHclTerraform, true)(struct!.unsharpMask),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMaskList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquare | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backgroundColor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backgroundColor = this._backgroundColor?.internalValue;
    }
    if (this._blur?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.blur = this._blur?.internalValue;
    }
    if (this._chromaKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.chromaKey = this._chromaKey?.internalValue;
    }
    if (this._composite?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.composite = this._composite?.internalValue;
    }
    if (this._compound?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.compound = this._compound?.internalValue;
    }
    if (this._contrast?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.contrast = this._contrast?.internalValue;
    }
    if (this._goop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.goop = this._goop?.internalValue;
    }
    if (this._grayscale?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grayscale = this._grayscale?.internalValue;
    }
    if (this._hsl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hsl = this._hsl?.internalValue;
    }
    if (this._hsv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hsv = this._hsv?.internalValue;
    }
    if (this._ifDimension?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ifDimension = this._ifDimension?.internalValue;
    }
    if (this._ifOrientation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ifOrientation = this._ifOrientation?.internalValue;
    }
    if (this._maxColors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxColors = this._maxColors?.internalValue;
    }
    if (this._mirror?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mirror = this._mirror?.internalValue;
    }
    if (this._monoHue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.monoHue = this._monoHue?.internalValue;
    }
    if (this._opacity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.opacity = this._opacity?.internalValue;
    }
    if (this._removeColor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeColor = this._removeColor?.internalValue;
    }
    if (this._unsharpMask?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unsharpMask = this._unsharpMask?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquare | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._backgroundColor.internalValue = undefined;
      this._blur.internalValue = undefined;
      this._chromaKey.internalValue = undefined;
      this._composite.internalValue = undefined;
      this._compound.internalValue = undefined;
      this._contrast.internalValue = undefined;
      this._goop.internalValue = undefined;
      this._grayscale.internalValue = undefined;
      this._hsl.internalValue = undefined;
      this._hsv.internalValue = undefined;
      this._ifDimension.internalValue = undefined;
      this._ifOrientation.internalValue = undefined;
      this._maxColors.internalValue = undefined;
      this._mirror.internalValue = undefined;
      this._monoHue.internalValue = undefined;
      this._opacity.internalValue = undefined;
      this._removeColor.internalValue = undefined;
      this._unsharpMask.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._backgroundColor.internalValue = value.backgroundColor;
      this._blur.internalValue = value.blur;
      this._chromaKey.internalValue = value.chromaKey;
      this._composite.internalValue = value.composite;
      this._compound.internalValue = value.compound;
      this._contrast.internalValue = value.contrast;
      this._goop.internalValue = value.goop;
      this._grayscale.internalValue = value.grayscale;
      this._hsl.internalValue = value.hsl;
      this._hsv.internalValue = value.hsv;
      this._ifDimension.internalValue = value.ifDimension;
      this._ifOrientation.internalValue = value.ifOrientation;
      this._maxColors.internalValue = value.maxColors;
      this._mirror.internalValue = value.mirror;
      this._monoHue.internalValue = value.monoHue;
      this._opacity.internalValue = value.opacity;
      this._removeColor.internalValue = value.removeColor;
      this._unsharpMask.internalValue = value.unsharpMask;
    }
  }

  // background_color - computed: false, optional: true, required: false
  private _backgroundColor = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColorList(this, "background_color", false);
  public get backgroundColor() {
    return this._backgroundColor;
  }
  public putBackgroundColor(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBackgroundColor[] | cdktf.IResolvable) {
    this._backgroundColor.internalValue = value;
  }
  public resetBackgroundColor() {
    this._backgroundColor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backgroundColorInput() {
    return this._backgroundColor.internalValue;
  }

  // blur - computed: false, optional: true, required: false
  private _blur = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlurList(this, "blur", false);
  public get blur() {
    return this._blur;
  }
  public putBlur(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareBlur[] | cdktf.IResolvable) {
    this._blur.internalValue = value;
  }
  public resetBlur() {
    this._blur.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blurInput() {
    return this._blur.internalValue;
  }

  // chroma_key - computed: false, optional: true, required: false
  private _chromaKey = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKeyList(this, "chroma_key", false);
  public get chromaKey() {
    return this._chromaKey;
  }
  public putChromaKey(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareChromaKey[] | cdktf.IResolvable) {
    this._chromaKey.internalValue = value;
  }
  public resetChromaKey() {
    this._chromaKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chromaKeyInput() {
    return this._chromaKey.internalValue;
  }

  // composite - computed: false, optional: true, required: false
  private _composite = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompositeList(this, "composite", false);
  public get composite() {
    return this._composite;
  }
  public putComposite(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareComposite[] | cdktf.IResolvable) {
    this._composite.internalValue = value;
  }
  public resetComposite() {
    this._composite.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compositeInput() {
    return this._composite.internalValue;
  }

  // compound - computed: false, optional: true, required: false
  private _compound = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompoundList(this, "compound", false);
  public get compound() {
    return this._compound;
  }
  public putCompound(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareCompound[] | cdktf.IResolvable) {
    this._compound.internalValue = value;
  }
  public resetCompound() {
    this._compound.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compoundInput() {
    return this._compound.internalValue;
  }

  // contrast - computed: false, optional: true, required: false
  private _contrast = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrastList(this, "contrast", false);
  public get contrast() {
    return this._contrast;
  }
  public putContrast(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareContrast[] | cdktf.IResolvable) {
    this._contrast.internalValue = value;
  }
  public resetContrast() {
    this._contrast.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contrastInput() {
    return this._contrast.internalValue;
  }

  // goop - computed: false, optional: true, required: false
  private _goop = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoopList(this, "goop", false);
  public get goop() {
    return this._goop;
  }
  public putGoop(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGoop[] | cdktf.IResolvable) {
    this._goop.internalValue = value;
  }
  public resetGoop() {
    this._goop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get goopInput() {
    return this._goop.internalValue;
  }

  // grayscale - computed: false, optional: true, required: false
  private _grayscale = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscaleList(this, "grayscale", false);
  public get grayscale() {
    return this._grayscale;
  }
  public putGrayscale(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareGrayscale[] | cdktf.IResolvable) {
    this._grayscale.internalValue = value;
  }
  public resetGrayscale() {
    this._grayscale.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grayscaleInput() {
    return this._grayscale.internalValue;
  }

  // hsl - computed: false, optional: true, required: false
  private _hsl = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHslList(this, "hsl", false);
  public get hsl() {
    return this._hsl;
  }
  public putHsl(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsl[] | cdktf.IResolvable) {
    this._hsl.internalValue = value;
  }
  public resetHsl() {
    this._hsl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hslInput() {
    return this._hsl.internalValue;
  }

  // hsv - computed: false, optional: true, required: false
  private _hsv = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsvList(this, "hsv", false);
  public get hsv() {
    return this._hsv;
  }
  public putHsv(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareHsv[] | cdktf.IResolvable) {
    this._hsv.internalValue = value;
  }
  public resetHsv() {
    this._hsv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hsvInput() {
    return this._hsv.internalValue;
  }

  // if_dimension - computed: false, optional: true, required: false
  private _ifDimension = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimensionList(this, "if_dimension", false);
  public get ifDimension() {
    return this._ifDimension;
  }
  public putIfDimension(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfDimension[] | cdktf.IResolvable) {
    this._ifDimension.internalValue = value;
  }
  public resetIfDimension() {
    this._ifDimension.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ifDimensionInput() {
    return this._ifDimension.internalValue;
  }

  // if_orientation - computed: false, optional: true, required: false
  private _ifOrientation = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientationList(this, "if_orientation", false);
  public get ifOrientation() {
    return this._ifOrientation;
  }
  public putIfOrientation(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareIfOrientation[] | cdktf.IResolvable) {
    this._ifOrientation.internalValue = value;
  }
  public resetIfOrientation() {
    this._ifOrientation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ifOrientationInput() {
    return this._ifOrientation.internalValue;
  }

  // max_colors - computed: false, optional: true, required: false
  private _maxColors = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColorsList(this, "max_colors", false);
  public get maxColors() {
    return this._maxColors;
  }
  public putMaxColors(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMaxColors[] | cdktf.IResolvable) {
    this._maxColors.internalValue = value;
  }
  public resetMaxColors() {
    this._maxColors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxColorsInput() {
    return this._maxColors.internalValue;
  }

  // mirror - computed: false, optional: true, required: false
  private _mirror = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirrorList(this, "mirror", false);
  public get mirror() {
    return this._mirror;
  }
  public putMirror(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMirror[] | cdktf.IResolvable) {
    this._mirror.internalValue = value;
  }
  public resetMirror() {
    this._mirror.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mirrorInput() {
    return this._mirror.internalValue;
  }

  // mono_hue - computed: false, optional: true, required: false
  private _monoHue = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHueList(this, "mono_hue", false);
  public get monoHue() {
    return this._monoHue;
  }
  public putMonoHue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareMonoHue[] | cdktf.IResolvable) {
    this._monoHue.internalValue = value;
  }
  public resetMonoHue() {
    this._monoHue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monoHueInput() {
    return this._monoHue.internalValue;
  }

  // opacity - computed: false, optional: true, required: false
  private _opacity = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacityList(this, "opacity", false);
  public get opacity() {
    return this._opacity;
  }
  public putOpacity(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOpacity[] | cdktf.IResolvable) {
    this._opacity.internalValue = value;
  }
  public resetOpacity() {
    this._opacity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opacityInput() {
    return this._opacity.internalValue;
  }

  // remove_color - computed: false, optional: true, required: false
  private _removeColor = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColorList(this, "remove_color", false);
  public get removeColor() {
    return this._removeColor;
  }
  public putRemoveColor(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareRemoveColor[] | cdktf.IResolvable) {
    this._removeColor.internalValue = value;
  }
  public resetRemoveColor() {
    this._removeColor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeColorInput() {
    return this._removeColor.internalValue;
  }

  // unsharp_mask - computed: false, optional: true, required: false
  private _unsharpMask = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMaskList(this, "unsharp_mask", false);
  public get unsharpMask() {
    return this._unsharpMask;
  }
  public putUnsharpMask(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareUnsharpMask[] | cdktf.IResolvable) {
    this._unsharpMask.internalValue = value;
  }
  public resetUnsharpMask() {
    this._unsharpMask.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unsharpMaskInput() {
    return this._unsharpMask.internalValue;
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientation {
  /**
  * default block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#default DataAkamaiImagingPolicyImage#default}
  */
  readonly default?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefault;
  /**
  * landscape block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#landscape DataAkamaiImagingPolicyImage#landscape}
  */
  readonly landscape?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscape;
  /**
  * portrait block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#portrait DataAkamaiImagingPolicyImage#portrait}
  */
  readonly portrait?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortrait;
  /**
  * square block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#square DataAkamaiImagingPolicyImage#square}
  */
  readonly square?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquare;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultToTerraform(struct!.default),
    landscape: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeToTerraform(struct!.landscape),
    portrait: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitToTerraform(struct!.portrait),
    square: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareToTerraform(struct!.square),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultToHclTerraform(struct!.default),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultList",
    },
    landscape: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeToHclTerraform(struct!.landscape),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeList",
    },
    portrait: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitToHclTerraform(struct!.portrait),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitList",
    },
    square: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareToHclTerraform(struct!.square),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._default?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default?.internalValue;
    }
    if (this._landscape?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.landscape = this._landscape?.internalValue;
    }
    if (this._portrait?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.portrait = this._portrait?.internalValue;
    }
    if (this._square?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.square = this._square?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._default.internalValue = undefined;
      this._landscape.internalValue = undefined;
      this._portrait.internalValue = undefined;
      this._square.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._default.internalValue = value.default;
      this._landscape.internalValue = value.landscape;
      this._portrait.internalValue = value.portrait;
      this._square.internalValue = value.square;
    }
  }

  // default - computed: false, optional: true, required: false
  private _default = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOutputReference(this, "default");
  public get default() {
    return this._default;
  }
  public putDefault(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefault) {
    this._default.internalValue = value;
  }
  public resetDefault() {
    this._default.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default.internalValue;
  }

  // landscape - computed: false, optional: true, required: false
  private _landscape = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscapeOutputReference(this, "landscape");
  public get landscape() {
    return this._landscape;
  }
  public putLandscape(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationLandscape) {
    this._landscape.internalValue = value;
  }
  public resetLandscape() {
    this._landscape.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get landscapeInput() {
    return this._landscape.internalValue;
  }

  // portrait - computed: false, optional: true, required: false
  private _portrait = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortraitOutputReference(this, "portrait");
  public get portrait() {
    return this._portrait;
  }
  public putPortrait(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationPortrait) {
    this._portrait.internalValue = value;
  }
  public resetPortrait() {
    this._portrait.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portraitInput() {
    return this._portrait.internalValue;
  }

  // square - computed: false, optional: true, required: false
  private _square = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquareOutputReference(this, "square");
  public get square() {
    return this._square;
  }
  public putSquare(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationSquare) {
    this._square.internalValue = value;
  }
  public resetSquare() {
    this._square.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get squareInput() {
    return this._square.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientation[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColors {
  /**
  * The value representing the maximum number of colors to use with the source image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#colors DataAkamaiImagingPolicyImage#colors}
  */
  readonly colors?: string;
  /**
  * The value representing the maximum number of colors to use with the source image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#colors_var DataAkamaiImagingPolicyImage#colors_var}
  */
  readonly colorsVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColorsToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    colors: cdktf.stringToTerraform(struct!.colors),
    colors_var: cdktf.stringToTerraform(struct!.colorsVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColorsToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    colors: {
      value: cdktf.stringToHclTerraform(struct!.colors),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    colors_var: {
      value: cdktf.stringToHclTerraform(struct!.colorsVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._colors !== undefined) {
      hasAnyValues = true;
      internalValueResult.colors = this._colors;
    }
    if (this._colorsVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorsVar = this._colorsVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._colors = undefined;
      this._colorsVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._colors = value.colors;
      this._colorsVar = value.colorsVar;
    }
  }

  // colors - computed: false, optional: true, required: false
  private _colors?: string; 
  public get colors() {
    return this.getStringAttribute('colors');
  }
  public set colors(value: string) {
    this._colors = value;
  }
  public resetColors() {
    this._colors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorsInput() {
    return this._colors;
  }

  // colors_var - computed: false, optional: true, required: false
  private _colorsVar?: string; 
  public get colorsVar() {
    return this.getStringAttribute('colors_var');
  }
  public set colorsVar(value: string) {
    this._colorsVar = value;
  }
  public resetColorsVar() {
    this._colorsVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorsVarInput() {
    return this._colorsVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColorsList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColorsOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirror {
  /**
  * Flips the image horizontally.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#horizontal DataAkamaiImagingPolicyImage#horizontal}
  */
  readonly horizontal?: string;
  /**
  * Flips the image horizontally.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#horizontal_var DataAkamaiImagingPolicyImage#horizontal_var}
  */
  readonly horizontalVar?: string;
  /**
  * Flips the image vertically.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#vertical DataAkamaiImagingPolicyImage#vertical}
  */
  readonly vertical?: string;
  /**
  * Flips the image vertically.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#vertical_var DataAkamaiImagingPolicyImage#vertical_var}
  */
  readonly verticalVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirrorToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirror | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    horizontal: cdktf.stringToTerraform(struct!.horizontal),
    horizontal_var: cdktf.stringToTerraform(struct!.horizontalVar),
    vertical: cdktf.stringToTerraform(struct!.vertical),
    vertical_var: cdktf.stringToTerraform(struct!.verticalVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirrorToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirror | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    horizontal: {
      value: cdktf.stringToHclTerraform(struct!.horizontal),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    horizontal_var: {
      value: cdktf.stringToHclTerraform(struct!.horizontalVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vertical: {
      value: cdktf.stringToHclTerraform(struct!.vertical),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vertical_var: {
      value: cdktf.stringToHclTerraform(struct!.verticalVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirrorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirror | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._horizontal !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontal = this._horizontal;
    }
    if (this._horizontalVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.horizontalVar = this._horizontalVar;
    }
    if (this._vertical !== undefined) {
      hasAnyValues = true;
      internalValueResult.vertical = this._vertical;
    }
    if (this._verticalVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.verticalVar = this._verticalVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirror | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._horizontal = undefined;
      this._horizontalVar = undefined;
      this._vertical = undefined;
      this._verticalVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._horizontal = value.horizontal;
      this._horizontalVar = value.horizontalVar;
      this._vertical = value.vertical;
      this._verticalVar = value.verticalVar;
    }
  }

  // horizontal - computed: false, optional: true, required: false
  private _horizontal?: string; 
  public get horizontal() {
    return this.getStringAttribute('horizontal');
  }
  public set horizontal(value: string) {
    this._horizontal = value;
  }
  public resetHorizontal() {
    this._horizontal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalInput() {
    return this._horizontal;
  }

  // horizontal_var - computed: false, optional: true, required: false
  private _horizontalVar?: string; 
  public get horizontalVar() {
    return this.getStringAttribute('horizontal_var');
  }
  public set horizontalVar(value: string) {
    this._horizontalVar = value;
  }
  public resetHorizontalVar() {
    this._horizontalVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get horizontalVarInput() {
    return this._horizontalVar;
  }

  // vertical - computed: false, optional: true, required: false
  private _vertical?: string; 
  public get vertical() {
    return this.getStringAttribute('vertical');
  }
  public set vertical(value: string) {
    this._vertical = value;
  }
  public resetVertical() {
    this._vertical = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verticalInput() {
    return this._vertical;
  }

  // vertical_var - computed: false, optional: true, required: false
  private _verticalVar?: string; 
  public get verticalVar() {
    return this.getStringAttribute('vertical_var');
  }
  public set verticalVar(value: string) {
    this._verticalVar = value;
  }
  public resetVerticalVar() {
    this._verticalVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verticalVarInput() {
    return this._verticalVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirrorList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirror[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirrorOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirrorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHue {
  /**
  * Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * Specify a hue by indicating the degree of rotation between 0 and 360 degrees around the color wheel. By default Mono Hue applies a red hue, 0.0 on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHueToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHueToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueVar = value.hueVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHueList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHue[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHueOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHueOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacity {
  /**
  * Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#opacity DataAkamaiImagingPolicyImage#opacity}
  */
  readonly opacity?: string;
  /**
  * Represents alpha values on a scale of `0` to `1`. Values below `1` increase transparency, and `0` is invisible. For images that have some transparency, values above `1` increase the opacity of the transparent portions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#opacity_var DataAkamaiImagingPolicyImage#opacity_var}
  */
  readonly opacityVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacityToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    opacity: cdktf.stringToTerraform(struct!.opacity),
    opacity_var: cdktf.stringToTerraform(struct!.opacityVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacityToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    opacity: {
      value: cdktf.stringToHclTerraform(struct!.opacity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    opacity_var: {
      value: cdktf.stringToHclTerraform(struct!.opacityVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._opacity !== undefined) {
      hasAnyValues = true;
      internalValueResult.opacity = this._opacity;
    }
    if (this._opacityVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.opacityVar = this._opacityVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._opacity = undefined;
      this._opacityVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._opacity = value.opacity;
      this._opacityVar = value.opacityVar;
    }
  }

  // opacity - computed: false, optional: true, required: false
  private _opacity?: string; 
  public get opacity() {
    return this.getStringAttribute('opacity');
  }
  public set opacity(value: string) {
    this._opacity = value;
  }
  public resetOpacity() {
    this._opacity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opacityInput() {
    return this._opacity;
  }

  // opacity_var - computed: false, optional: true, required: false
  private _opacityVar?: string; 
  public get opacityVar() {
    return this.getStringAttribute('opacity_var');
  }
  public set opacityVar(value: string) {
    this._opacityVar = value;
  }
  public resetOpacityVar() {
    this._opacityVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opacityVarInput() {
    return this._opacityVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacityList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacity[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacityOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacityOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColor {
  /**
  * The hexadecimal CSS color value to remove.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color DataAkamaiImagingPolicyImage#color}
  */
  readonly color?: string;
  /**
  * The hexadecimal CSS color value to remove.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color_var DataAkamaiImagingPolicyImage#color_var}
  */
  readonly colorVar?: string;
  /**
  * The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#feather DataAkamaiImagingPolicyImage#feather}
  */
  readonly feather?: string;
  /**
  * The RemoveColor transformation may create a hard edge around an image. To minimize these hard edges and make the removal of the color more gradual in appearance, use the Feather option. This option allows you to extend the color removal beyond the specified Tolerance. The pixels in this extended tolerance become semi-transparent - creating a softer edge.  The first realtime request for an image using the feather option may result in a slow transformation time. Subsequent requests are not impacted as they are served directly out of cache.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#feather_var DataAkamaiImagingPolicyImage#feather_var}
  */
  readonly featherVar?: string;
  /**
  * The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#tolerance DataAkamaiImagingPolicyImage#tolerance}
  */
  readonly tolerance?: string;
  /**
  * The Tolerance option defines how close the color needs to be to the selected color before it's changed to fully transparent. Set the Tolerance to 0.0 to remove only the exact color specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#tolerance_var DataAkamaiImagingPolicyImage#tolerance_var}
  */
  readonly toleranceVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColorToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    color: cdktf.stringToTerraform(struct!.color),
    color_var: cdktf.stringToTerraform(struct!.colorVar),
    feather: cdktf.stringToTerraform(struct!.feather),
    feather_var: cdktf.stringToTerraform(struct!.featherVar),
    tolerance: cdktf.stringToTerraform(struct!.tolerance),
    tolerance_var: cdktf.stringToTerraform(struct!.toleranceVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColorToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    color_var: {
      value: cdktf.stringToHclTerraform(struct!.colorVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    feather: {
      value: cdktf.stringToHclTerraform(struct!.feather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    feather_var: {
      value: cdktf.stringToHclTerraform(struct!.featherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tolerance: {
      value: cdktf.stringToHclTerraform(struct!.tolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.toleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._colorVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorVar = this._colorVar;
    }
    if (this._feather !== undefined) {
      hasAnyValues = true;
      internalValueResult.feather = this._feather;
    }
    if (this._featherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.featherVar = this._featherVar;
    }
    if (this._tolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerance = this._tolerance;
    }
    if (this._toleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.toleranceVar = this._toleranceVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._color = undefined;
      this._colorVar = undefined;
      this._feather = undefined;
      this._featherVar = undefined;
      this._tolerance = undefined;
      this._toleranceVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._color = value.color;
      this._colorVar = value.colorVar;
      this._feather = value.feather;
      this._featherVar = value.featherVar;
      this._tolerance = value.tolerance;
      this._toleranceVar = value.toleranceVar;
    }
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // color_var - computed: false, optional: true, required: false
  private _colorVar?: string; 
  public get colorVar() {
    return this.getStringAttribute('color_var');
  }
  public set colorVar(value: string) {
    this._colorVar = value;
  }
  public resetColorVar() {
    this._colorVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorVarInput() {
    return this._colorVar;
  }

  // feather - computed: false, optional: true, required: false
  private _feather?: string; 
  public get feather() {
    return this.getStringAttribute('feather');
  }
  public set feather(value: string) {
    this._feather = value;
  }
  public resetFeather() {
    this._feather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featherInput() {
    return this._feather;
  }

  // feather_var - computed: false, optional: true, required: false
  private _featherVar?: string; 
  public get featherVar() {
    return this.getStringAttribute('feather_var');
  }
  public set featherVar(value: string) {
    this._featherVar = value;
  }
  public resetFeatherVar() {
    this._featherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get featherVarInput() {
    return this._featherVar;
  }

  // tolerance - computed: false, optional: true, required: false
  private _tolerance?: string; 
  public get tolerance() {
    return this.getStringAttribute('tolerance');
  }
  public set tolerance(value: string) {
    this._tolerance = value;
  }
  public resetTolerance() {
    this._tolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toleranceInput() {
    return this._tolerance;
  }

  // tolerance_var - computed: false, optional: true, required: false
  private _toleranceVar?: string; 
  public get toleranceVar() {
    return this.getStringAttribute('tolerance_var');
  }
  public set toleranceVar(value: string) {
    this._toleranceVar = value;
  }
  public resetToleranceVar() {
    this._toleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toleranceVarInput() {
    return this._toleranceVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColorList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColor[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColorOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMask {
  /**
  * Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gain DataAkamaiImagingPolicyImage#gain}
  */
  readonly gain?: string;
  /**
  * Set how much emphasis the filter applies to details. Higher values increase apparent sharpness of details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#gain_var DataAkamaiImagingPolicyImage#gain_var}
  */
  readonly gainVar?: string;
  /**
  * The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma DataAkamaiImagingPolicyImage#sigma}
  */
  readonly sigma?: string;
  /**
  * The standard deviation of the Gaussian distribution used in the in unsharp mask, measured in pixels, `1.0` by default. High values emphasize large details and low values emphasize small details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma_var DataAkamaiImagingPolicyImage#sigma_var}
  */
  readonly sigmaVar?: string;
  /**
  * Set the minimum change required to include a detail in the filter. Higher values discard more changes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#threshold DataAkamaiImagingPolicyImage#threshold}
  */
  readonly threshold?: string;
  /**
  * Set the minimum change required to include a detail in the filter. Higher values discard more changes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#threshold_var DataAkamaiImagingPolicyImage#threshold_var}
  */
  readonly thresholdVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMaskToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMask | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gain: cdktf.stringToTerraform(struct!.gain),
    gain_var: cdktf.stringToTerraform(struct!.gainVar),
    sigma: cdktf.stringToTerraform(struct!.sigma),
    sigma_var: cdktf.stringToTerraform(struct!.sigmaVar),
    threshold: cdktf.stringToTerraform(struct!.threshold),
    threshold_var: cdktf.stringToTerraform(struct!.thresholdVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMaskToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMask | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gain: {
      value: cdktf.stringToHclTerraform(struct!.gain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gain_var: {
      value: cdktf.stringToHclTerraform(struct!.gainVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sigma: {
      value: cdktf.stringToHclTerraform(struct!.sigma),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sigma_var: {
      value: cdktf.stringToHclTerraform(struct!.sigmaVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threshold: {
      value: cdktf.stringToHclTerraform(struct!.threshold),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    threshold_var: {
      value: cdktf.stringToHclTerraform(struct!.thresholdVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMaskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMask | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gain !== undefined) {
      hasAnyValues = true;
      internalValueResult.gain = this._gain;
    }
    if (this._gainVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.gainVar = this._gainVar;
    }
    if (this._sigma !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigma = this._sigma;
    }
    if (this._sigmaVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigmaVar = this._sigmaVar;
    }
    if (this._threshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.threshold = this._threshold;
    }
    if (this._thresholdVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.thresholdVar = this._thresholdVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMask | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gain = undefined;
      this._gainVar = undefined;
      this._sigma = undefined;
      this._sigmaVar = undefined;
      this._threshold = undefined;
      this._thresholdVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gain = value.gain;
      this._gainVar = value.gainVar;
      this._sigma = value.sigma;
      this._sigmaVar = value.sigmaVar;
      this._threshold = value.threshold;
      this._thresholdVar = value.thresholdVar;
    }
  }

  // gain - computed: false, optional: true, required: false
  private _gain?: string; 
  public get gain() {
    return this.getStringAttribute('gain');
  }
  public set gain(value: string) {
    this._gain = value;
  }
  public resetGain() {
    this._gain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gainInput() {
    return this._gain;
  }

  // gain_var - computed: false, optional: true, required: false
  private _gainVar?: string; 
  public get gainVar() {
    return this.getStringAttribute('gain_var');
  }
  public set gainVar(value: string) {
    this._gainVar = value;
  }
  public resetGainVar() {
    this._gainVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gainVarInput() {
    return this._gainVar;
  }

  // sigma - computed: false, optional: true, required: false
  private _sigma?: string; 
  public get sigma() {
    return this.getStringAttribute('sigma');
  }
  public set sigma(value: string) {
    this._sigma = value;
  }
  public resetSigma() {
    this._sigma = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaInput() {
    return this._sigma;
  }

  // sigma_var - computed: false, optional: true, required: false
  private _sigmaVar?: string; 
  public get sigmaVar() {
    return this.getStringAttribute('sigma_var');
  }
  public set sigmaVar(value: string) {
    this._sigmaVar = value;
  }
  public resetSigmaVar() {
    this._sigmaVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaVarInput() {
    return this._sigmaVar;
  }

  // threshold - computed: false, optional: true, required: false
  private _threshold?: string; 
  public get threshold() {
    return this.getStringAttribute('threshold');
  }
  public set threshold(value: string) {
    this._threshold = value;
  }
  public resetThreshold() {
    this._threshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdInput() {
    return this._threshold;
  }

  // threshold_var - computed: false, optional: true, required: false
  private _thresholdVar?: string; 
  public get thresholdVar() {
    return this.getStringAttribute('threshold_var');
  }
  public set thresholdVar(value: string) {
    this._thresholdVar = value;
  }
  public resetThresholdVar() {
    this._thresholdVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdVarInput() {
    return this._thresholdVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMaskList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMask[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMaskOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMaskOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefault {
  /**
  * background_color block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#background_color DataAkamaiImagingPolicyImage#background_color}
  */
  readonly backgroundColor?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBackgroundColor[] | cdktf.IResolvable;
  /**
  * blur block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#blur DataAkamaiImagingPolicyImage#blur}
  */
  readonly blur?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBlur[] | cdktf.IResolvable;
  /**
  * chroma_key block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#chroma_key DataAkamaiImagingPolicyImage#chroma_key}
  */
  readonly chromaKey?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultChromaKey[] | cdktf.IResolvable;
  /**
  * composite block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#composite DataAkamaiImagingPolicyImage#composite}
  */
  readonly composite?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultComposite[] | cdktf.IResolvable;
  /**
  * compound block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#compound DataAkamaiImagingPolicyImage#compound}
  */
  readonly compound?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompound[] | cdktf.IResolvable;
  /**
  * contrast block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#contrast DataAkamaiImagingPolicyImage#contrast}
  */
  readonly contrast?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrast[] | cdktf.IResolvable;
  /**
  * goop block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#goop DataAkamaiImagingPolicyImage#goop}
  */
  readonly goop?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoop[] | cdktf.IResolvable;
  /**
  * grayscale block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#grayscale DataAkamaiImagingPolicyImage#grayscale}
  */
  readonly grayscale?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscale[] | cdktf.IResolvable;
  /**
  * hsl block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hsl DataAkamaiImagingPolicyImage#hsl}
  */
  readonly hsl?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsl[] | cdktf.IResolvable;
  /**
  * hsv block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hsv DataAkamaiImagingPolicyImage#hsv}
  */
  readonly hsv?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsv[] | cdktf.IResolvable;
  /**
  * if_dimension block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#if_dimension DataAkamaiImagingPolicyImage#if_dimension}
  */
  readonly ifDimension?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimension[] | cdktf.IResolvable;
  /**
  * if_orientation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#if_orientation DataAkamaiImagingPolicyImage#if_orientation}
  */
  readonly ifOrientation?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientation[] | cdktf.IResolvable;
  /**
  * max_colors block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#max_colors DataAkamaiImagingPolicyImage#max_colors}
  */
  readonly maxColors?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColors[] | cdktf.IResolvable;
  /**
  * mirror block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#mirror DataAkamaiImagingPolicyImage#mirror}
  */
  readonly mirror?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirror[] | cdktf.IResolvable;
  /**
  * mono_hue block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#mono_hue DataAkamaiImagingPolicyImage#mono_hue}
  */
  readonly monoHue?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHue[] | cdktf.IResolvable;
  /**
  * opacity block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#opacity DataAkamaiImagingPolicyImage#opacity}
  */
  readonly opacity?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacity[] | cdktf.IResolvable;
  /**
  * remove_color block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#remove_color DataAkamaiImagingPolicyImage#remove_color}
  */
  readonly removeColor?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColor[] | cdktf.IResolvable;
  /**
  * unsharp_mask block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#unsharp_mask DataAkamaiImagingPolicyImage#unsharp_mask}
  */
  readonly unsharpMask?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMask[] | cdktf.IResolvable;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    background_color: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBackgroundColorToTerraform, true)(struct!.backgroundColor),
    blur: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBlurToTerraform, true)(struct!.blur),
    chroma_key: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultChromaKeyToTerraform, true)(struct!.chromaKey),
    composite: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompositeToTerraform, true)(struct!.composite),
    compound: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundToTerraform, true)(struct!.compound),
    contrast: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrastToTerraform, true)(struct!.contrast),
    goop: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoopToTerraform, true)(struct!.goop),
    grayscale: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscaleToTerraform, true)(struct!.grayscale),
    hsl: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHslToTerraform, true)(struct!.hsl),
    hsv: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsvToTerraform, true)(struct!.hsv),
    if_dimension: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionToTerraform, true)(struct!.ifDimension),
    if_orientation: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationToTerraform, true)(struct!.ifOrientation),
    max_colors: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColorsToTerraform, true)(struct!.maxColors),
    mirror: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirrorToTerraform, true)(struct!.mirror),
    mono_hue: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHueToTerraform, true)(struct!.monoHue),
    opacity: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacityToTerraform, true)(struct!.opacity),
    remove_color: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColorToTerraform, true)(struct!.removeColor),
    unsharp_mask: cdktf.listMapper(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMaskToTerraform, true)(struct!.unsharpMask),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefault): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    background_color: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBackgroundColorToHclTerraform, true)(struct!.backgroundColor),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBackgroundColorList",
    },
    blur: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBlurToHclTerraform, true)(struct!.blur),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBlurList",
    },
    chroma_key: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultChromaKeyToHclTerraform, true)(struct!.chromaKey),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultChromaKeyList",
    },
    composite: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompositeToHclTerraform, true)(struct!.composite),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompositeList",
    },
    compound: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundToHclTerraform, true)(struct!.compound),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundList",
    },
    contrast: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrastToHclTerraform, true)(struct!.contrast),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrastList",
    },
    goop: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoopToHclTerraform, true)(struct!.goop),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoopList",
    },
    grayscale: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscaleToHclTerraform, true)(struct!.grayscale),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscaleList",
    },
    hsl: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHslToHclTerraform, true)(struct!.hsl),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHslList",
    },
    hsv: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsvToHclTerraform, true)(struct!.hsv),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsvList",
    },
    if_dimension: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionToHclTerraform, true)(struct!.ifDimension),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionList",
    },
    if_orientation: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationToHclTerraform, true)(struct!.ifOrientation),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationList",
    },
    max_colors: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColorsToHclTerraform, true)(struct!.maxColors),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColorsList",
    },
    mirror: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirrorToHclTerraform, true)(struct!.mirror),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirrorList",
    },
    mono_hue: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHueToHclTerraform, true)(struct!.monoHue),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHueList",
    },
    opacity: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacityToHclTerraform, true)(struct!.opacity),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacityList",
    },
    remove_color: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColorToHclTerraform, true)(struct!.removeColor),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColorList",
    },
    unsharp_mask: {
      value: cdktf.listMapperHcl(dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMaskToHclTerraform, true)(struct!.unsharpMask),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMaskList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefault | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backgroundColor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backgroundColor = this._backgroundColor?.internalValue;
    }
    if (this._blur?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.blur = this._blur?.internalValue;
    }
    if (this._chromaKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.chromaKey = this._chromaKey?.internalValue;
    }
    if (this._composite?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.composite = this._composite?.internalValue;
    }
    if (this._compound?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.compound = this._compound?.internalValue;
    }
    if (this._contrast?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.contrast = this._contrast?.internalValue;
    }
    if (this._goop?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.goop = this._goop?.internalValue;
    }
    if (this._grayscale?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grayscale = this._grayscale?.internalValue;
    }
    if (this._hsl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hsl = this._hsl?.internalValue;
    }
    if (this._hsv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hsv = this._hsv?.internalValue;
    }
    if (this._ifDimension?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ifDimension = this._ifDimension?.internalValue;
    }
    if (this._ifOrientation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ifOrientation = this._ifOrientation?.internalValue;
    }
    if (this._maxColors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxColors = this._maxColors?.internalValue;
    }
    if (this._mirror?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mirror = this._mirror?.internalValue;
    }
    if (this._monoHue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.monoHue = this._monoHue?.internalValue;
    }
    if (this._opacity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.opacity = this._opacity?.internalValue;
    }
    if (this._removeColor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeColor = this._removeColor?.internalValue;
    }
    if (this._unsharpMask?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.unsharpMask = this._unsharpMask?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefault | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._backgroundColor.internalValue = undefined;
      this._blur.internalValue = undefined;
      this._chromaKey.internalValue = undefined;
      this._composite.internalValue = undefined;
      this._compound.internalValue = undefined;
      this._contrast.internalValue = undefined;
      this._goop.internalValue = undefined;
      this._grayscale.internalValue = undefined;
      this._hsl.internalValue = undefined;
      this._hsv.internalValue = undefined;
      this._ifDimension.internalValue = undefined;
      this._ifOrientation.internalValue = undefined;
      this._maxColors.internalValue = undefined;
      this._mirror.internalValue = undefined;
      this._monoHue.internalValue = undefined;
      this._opacity.internalValue = undefined;
      this._removeColor.internalValue = undefined;
      this._unsharpMask.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._backgroundColor.internalValue = value.backgroundColor;
      this._blur.internalValue = value.blur;
      this._chromaKey.internalValue = value.chromaKey;
      this._composite.internalValue = value.composite;
      this._compound.internalValue = value.compound;
      this._contrast.internalValue = value.contrast;
      this._goop.internalValue = value.goop;
      this._grayscale.internalValue = value.grayscale;
      this._hsl.internalValue = value.hsl;
      this._hsv.internalValue = value.hsv;
      this._ifDimension.internalValue = value.ifDimension;
      this._ifOrientation.internalValue = value.ifOrientation;
      this._maxColors.internalValue = value.maxColors;
      this._mirror.internalValue = value.mirror;
      this._monoHue.internalValue = value.monoHue;
      this._opacity.internalValue = value.opacity;
      this._removeColor.internalValue = value.removeColor;
      this._unsharpMask.internalValue = value.unsharpMask;
    }
  }

  // background_color - computed: false, optional: true, required: false
  private _backgroundColor = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBackgroundColorList(this, "background_color", false);
  public get backgroundColor() {
    return this._backgroundColor;
  }
  public putBackgroundColor(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBackgroundColor[] | cdktf.IResolvable) {
    this._backgroundColor.internalValue = value;
  }
  public resetBackgroundColor() {
    this._backgroundColor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backgroundColorInput() {
    return this._backgroundColor.internalValue;
  }

  // blur - computed: false, optional: true, required: false
  private _blur = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBlurList(this, "blur", false);
  public get blur() {
    return this._blur;
  }
  public putBlur(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultBlur[] | cdktf.IResolvable) {
    this._blur.internalValue = value;
  }
  public resetBlur() {
    this._blur.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blurInput() {
    return this._blur.internalValue;
  }

  // chroma_key - computed: false, optional: true, required: false
  private _chromaKey = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultChromaKeyList(this, "chroma_key", false);
  public get chromaKey() {
    return this._chromaKey;
  }
  public putChromaKey(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultChromaKey[] | cdktf.IResolvable) {
    this._chromaKey.internalValue = value;
  }
  public resetChromaKey() {
    this._chromaKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chromaKeyInput() {
    return this._chromaKey.internalValue;
  }

  // composite - computed: false, optional: true, required: false
  private _composite = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompositeList(this, "composite", false);
  public get composite() {
    return this._composite;
  }
  public putComposite(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultComposite[] | cdktf.IResolvable) {
    this._composite.internalValue = value;
  }
  public resetComposite() {
    this._composite.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compositeInput() {
    return this._composite.internalValue;
  }

  // compound - computed: false, optional: true, required: false
  private _compound = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompoundList(this, "compound", false);
  public get compound() {
    return this._compound;
  }
  public putCompound(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultCompound[] | cdktf.IResolvable) {
    this._compound.internalValue = value;
  }
  public resetCompound() {
    this._compound.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compoundInput() {
    return this._compound.internalValue;
  }

  // contrast - computed: false, optional: true, required: false
  private _contrast = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrastList(this, "contrast", false);
  public get contrast() {
    return this._contrast;
  }
  public putContrast(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultContrast[] | cdktf.IResolvable) {
    this._contrast.internalValue = value;
  }
  public resetContrast() {
    this._contrast.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contrastInput() {
    return this._contrast.internalValue;
  }

  // goop - computed: false, optional: true, required: false
  private _goop = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoopList(this, "goop", false);
  public get goop() {
    return this._goop;
  }
  public putGoop(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGoop[] | cdktf.IResolvable) {
    this._goop.internalValue = value;
  }
  public resetGoop() {
    this._goop.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get goopInput() {
    return this._goop.internalValue;
  }

  // grayscale - computed: false, optional: true, required: false
  private _grayscale = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscaleList(this, "grayscale", false);
  public get grayscale() {
    return this._grayscale;
  }
  public putGrayscale(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultGrayscale[] | cdktf.IResolvable) {
    this._grayscale.internalValue = value;
  }
  public resetGrayscale() {
    this._grayscale.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grayscaleInput() {
    return this._grayscale.internalValue;
  }

  // hsl - computed: false, optional: true, required: false
  private _hsl = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHslList(this, "hsl", false);
  public get hsl() {
    return this._hsl;
  }
  public putHsl(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsl[] | cdktf.IResolvable) {
    this._hsl.internalValue = value;
  }
  public resetHsl() {
    this._hsl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hslInput() {
    return this._hsl.internalValue;
  }

  // hsv - computed: false, optional: true, required: false
  private _hsv = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsvList(this, "hsv", false);
  public get hsv() {
    return this._hsv;
  }
  public putHsv(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultHsv[] | cdktf.IResolvable) {
    this._hsv.internalValue = value;
  }
  public resetHsv() {
    this._hsv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hsvInput() {
    return this._hsv.internalValue;
  }

  // if_dimension - computed: false, optional: true, required: false
  private _ifDimension = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionList(this, "if_dimension", false);
  public get ifDimension() {
    return this._ifDimension;
  }
  public putIfDimension(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimension[] | cdktf.IResolvable) {
    this._ifDimension.internalValue = value;
  }
  public resetIfDimension() {
    this._ifDimension.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ifDimensionInput() {
    return this._ifDimension.internalValue;
  }

  // if_orientation - computed: false, optional: true, required: false
  private _ifOrientation = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientationList(this, "if_orientation", false);
  public get ifOrientation() {
    return this._ifOrientation;
  }
  public putIfOrientation(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultIfOrientation[] | cdktf.IResolvable) {
    this._ifOrientation.internalValue = value;
  }
  public resetIfOrientation() {
    this._ifOrientation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ifOrientationInput() {
    return this._ifOrientation.internalValue;
  }

  // max_colors - computed: false, optional: true, required: false
  private _maxColors = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColorsList(this, "max_colors", false);
  public get maxColors() {
    return this._maxColors;
  }
  public putMaxColors(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMaxColors[] | cdktf.IResolvable) {
    this._maxColors.internalValue = value;
  }
  public resetMaxColors() {
    this._maxColors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxColorsInput() {
    return this._maxColors.internalValue;
  }

  // mirror - computed: false, optional: true, required: false
  private _mirror = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirrorList(this, "mirror", false);
  public get mirror() {
    return this._mirror;
  }
  public putMirror(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMirror[] | cdktf.IResolvable) {
    this._mirror.internalValue = value;
  }
  public resetMirror() {
    this._mirror.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mirrorInput() {
    return this._mirror.internalValue;
  }

  // mono_hue - computed: false, optional: true, required: false
  private _monoHue = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHueList(this, "mono_hue", false);
  public get monoHue() {
    return this._monoHue;
  }
  public putMonoHue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultMonoHue[] | cdktf.IResolvable) {
    this._monoHue.internalValue = value;
  }
  public resetMonoHue() {
    this._monoHue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monoHueInput() {
    return this._monoHue.internalValue;
  }

  // opacity - computed: false, optional: true, required: false
  private _opacity = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacityList(this, "opacity", false);
  public get opacity() {
    return this._opacity;
  }
  public putOpacity(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultOpacity[] | cdktf.IResolvable) {
    this._opacity.internalValue = value;
  }
  public resetOpacity() {
    this._opacity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opacityInput() {
    return this._opacity.internalValue;
  }

  // remove_color - computed: false, optional: true, required: false
  private _removeColor = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColorList(this, "remove_color", false);
  public get removeColor() {
    return this._removeColor;
  }
  public putRemoveColor(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultRemoveColor[] | cdktf.IResolvable) {
    this._removeColor.internalValue = value;
  }
  public resetRemoveColor() {
    this._removeColor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeColorInput() {
    return this._removeColor.internalValue;
  }

  // unsharp_mask - computed: false, optional: true, required: false
  private _unsharpMask = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMaskList(this, "unsharp_mask", false);
  public get unsharpMask() {
    return this._unsharpMask;
  }
  public putUnsharpMask(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionDefaultUnsharpMask[] | cdktf.IResolvable) {
    this._unsharpMask.internalValue = value;
  }
  public resetUnsharpMask() {
    this._unsharpMask.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unsharpMaskInput() {
    return this._unsharpMask.internalValue;
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBackgroundColor {
  /**
  * The hexadecimal CSS color value for the background.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color DataAkamaiImagingPolicyImage#color}
  */
  readonly color?: string;
  /**
  * The hexadecimal CSS color value for the background.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color_var DataAkamaiImagingPolicyImage#color_var}
  */
  readonly colorVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBackgroundColorToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBackgroundColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    color: cdktf.stringToTerraform(struct!.color),
    color_var: cdktf.stringToTerraform(struct!.colorVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBackgroundColorToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBackgroundColor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    color_var: {
      value: cdktf.stringToHclTerraform(struct!.colorVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBackgroundColorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBackgroundColor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._colorVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorVar = this._colorVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBackgroundColor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._color = undefined;
      this._colorVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._color = value.color;
      this._colorVar = value.colorVar;
    }
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // color_var - computed: false, optional: true, required: false
  private _colorVar?: string; 
  public get colorVar() {
    return this.getStringAttribute('color_var');
  }
  public set colorVar(value: string) {
    this._colorVar = value;
  }
  public resetColorVar() {
    this._colorVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorVarInput() {
    return this._colorVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBackgroundColorList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBackgroundColor[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBackgroundColorOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBackgroundColorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBlur {
  /**
  * The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma DataAkamaiImagingPolicyImage#sigma}
  */
  readonly sigma?: string;
  /**
  * The number of pixels to scatter the original pixel by to create the blur effect. Resulting images may be larger than the original as pixels at the edge of the image might scatter outside the image's original dimensions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#sigma_var DataAkamaiImagingPolicyImage#sigma_var}
  */
  readonly sigmaVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBlurToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBlur | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sigma: cdktf.stringToTerraform(struct!.sigma),
    sigma_var: cdktf.stringToTerraform(struct!.sigmaVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBlurToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBlur | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sigma: {
      value: cdktf.stringToHclTerraform(struct!.sigma),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sigma_var: {
      value: cdktf.stringToHclTerraform(struct!.sigmaVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBlurOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBlur | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sigma !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigma = this._sigma;
    }
    if (this._sigmaVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.sigmaVar = this._sigmaVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBlur | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sigma = undefined;
      this._sigmaVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sigma = value.sigma;
      this._sigmaVar = value.sigmaVar;
    }
  }

  // sigma - computed: false, optional: true, required: false
  private _sigma?: string; 
  public get sigma() {
    return this.getStringAttribute('sigma');
  }
  public set sigma(value: string) {
    this._sigma = value;
  }
  public resetSigma() {
    this._sigma = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaInput() {
    return this._sigma;
  }

  // sigma_var - computed: false, optional: true, required: false
  private _sigmaVar?: string; 
  public get sigmaVar() {
    return this.getStringAttribute('sigma_var');
  }
  public set sigmaVar(value: string) {
    this._sigmaVar = value;
  }
  public resetSigmaVar() {
    this._sigmaVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sigmaVarInput() {
    return this._sigmaVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBlurList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBlur[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBlurOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualBlurOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualChromaKey {
  /**
  * The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue DataAkamaiImagingPolicyImage#hue}
  */
  readonly hue?: string;
  /**
  * How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_feather DataAkamaiImagingPolicyImage#hue_feather}
  */
  readonly hueFeather?: string;
  /**
  * How much additional hue to make semi-transparent beyond the Hue Tolerance. By default Hue Feather is 0.083 which applies semi-transparency to hues 30° around the Hue Tolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_feather_var DataAkamaiImagingPolicyImage#hue_feather_var}
  */
  readonly hueFeatherVar?: string;
  /**
  * How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_tolerance DataAkamaiImagingPolicyImage#hue_tolerance}
  */
  readonly hueTolerance?: string;
  /**
  * How close a color's hue needs to be to the selected hue for it to be changed to fully transparent. If you enter the maximum value of 1.0 the entire image is made transparent. By default Hue Tolerance is approximately 0.083 or 8.3% of the color wheel. This value corresponds to 30° around the specified hue.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_tolerance_var DataAkamaiImagingPolicyImage#hue_tolerance_var}
  */
  readonly hueToleranceVar?: string;
  /**
  * The hue to remove. Enter the degree of rotation between 0 and 360 degrees around the color wheel. By default Chroma Key removes a green hue, 120° on the color wheel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#hue_var DataAkamaiImagingPolicyImage#hue_var}
  */
  readonly hueVar?: string;
  /**
  * How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_feather DataAkamaiImagingPolicyImage#lightness_feather}
  */
  readonly lightnessFeather?: string;
  /**
  * How much additional lightness to make semi-transparent beyond the Lightness Tolerance. The default value of 0.1 corresponds to 10% away from the tolerated lightness towards full black or full white.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_feather_var DataAkamaiImagingPolicyImage#lightness_feather_var}
  */
  readonly lightnessFeatherVar?: string;
  /**
  * How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_tolerance DataAkamaiImagingPolicyImage#lightness_tolerance}
  */
  readonly lightnessTolerance?: string;
  /**
  * How much of the lightest part and darkest part of a color to preserve. For example, you can space this value out from the middle (i.e. 0.5 lightness or full color) to help preserve the splash lighting impact in the image. You can define how close the color needs to be to the full color to remove it from your image. The default value of 0.75 means that a colour must be within 75% of the full color to full white or full black for full removal.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#lightness_tolerance_var DataAkamaiImagingPolicyImage#lightness_tolerance_var}
  */
  readonly lightnessToleranceVar?: string;
  /**
  * How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_feather DataAkamaiImagingPolicyImage#saturation_feather}
  */
  readonly saturationFeather?: string;
  /**
  * How much additional saturation to make semi-transparent beyond the Saturation Tolerance. By default Saturation Feather is 0.1 which applies semi-transparency to hues 10% below the saturationTolerance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_feather_var DataAkamaiImagingPolicyImage#saturation_feather_var}
  */
  readonly saturationFeatherVar?: string;
  /**
  * How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_tolerance DataAkamaiImagingPolicyImage#saturation_tolerance}
  */
  readonly saturationTolerance?: string;
  /**
  * How close a color's saturation needs to be to full saturation for it to be changed to fully transparent. For example, you can define how green the color needs to be to remove it from your image. The default value of 0.75 means that a color must be within 75% of full saturation in order to be made fully transparent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#saturation_tolerance_var DataAkamaiImagingPolicyImage#saturation_tolerance_var}
  */
  readonly saturationToleranceVar?: string;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualChromaKeyToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualChromaKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hue: cdktf.stringToTerraform(struct!.hue),
    hue_feather: cdktf.stringToTerraform(struct!.hueFeather),
    hue_feather_var: cdktf.stringToTerraform(struct!.hueFeatherVar),
    hue_tolerance: cdktf.stringToTerraform(struct!.hueTolerance),
    hue_tolerance_var: cdktf.stringToTerraform(struct!.hueToleranceVar),
    hue_var: cdktf.stringToTerraform(struct!.hueVar),
    lightness_feather: cdktf.stringToTerraform(struct!.lightnessFeather),
    lightness_feather_var: cdktf.stringToTerraform(struct!.lightnessFeatherVar),
    lightness_tolerance: cdktf.stringToTerraform(struct!.lightnessTolerance),
    lightness_tolerance_var: cdktf.stringToTerraform(struct!.lightnessToleranceVar),
    saturation_feather: cdktf.stringToTerraform(struct!.saturationFeather),
    saturation_feather_var: cdktf.stringToTerraform(struct!.saturationFeatherVar),
    saturation_tolerance: cdktf.stringToTerraform(struct!.saturationTolerance),
    saturation_tolerance_var: cdktf.stringToTerraform(struct!.saturationToleranceVar),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualChromaKeyToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualChromaKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hue: {
      value: cdktf.stringToHclTerraform(struct!.hue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_feather: {
      value: cdktf.stringToHclTerraform(struct!.hueFeather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_feather_var: {
      value: cdktf.stringToHclTerraform(struct!.hueFeatherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.hueTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.hueToleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hue_var: {
      value: cdktf.stringToHclTerraform(struct!.hueVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_feather: {
      value: cdktf.stringToHclTerraform(struct!.lightnessFeather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_feather_var: {
      value: cdktf.stringToHclTerraform(struct!.lightnessFeatherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.lightnessTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lightness_tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.lightnessToleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_feather: {
      value: cdktf.stringToHclTerraform(struct!.saturationFeather),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_feather_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationFeatherVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_tolerance: {
      value: cdktf.stringToHclTerraform(struct!.saturationTolerance),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saturation_tolerance_var: {
      value: cdktf.stringToHclTerraform(struct!.saturationToleranceVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualChromaKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualChromaKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hue = this._hue;
    }
    if (this._hueFeather !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueFeather = this._hueFeather;
    }
    if (this._hueFeatherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueFeatherVar = this._hueFeatherVar;
    }
    if (this._hueTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueTolerance = this._hueTolerance;
    }
    if (this._hueToleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueToleranceVar = this._hueToleranceVar;
    }
    if (this._hueVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.hueVar = this._hueVar;
    }
    if (this._lightnessFeather !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessFeather = this._lightnessFeather;
    }
    if (this._lightnessFeatherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessFeatherVar = this._lightnessFeatherVar;
    }
    if (this._lightnessTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessTolerance = this._lightnessTolerance;
    }
    if (this._lightnessToleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.lightnessToleranceVar = this._lightnessToleranceVar;
    }
    if (this._saturationFeather !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationFeather = this._saturationFeather;
    }
    if (this._saturationFeatherVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationFeatherVar = this._saturationFeatherVar;
    }
    if (this._saturationTolerance !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationTolerance = this._saturationTolerance;
    }
    if (this._saturationToleranceVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.saturationToleranceVar = this._saturationToleranceVar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualChromaKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hue = undefined;
      this._hueFeather = undefined;
      this._hueFeatherVar = undefined;
      this._hueTolerance = undefined;
      this._hueToleranceVar = undefined;
      this._hueVar = undefined;
      this._lightnessFeather = undefined;
      this._lightnessFeatherVar = undefined;
      this._lightnessTolerance = undefined;
      this._lightnessToleranceVar = undefined;
      this._saturationFeather = undefined;
      this._saturationFeatherVar = undefined;
      this._saturationTolerance = undefined;
      this._saturationToleranceVar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hue = value.hue;
      this._hueFeather = value.hueFeather;
      this._hueFeatherVar = value.hueFeatherVar;
      this._hueTolerance = value.hueTolerance;
      this._hueToleranceVar = value.hueToleranceVar;
      this._hueVar = value.hueVar;
      this._lightnessFeather = value.lightnessFeather;
      this._lightnessFeatherVar = value.lightnessFeatherVar;
      this._lightnessTolerance = value.lightnessTolerance;
      this._lightnessToleranceVar = value.lightnessToleranceVar;
      this._saturationFeather = value.saturationFeather;
      this._saturationFeatherVar = value.saturationFeatherVar;
      this._saturationTolerance = value.saturationTolerance;
      this._saturationToleranceVar = value.saturationToleranceVar;
    }
  }

  // hue - computed: false, optional: true, required: false
  private _hue?: string; 
  public get hue() {
    return this.getStringAttribute('hue');
  }
  public set hue(value: string) {
    this._hue = value;
  }
  public resetHue() {
    this._hue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueInput() {
    return this._hue;
  }

  // hue_feather - computed: false, optional: true, required: false
  private _hueFeather?: string; 
  public get hueFeather() {
    return this.getStringAttribute('hue_feather');
  }
  public set hueFeather(value: string) {
    this._hueFeather = value;
  }
  public resetHueFeather() {
    this._hueFeather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueFeatherInput() {
    return this._hueFeather;
  }

  // hue_feather_var - computed: false, optional: true, required: false
  private _hueFeatherVar?: string; 
  public get hueFeatherVar() {
    return this.getStringAttribute('hue_feather_var');
  }
  public set hueFeatherVar(value: string) {
    this._hueFeatherVar = value;
  }
  public resetHueFeatherVar() {
    this._hueFeatherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueFeatherVarInput() {
    return this._hueFeatherVar;
  }

  // hue_tolerance - computed: false, optional: true, required: false
  private _hueTolerance?: string; 
  public get hueTolerance() {
    return this.getStringAttribute('hue_tolerance');
  }
  public set hueTolerance(value: string) {
    this._hueTolerance = value;
  }
  public resetHueTolerance() {
    this._hueTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueToleranceInput() {
    return this._hueTolerance;
  }

  // hue_tolerance_var - computed: false, optional: true, required: false
  private _hueToleranceVar?: string; 
  public get hueToleranceVar() {
    return this.getStringAttribute('hue_tolerance_var');
  }
  public set hueToleranceVar(value: string) {
    this._hueToleranceVar = value;
  }
  public resetHueToleranceVar() {
    this._hueToleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueToleranceVarInput() {
    return this._hueToleranceVar;
  }

  // hue_var - computed: false, optional: true, required: false
  private _hueVar?: string; 
  public get hueVar() {
    return this.getStringAttribute('hue_var');
  }
  public set hueVar(value: string) {
    this._hueVar = value;
  }
  public resetHueVar() {
    this._hueVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hueVarInput() {
    return this._hueVar;
  }

  // lightness_feather - computed: false, optional: true, required: false
  private _lightnessFeather?: string; 
  public get lightnessFeather() {
    return this.getStringAttribute('lightness_feather');
  }
  public set lightnessFeather(value: string) {
    this._lightnessFeather = value;
  }
  public resetLightnessFeather() {
    this._lightnessFeather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessFeatherInput() {
    return this._lightnessFeather;
  }

  // lightness_feather_var - computed: false, optional: true, required: false
  private _lightnessFeatherVar?: string; 
  public get lightnessFeatherVar() {
    return this.getStringAttribute('lightness_feather_var');
  }
  public set lightnessFeatherVar(value: string) {
    this._lightnessFeatherVar = value;
  }
  public resetLightnessFeatherVar() {
    this._lightnessFeatherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessFeatherVarInput() {
    return this._lightnessFeatherVar;
  }

  // lightness_tolerance - computed: false, optional: true, required: false
  private _lightnessTolerance?: string; 
  public get lightnessTolerance() {
    return this.getStringAttribute('lightness_tolerance');
  }
  public set lightnessTolerance(value: string) {
    this._lightnessTolerance = value;
  }
  public resetLightnessTolerance() {
    this._lightnessTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessToleranceInput() {
    return this._lightnessTolerance;
  }

  // lightness_tolerance_var - computed: false, optional: true, required: false
  private _lightnessToleranceVar?: string; 
  public get lightnessToleranceVar() {
    return this.getStringAttribute('lightness_tolerance_var');
  }
  public set lightnessToleranceVar(value: string) {
    this._lightnessToleranceVar = value;
  }
  public resetLightnessToleranceVar() {
    this._lightnessToleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lightnessToleranceVarInput() {
    return this._lightnessToleranceVar;
  }

  // saturation_feather - computed: false, optional: true, required: false
  private _saturationFeather?: string; 
  public get saturationFeather() {
    return this.getStringAttribute('saturation_feather');
  }
  public set saturationFeather(value: string) {
    this._saturationFeather = value;
  }
  public resetSaturationFeather() {
    this._saturationFeather = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationFeatherInput() {
    return this._saturationFeather;
  }

  // saturation_feather_var - computed: false, optional: true, required: false
  private _saturationFeatherVar?: string; 
  public get saturationFeatherVar() {
    return this.getStringAttribute('saturation_feather_var');
  }
  public set saturationFeatherVar(value: string) {
    this._saturationFeatherVar = value;
  }
  public resetSaturationFeatherVar() {
    this._saturationFeatherVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationFeatherVarInput() {
    return this._saturationFeatherVar;
  }

  // saturation_tolerance - computed: false, optional: true, required: false
  private _saturationTolerance?: string; 
  public get saturationTolerance() {
    return this.getStringAttribute('saturation_tolerance');
  }
  public set saturationTolerance(value: string) {
    this._saturationTolerance = value;
  }
  public resetSaturationTolerance() {
    this._saturationTolerance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationToleranceInput() {
    return this._saturationTolerance;
  }

  // saturation_tolerance_var - computed: false, optional: true, required: false
  private _saturationToleranceVar?: string; 
  public get saturationToleranceVar() {
    return this.getStringAttribute('saturation_tolerance_var');
  }
  public set saturationToleranceVar(value: string) {
    this._saturationToleranceVar = value;
  }
  public resetSaturationToleranceVar() {
    this._saturationToleranceVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saturationToleranceVarInput() {
    return this._saturationToleranceVar;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualChromaKeyList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualChromaKey[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualChromaKeyOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualChromaKeyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformation {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformationToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformationOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformationToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformationOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformation | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformation | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImage {
  /**
  * The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color DataAkamaiImagingPolicyImage#color}
  */
  readonly color?: string;
  /**
  * The fill color of the box, not the edge of the box. The API supports hexadecimal representation and CSS hexadecimal color values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color_var DataAkamaiImagingPolicyImage#color_var}
  */
  readonly colorVar?: string;
  /**
  * The height of the box in pixels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#height DataAkamaiImagingPolicyImage#height}
  */
  readonly height?: string;
  /**
  * The height of the box in pixels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#height_var DataAkamaiImagingPolicyImage#height_var}
  */
  readonly heightVar?: string;
  /**
  * The width of the box in pixels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#width DataAkamaiImagingPolicyImage#width}
  */
  readonly width?: string;
  /**
  * The width of the box in pixels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#width_var DataAkamaiImagingPolicyImage#width_var}
  */
  readonly widthVar?: string;
  /**
  * transformation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#transformation DataAkamaiImagingPolicyImage#transformation}
  */
  readonly transformation?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformation;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    color: cdktf.stringToTerraform(struct!.color),
    color_var: cdktf.stringToTerraform(struct!.colorVar),
    height: cdktf.stringToTerraform(struct!.height),
    height_var: cdktf.stringToTerraform(struct!.heightVar),
    width: cdktf.stringToTerraform(struct!.width),
    width_var: cdktf.stringToTerraform(struct!.widthVar),
    transformation: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformationToTerraform(struct!.transformation),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    color_var: {
      value: cdktf.stringToHclTerraform(struct!.colorVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    height: {
      value: cdktf.stringToHclTerraform(struct!.height),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    height_var: {
      value: cdktf.stringToHclTerraform(struct!.heightVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    width: {
      value: cdktf.stringToHclTerraform(struct!.width),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    width_var: {
      value: cdktf.stringToHclTerraform(struct!.widthVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    transformation: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformationToHclTerraform(struct!.transformation),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformationList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._colorVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorVar = this._colorVar;
    }
    if (this._height !== undefined) {
      hasAnyValues = true;
      internalValueResult.height = this._height;
    }
    if (this._heightVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.heightVar = this._heightVar;
    }
    if (this._width !== undefined) {
      hasAnyValues = true;
      internalValueResult.width = this._width;
    }
    if (this._widthVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.widthVar = this._widthVar;
    }
    if (this._transformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformation = this._transformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._color = undefined;
      this._colorVar = undefined;
      this._height = undefined;
      this._heightVar = undefined;
      this._width = undefined;
      this._widthVar = undefined;
      this._transformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._color = value.color;
      this._colorVar = value.colorVar;
      this._height = value.height;
      this._heightVar = value.heightVar;
      this._width = value.width;
      this._widthVar = value.widthVar;
      this._transformation.internalValue = value.transformation;
    }
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // color_var - computed: false, optional: true, required: false
  private _colorVar?: string; 
  public get colorVar() {
    return this.getStringAttribute('color_var');
  }
  public set colorVar(value: string) {
    this._colorVar = value;
  }
  public resetColorVar() {
    this._colorVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorVarInput() {
    return this._colorVar;
  }

  // height - computed: false, optional: true, required: false
  private _height?: string; 
  public get height() {
    return this.getStringAttribute('height');
  }
  public set height(value: string) {
    this._height = value;
  }
  public resetHeight() {
    this._height = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get heightInput() {
    return this._height;
  }

  // height_var - computed: false, optional: true, required: false
  private _heightVar?: string; 
  public get heightVar() {
    return this.getStringAttribute('height_var');
  }
  public set heightVar(value: string) {
    this._heightVar = value;
  }
  public resetHeightVar() {
    this._heightVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get heightVarInput() {
    return this._heightVar;
  }

  // width - computed: false, optional: true, required: false
  private _width?: string; 
  public get width() {
    return this.getStringAttribute('width');
  }
  public set width(value: string) {
    this._width = value;
  }
  public resetWidth() {
    this._width = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get widthInput() {
    return this._width;
  }

  // width_var - computed: false, optional: true, required: false
  private _widthVar?: string; 
  public get widthVar() {
    return this.getStringAttribute('width_var');
  }
  public set widthVar(value: string) {
    this._widthVar = value;
  }
  public resetWidthVar() {
    this._widthVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get widthVarInput() {
    return this._widthVar;
  }

  // transformation - computed: false, optional: true, required: false
  private _transformation = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformationOutputReference(this, "transformation");
  public get transformation() {
    return this._transformation;
  }
  public putTransformation(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageTransformation) {
    this._transformation.internalValue = value;
  }
  public resetTransformation() {
    this._transformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationInput() {
    return this._transformation.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImage[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageBoxImageOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformation {
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformationToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformationOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformationToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformationOutputReference | DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformation | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformation | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }
}
export interface DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImage {
  /**
  * The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color DataAkamaiImagingPolicyImage#color}
  */
  readonly color?: string;
  /**
  * The fill color of the circle. The API supports hexadecimal representation and CSS hexadecimal color values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#color_var DataAkamaiImagingPolicyImage#color_var}
  */
  readonly colorVar?: string;
  /**
  * The diameter of the circle. The diameter will be the width and the height of the image in pixels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#diameter DataAkamaiImagingPolicyImage#diameter}
  */
  readonly diameter?: string;
  /**
  * The diameter of the circle. The diameter will be the width and the height of the image in pixels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#diameter_var DataAkamaiImagingPolicyImage#diameter_var}
  */
  readonly diameterVar?: string;
  /**
  * The width of the box in pixels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#width DataAkamaiImagingPolicyImage#width}
  */
  readonly width?: string;
  /**
  * The width of the box in pixels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#width_var DataAkamaiImagingPolicyImage#width_var}
  */
  readonly widthVar?: string;
  /**
  * transformation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/akamai/akamai/9.1.0/docs/data-sources/imaging_policy_image#transformation DataAkamaiImagingPolicyImage#transformation}
  */
  readonly transformation?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformation;
}

export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageToTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    color: cdktf.stringToTerraform(struct!.color),
    color_var: cdktf.stringToTerraform(struct!.colorVar),
    diameter: cdktf.stringToTerraform(struct!.diameter),
    diameter_var: cdktf.stringToTerraform(struct!.diameterVar),
    width: cdktf.stringToTerraform(struct!.width),
    width_var: cdktf.stringToTerraform(struct!.widthVar),
    transformation: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformationToTerraform(struct!.transformation),
  }
}


export function dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageToHclTerraform(struct?: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    color: {
      value: cdktf.stringToHclTerraform(struct!.color),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    color_var: {
      value: cdktf.stringToHclTerraform(struct!.colorVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    diameter: {
      value: cdktf.stringToHclTerraform(struct!.diameter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    diameter_var: {
      value: cdktf.stringToHclTerraform(struct!.diameterVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    width: {
      value: cdktf.stringToHclTerraform(struct!.width),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    width_var: {
      value: cdktf.stringToHclTerraform(struct!.widthVar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    transformation: {
      value: dataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformationToHclTerraform(struct!.transformation),
      isBlock: true,
      type: "list",
      storageClassType: "DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformationList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._color !== undefined) {
      hasAnyValues = true;
      internalValueResult.color = this._color;
    }
    if (this._colorVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.colorVar = this._colorVar;
    }
    if (this._diameter !== undefined) {
      hasAnyValues = true;
      internalValueResult.diameter = this._diameter;
    }
    if (this._diameterVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.diameterVar = this._diameterVar;
    }
    if (this._width !== undefined) {
      hasAnyValues = true;
      internalValueResult.width = this._width;
    }
    if (this._widthVar !== undefined) {
      hasAnyValues = true;
      internalValueResult.widthVar = this._widthVar;
    }
    if (this._transformation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformation = this._transformation?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._color = undefined;
      this._colorVar = undefined;
      this._diameter = undefined;
      this._diameterVar = undefined;
      this._width = undefined;
      this._widthVar = undefined;
      this._transformation.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._color = value.color;
      this._colorVar = value.colorVar;
      this._diameter = value.diameter;
      this._diameterVar = value.diameterVar;
      this._width = value.width;
      this._widthVar = value.widthVar;
      this._transformation.internalValue = value.transformation;
    }
  }

  // color - computed: false, optional: true, required: false
  private _color?: string; 
  public get color() {
    return this.getStringAttribute('color');
  }
  public set color(value: string) {
    this._color = value;
  }
  public resetColor() {
    this._color = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorInput() {
    return this._color;
  }

  // color_var - computed: false, optional: true, required: false
  private _colorVar?: string; 
  public get colorVar() {
    return this.getStringAttribute('color_var');
  }
  public set colorVar(value: string) {
    this._colorVar = value;
  }
  public resetColorVar() {
    this._colorVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get colorVarInput() {
    return this._colorVar;
  }

  // diameter - computed: false, optional: true, required: false
  private _diameter?: string; 
  public get diameter() {
    return this.getStringAttribute('diameter');
  }
  public set diameter(value: string) {
    this._diameter = value;
  }
  public resetDiameter() {
    this._diameter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diameterInput() {
    return this._diameter;
  }

  // diameter_var - computed: false, optional: true, required: false
  private _diameterVar?: string; 
  public get diameterVar() {
    return this.getStringAttribute('diameter_var');
  }
  public set diameterVar(value: string) {
    this._diameterVar = value;
  }
  public resetDiameterVar() {
    this._diameterVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diameterVarInput() {
    return this._diameterVar;
  }

  // width - computed: false, optional: true, required: false
  private _width?: string; 
  public get width() {
    return this.getStringAttribute('width');
  }
  public set width(value: string) {
    this._width = value;
  }
  public resetWidth() {
    this._width = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get widthInput() {
    return this._width;
  }

  // width_var - computed: false, optional: true, required: false
  private _widthVar?: string; 
  public get widthVar() {
    return this.getStringAttribute('width_var');
  }
  public set widthVar(value: string) {
    this._widthVar = value;
  }
  public resetWidthVar() {
    this._widthVar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get widthVarInput() {
    return this._widthVar;
  }

  // transformation - computed: false, optional: true, required: false
  private _transformation = new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformationOutputReference(this, "transformation");
  public get transformation() {
    return this._transformation;
  }
  public putTransformation(value: DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageTransformation) {
    this._transformation.internalValue = value;
  }
  public resetTransformation() {
    this._transformation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationInput() {
    return this._transformation.internalValue;
  }
}

export class DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageList extends cdktf.ComplexList {
  public internalValue? : DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImage[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageOutputReference {
    return new DataAkamaiImagingPolicyImagePolicyPostBreakpointTransformationsIfDimensionEqualCompositeImageCircleImageOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
