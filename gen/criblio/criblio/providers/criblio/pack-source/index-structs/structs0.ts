import * as cdktf from 'cdktf';
export interface PackSourceInputAppscopeConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputAppscopeConnectionsToTerraform(struct?: PackSourceInputAppscopeConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputAppscopeConnectionsToHclTerraform(struct?: PackSourceInputAppscopeConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAppscopeConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputAppscopeConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAppscopeConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputAppscopeConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputAppscopeConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputAppscopeConnectionsOutputReference {
    return new PackSourceInputAppscopeConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputAppscopeFilterAllow {
  /**
  * Specify a string to substring-match against process command-line.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#arg PackSource#arg}
  */
  readonly arg?: string;
  /**
  * Choose a config to apply to processes that match the process name and/or argument.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#config PackSource#config}
  */
  readonly config: string;
  /**
  * Specify the name of a process or family of processes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#procname PackSource#procname}
  */
  readonly procname: string;
}

export function packSourceInputAppscopeFilterAllowToTerraform(struct?: PackSourceInputAppscopeFilterAllow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    arg: cdktf.stringToTerraform(struct!.arg),
    config: cdktf.stringToTerraform(struct!.config),
    procname: cdktf.stringToTerraform(struct!.procname),
  }
}


export function packSourceInputAppscopeFilterAllowToHclTerraform(struct?: PackSourceInputAppscopeFilterAllow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    arg: {
      value: cdktf.stringToHclTerraform(struct!.arg),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    config: {
      value: cdktf.stringToHclTerraform(struct!.config),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    procname: {
      value: cdktf.stringToHclTerraform(struct!.procname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAppscopeFilterAllowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputAppscopeFilterAllow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._arg !== undefined) {
      hasAnyValues = true;
      internalValueResult.arg = this._arg;
    }
    if (this._config !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config;
    }
    if (this._procname !== undefined) {
      hasAnyValues = true;
      internalValueResult.procname = this._procname;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAppscopeFilterAllow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._arg = undefined;
      this._config = undefined;
      this._procname = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._arg = value.arg;
      this._config = value.config;
      this._procname = value.procname;
    }
  }

  // arg - computed: false, optional: true, required: false
  private _arg?: string; 
  public get arg() {
    return this.getStringAttribute('arg');
  }
  public set arg(value: string) {
    this._arg = value;
  }
  public resetArg() {
    this._arg = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argInput() {
    return this._arg;
  }

  // config - computed: false, optional: false, required: true
  private _config?: string; 
  public get config() {
    return this.getStringAttribute('config');
  }
  public set config(value: string) {
    this._config = value;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config;
  }

  // procname - computed: false, optional: false, required: true
  private _procname?: string; 
  public get procname() {
    return this.getStringAttribute('procname');
  }
  public set procname(value: string) {
    this._procname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get procnameInput() {
    return this._procname;
  }
}

export class PackSourceInputAppscopeFilterAllowList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputAppscopeFilterAllow[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputAppscopeFilterAllowOutputReference {
    return new PackSourceInputAppscopeFilterAllowOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputAppscopeFilter {
  /**
  * Specify processes that AppScope should be loaded into, and the config to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#allow PackSource#allow}
  */
  readonly allow?: PackSourceInputAppscopeFilterAllow[] | cdktf.IResolvable;
  /**
  * To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#transport_url PackSource#transport_url}
  */
  readonly transportUrl?: string;
}

export function packSourceInputAppscopeFilterToTerraform(struct?: PackSourceInputAppscopeFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow: cdktf.listMapper(packSourceInputAppscopeFilterAllowToTerraform, false)(struct!.allow),
    transport_url: cdktf.stringToTerraform(struct!.transportUrl),
  }
}


export function packSourceInputAppscopeFilterToHclTerraform(struct?: PackSourceInputAppscopeFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow: {
      value: cdktf.listMapperHcl(packSourceInputAppscopeFilterAllowToHclTerraform, false)(struct!.allow),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputAppscopeFilterAllowList",
    },
    transport_url: {
      value: cdktf.stringToHclTerraform(struct!.transportUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAppscopeFilterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputAppscopeFilter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allow?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allow = this._allow?.internalValue;
    }
    if (this._transportUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.transportUrl = this._transportUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAppscopeFilter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allow.internalValue = undefined;
      this._transportUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allow.internalValue = value.allow;
      this._transportUrl = value.transportUrl;
    }
  }

  // allow - computed: false, optional: true, required: false
  private _allow = new PackSourceInputAppscopeFilterAllowList(this, "allow", false);
  public get allow() {
    return this._allow;
  }
  public putAllow(value: PackSourceInputAppscopeFilterAllow[] | cdktf.IResolvable) {
    this._allow.internalValue = value;
  }
  public resetAllow() {
    this._allow.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInput() {
    return this._allow.internalValue;
  }

  // transport_url - computed: false, optional: true, required: false
  private _transportUrl?: string; 
  public get transportUrl() {
    return this.getStringAttribute('transport_url');
  }
  public set transportUrl(value: string) {
    this._transportUrl = value;
  }
  public resetTransportUrl() {
    this._transportUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transportUrlInput() {
    return this._transportUrl;
  }
}
export interface PackSourceInputAppscopeMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputAppscopeMetadataToTerraform(struct?: PackSourceInputAppscopeMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputAppscopeMetadataToHclTerraform(struct?: PackSourceInputAppscopeMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAppscopeMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputAppscopeMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAppscopeMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputAppscopeMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputAppscopeMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputAppscopeMetadataOutputReference {
    return new PackSourceInputAppscopeMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputAppscopePersistence {
  /**
  * Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * Path to use to write metrics. Defaults to $CRIBL_HOME/state/appscope. Default: "$CRIBL_HOME/state/appscope"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#dest_path PackSource#dest_path}
  */
  readonly destPath?: string;
  /**
  * Spool events and metrics on disk for Cribl Edge and Search. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_size PackSource#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_time PackSource#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * Time span for each file bucket. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#time_window PackSource#time_window}
  */
  readonly timeWindow?: string;
}

export function packSourceInputAppscopePersistenceToTerraform(struct?: PackSourceInputAppscopePersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
  }
}


export function packSourceInputAppscopePersistenceToHclTerraform(struct?: PackSourceInputAppscopePersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAppscopePersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputAppscopePersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAppscopePersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._destPath = undefined;
      this._enable = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._timeWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._destPath = value.destPath;
      this._enable = value.enable;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._timeWindow = value.timeWindow;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }
}
export interface PackSourceInputAppscopePq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputAppscopePqToTerraform(struct?: PackSourceInputAppscopePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputAppscopePqToHclTerraform(struct?: PackSourceInputAppscopePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAppscopePqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputAppscopePq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAppscopePq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputAppscopeTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputAppscopeTlsToTerraform(struct?: PackSourceInputAppscopeTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputAppscopeTlsToHclTerraform(struct?: PackSourceInputAppscopeTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAppscopeTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputAppscopeTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAppscopeTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputAppscope {
  /**
  * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_token PackSource#auth_token}
  */
  readonly authToken?: string;
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputAppscopeConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_unix_path PackSource#enable_unix_path}
  */
  readonly enableUnixPath?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#filter PackSource#filter}
  */
  readonly filter?: PackSourceInputAppscopeFilter;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Regex matching IP addresses that are allowed to establish a connection. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_whitelist_regex PackSource#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_cxn PackSource#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputAppscopeMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#persistence PackSource#persistence}
  */
  readonly persistence?: PackSourceInputAppscopePersistence;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputAppscopePq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_ending_max_wait PackSource#socket_ending_max_wait}
  */
  readonly socketEndingMaxWait?: number;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_idle_timeout PackSource#socket_idle_timeout}
  */
  readonly socketIdleTimeout?: number;
  /**
  * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_max_lifespan PackSource#socket_max_lifespan}
  */
  readonly socketMaxLifespan?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputAppscopeTls;
  /**
  * must be "appscope"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
  /**
  * Path to the UNIX domain socket to listen on. Default: "$CRIBL_HOME/state/appscope.sock"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#unix_socket_path PackSource#unix_socket_path}
  */
  readonly unixSocketPath?: string;
  /**
  * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#unix_socket_perms PackSource#unix_socket_perms}
  */
  readonly unixSocketPerms?: string;
}

export function packSourceInputAppscopeToTerraform(struct?: PackSourceInputAppscope | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: cdktf.stringToTerraform(struct!.authToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    connections: cdktf.listMapper(packSourceInputAppscopeConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    enable_unix_path: cdktf.booleanToTerraform(struct!.enableUnixPath),
    environment: cdktf.stringToTerraform(struct!.environment),
    filter: packSourceInputAppscopeFilterToTerraform(struct!.filter),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    metadata: cdktf.listMapper(packSourceInputAppscopeMetadataToTerraform, false)(struct!.metadata),
    persistence: packSourceInputAppscopePersistenceToTerraform(struct!.persistence),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputAppscopePqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_ending_max_wait: cdktf.numberToTerraform(struct!.socketEndingMaxWait),
    socket_idle_timeout: cdktf.numberToTerraform(struct!.socketIdleTimeout),
    socket_max_lifespan: cdktf.numberToTerraform(struct!.socketMaxLifespan),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    tls: packSourceInputAppscopeTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    unix_socket_path: cdktf.stringToTerraform(struct!.unixSocketPath),
    unix_socket_perms: cdktf.stringToTerraform(struct!.unixSocketPerms),
  }
}


export function packSourceInputAppscopeToHclTerraform(struct?: PackSourceInputAppscope | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: cdktf.stringToHclTerraform(struct!.authToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputAppscopeConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputAppscopeConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_unix_path: {
      value: cdktf.booleanToHclTerraform(struct!.enableUnixPath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: packSourceInputAppscopeFilterToHclTerraform(struct!.filter),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputAppscopeFilter",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputAppscopeMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputAppscopeMetadataList",
    },
    persistence: {
      value: packSourceInputAppscopePersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputAppscopePersistence",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputAppscopePqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputAppscopePq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_ending_max_wait: {
      value: cdktf.numberToHclTerraform(struct!.socketEndingMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_max_lifespan: {
      value: cdktf.numberToHclTerraform(struct!.socketMaxLifespan),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packSourceInputAppscopeTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputAppscopeTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    unix_socket_path: {
      value: cdktf.stringToHclTerraform(struct!.unixSocketPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    unix_socket_perms: {
      value: cdktf.stringToHclTerraform(struct!.unixSocketPerms),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAppscopeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputAppscope | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._enableUnixPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableUnixPath = this._enableUnixPath;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._filter?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter?.internalValue;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketEndingMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketEndingMaxWait = this._socketEndingMaxWait;
    }
    if (this._socketIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketIdleTimeout = this._socketIdleTimeout;
    }
    if (this._socketMaxLifespan !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketMaxLifespan = this._socketMaxLifespan;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._unixSocketPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.unixSocketPath = this._unixSocketPath;
    }
    if (this._unixSocketPerms !== undefined) {
      hasAnyValues = true;
      internalValueResult.unixSocketPerms = this._unixSocketPerms;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAppscope | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken = undefined;
      this._authType = undefined;
      this._breakerRulesets = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableProxyHeader = undefined;
      this._enableUnixPath = undefined;
      this._environment = undefined;
      this._filter.internalValue = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxActiveCxn = undefined;
      this._metadata.internalValue = undefined;
      this._persistence.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._socketEndingMaxWait = undefined;
      this._socketIdleTimeout = undefined;
      this._socketMaxLifespan = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._unixSocketPath = undefined;
      this._unixSocketPerms = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken = value.authToken;
      this._authType = value.authType;
      this._breakerRulesets = value.breakerRulesets;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableProxyHeader = value.enableProxyHeader;
      this._enableUnixPath = value.enableUnixPath;
      this._environment = value.environment;
      this._filter.internalValue = value.filter;
      this._host = value.host;
      this._id = value.id;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxActiveCxn = value.maxActiveCxn;
      this._metadata.internalValue = value.metadata;
      this._persistence.internalValue = value.persistence;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._socketEndingMaxWait = value.socketEndingMaxWait;
      this._socketIdleTimeout = value.socketIdleTimeout;
      this._socketMaxLifespan = value.socketMaxLifespan;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._unixSocketPath = value.unixSocketPath;
      this._unixSocketPerms = value.unixSocketPerms;
    }
  }

  // auth_token - computed: true, optional: true, required: false
  private _authToken?: string; 
  public get authToken() {
    return this.getStringAttribute('auth_token');
  }
  public set authToken(value: string) {
    this._authToken = value;
  }
  public resetAuthToken() {
    this._authToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputAppscopeConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputAppscopeConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // enable_unix_path - computed: true, optional: true, required: false
  private _enableUnixPath?: boolean | cdktf.IResolvable; 
  public get enableUnixPath() {
    return this.getBooleanAttribute('enable_unix_path');
  }
  public set enableUnixPath(value: boolean | cdktf.IResolvable) {
    this._enableUnixPath = value;
  }
  public resetEnableUnixPath() {
    this._enableUnixPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableUnixPathInput() {
    return this._enableUnixPath;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // filter - computed: false, optional: true, required: false
  private _filter = new PackSourceInputAppscopeFilterOutputReference(this, "filter");
  public get filter() {
    return this._filter;
  }
  public putFilter(value: PackSourceInputAppscopeFilter) {
    this._filter.internalValue = value;
  }
  public resetFilter() {
    this._filter.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter.internalValue;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputAppscopeMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputAppscopeMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // persistence - computed: false, optional: true, required: false
  private _persistence = new PackSourceInputAppscopePersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: PackSourceInputAppscopePersistence) {
    this._persistence.internalValue = value;
  }
  public resetPersistence() {
    this._persistence.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputAppscopePqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputAppscopePq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_ending_max_wait - computed: true, optional: true, required: false
  private _socketEndingMaxWait?: number; 
  public get socketEndingMaxWait() {
    return this.getNumberAttribute('socket_ending_max_wait');
  }
  public set socketEndingMaxWait(value: number) {
    this._socketEndingMaxWait = value;
  }
  public resetSocketEndingMaxWait() {
    this._socketEndingMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketEndingMaxWaitInput() {
    return this._socketEndingMaxWait;
  }

  // socket_idle_timeout - computed: true, optional: true, required: false
  private _socketIdleTimeout?: number; 
  public get socketIdleTimeout() {
    return this.getNumberAttribute('socket_idle_timeout');
  }
  public set socketIdleTimeout(value: number) {
    this._socketIdleTimeout = value;
  }
  public resetSocketIdleTimeout() {
    this._socketIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketIdleTimeoutInput() {
    return this._socketIdleTimeout;
  }

  // socket_max_lifespan - computed: true, optional: true, required: false
  private _socketMaxLifespan?: number; 
  public get socketMaxLifespan() {
    return this.getNumberAttribute('socket_max_lifespan');
  }
  public set socketMaxLifespan(value: number) {
    this._socketMaxLifespan = value;
  }
  public resetSocketMaxLifespan() {
    this._socketMaxLifespan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketMaxLifespanInput() {
    return this._socketMaxLifespan;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputAppscopeTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputAppscopeTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // unix_socket_path - computed: true, optional: true, required: false
  private _unixSocketPath?: string; 
  public get unixSocketPath() {
    return this.getStringAttribute('unix_socket_path');
  }
  public set unixSocketPath(value: string) {
    this._unixSocketPath = value;
  }
  public resetUnixSocketPath() {
    this._unixSocketPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixSocketPathInput() {
    return this._unixSocketPath;
  }

  // unix_socket_perms - computed: false, optional: true, required: false
  private _unixSocketPerms?: string; 
  public get unixSocketPerms() {
    return this.getStringAttribute('unix_socket_perms');
  }
  public set unixSocketPerms(value: string) {
    this._unixSocketPerms = value;
  }
  public resetUnixSocketPerms() {
    this._unixSocketPerms = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixSocketPermsInput() {
    return this._unixSocketPerms;
  }
}
export interface PackSourceInputAzureBlobCertificate {
  /**
  * The certificate you registered as credentials for your app in the Azure portal
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName: string;
}

export function packSourceInputAzureBlobCertificateToTerraform(struct?: PackSourceInputAzureBlobCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
  }
}


export function packSourceInputAzureBlobCertificateToHclTerraform(struct?: PackSourceInputAzureBlobCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAzureBlobCertificateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputAzureBlobCertificate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAzureBlobCertificate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certificateName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certificateName = value.certificateName;
    }
  }

  // certificate_name - computed: false, optional: false, required: true
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }
}
export interface PackSourceInputAzureBlobConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputAzureBlobConnectionsToTerraform(struct?: PackSourceInputAzureBlobConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputAzureBlobConnectionsToHclTerraform(struct?: PackSourceInputAzureBlobConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAzureBlobConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputAzureBlobConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAzureBlobConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputAzureBlobConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputAzureBlobConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputAzureBlobConnectionsOutputReference {
    return new PackSourceInputAzureBlobConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputAzureBlobMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputAzureBlobMetadataToTerraform(struct?: PackSourceInputAzureBlobMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputAzureBlobMetadataToHclTerraform(struct?: PackSourceInputAzureBlobMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAzureBlobMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputAzureBlobMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAzureBlobMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputAzureBlobMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputAzureBlobMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputAzureBlobMetadataOutputReference {
    return new PackSourceInputAzureBlobMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputAzureBlobPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputAzureBlobPqToTerraform(struct?: PackSourceInputAzureBlobPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputAzureBlobPqToHclTerraform(struct?: PackSourceInputAzureBlobPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAzureBlobPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputAzureBlobPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAzureBlobPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputAzureBlob {
  /**
  * Default: "manual"; must be one of ["manual", "secret", "clientSecret", "clientCert"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * The Azure cloud to use. Defaults to Azure Public Cloud.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#azure_cloud PackSource#azure_cloud}
  */
  readonly azureCloud?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate PackSource#certificate}
  */
  readonly certificate?: PackSourceInputAzureBlobCertificate;
  /**
  * The service principal's client ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#client_id PackSource#client_id}
  */
  readonly clientId?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#client_text_secret PackSource#client_text_secret}
  */
  readonly clientTextSecret?: string;
  /**
  * Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connection_string PackSource#connection_string}
  */
  readonly connectionString?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputAzureBlobConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint_suffix PackSource#endpoint_suffix}
  */
  readonly endpointSuffix?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Regex matching file names to download and process. Defaults to: .*. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#file_filter PackSource#file_filter}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly fileFilter?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_messages PackSource#max_messages}
  */
  readonly maxMessages?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputAzureBlobMetadata[] | cdktf.IResolvable;
  /**
  * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#num_receivers PackSource#num_receivers}
  */
  readonly numReceivers?: number;
  /**
  * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#parquet_chunk_download_timeout PackSource#parquet_chunk_download_timeout}
  */
  readonly parquetChunkDownloadTimeout?: number;
  /**
  * Maximum file size for each Parquet chunk. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#parquet_chunk_size_mb PackSource#parquet_chunk_size_mb}
  */
  readonly parquetChunkSizeMb?: number;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputAzureBlobPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#queue_name PackSource#queue_name}
  */
  readonly queueName: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * The duration (in seconds) which pollers should be validated and restarted if exited. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#service_period_secs PackSource#service_period_secs}
  */
  readonly servicePeriodSecs?: number;
  /**
  * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#skip_on_error PackSource#skip_on_error}
  */
  readonly skipOnError?: boolean | cdktf.IResolvable;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * The name of your Azure storage account
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#storage_account_name PackSource#storage_account_name}
  */
  readonly storageAccountName?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * The service principal's tenant ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tenant_id PackSource#tenant_id}
  */
  readonly tenantId?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * must be "azure_blob"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
  /**
  * The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#visibility_timeout PackSource#visibility_timeout}
  */
  readonly visibilityTimeout?: number;
}

export function packSourceInputAzureBlobToTerraform(struct?: PackSourceInputAzureBlob | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    azure_cloud: cdktf.stringToTerraform(struct!.azureCloud),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    certificate: packSourceInputAzureBlobCertificateToTerraform(struct!.certificate),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_text_secret: cdktf.stringToTerraform(struct!.clientTextSecret),
    connection_string: cdktf.stringToTerraform(struct!.connectionString),
    connections: cdktf.listMapper(packSourceInputAzureBlobConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    endpoint_suffix: cdktf.stringToTerraform(struct!.endpointSuffix),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_filter: cdktf.stringToTerraform(struct!.fileFilter),
    id: cdktf.stringToTerraform(struct!.id),
    max_messages: cdktf.numberToTerraform(struct!.maxMessages),
    metadata: cdktf.listMapper(packSourceInputAzureBlobMetadataToTerraform, false)(struct!.metadata),
    num_receivers: cdktf.numberToTerraform(struct!.numReceivers),
    parquet_chunk_download_timeout: cdktf.numberToTerraform(struct!.parquetChunkDownloadTimeout),
    parquet_chunk_size_mb: cdktf.numberToTerraform(struct!.parquetChunkSizeMb),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputAzureBlobPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    service_period_secs: cdktf.numberToTerraform(struct!.servicePeriodSecs),
    skip_on_error: cdktf.booleanToTerraform(struct!.skipOnError),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    storage_account_name: cdktf.stringToTerraform(struct!.storageAccountName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    type: cdktf.stringToTerraform(struct!.type),
    visibility_timeout: cdktf.numberToTerraform(struct!.visibilityTimeout),
  }
}


export function packSourceInputAzureBlobToHclTerraform(struct?: PackSourceInputAzureBlob | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    azure_cloud: {
      value: cdktf.stringToHclTerraform(struct!.azureCloud),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    certificate: {
      value: packSourceInputAzureBlobCertificateToHclTerraform(struct!.certificate),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputAzureBlobCertificate",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_text_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientTextSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_string: {
      value: cdktf.stringToHclTerraform(struct!.connectionString),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputAzureBlobConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputAzureBlobConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint_suffix: {
      value: cdktf.stringToHclTerraform(struct!.endpointSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_filter: {
      value: cdktf.stringToHclTerraform(struct!.fileFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_messages: {
      value: cdktf.numberToHclTerraform(struct!.maxMessages),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputAzureBlobMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputAzureBlobMetadataList",
    },
    num_receivers: {
      value: cdktf.numberToHclTerraform(struct!.numReceivers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_download_timeout: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkDownloadTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputAzureBlobPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputAzureBlobPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    service_period_secs: {
      value: cdktf.numberToHclTerraform(struct!.servicePeriodSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    skip_on_error: {
      value: cdktf.booleanToHclTerraform(struct!.skipOnError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    storage_account_name: {
      value: cdktf.stringToHclTerraform(struct!.storageAccountName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    visibility_timeout: {
      value: cdktf.numberToHclTerraform(struct!.visibilityTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputAzureBlobOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputAzureBlob | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._azureCloud !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureCloud = this._azureCloud;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._certificate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificate = this._certificate?.internalValue;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientTextSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientTextSecret = this._clientTextSecret;
    }
    if (this._connectionString !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionString = this._connectionString;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._endpointSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointSuffix = this._endpointSuffix;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileFilter = this._fileFilter;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxMessages !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMessages = this._maxMessages;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._numReceivers !== undefined) {
      hasAnyValues = true;
      internalValueResult.numReceivers = this._numReceivers;
    }
    if (this._parquetChunkDownloadTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkDownloadTimeout = this._parquetChunkDownloadTimeout;
    }
    if (this._parquetChunkSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkSizeMb = this._parquetChunkSizeMb;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._servicePeriodSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.servicePeriodSecs = this._servicePeriodSecs;
    }
    if (this._skipOnError !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipOnError = this._skipOnError;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._storageAccountName !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageAccountName = this._storageAccountName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._visibilityTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibilityTimeout = this._visibilityTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputAzureBlob | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._azureCloud = undefined;
      this._breakerRulesets = undefined;
      this._certificate.internalValue = undefined;
      this._clientId = undefined;
      this._clientTextSecret = undefined;
      this._connectionString = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._endpointSuffix = undefined;
      this._environment = undefined;
      this._fileFilter = undefined;
      this._id = undefined;
      this._maxMessages = undefined;
      this._metadata.internalValue = undefined;
      this._numReceivers = undefined;
      this._parquetChunkDownloadTimeout = undefined;
      this._parquetChunkSizeMb = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._queueName = undefined;
      this._sendToRoutes = undefined;
      this._servicePeriodSecs = undefined;
      this._skipOnError = undefined;
      this._staleChannelFlushMs = undefined;
      this._storageAccountName = undefined;
      this._streamtags = undefined;
      this._tenantId = undefined;
      this._textSecret = undefined;
      this._type = undefined;
      this._visibilityTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._azureCloud = value.azureCloud;
      this._breakerRulesets = value.breakerRulesets;
      this._certificate.internalValue = value.certificate;
      this._clientId = value.clientId;
      this._clientTextSecret = value.clientTextSecret;
      this._connectionString = value.connectionString;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._endpointSuffix = value.endpointSuffix;
      this._environment = value.environment;
      this._fileFilter = value.fileFilter;
      this._id = value.id;
      this._maxMessages = value.maxMessages;
      this._metadata.internalValue = value.metadata;
      this._numReceivers = value.numReceivers;
      this._parquetChunkDownloadTimeout = value.parquetChunkDownloadTimeout;
      this._parquetChunkSizeMb = value.parquetChunkSizeMb;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._queueName = value.queueName;
      this._sendToRoutes = value.sendToRoutes;
      this._servicePeriodSecs = value.servicePeriodSecs;
      this._skipOnError = value.skipOnError;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._storageAccountName = value.storageAccountName;
      this._streamtags = value.streamtags;
      this._tenantId = value.tenantId;
      this._textSecret = value.textSecret;
      this._type = value.type;
      this._visibilityTimeout = value.visibilityTimeout;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // azure_cloud - computed: false, optional: true, required: false
  private _azureCloud?: string; 
  public get azureCloud() {
    return this.getStringAttribute('azure_cloud');
  }
  public set azureCloud(value: string) {
    this._azureCloud = value;
  }
  public resetAzureCloud() {
    this._azureCloud = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureCloudInput() {
    return this._azureCloud;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // certificate - computed: false, optional: true, required: false
  private _certificate = new PackSourceInputAzureBlobCertificateOutputReference(this, "certificate");
  public get certificate() {
    return this._certificate;
  }
  public putCertificate(value: PackSourceInputAzureBlobCertificate) {
    this._certificate.internalValue = value;
  }
  public resetCertificate() {
    this._certificate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateInput() {
    return this._certificate.internalValue;
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_text_secret - computed: false, optional: true, required: false
  private _clientTextSecret?: string; 
  public get clientTextSecret() {
    return this.getStringAttribute('client_text_secret');
  }
  public set clientTextSecret(value: string) {
    this._clientTextSecret = value;
  }
  public resetClientTextSecret() {
    this._clientTextSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientTextSecretInput() {
    return this._clientTextSecret;
  }

  // connection_string - computed: false, optional: true, required: false
  private _connectionString?: string; 
  public get connectionString() {
    return this.getStringAttribute('connection_string');
  }
  public set connectionString(value: string) {
    this._connectionString = value;
  }
  public resetConnectionString() {
    this._connectionString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionStringInput() {
    return this._connectionString;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputAzureBlobConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputAzureBlobConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // endpoint_suffix - computed: false, optional: true, required: false
  private _endpointSuffix?: string; 
  public get endpointSuffix() {
    return this.getStringAttribute('endpoint_suffix');
  }
  public set endpointSuffix(value: string) {
    this._endpointSuffix = value;
  }
  public resetEndpointSuffix() {
    this._endpointSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointSuffixInput() {
    return this._endpointSuffix;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_filter - computed: true, optional: true, required: false
  private _fileFilter?: string; 
  public get fileFilter() {
    return this.getStringAttribute('file_filter');
  }
  public set fileFilter(value: string) {
    this._fileFilter = value;
  }
  public resetFileFilter() {
    this._fileFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileFilterInput() {
    return this._fileFilter;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_messages - computed: true, optional: true, required: false
  private _maxMessages?: number; 
  public get maxMessages() {
    return this.getNumberAttribute('max_messages');
  }
  public set maxMessages(value: number) {
    this._maxMessages = value;
  }
  public resetMaxMessages() {
    this._maxMessages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMessagesInput() {
    return this._maxMessages;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputAzureBlobMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputAzureBlobMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // num_receivers - computed: true, optional: true, required: false
  private _numReceivers?: number; 
  public get numReceivers() {
    return this.getNumberAttribute('num_receivers');
  }
  public set numReceivers(value: number) {
    this._numReceivers = value;
  }
  public resetNumReceivers() {
    this._numReceivers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numReceiversInput() {
    return this._numReceivers;
  }

  // parquet_chunk_download_timeout - computed: true, optional: true, required: false
  private _parquetChunkDownloadTimeout?: number; 
  public get parquetChunkDownloadTimeout() {
    return this.getNumberAttribute('parquet_chunk_download_timeout');
  }
  public set parquetChunkDownloadTimeout(value: number) {
    this._parquetChunkDownloadTimeout = value;
  }
  public resetParquetChunkDownloadTimeout() {
    this._parquetChunkDownloadTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkDownloadTimeoutInput() {
    return this._parquetChunkDownloadTimeout;
  }

  // parquet_chunk_size_mb - computed: true, optional: true, required: false
  private _parquetChunkSizeMb?: number; 
  public get parquetChunkSizeMb() {
    return this.getNumberAttribute('parquet_chunk_size_mb');
  }
  public set parquetChunkSizeMb(value: number) {
    this._parquetChunkSizeMb = value;
  }
  public resetParquetChunkSizeMb() {
    this._parquetChunkSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkSizeMbInput() {
    return this._parquetChunkSizeMb;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputAzureBlobPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputAzureBlobPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // queue_name - computed: false, optional: false, required: true
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // service_period_secs - computed: true, optional: true, required: false
  private _servicePeriodSecs?: number; 
  public get servicePeriodSecs() {
    return this.getNumberAttribute('service_period_secs');
  }
  public set servicePeriodSecs(value: number) {
    this._servicePeriodSecs = value;
  }
  public resetServicePeriodSecs() {
    this._servicePeriodSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicePeriodSecsInput() {
    return this._servicePeriodSecs;
  }

  // skip_on_error - computed: true, optional: true, required: false
  private _skipOnError?: boolean | cdktf.IResolvable; 
  public get skipOnError() {
    return this.getBooleanAttribute('skip_on_error');
  }
  public set skipOnError(value: boolean | cdktf.IResolvable) {
    this._skipOnError = value;
  }
  public resetSkipOnError() {
    this._skipOnError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipOnErrorInput() {
    return this._skipOnError;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // storage_account_name - computed: false, optional: true, required: false
  private _storageAccountName?: string; 
  public get storageAccountName() {
    return this.getStringAttribute('storage_account_name');
  }
  public set storageAccountName(value: string) {
    this._storageAccountName = value;
  }
  public resetStorageAccountName() {
    this._storageAccountName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageAccountNameInput() {
    return this._storageAccountName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // visibility_timeout - computed: true, optional: true, required: false
  private _visibilityTimeout?: number; 
  public get visibilityTimeout() {
    return this.getNumberAttribute('visibility_timeout');
  }
  public set visibilityTimeout(value: number) {
    this._visibilityTimeout = value;
  }
  public resetVisibilityTimeout() {
    this._visibilityTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityTimeoutInput() {
    return this._visibilityTimeout;
  }
}
export interface PackSourceInputCollectionConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputCollectionConnectionsToTerraform(struct?: PackSourceInputCollectionConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputCollectionConnectionsToHclTerraform(struct?: PackSourceInputCollectionConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCollectionConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCollectionConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCollectionConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputCollectionConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCollectionConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCollectionConnectionsOutputReference {
    return new PackSourceInputCollectionConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCollectionMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputCollectionMetadataToTerraform(struct?: PackSourceInputCollectionMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputCollectionMetadataToHclTerraform(struct?: PackSourceInputCollectionMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCollectionMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCollectionMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCollectionMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputCollectionMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCollectionMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCollectionMetadataOutputReference {
    return new PackSourceInputCollectionMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCollectionPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputCollectionPqToTerraform(struct?: PackSourceInputCollectionPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputCollectionPqToHclTerraform(struct?: PackSourceInputCollectionPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCollectionPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCollectionPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCollectionPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputCollectionPreprocess {
  /**
  * Arguments to be added to the custom command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#args PackSource#args}
  */
  readonly args?: string[];
  /**
  * Command to feed the data through (via stdin) and process its output (stdout)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#command PackSource#command}
  */
  readonly command?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packSourceInputCollectionPreprocessToTerraform(struct?: PackSourceInputCollectionPreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.stringToTerraform(struct!.command),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packSourceInputCollectionPreprocessToHclTerraform(struct?: PackSourceInputCollectionPreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.stringToHclTerraform(struct!.command),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCollectionPreprocessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCollectionPreprocess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCollectionPreprocess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._command = value.command;
      this._disabled = value.disabled;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string; 
  public get command() {
    return this.getStringAttribute('command');
  }
  public set command(value: string) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackSourceInputCollection {
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputCollectionConnections[] | cdktf.IResolvable;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputCollectionMetadata[] | cdktf.IResolvable;
  /**
  * Destination to send results to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output?: string;
  /**
  * Pipeline to process results
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputCollectionPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#preprocess PackSource#preprocess}
  */
  readonly preprocess?: PackSourceInputCollectionPreprocess;
  /**
  * Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#throttle_rate_per_sec PackSource#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * Default: "collection"; must be "collection"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputCollectionToTerraform(struct?: PackSourceInputCollection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    connections: cdktf.listMapper(packSourceInputCollectionConnectionsToTerraform, false)(struct!.connections),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    metadata: cdktf.listMapper(packSourceInputCollectionMetadataToTerraform, false)(struct!.metadata),
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputCollectionPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    preprocess: packSourceInputCollectionPreprocessToTerraform(struct!.preprocess),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputCollectionToHclTerraform(struct?: PackSourceInputCollection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputCollectionConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCollectionConnectionsList",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputCollectionMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCollectionMetadataList",
    },
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputCollectionPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCollectionPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preprocess: {
      value: packSourceInputCollectionPreprocessToHclTerraform(struct!.preprocess),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCollectionPreprocess",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCollectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCollection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._preprocess?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preprocess = this._preprocess?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCollection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._breakerRulesets = undefined;
      this._connections.internalValue = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._metadata.internalValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._preprocess.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._throttleRatePerSec = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._breakerRulesets = value.breakerRulesets;
      this._connections.internalValue = value.connections;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._metadata.internalValue = value.metadata;
      this._output = value.output;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._preprocess.internalValue = value.preprocess;
      this._sendToRoutes = value.sendToRoutes;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._type = value.type;
    }
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputCollectionConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputCollectionConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputCollectionMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputCollectionMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // output - computed: false, optional: true, required: false
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  public resetOutput() {
    this._output = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputCollectionPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputCollectionPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // preprocess - computed: false, optional: true, required: false
  private _preprocess = new PackSourceInputCollectionPreprocessOutputReference(this, "preprocess");
  public get preprocess() {
    return this._preprocess;
  }
  public putPreprocess(value: PackSourceInputCollectionPreprocess) {
    this._preprocess.internalValue = value;
  }
  public resetPreprocess() {
    this._preprocess.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preprocessInput() {
    return this._preprocess.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputConfluentCloudConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputConfluentCloudConnectionsToTerraform(struct?: PackSourceInputConfluentCloudConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputConfluentCloudConnectionsToHclTerraform(struct?: PackSourceInputConfluentCloudConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputConfluentCloudConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputConfluentCloudConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputConfluentCloudConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputConfluentCloudConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputConfluentCloudConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputConfluentCloudConnectionsOutputReference {
    return new PackSourceInputConfluentCloudConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputConfluentCloudKafkaSchemaRegistryAuth {
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packSourceInputConfluentCloudKafkaSchemaRegistryAuthToTerraform(struct?: PackSourceInputConfluentCloudKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packSourceInputConfluentCloudKafkaSchemaRegistryAuthToHclTerraform(struct?: PackSourceInputConfluentCloudKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputConfluentCloudKafkaSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputConfluentCloudKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputConfluentCloudKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsSecret = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsSecret = value.credentialsSecret;
      this._disabled = value.disabled;
    }
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackSourceInputConfluentCloudKafkaSchemaRegistryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#servername PackSource#servername}
  */
  readonly servername?: string;
}

export function packSourceInputConfluentCloudKafkaSchemaRegistryTlsToTerraform(struct?: PackSourceInputConfluentCloudKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packSourceInputConfluentCloudKafkaSchemaRegistryTlsToHclTerraform(struct?: PackSourceInputConfluentCloudKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputConfluentCloudKafkaSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputConfluentCloudKafkaSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputConfluentCloudKafkaSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackSourceInputConfluentCloudKafkaSchemaRegistry {
  /**
  * Credentials to use when authenticating with the schema registry using basic HTTP authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth PackSource#auth}
  */
  readonly auth?: PackSourceInputConfluentCloudKafkaSchemaRegistryAuth;
  /**
  * Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connection_timeout PackSource#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times to try fetching schemas from the Schema Registry. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_retries PackSource#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum time to wait for the Schema Registry to respond to a request. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#schema_registry_url PackSource#schema_registry_url}
  */
  readonly schemaRegistryUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputConfluentCloudKafkaSchemaRegistryTls;
}

export function packSourceInputConfluentCloudKafkaSchemaRegistryToTerraform(struct?: PackSourceInputConfluentCloudKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: packSourceInputConfluentCloudKafkaSchemaRegistryAuthToTerraform(struct!.auth),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    schema_registry_url: cdktf.stringToTerraform(struct!.schemaRegistryUrl),
    tls: packSourceInputConfluentCloudKafkaSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function packSourceInputConfluentCloudKafkaSchemaRegistryToHclTerraform(struct?: PackSourceInputConfluentCloudKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: packSourceInputConfluentCloudKafkaSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputConfluentCloudKafkaSchemaRegistryAuth",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schema_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.schemaRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packSourceInputConfluentCloudKafkaSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputConfluentCloudKafkaSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputConfluentCloudKafkaSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputConfluentCloudKafkaSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._schemaRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistryUrl = this._schemaRegistryUrl;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputConfluentCloudKafkaSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectionTimeout = undefined;
      this._disabled = undefined;
      this._maxRetries = undefined;
      this._requestTimeout = undefined;
      this._schemaRegistryUrl = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectionTimeout = value.connectionTimeout;
      this._disabled = value.disabled;
      this._maxRetries = value.maxRetries;
      this._requestTimeout = value.requestTimeout;
      this._schemaRegistryUrl = value.schemaRegistryUrl;
      this._tls.internalValue = value.tls;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new PackSourceInputConfluentCloudKafkaSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: PackSourceInputConfluentCloudKafkaSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // schema_registry_url - computed: true, optional: true, required: false
  private _schemaRegistryUrl?: string; 
  public get schemaRegistryUrl() {
    return this.getStringAttribute('schema_registry_url');
  }
  public set schemaRegistryUrl(value: string) {
    this._schemaRegistryUrl = value;
  }
  public resetSchemaRegistryUrl() {
    this._schemaRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryUrlInput() {
    return this._schemaRegistryUrl;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputConfluentCloudKafkaSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputConfluentCloudKafkaSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface PackSourceInputConfluentCloudMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputConfluentCloudMetadataToTerraform(struct?: PackSourceInputConfluentCloudMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputConfluentCloudMetadataToHclTerraform(struct?: PackSourceInputConfluentCloudMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputConfluentCloudMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputConfluentCloudMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputConfluentCloudMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputConfluentCloudMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputConfluentCloudMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputConfluentCloudMetadataOutputReference {
    return new PackSourceInputConfluentCloudMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputConfluentCloudPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputConfluentCloudPqToTerraform(struct?: PackSourceInputConfluentCloudPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputConfluentCloudPqToHclTerraform(struct?: PackSourceInputConfluentCloudPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputConfluentCloudPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputConfluentCloudPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputConfluentCloudPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputConfluentCloudSasl {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Default: "plain"; must be one of ["plain", "scram-sha-256", "scram-sha-512", "kerberos"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mechanism PackSource#mechanism}
  */
  readonly mechanism?: string;
}

export function packSourceInputConfluentCloudSaslToTerraform(struct?: PackSourceInputConfluentCloudSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    mechanism: cdktf.stringToTerraform(struct!.mechanism),
  }
}


export function packSourceInputConfluentCloudSaslToHclTerraform(struct?: PackSourceInputConfluentCloudSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mechanism: {
      value: cdktf.stringToHclTerraform(struct!.mechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputConfluentCloudSaslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputConfluentCloudSasl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._mechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.mechanism = this._mechanism;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputConfluentCloudSasl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._mechanism = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._mechanism = value.mechanism;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // mechanism - computed: true, optional: true, required: false
  private _mechanism?: string; 
  public get mechanism() {
    return this.getStringAttribute('mechanism');
  }
  public set mechanism(value: string) {
    this._mechanism = value;
  }
  public resetMechanism() {
    this._mechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mechanismInput() {
    return this._mechanism;
  }
}
export interface PackSourceInputConfluentCloudTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#servername PackSource#servername}
  */
  readonly servername?: string;
}

export function packSourceInputConfluentCloudTlsToTerraform(struct?: PackSourceInputConfluentCloudTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packSourceInputConfluentCloudTlsToHclTerraform(struct?: PackSourceInputConfluentCloudTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputConfluentCloudTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputConfluentCloudTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputConfluentCloudTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackSourceInputConfluentCloud {
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#authentication_timeout PackSource#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auto_commit_interval PackSource#auto_commit_interval}
  */
  readonly autoCommitInterval?: number;
  /**
  * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auto_commit_threshold PackSource#auto_commit_threshold}
  */
  readonly autoCommitThreshold?: number;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#backoff_rate PackSource#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#brokers PackSource#brokers}
  */
  readonly brokers: string[];
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connection_timeout PackSource#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputConfluentCloudConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#from_beginning PackSource#from_beginning}
  */
  readonly fromBeginning?: boolean | cdktf.IResolvable;
  /**
  * The consumer group to which this instance belongs. Defaults to 'Cribl'. Default: "Cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#group_id PackSource#group_id}
  */
  readonly groupId?: string;
  /**
  * Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
  *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
  *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
  * Default: 3000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#heartbeat_interval PackSource#heartbeat_interval}
  */
  readonly heartbeatInterval?: number;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#initial_backoff PackSource#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#kafka_schema_registry PackSource#kafka_schema_registry}
  */
  readonly kafkaSchemaRegistry?: PackSourceInputConfluentCloudKafkaSchemaRegistry;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_back_off PackSource#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB). Default: 10485760
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_bytes PackSource#max_bytes}
  */
  readonly maxBytes?: number;
  /**
  * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB). Default: 1048576
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_bytes_per_partition PackSource#max_bytes_per_partition}
  */
  readonly maxBytesPerPartition?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_retries PackSource#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum number of network errors before the consumer re-creates a socket. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_socket_errors PackSource#max_socket_errors}
  */
  readonly maxSocketErrors?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputConfluentCloudMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputConfluentCloudPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reauthentication_threshold PackSource#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Maximum allowed time for each worker to join the group after a rebalance begins.
  *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
  *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
  * Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#rebalance_timeout PackSource#rebalance_timeout}
  */
  readonly rebalanceTimeout?: number;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#sasl PackSource#sasl}
  */
  readonly sasl?: PackSourceInputConfluentCloudSasl;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Timeout used to detect client failures when using Kafka's group-management facilities.
  *       If the client sends no heartbeats to the broker before the timeout expires,
  *       the broker will remove the client from the group and initiate a rebalance.
  *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
  *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
  * Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#session_timeout PackSource#session_timeout}
  */
  readonly sessionTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputConfluentCloudTls;
  /**
  * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#topics PackSource#topics}
  */
  readonly topics?: string[];
  /**
  * must be "confluent_cloud"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputConfluentCloudToTerraform(struct?: PackSourceInputConfluentCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    auto_commit_interval: cdktf.numberToTerraform(struct!.autoCommitInterval),
    auto_commit_threshold: cdktf.numberToTerraform(struct!.autoCommitThreshold),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    connections: cdktf.listMapper(packSourceInputConfluentCloudConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    from_beginning: cdktf.booleanToTerraform(struct!.fromBeginning),
    group_id: cdktf.stringToTerraform(struct!.groupId),
    heartbeat_interval: cdktf.numberToTerraform(struct!.heartbeatInterval),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    kafka_schema_registry: packSourceInputConfluentCloudKafkaSchemaRegistryToTerraform(struct!.kafkaSchemaRegistry),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_bytes: cdktf.numberToTerraform(struct!.maxBytes),
    max_bytes_per_partition: cdktf.numberToTerraform(struct!.maxBytesPerPartition),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    max_socket_errors: cdktf.numberToTerraform(struct!.maxSocketErrors),
    metadata: cdktf.listMapper(packSourceInputConfluentCloudMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputConfluentCloudPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    rebalance_timeout: cdktf.numberToTerraform(struct!.rebalanceTimeout),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    sasl: packSourceInputConfluentCloudSaslToTerraform(struct!.sasl),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    session_timeout: cdktf.numberToTerraform(struct!.sessionTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputConfluentCloudTlsToTerraform(struct!.tls),
    topics: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.topics),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputConfluentCloudToHclTerraform(struct?: PackSourceInputConfluentCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_commit_interval: {
      value: cdktf.numberToHclTerraform(struct!.autoCommitInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_commit_threshold: {
      value: cdktf.numberToHclTerraform(struct!.autoCommitThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputConfluentCloudConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputConfluentCloudConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    from_beginning: {
      value: cdktf.booleanToHclTerraform(struct!.fromBeginning),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    group_id: {
      value: cdktf.stringToHclTerraform(struct!.groupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    heartbeat_interval: {
      value: cdktf.numberToHclTerraform(struct!.heartbeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kafka_schema_registry: {
      value: packSourceInputConfluentCloudKafkaSchemaRegistryToHclTerraform(struct!.kafkaSchemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputConfluentCloudKafkaSchemaRegistry",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_bytes_per_partition: {
      value: cdktf.numberToHclTerraform(struct!.maxBytesPerPartition),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_socket_errors: {
      value: cdktf.numberToHclTerraform(struct!.maxSocketErrors),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputConfluentCloudMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputConfluentCloudMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputConfluentCloudPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputConfluentCloudPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rebalance_timeout: {
      value: cdktf.numberToHclTerraform(struct!.rebalanceTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sasl: {
      value: packSourceInputConfluentCloudSaslToHclTerraform(struct!.sasl),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputConfluentCloudSasl",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    session_timeout: {
      value: cdktf.numberToHclTerraform(struct!.sessionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputConfluentCloudTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputConfluentCloudTls",
    },
    topics: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.topics),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputConfluentCloudOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputConfluentCloud | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._autoCommitInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCommitInterval = this._autoCommitInterval;
    }
    if (this._autoCommitThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCommitThreshold = this._autoCommitThreshold;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fromBeginning !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromBeginning = this._fromBeginning;
    }
    if (this._groupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupId = this._groupId;
    }
    if (this._heartbeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.heartbeatInterval = this._heartbeatInterval;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._kafkaSchemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaSchemaRegistry = this._kafkaSchemaRegistry?.internalValue;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBytes = this._maxBytes;
    }
    if (this._maxBytesPerPartition !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBytesPerPartition = this._maxBytesPerPartition;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._maxSocketErrors !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSocketErrors = this._maxSocketErrors;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._rebalanceTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.rebalanceTimeout = this._rebalanceTimeout;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sasl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sasl = this._sasl?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._sessionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionTimeout = this._sessionTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topics !== undefined) {
      hasAnyValues = true;
      internalValueResult.topics = this._topics;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputConfluentCloud | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authenticationTimeout = undefined;
      this._autoCommitInterval = undefined;
      this._autoCommitThreshold = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._connectionTimeout = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._fromBeginning = undefined;
      this._groupId = undefined;
      this._heartbeatInterval = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._kafkaSchemaRegistry.internalValue = undefined;
      this._maxBackOff = undefined;
      this._maxBytes = undefined;
      this._maxBytesPerPartition = undefined;
      this._maxRetries = undefined;
      this._maxSocketErrors = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._reauthenticationThreshold = undefined;
      this._rebalanceTimeout = undefined;
      this._requestTimeout = undefined;
      this._sasl.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._sessionTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._topics = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authenticationTimeout = value.authenticationTimeout;
      this._autoCommitInterval = value.autoCommitInterval;
      this._autoCommitThreshold = value.autoCommitThreshold;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._connectionTimeout = value.connectionTimeout;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._fromBeginning = value.fromBeginning;
      this._groupId = value.groupId;
      this._heartbeatInterval = value.heartbeatInterval;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._kafkaSchemaRegistry.internalValue = value.kafkaSchemaRegistry;
      this._maxBackOff = value.maxBackOff;
      this._maxBytes = value.maxBytes;
      this._maxBytesPerPartition = value.maxBytesPerPartition;
      this._maxRetries = value.maxRetries;
      this._maxSocketErrors = value.maxSocketErrors;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._rebalanceTimeout = value.rebalanceTimeout;
      this._requestTimeout = value.requestTimeout;
      this._sasl.internalValue = value.sasl;
      this._sendToRoutes = value.sendToRoutes;
      this._sessionTimeout = value.sessionTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._topics = value.topics;
      this._type = value.type;
    }
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // auto_commit_interval - computed: false, optional: true, required: false
  private _autoCommitInterval?: number; 
  public get autoCommitInterval() {
    return this.getNumberAttribute('auto_commit_interval');
  }
  public set autoCommitInterval(value: number) {
    this._autoCommitInterval = value;
  }
  public resetAutoCommitInterval() {
    this._autoCommitInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCommitIntervalInput() {
    return this._autoCommitInterval;
  }

  // auto_commit_threshold - computed: false, optional: true, required: false
  private _autoCommitThreshold?: number; 
  public get autoCommitThreshold() {
    return this.getNumberAttribute('auto_commit_threshold');
  }
  public set autoCommitThreshold(value: number) {
    this._autoCommitThreshold = value;
  }
  public resetAutoCommitThreshold() {
    this._autoCommitThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCommitThresholdInput() {
    return this._autoCommitThreshold;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputConfluentCloudConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputConfluentCloudConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // from_beginning - computed: true, optional: true, required: false
  private _fromBeginning?: boolean | cdktf.IResolvable; 
  public get fromBeginning() {
    return this.getBooleanAttribute('from_beginning');
  }
  public set fromBeginning(value: boolean | cdktf.IResolvable) {
    this._fromBeginning = value;
  }
  public resetFromBeginning() {
    this._fromBeginning = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromBeginningInput() {
    return this._fromBeginning;
  }

  // group_id - computed: true, optional: true, required: false
  private _groupId?: string; 
  public get groupId() {
    return this.getStringAttribute('group_id');
  }
  public set groupId(value: string) {
    this._groupId = value;
  }
  public resetGroupId() {
    this._groupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupIdInput() {
    return this._groupId;
  }

  // heartbeat_interval - computed: true, optional: true, required: false
  private _heartbeatInterval?: number; 
  public get heartbeatInterval() {
    return this.getNumberAttribute('heartbeat_interval');
  }
  public set heartbeatInterval(value: number) {
    this._heartbeatInterval = value;
  }
  public resetHeartbeatInterval() {
    this._heartbeatInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get heartbeatIntervalInput() {
    return this._heartbeatInterval;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // kafka_schema_registry - computed: false, optional: true, required: false
  private _kafkaSchemaRegistry = new PackSourceInputConfluentCloudKafkaSchemaRegistryOutputReference(this, "kafka_schema_registry");
  public get kafkaSchemaRegistry() {
    return this._kafkaSchemaRegistry;
  }
  public putKafkaSchemaRegistry(value: PackSourceInputConfluentCloudKafkaSchemaRegistry) {
    this._kafkaSchemaRegistry.internalValue = value;
  }
  public resetKafkaSchemaRegistry() {
    this._kafkaSchemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaSchemaRegistryInput() {
    return this._kafkaSchemaRegistry.internalValue;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_bytes - computed: true, optional: true, required: false
  private _maxBytes?: number; 
  public get maxBytes() {
    return this.getNumberAttribute('max_bytes');
  }
  public set maxBytes(value: number) {
    this._maxBytes = value;
  }
  public resetMaxBytes() {
    this._maxBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBytesInput() {
    return this._maxBytes;
  }

  // max_bytes_per_partition - computed: true, optional: true, required: false
  private _maxBytesPerPartition?: number; 
  public get maxBytesPerPartition() {
    return this.getNumberAttribute('max_bytes_per_partition');
  }
  public set maxBytesPerPartition(value: number) {
    this._maxBytesPerPartition = value;
  }
  public resetMaxBytesPerPartition() {
    this._maxBytesPerPartition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBytesPerPartitionInput() {
    return this._maxBytesPerPartition;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // max_socket_errors - computed: true, optional: true, required: false
  private _maxSocketErrors?: number; 
  public get maxSocketErrors() {
    return this.getNumberAttribute('max_socket_errors');
  }
  public set maxSocketErrors(value: number) {
    this._maxSocketErrors = value;
  }
  public resetMaxSocketErrors() {
    this._maxSocketErrors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSocketErrorsInput() {
    return this._maxSocketErrors;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputConfluentCloudMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputConfluentCloudMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputConfluentCloudPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputConfluentCloudPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // rebalance_timeout - computed: true, optional: true, required: false
  private _rebalanceTimeout?: number; 
  public get rebalanceTimeout() {
    return this.getNumberAttribute('rebalance_timeout');
  }
  public set rebalanceTimeout(value: number) {
    this._rebalanceTimeout = value;
  }
  public resetRebalanceTimeout() {
    this._rebalanceTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rebalanceTimeoutInput() {
    return this._rebalanceTimeout;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // sasl - computed: false, optional: true, required: false
  private _sasl = new PackSourceInputConfluentCloudSaslOutputReference(this, "sasl");
  public get sasl() {
    return this._sasl;
  }
  public putSasl(value: PackSourceInputConfluentCloudSasl) {
    this._sasl.internalValue = value;
  }
  public resetSasl() {
    this._sasl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saslInput() {
    return this._sasl.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // session_timeout - computed: true, optional: true, required: false
  private _sessionTimeout?: number; 
  public get sessionTimeout() {
    return this.getNumberAttribute('session_timeout');
  }
  public set sessionTimeout(value: number) {
    this._sessionTimeout = value;
  }
  public resetSessionTimeout() {
    this._sessionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTimeoutInput() {
    return this._sessionTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputConfluentCloudTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputConfluentCloudTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topics - computed: true, optional: true, required: false
  private _topics?: string[]; 
  public get topics() {
    return this.getListAttribute('topics');
  }
  public set topics(value: string[]) {
    this._topics = value;
  }
  public resetTopics() {
    this._topics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicsInput() {
    return this._topics;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputCriblConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputCriblConnectionsToTerraform(struct?: PackSourceInputCriblConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputCriblConnectionsToHclTerraform(struct?: PackSourceInputCriblConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCriblConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputCriblConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCriblConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCriblConnectionsOutputReference {
    return new PackSourceInputCriblConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCriblMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputCriblMetadataToTerraform(struct?: PackSourceInputCriblMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputCriblMetadataToHclTerraform(struct?: PackSourceInputCriblMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCriblMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputCriblMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCriblMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCriblMetadataOutputReference {
    return new PackSourceInputCriblMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCriblPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputCriblPqToTerraform(struct?: PackSourceInputCriblPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputCriblPqToHclTerraform(struct?: PackSourceInputCriblPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCriblPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputCribl {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputCriblConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#filter PackSource#filter}
  */
  readonly filter?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputCriblMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputCriblPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
}

export function packSourceInputCriblToTerraform(struct?: PackSourceInputCribl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputCriblConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    filter: cdktf.stringToTerraform(struct!.filter),
    id: cdktf.stringToTerraform(struct!.id),
    metadata: cdktf.listMapper(packSourceInputCriblMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputCriblPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputCriblToHclTerraform(struct?: PackSourceInputCribl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputCriblConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCriblConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputCriblMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCriblMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputCriblPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCriblPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCribl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCribl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._filter = undefined;
      this._id = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._filter = value.filter;
      this._id = value.id;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputCriblConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputCriblConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // filter - computed: false, optional: true, required: false
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  public resetFilter() {
    this._filter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputCriblMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputCriblMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputCriblPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputCriblPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputCriblHttpConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputCriblHttpConnectionsToTerraform(struct?: PackSourceInputCriblHttpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputCriblHttpConnectionsToHclTerraform(struct?: PackSourceInputCriblHttpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblHttpConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCriblHttpConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblHttpConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputCriblHttpConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCriblHttpConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCriblHttpConnectionsOutputReference {
    return new PackSourceInputCriblHttpConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCriblHttpMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputCriblHttpMetadataToTerraform(struct?: PackSourceInputCriblHttpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputCriblHttpMetadataToHclTerraform(struct?: PackSourceInputCriblHttpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblHttpMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCriblHttpMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblHttpMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputCriblHttpMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCriblHttpMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCriblHttpMetadataOutputReference {
    return new PackSourceInputCriblHttpMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCriblHttpPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputCriblHttpPqToTerraform(struct?: PackSourceInputCriblHttpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputCriblHttpPqToHclTerraform(struct?: PackSourceInputCriblHttpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblHttpPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCriblHttpPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblHttpPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputCriblHttpTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputCriblHttpTlsToTerraform(struct?: PackSourceInputCriblHttpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputCriblHttpTlsToHclTerraform(struct?: PackSourceInputCriblHttpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblHttpTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCriblHttpTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblHttpTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputCriblHttp {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_tokens PackSource#auth_tokens}
  */
  readonly authTokens?: string[];
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputCriblHttpConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputCriblHttpMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputCriblHttpPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputCriblHttpTls;
  /**
  * must be "cribl_http"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputCriblHttpToTerraform(struct?: PackSourceInputCriblHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    auth_tokens: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.authTokens),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputCriblHttpConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputCriblHttpMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputCriblHttpPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputCriblHttpTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputCriblHttpToHclTerraform(struct?: PackSourceInputCriblHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.authTokens),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputCriblHttpConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCriblHttpConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputCriblHttpMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCriblHttpMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputCriblHttpPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCriblHttpPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputCriblHttpTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCriblHttpTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCriblHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._authTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._authTokens = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._authTokens = value.authTokens;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens?: string[]; 
  public get authTokens() {
    return this.getListAttribute('auth_tokens');
  }
  public set authTokens(value: string[]) {
    this._authTokens = value;
  }
  public resetAuthTokens() {
    this._authTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputCriblHttpConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputCriblHttpConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputCriblHttpMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputCriblHttpMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputCriblHttpPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputCriblHttpPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputCriblHttpTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputCriblHttpTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputCriblLakeHttpConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputCriblLakeHttpConnectionsToTerraform(struct?: PackSourceInputCriblLakeHttpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputCriblLakeHttpConnectionsToHclTerraform(struct?: PackSourceInputCriblLakeHttpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblLakeHttpConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCriblLakeHttpConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblLakeHttpConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputCriblLakeHttpConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCriblLakeHttpConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCriblLakeHttpConnectionsOutputReference {
    return new PackSourceInputCriblLakeHttpConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCriblLakeHttpMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputCriblLakeHttpMetadataToTerraform(struct?: PackSourceInputCriblLakeHttpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputCriblLakeHttpMetadataToHclTerraform(struct?: PackSourceInputCriblLakeHttpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblLakeHttpMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCriblLakeHttpMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblLakeHttpMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputCriblLakeHttpMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCriblLakeHttpMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCriblLakeHttpMetadataOutputReference {
    return new PackSourceInputCriblLakeHttpMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCriblLakeHttpPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputCriblLakeHttpPqToTerraform(struct?: PackSourceInputCriblLakeHttpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputCriblLakeHttpPqToHclTerraform(struct?: PackSourceInputCriblLakeHttpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblLakeHttpPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCriblLakeHttpPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblLakeHttpPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputCriblLakeHttpTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputCriblLakeHttpTlsToTerraform(struct?: PackSourceInputCriblLakeHttpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputCriblLakeHttpTlsToHclTerraform(struct?: PackSourceInputCriblLakeHttpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblLakeHttpTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCriblLakeHttpTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblLakeHttpTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputCriblLakeHttp {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_tokens PackSource#auth_tokens}
  */
  readonly authTokens?: string[];
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputCriblLakeHttpConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputCriblLakeHttpMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputCriblLakeHttpPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputCriblLakeHttpTls;
  /**
  * must be "cribl_lake_http"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputCriblLakeHttpToTerraform(struct?: PackSourceInputCriblLakeHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    auth_tokens: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.authTokens),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputCriblLakeHttpConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputCriblLakeHttpMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputCriblLakeHttpPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputCriblLakeHttpTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputCriblLakeHttpToHclTerraform(struct?: PackSourceInputCriblLakeHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.authTokens),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputCriblLakeHttpConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCriblLakeHttpConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputCriblLakeHttpMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCriblLakeHttpMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputCriblLakeHttpPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCriblLakeHttpPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputCriblLakeHttpTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCriblLakeHttpTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblLakeHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCriblLakeHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._authTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblLakeHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._authTokens = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._authTokens = value.authTokens;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens?: string[]; 
  public get authTokens() {
    return this.getListAttribute('auth_tokens');
  }
  public set authTokens(value: string[]) {
    this._authTokens = value;
  }
  public resetAuthTokens() {
    this._authTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputCriblLakeHttpConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputCriblLakeHttpConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputCriblLakeHttpMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputCriblLakeHttpMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputCriblLakeHttpPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputCriblLakeHttpPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputCriblLakeHttpTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputCriblLakeHttpTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputCriblTcpConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputCriblTcpConnectionsToTerraform(struct?: PackSourceInputCriblTcpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputCriblTcpConnectionsToHclTerraform(struct?: PackSourceInputCriblTcpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblTcpConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCriblTcpConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblTcpConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputCriblTcpConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCriblTcpConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCriblTcpConnectionsOutputReference {
    return new PackSourceInputCriblTcpConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCriblTcpMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputCriblTcpMetadataToTerraform(struct?: PackSourceInputCriblTcpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputCriblTcpMetadataToHclTerraform(struct?: PackSourceInputCriblTcpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblTcpMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCriblTcpMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblTcpMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputCriblTcpMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCriblTcpMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCriblTcpMetadataOutputReference {
    return new PackSourceInputCriblTcpMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCriblTcpPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputCriblTcpPqToTerraform(struct?: PackSourceInputCriblTcpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputCriblTcpPqToHclTerraform(struct?: PackSourceInputCriblTcpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblTcpPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCriblTcpPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblTcpPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputCriblTcpTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputCriblTcpTlsToTerraform(struct?: PackSourceInputCriblTcpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputCriblTcpTlsToHclTerraform(struct?: PackSourceInputCriblTcpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblTcpTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCriblTcpTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblTcpTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputCriblTcp {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputCriblTcpConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Load balance traffic across all Worker Processes. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_load_balancing PackSource#enable_load_balancing}
  */
  readonly enableLoadBalancing?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_cxn PackSource#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputCriblTcpMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputCriblTcpPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_ending_max_wait PackSource#socket_ending_max_wait}
  */
  readonly socketEndingMaxWait?: number;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_idle_timeout PackSource#socket_idle_timeout}
  */
  readonly socketIdleTimeout?: number;
  /**
  * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_max_lifespan PackSource#socket_max_lifespan}
  */
  readonly socketMaxLifespan?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputCriblTcpTls;
  /**
  * must be "cribl_tcp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputCriblTcpToTerraform(struct?: PackSourceInputCriblTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputCriblTcpConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_load_balancing: cdktf.booleanToTerraform(struct!.enableLoadBalancing),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    metadata: cdktf.listMapper(packSourceInputCriblTcpMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputCriblTcpPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_ending_max_wait: cdktf.numberToTerraform(struct!.socketEndingMaxWait),
    socket_idle_timeout: cdktf.numberToTerraform(struct!.socketIdleTimeout),
    socket_max_lifespan: cdktf.numberToTerraform(struct!.socketMaxLifespan),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputCriblTcpTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputCriblTcpToHclTerraform(struct?: PackSourceInputCriblTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputCriblTcpConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCriblTcpConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_load_balancing: {
      value: cdktf.booleanToHclTerraform(struct!.enableLoadBalancing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputCriblTcpMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCriblTcpMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputCriblTcpPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCriblTcpPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_ending_max_wait: {
      value: cdktf.numberToHclTerraform(struct!.socketEndingMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_max_lifespan: {
      value: cdktf.numberToHclTerraform(struct!.socketMaxLifespan),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputCriblTcpTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCriblTcpTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCriblTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableLoadBalancing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLoadBalancing = this._enableLoadBalancing;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketEndingMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketEndingMaxWait = this._socketEndingMaxWait;
    }
    if (this._socketIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketIdleTimeout = this._socketIdleTimeout;
    }
    if (this._socketMaxLifespan !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketMaxLifespan = this._socketMaxLifespan;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableLoadBalancing = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._maxActiveCxn = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._socketEndingMaxWait = undefined;
      this._socketIdleTimeout = undefined;
      this._socketMaxLifespan = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableLoadBalancing = value.enableLoadBalancing;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._maxActiveCxn = value.maxActiveCxn;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._socketEndingMaxWait = value.socketEndingMaxWait;
      this._socketIdleTimeout = value.socketIdleTimeout;
      this._socketMaxLifespan = value.socketMaxLifespan;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputCriblTcpConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputCriblTcpConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_load_balancing - computed: true, optional: true, required: false
  private _enableLoadBalancing?: boolean | cdktf.IResolvable; 
  public get enableLoadBalancing() {
    return this.getBooleanAttribute('enable_load_balancing');
  }
  public set enableLoadBalancing(value: boolean | cdktf.IResolvable) {
    this._enableLoadBalancing = value;
  }
  public resetEnableLoadBalancing() {
    this._enableLoadBalancing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoadBalancingInput() {
    return this._enableLoadBalancing;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputCriblTcpMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputCriblTcpMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputCriblTcpPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputCriblTcpPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_ending_max_wait - computed: true, optional: true, required: false
  private _socketEndingMaxWait?: number; 
  public get socketEndingMaxWait() {
    return this.getNumberAttribute('socket_ending_max_wait');
  }
  public set socketEndingMaxWait(value: number) {
    this._socketEndingMaxWait = value;
  }
  public resetSocketEndingMaxWait() {
    this._socketEndingMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketEndingMaxWaitInput() {
    return this._socketEndingMaxWait;
  }

  // socket_idle_timeout - computed: true, optional: true, required: false
  private _socketIdleTimeout?: number; 
  public get socketIdleTimeout() {
    return this.getNumberAttribute('socket_idle_timeout');
  }
  public set socketIdleTimeout(value: number) {
    this._socketIdleTimeout = value;
  }
  public resetSocketIdleTimeout() {
    this._socketIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketIdleTimeoutInput() {
    return this._socketIdleTimeout;
  }

  // socket_max_lifespan - computed: true, optional: true, required: false
  private _socketMaxLifespan?: number; 
  public get socketMaxLifespan() {
    return this.getNumberAttribute('socket_max_lifespan');
  }
  public set socketMaxLifespan(value: number) {
    this._socketMaxLifespan = value;
  }
  public resetSocketMaxLifespan() {
    this._socketMaxLifespan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketMaxLifespanInput() {
    return this._socketMaxLifespan;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputCriblTcpTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputCriblTcpTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputCriblmetricsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputCriblmetricsConnectionsToTerraform(struct?: PackSourceInputCriblmetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputCriblmetricsConnectionsToHclTerraform(struct?: PackSourceInputCriblmetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblmetricsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCriblmetricsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblmetricsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputCriblmetricsConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCriblmetricsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCriblmetricsConnectionsOutputReference {
    return new PackSourceInputCriblmetricsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCriblmetricsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputCriblmetricsMetadataToTerraform(struct?: PackSourceInputCriblmetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputCriblmetricsMetadataToHclTerraform(struct?: PackSourceInputCriblmetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblmetricsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCriblmetricsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblmetricsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputCriblmetricsMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCriblmetricsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCriblmetricsMetadataOutputReference {
    return new PackSourceInputCriblmetricsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCriblmetricsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputCriblmetricsPqToTerraform(struct?: PackSourceInputCriblmetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputCriblmetricsPqToHclTerraform(struct?: PackSourceInputCriblmetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblmetricsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCriblmetricsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblmetricsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputCriblmetrics {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputCriblmetricsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#full_fidelity PackSource#full_fidelity}
  */
  readonly fullFidelity?: boolean | cdktf.IResolvable;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputCriblmetricsMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputCriblmetricsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * A prefix that is applied to the metrics provided by Cribl Stream. Default: "cribl.logstream."
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#prefix PackSource#prefix}
  */
  readonly prefix?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "criblmetrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
}

export function packSourceInputCriblmetricsToTerraform(struct?: PackSourceInputCriblmetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputCriblmetricsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    full_fidelity: cdktf.booleanToTerraform(struct!.fullFidelity),
    id: cdktf.stringToTerraform(struct!.id),
    metadata: cdktf.listMapper(packSourceInputCriblmetricsMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputCriblmetricsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputCriblmetricsToHclTerraform(struct?: PackSourceInputCriblmetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputCriblmetricsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCriblmetricsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    full_fidelity: {
      value: cdktf.booleanToHclTerraform(struct!.fullFidelity),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputCriblmetricsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCriblmetricsMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputCriblmetricsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCriblmetricsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCriblmetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCriblmetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fullFidelity !== undefined) {
      hasAnyValues = true;
      internalValueResult.fullFidelity = this._fullFidelity;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCriblmetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._fullFidelity = undefined;
      this._id = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._prefix = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._fullFidelity = value.fullFidelity;
      this._id = value.id;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._prefix = value.prefix;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputCriblmetricsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputCriblmetricsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // full_fidelity - computed: true, optional: true, required: false
  private _fullFidelity?: boolean | cdktf.IResolvable; 
  public get fullFidelity() {
    return this.getBooleanAttribute('full_fidelity');
  }
  public set fullFidelity(value: boolean | cdktf.IResolvable) {
    this._fullFidelity = value;
  }
  public resetFullFidelity() {
    this._fullFidelity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fullFidelityInput() {
    return this._fullFidelity;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputCriblmetricsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputCriblmetricsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputCriblmetricsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputCriblmetricsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // prefix - computed: true, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputCrowdstrikeCheckpointing {
  /**
  * Resume processing files after an interruption. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enabled PackSource#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retries PackSource#retries}
  */
  readonly retries?: number;
}

export function packSourceInputCrowdstrikeCheckpointingToTerraform(struct?: PackSourceInputCrowdstrikeCheckpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    retries: cdktf.numberToTerraform(struct!.retries),
  }
}


export function packSourceInputCrowdstrikeCheckpointingToHclTerraform(struct?: PackSourceInputCrowdstrikeCheckpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retries: {
      value: cdktf.numberToHclTerraform(struct!.retries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCrowdstrikeCheckpointingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCrowdstrikeCheckpointing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._retries !== undefined) {
      hasAnyValues = true;
      internalValueResult.retries = this._retries;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCrowdstrikeCheckpointing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._retries = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._retries = value.retries;
    }
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // retries - computed: true, optional: true, required: false
  private _retries?: number; 
  public get retries() {
    return this.getNumberAttribute('retries');
  }
  public set retries(value: number) {
    this._retries = value;
  }
  public resetRetries() {
    this._retries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retriesInput() {
    return this._retries;
  }
}
export interface PackSourceInputCrowdstrikeConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputCrowdstrikeConnectionsToTerraform(struct?: PackSourceInputCrowdstrikeConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputCrowdstrikeConnectionsToHclTerraform(struct?: PackSourceInputCrowdstrikeConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCrowdstrikeConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCrowdstrikeConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCrowdstrikeConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputCrowdstrikeConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCrowdstrikeConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCrowdstrikeConnectionsOutputReference {
    return new PackSourceInputCrowdstrikeConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCrowdstrikeMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputCrowdstrikeMetadataToTerraform(struct?: PackSourceInputCrowdstrikeMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputCrowdstrikeMetadataToHclTerraform(struct?: PackSourceInputCrowdstrikeMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCrowdstrikeMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputCrowdstrikeMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCrowdstrikeMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputCrowdstrikeMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputCrowdstrikeMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputCrowdstrikeMetadataOutputReference {
    return new PackSourceInputCrowdstrikeMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputCrowdstrikePq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputCrowdstrikePqToTerraform(struct?: PackSourceInputCrowdstrikePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputCrowdstrikePqToHclTerraform(struct?: PackSourceInputCrowdstrikePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCrowdstrikePqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCrowdstrikePq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCrowdstrikePq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputCrowdstrikePreprocess {
  /**
  * Arguments to be added to the custom command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#args PackSource#args}
  */
  readonly args?: string[];
  /**
  * Command to feed the data through (via stdin) and process its output (stdout)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#command PackSource#command}
  */
  readonly command?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packSourceInputCrowdstrikePreprocessToTerraform(struct?: PackSourceInputCrowdstrikePreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.stringToTerraform(struct!.command),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packSourceInputCrowdstrikePreprocessToHclTerraform(struct?: PackSourceInputCrowdstrikePreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.stringToHclTerraform(struct!.command),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCrowdstrikePreprocessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCrowdstrikePreprocess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCrowdstrikePreprocess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._command = value.command;
      this._disabled = value.disabled;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string; 
  public get command() {
    return this.getStringAttribute('command');
  }
  public set command(value: string) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackSourceInputCrowdstrike {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_arn PackSource#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_external_id PackSource#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_account_id PackSource#aws_account_id}
  */
  readonly awsAccountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_api_key PackSource#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_authentication_method PackSource#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret PackSource#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret_key PackSource#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#checkpointing PackSource#checkpointing}
  */
  readonly checkpointing?: PackSourceInputCrowdstrikeCheckpointing;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputCrowdstrikeConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#duration_seconds PackSource#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access Amazon S3. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_assume_role PackSource#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Use Assume Role credentials when accessing Amazon SQS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_sqs_assume_role PackSource#enable_sqs_assume_role}
  */
  readonly enableSqsAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#encoding PackSource#encoding}
  */
  readonly encoding?: string;
  /**
  * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint PackSource#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Regex matching file names to download and process. Defaults to: .*. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#file_filter PackSource#file_filter}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly fileFilter?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_messages PackSource#max_messages}
  */
  readonly maxMessages?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputCrowdstrikeMetadata[] | cdktf.IResolvable;
  /**
  * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#num_receivers PackSource#num_receivers}
  */
  readonly numReceivers?: number;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#poll_timeout PackSource#poll_timeout}
  */
  readonly pollTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputCrowdstrikePq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#preprocess PackSource#preprocess}
  */
  readonly preprocess?: PackSourceInputCrowdstrikePreprocess;
  /**
  * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#processed_tag_key PackSource#processed_tag_key}
  */
  readonly processedTagKey?: string;
  /**
  * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#processed_tag_value PackSource#processed_tag_value}
  */
  readonly processedTagValue?: string;
  /**
  * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#queue_name PackSource#queue_name}
  */
  readonly queueName: string;
  /**
  * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#region PackSource#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reuse_connections PackSource#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#signature_version PackSource#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#skip_on_error PackSource#skip_on_error}
  */
  readonly skipOnError?: boolean | cdktf.IResolvable;
  /**
  * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be one of ["false", "true"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tag_after_processing PackSource#tag_after_processing}
  */
  readonly tagAfterProcessing?: string;
  /**
  * must be "crowdstrike"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
  /**
  * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 21600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#visibility_timeout PackSource#visibility_timeout}
  */
  readonly visibilityTimeout?: number;
}

export function packSourceInputCrowdstrikeToTerraform(struct?: PackSourceInputCrowdstrike | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_account_id: cdktf.stringToTerraform(struct!.awsAccountId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    checkpointing: packSourceInputCrowdstrikeCheckpointingToTerraform(struct!.checkpointing),
    connections: cdktf.listMapper(packSourceInputCrowdstrikeConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_sqs_assume_role: cdktf.booleanToTerraform(struct!.enableSqsAssumeRole),
    encoding: cdktf.stringToTerraform(struct!.encoding),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_filter: cdktf.stringToTerraform(struct!.fileFilter),
    id: cdktf.stringToTerraform(struct!.id),
    max_messages: cdktf.numberToTerraform(struct!.maxMessages),
    metadata: cdktf.listMapper(packSourceInputCrowdstrikeMetadataToTerraform, false)(struct!.metadata),
    num_receivers: cdktf.numberToTerraform(struct!.numReceivers),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    poll_timeout: cdktf.numberToTerraform(struct!.pollTimeout),
    pq: packSourceInputCrowdstrikePqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    preprocess: packSourceInputCrowdstrikePreprocessToTerraform(struct!.preprocess),
    processed_tag_key: cdktf.stringToTerraform(struct!.processedTagKey),
    processed_tag_value: cdktf.stringToTerraform(struct!.processedTagValue),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    skip_on_error: cdktf.booleanToTerraform(struct!.skipOnError),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tag_after_processing: cdktf.stringToTerraform(struct!.tagAfterProcessing),
    type: cdktf.stringToTerraform(struct!.type),
    visibility_timeout: cdktf.numberToTerraform(struct!.visibilityTimeout),
  }
}


export function packSourceInputCrowdstrikeToHclTerraform(struct?: PackSourceInputCrowdstrike | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_account_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    checkpointing: {
      value: packSourceInputCrowdstrikeCheckpointingToHclTerraform(struct!.checkpointing),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCrowdstrikeCheckpointing",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputCrowdstrikeConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCrowdstrikeConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sqs_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableSqsAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    encoding: {
      value: cdktf.stringToHclTerraform(struct!.encoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_filter: {
      value: cdktf.stringToHclTerraform(struct!.fileFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_messages: {
      value: cdktf.numberToHclTerraform(struct!.maxMessages),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputCrowdstrikeMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputCrowdstrikeMetadataList",
    },
    num_receivers: {
      value: cdktf.numberToHclTerraform(struct!.numReceivers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    poll_timeout: {
      value: cdktf.numberToHclTerraform(struct!.pollTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputCrowdstrikePqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCrowdstrikePq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preprocess: {
      value: packSourceInputCrowdstrikePreprocessToHclTerraform(struct!.preprocess),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputCrowdstrikePreprocess",
    },
    processed_tag_key: {
      value: cdktf.stringToHclTerraform(struct!.processedTagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    processed_tag_value: {
      value: cdktf.stringToHclTerraform(struct!.processedTagValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_on_error: {
      value: cdktf.booleanToHclTerraform(struct!.skipOnError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag_after_processing: {
      value: cdktf.stringToHclTerraform(struct!.tagAfterProcessing),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    visibility_timeout: {
      value: cdktf.numberToHclTerraform(struct!.visibilityTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputCrowdstrikeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputCrowdstrike | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccountId = this._awsAccountId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._checkpointing?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.checkpointing = this._checkpointing?.internalValue;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enableSqsAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSqsAssumeRole = this._enableSqsAssumeRole;
    }
    if (this._encoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.encoding = this._encoding;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileFilter = this._fileFilter;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxMessages !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMessages = this._maxMessages;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._numReceivers !== undefined) {
      hasAnyValues = true;
      internalValueResult.numReceivers = this._numReceivers;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pollTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollTimeout = this._pollTimeout;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._preprocess?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preprocess = this._preprocess?.internalValue;
    }
    if (this._processedTagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagKey = this._processedTagKey;
    }
    if (this._processedTagValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagValue = this._processedTagValue;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._skipOnError !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipOnError = this._skipOnError;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tagAfterProcessing !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagAfterProcessing = this._tagAfterProcessing;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._visibilityTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibilityTimeout = this._visibilityTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputCrowdstrike | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsAccountId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._breakerRulesets = undefined;
      this._checkpointing.internalValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._enableSqsAssumeRole = undefined;
      this._encoding = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileFilter = undefined;
      this._id = undefined;
      this._maxMessages = undefined;
      this._metadata.internalValue = undefined;
      this._numReceivers = undefined;
      this._pipeline = undefined;
      this._pollTimeout = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._preprocess.internalValue = undefined;
      this._processedTagKey = undefined;
      this._processedTagValue = undefined;
      this._queueName = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._signatureVersion = undefined;
      this._skipOnError = undefined;
      this._socketTimeout = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tagAfterProcessing = undefined;
      this._type = undefined;
      this._visibilityTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsAccountId = value.awsAccountId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._breakerRulesets = value.breakerRulesets;
      this._checkpointing.internalValue = value.checkpointing;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enableSqsAssumeRole = value.enableSqsAssumeRole;
      this._encoding = value.encoding;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileFilter = value.fileFilter;
      this._id = value.id;
      this._maxMessages = value.maxMessages;
      this._metadata.internalValue = value.metadata;
      this._numReceivers = value.numReceivers;
      this._pipeline = value.pipeline;
      this._pollTimeout = value.pollTimeout;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._preprocess.internalValue = value.preprocess;
      this._processedTagKey = value.processedTagKey;
      this._processedTagValue = value.processedTagValue;
      this._queueName = value.queueName;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._signatureVersion = value.signatureVersion;
      this._skipOnError = value.skipOnError;
      this._socketTimeout = value.socketTimeout;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tagAfterProcessing = value.tagAfterProcessing;
      this._type = value.type;
      this._visibilityTimeout = value.visibilityTimeout;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_account_id - computed: false, optional: true, required: false
  private _awsAccountId?: string; 
  public get awsAccountId() {
    return this.getStringAttribute('aws_account_id');
  }
  public set awsAccountId(value: string) {
    this._awsAccountId = value;
  }
  public resetAwsAccountId() {
    this._awsAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccountIdInput() {
    return this._awsAccountId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // checkpointing - computed: false, optional: true, required: false
  private _checkpointing = new PackSourceInputCrowdstrikeCheckpointingOutputReference(this, "checkpointing");
  public get checkpointing() {
    return this._checkpointing;
  }
  public putCheckpointing(value: PackSourceInputCrowdstrikeCheckpointing) {
    this._checkpointing.internalValue = value;
  }
  public resetCheckpointing() {
    this._checkpointing.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkpointingInput() {
    return this._checkpointing.internalValue;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputCrowdstrikeConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputCrowdstrikeConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_sqs_assume_role - computed: true, optional: true, required: false
  private _enableSqsAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableSqsAssumeRole() {
    return this.getBooleanAttribute('enable_sqs_assume_role');
  }
  public set enableSqsAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableSqsAssumeRole = value;
  }
  public resetEnableSqsAssumeRole() {
    this._enableSqsAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSqsAssumeRoleInput() {
    return this._enableSqsAssumeRole;
  }

  // encoding - computed: false, optional: true, required: false
  private _encoding?: string; 
  public get encoding() {
    return this.getStringAttribute('encoding');
  }
  public set encoding(value: string) {
    this._encoding = value;
  }
  public resetEncoding() {
    this._encoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encodingInput() {
    return this._encoding;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_filter - computed: true, optional: true, required: false
  private _fileFilter?: string; 
  public get fileFilter() {
    return this.getStringAttribute('file_filter');
  }
  public set fileFilter(value: string) {
    this._fileFilter = value;
  }
  public resetFileFilter() {
    this._fileFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileFilterInput() {
    return this._fileFilter;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_messages - computed: true, optional: true, required: false
  private _maxMessages?: number; 
  public get maxMessages() {
    return this.getNumberAttribute('max_messages');
  }
  public set maxMessages(value: number) {
    this._maxMessages = value;
  }
  public resetMaxMessages() {
    this._maxMessages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMessagesInput() {
    return this._maxMessages;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputCrowdstrikeMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputCrowdstrikeMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // num_receivers - computed: true, optional: true, required: false
  private _numReceivers?: number; 
  public get numReceivers() {
    return this.getNumberAttribute('num_receivers');
  }
  public set numReceivers(value: number) {
    this._numReceivers = value;
  }
  public resetNumReceivers() {
    this._numReceivers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numReceiversInput() {
    return this._numReceivers;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // poll_timeout - computed: true, optional: true, required: false
  private _pollTimeout?: number; 
  public get pollTimeout() {
    return this.getNumberAttribute('poll_timeout');
  }
  public set pollTimeout(value: number) {
    this._pollTimeout = value;
  }
  public resetPollTimeout() {
    this._pollTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollTimeoutInput() {
    return this._pollTimeout;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputCrowdstrikePqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputCrowdstrikePq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // preprocess - computed: false, optional: true, required: false
  private _preprocess = new PackSourceInputCrowdstrikePreprocessOutputReference(this, "preprocess");
  public get preprocess() {
    return this._preprocess;
  }
  public putPreprocess(value: PackSourceInputCrowdstrikePreprocess) {
    this._preprocess.internalValue = value;
  }
  public resetPreprocess() {
    this._preprocess.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preprocessInput() {
    return this._preprocess.internalValue;
  }

  // processed_tag_key - computed: false, optional: true, required: false
  private _processedTagKey?: string; 
  public get processedTagKey() {
    return this.getStringAttribute('processed_tag_key');
  }
  public set processedTagKey(value: string) {
    this._processedTagKey = value;
  }
  public resetProcessedTagKey() {
    this._processedTagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagKeyInput() {
    return this._processedTagKey;
  }

  // processed_tag_value - computed: false, optional: true, required: false
  private _processedTagValue?: string; 
  public get processedTagValue() {
    return this.getStringAttribute('processed_tag_value');
  }
  public set processedTagValue(value: string) {
    this._processedTagValue = value;
  }
  public resetProcessedTagValue() {
    this._processedTagValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagValueInput() {
    return this._processedTagValue;
  }

  // queue_name - computed: false, optional: false, required: true
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // skip_on_error - computed: true, optional: true, required: false
  private _skipOnError?: boolean | cdktf.IResolvable; 
  public get skipOnError() {
    return this.getBooleanAttribute('skip_on_error');
  }
  public set skipOnError(value: boolean | cdktf.IResolvable) {
    this._skipOnError = value;
  }
  public resetSkipOnError() {
    this._skipOnError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipOnErrorInput() {
    return this._skipOnError;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tag_after_processing - computed: false, optional: true, required: false
  private _tagAfterProcessing?: string; 
  public get tagAfterProcessing() {
    return this.getStringAttribute('tag_after_processing');
  }
  public set tagAfterProcessing(value: string) {
    this._tagAfterProcessing = value;
  }
  public resetTagAfterProcessing() {
    this._tagAfterProcessing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagAfterProcessingInput() {
    return this._tagAfterProcessing;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // visibility_timeout - computed: true, optional: true, required: false
  private _visibilityTimeout?: number; 
  public get visibilityTimeout() {
    return this.getNumberAttribute('visibility_timeout');
  }
  public set visibilityTimeout(value: number) {
    this._visibilityTimeout = value;
  }
  public resetVisibilityTimeout() {
    this._visibilityTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityTimeoutInput() {
    return this._visibilityTimeout;
  }
}
export interface PackSourceInputDatadogAgentConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputDatadogAgentConnectionsToTerraform(struct?: PackSourceInputDatadogAgentConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputDatadogAgentConnectionsToHclTerraform(struct?: PackSourceInputDatadogAgentConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputDatadogAgentConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputDatadogAgentConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputDatadogAgentConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputDatadogAgentConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputDatadogAgentConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputDatadogAgentConnectionsOutputReference {
    return new PackSourceInputDatadogAgentConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputDatadogAgentMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputDatadogAgentMetadataToTerraform(struct?: PackSourceInputDatadogAgentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputDatadogAgentMetadataToHclTerraform(struct?: PackSourceInputDatadogAgentMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputDatadogAgentMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputDatadogAgentMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputDatadogAgentMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputDatadogAgentMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputDatadogAgentMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputDatadogAgentMetadataOutputReference {
    return new PackSourceInputDatadogAgentMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputDatadogAgentPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputDatadogAgentPqToTerraform(struct?: PackSourceInputDatadogAgentPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputDatadogAgentPqToHclTerraform(struct?: PackSourceInputDatadogAgentPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputDatadogAgentPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputDatadogAgentPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputDatadogAgentPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputDatadogAgentProxyMode {
  /**
  * Toggle to Yes to send key validation requests from Datadog Agent to the Datadog API. If toggled to No (the default), Stream handles key validation requests by always responding that the key is valid. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enabled PackSource#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates). Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
}

export function packSourceInputDatadogAgentProxyModeToTerraform(struct?: PackSourceInputDatadogAgentProxyMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
  }
}


export function packSourceInputDatadogAgentProxyModeToHclTerraform(struct?: PackSourceInputDatadogAgentProxyMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputDatadogAgentProxyModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputDatadogAgentProxyMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputDatadogAgentProxyMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._rejectUnauthorized = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._rejectUnauthorized = value.rejectUnauthorized;
    }
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }
}
export interface PackSourceInputDatadogAgentTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputDatadogAgentTlsToTerraform(struct?: PackSourceInputDatadogAgentTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputDatadogAgentTlsToHclTerraform(struct?: PackSourceInputDatadogAgentTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputDatadogAgentTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputDatadogAgentTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputDatadogAgentTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputDatadogAgent {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputDatadogAgentConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#extract_metrics PackSource#extract_metrics}
  */
  readonly extractMetrics?: boolean | cdktf.IResolvable;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputDatadogAgentMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputDatadogAgentPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#proxy_mode PackSource#proxy_mode}
  */
  readonly proxyMode?: PackSourceInputDatadogAgentProxyMode;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputDatadogAgentTls;
  /**
  * must be "datadog_agent"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputDatadogAgentToTerraform(struct?: PackSourceInputDatadogAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputDatadogAgentConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    extract_metrics: cdktf.booleanToTerraform(struct!.extractMetrics),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputDatadogAgentMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputDatadogAgentPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    proxy_mode: packSourceInputDatadogAgentProxyModeToTerraform(struct!.proxyMode),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputDatadogAgentTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputDatadogAgentToHclTerraform(struct?: PackSourceInputDatadogAgent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputDatadogAgentConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputDatadogAgentConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extract_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.extractMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputDatadogAgentMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputDatadogAgentMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputDatadogAgentPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputDatadogAgentPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_mode: {
      value: packSourceInputDatadogAgentProxyModeToHclTerraform(struct!.proxyMode),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputDatadogAgentProxyMode",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputDatadogAgentTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputDatadogAgentTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputDatadogAgentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputDatadogAgent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extractMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractMetrics = this._extractMetrics;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._proxyMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyMode = this._proxyMode?.internalValue;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputDatadogAgent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._extractMetrics = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._proxyMode.internalValue = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._extractMetrics = value.extractMetrics;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._proxyMode.internalValue = value.proxyMode;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputDatadogAgentConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputDatadogAgentConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extract_metrics - computed: true, optional: true, required: false
  private _extractMetrics?: boolean | cdktf.IResolvable; 
  public get extractMetrics() {
    return this.getBooleanAttribute('extract_metrics');
  }
  public set extractMetrics(value: boolean | cdktf.IResolvable) {
    this._extractMetrics = value;
  }
  public resetExtractMetrics() {
    this._extractMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractMetricsInput() {
    return this._extractMetrics;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputDatadogAgentMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputDatadogAgentMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputDatadogAgentPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputDatadogAgentPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // proxy_mode - computed: false, optional: true, required: false
  private _proxyMode = new PackSourceInputDatadogAgentProxyModeOutputReference(this, "proxy_mode");
  public get proxyMode() {
    return this._proxyMode;
  }
  public putProxyMode(value: PackSourceInputDatadogAgentProxyMode) {
    this._proxyMode.internalValue = value;
  }
  public resetProxyMode() {
    this._proxyMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyModeInput() {
    return this._proxyMode.internalValue;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputDatadogAgentTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputDatadogAgentTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputDatagenConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputDatagenConnectionsToTerraform(struct?: PackSourceInputDatagenConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputDatagenConnectionsToHclTerraform(struct?: PackSourceInputDatagenConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputDatagenConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputDatagenConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputDatagenConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputDatagenConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputDatagenConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputDatagenConnectionsOutputReference {
    return new PackSourceInputDatagenConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputDatagenMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputDatagenMetadataToTerraform(struct?: PackSourceInputDatagenMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputDatagenMetadataToHclTerraform(struct?: PackSourceInputDatagenMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputDatagenMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputDatagenMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputDatagenMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputDatagenMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputDatagenMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputDatagenMetadataOutputReference {
    return new PackSourceInputDatagenMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputDatagenPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputDatagenPqToTerraform(struct?: PackSourceInputDatagenPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputDatagenPqToHclTerraform(struct?: PackSourceInputDatagenPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputDatagenPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputDatagenPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputDatagenPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputDatagenSamples {
  /**
  * Maximum number of events to generate per second per Worker Node. Defaults to 10. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#events_per_sec PackSource#events_per_sec}
  */
  readonly eventsPerSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#sample PackSource#sample}
  */
  readonly sample: string;
}

export function packSourceInputDatagenSamplesToTerraform(struct?: PackSourceInputDatagenSamples | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    events_per_sec: cdktf.numberToTerraform(struct!.eventsPerSec),
    sample: cdktf.stringToTerraform(struct!.sample),
  }
}


export function packSourceInputDatagenSamplesToHclTerraform(struct?: PackSourceInputDatagenSamples | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    events_per_sec: {
      value: cdktf.numberToHclTerraform(struct!.eventsPerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sample: {
      value: cdktf.stringToHclTerraform(struct!.sample),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputDatagenSamplesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputDatagenSamples | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._eventsPerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventsPerSec = this._eventsPerSec;
    }
    if (this._sample !== undefined) {
      hasAnyValues = true;
      internalValueResult.sample = this._sample;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputDatagenSamples | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._eventsPerSec = undefined;
      this._sample = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._eventsPerSec = value.eventsPerSec;
      this._sample = value.sample;
    }
  }

  // events_per_sec - computed: true, optional: true, required: false
  private _eventsPerSec?: number; 
  public get eventsPerSec() {
    return this.getNumberAttribute('events_per_sec');
  }
  public set eventsPerSec(value: number) {
    this._eventsPerSec = value;
  }
  public resetEventsPerSec() {
    this._eventsPerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventsPerSecInput() {
    return this._eventsPerSec;
  }

  // sample - computed: false, optional: false, required: true
  private _sample?: string; 
  public get sample() {
    return this.getStringAttribute('sample');
  }
  public set sample(value: string) {
    this._sample = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sampleInput() {
    return this._sample;
  }
}

export class PackSourceInputDatagenSamplesList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputDatagenSamples[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputDatagenSamplesOutputReference {
    return new PackSourceInputDatagenSamplesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputDatagen {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputDatagenConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputDatagenMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputDatagenPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#samples PackSource#samples}
  */
  readonly samples: PackSourceInputDatagenSamples[] | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "datagen"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
}

export function packSourceInputDatagenToTerraform(struct?: PackSourceInputDatagen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputDatagenConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    metadata: cdktf.listMapper(packSourceInputDatagenMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputDatagenPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    samples: cdktf.listMapper(packSourceInputDatagenSamplesToTerraform, false)(struct!.samples),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputDatagenToHclTerraform(struct?: PackSourceInputDatagen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputDatagenConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputDatagenConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputDatagenMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputDatagenMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputDatagenPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputDatagenPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    samples: {
      value: cdktf.listMapperHcl(packSourceInputDatagenSamplesToHclTerraform, false)(struct!.samples),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputDatagenSamplesList",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputDatagenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputDatagen | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._samples?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.samples = this._samples?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputDatagen | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._samples.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._samples.internalValue = value.samples;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputDatagenConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputDatagenConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputDatagenMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputDatagenMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputDatagenPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputDatagenPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // samples - computed: false, optional: false, required: true
  private _samples = new PackSourceInputDatagenSamplesList(this, "samples", false);
  public get samples() {
    return this._samples;
  }
  public putSamples(value: PackSourceInputDatagenSamples[] | cdktf.IResolvable) {
    this._samples.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get samplesInput() {
    return this._samples.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputEdgePrometheusConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputEdgePrometheusConnectionsToTerraform(struct?: PackSourceInputEdgePrometheusConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputEdgePrometheusConnectionsToHclTerraform(struct?: PackSourceInputEdgePrometheusConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEdgePrometheusConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputEdgePrometheusConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEdgePrometheusConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputEdgePrometheusConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputEdgePrometheusConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputEdgePrometheusConnectionsOutputReference {
    return new PackSourceInputEdgePrometheusConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputEdgePrometheusMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputEdgePrometheusMetadataToTerraform(struct?: PackSourceInputEdgePrometheusMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputEdgePrometheusMetadataToHclTerraform(struct?: PackSourceInputEdgePrometheusMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEdgePrometheusMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputEdgePrometheusMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEdgePrometheusMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputEdgePrometheusMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputEdgePrometheusMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputEdgePrometheusMetadataOutputReference {
    return new PackSourceInputEdgePrometheusMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputEdgePrometheusPersistence {
  /**
  * Data compression format. Default is gzip. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * Spool events on disk for Cribl Edge and Search. Default is disabled. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_size PackSource#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_time PackSource#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * Time period for grouping spooled events. Default is 10m. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#time_window PackSource#time_window}
  */
  readonly timeWindow?: string;
}

export function packSourceInputEdgePrometheusPersistenceToTerraform(struct?: PackSourceInputEdgePrometheusPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
  }
}


export function packSourceInputEdgePrometheusPersistenceToHclTerraform(struct?: PackSourceInputEdgePrometheusPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEdgePrometheusPersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputEdgePrometheusPersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEdgePrometheusPersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._enable = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._timeWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._enable = value.enable;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._timeWindow = value.timeWindow;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }
}
export interface PackSourceInputEdgePrometheusPodFilter {
  /**
  * Optional description of this rule's purpose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * JavaScript expression applied to pods objects. Return 'true' to include it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#filter PackSource#filter}
  */
  readonly filter: string;
}

export function packSourceInputEdgePrometheusPodFilterToTerraform(struct?: PackSourceInputEdgePrometheusPodFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
  }
}


export function packSourceInputEdgePrometheusPodFilterToHclTerraform(struct?: PackSourceInputEdgePrometheusPodFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEdgePrometheusPodFilterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputEdgePrometheusPodFilter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEdgePrometheusPodFilter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._filter = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._filter = value.filter;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }
}

export class PackSourceInputEdgePrometheusPodFilterList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputEdgePrometheusPodFilter[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputEdgePrometheusPodFilterOutputReference {
    return new PackSourceInputEdgePrometheusPodFilterOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputEdgePrometheusPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputEdgePrometheusPqToTerraform(struct?: PackSourceInputEdgePrometheusPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputEdgePrometheusPqToHclTerraform(struct?: PackSourceInputEdgePrometheusPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEdgePrometheusPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputEdgePrometheusPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEdgePrometheusPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputEdgePrometheusSearchFilter {
  /**
  * Search filter attribute name, see: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html for more information. Attributes can be manually entered if not present in the drop down list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * Search Filter Values, if empty only "running" EC2 instances will be returned. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#values PackSource#values}
  */
  readonly values?: string[];
}

export function packSourceInputEdgePrometheusSearchFilterToTerraform(struct?: PackSourceInputEdgePrometheusSearchFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function packSourceInputEdgePrometheusSearchFilterToHclTerraform(struct?: PackSourceInputEdgePrometheusSearchFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEdgePrometheusSearchFilterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputEdgePrometheusSearchFilter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEdgePrometheusSearchFilter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._values = value.values;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // values - computed: true, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class PackSourceInputEdgePrometheusSearchFilterList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputEdgePrometheusSearchFilter[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputEdgePrometheusSearchFilterOutputReference {
    return new PackSourceInputEdgePrometheusSearchFilterOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputEdgePrometheusTargets {
  /**
  * Name of host from which to pull metrics.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host: string;
  /**
  * Path to use when collecting metrics from discovered targets. Default: "/metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
  /**
  * The port number in the metrics URL for discovered targets. Default: 9090
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port?: number;
  /**
  * Protocol to use when collecting metrics. Default: "http"; must be one of ["http", "https"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#protocol PackSource#protocol}
  */
  readonly protocol?: string;
}

export function packSourceInputEdgePrometheusTargetsToTerraform(struct?: PackSourceInputEdgePrometheusTargets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    path: cdktf.stringToTerraform(struct!.path),
    port: cdktf.numberToTerraform(struct!.port),
    protocol: cdktf.stringToTerraform(struct!.protocol),
  }
}


export function packSourceInputEdgePrometheusTargetsToHclTerraform(struct?: PackSourceInputEdgePrometheusTargets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEdgePrometheusTargetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputEdgePrometheusTargets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEdgePrometheusTargets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._path = undefined;
      this._port = undefined;
      this._protocol = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._path = value.path;
      this._port = value.port;
      this._protocol = value.protocol;
    }
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }
}

export class PackSourceInputEdgePrometheusTargetsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputEdgePrometheusTargets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputEdgePrometheusTargetsOutputReference {
    return new PackSourceInputEdgePrometheusTargetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputEdgePrometheus {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_arn PackSource#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_external_id PackSource#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Enter credentials directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret", "kubernetes"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_authentication_method PackSource#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret_key PackSource#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputEdgePrometheusConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Other dimensions to include in events. Default: ["host","source"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#dimension_list PackSource#dimension_list}
  */
  readonly dimensionList?: string[];
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Target discovery mechanism. Use static to manually enter a list of targets. Default: "static"; must be one of ["static", "dns", "ec2", "k8s-node", "k8s-pods"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#discovery_type PackSource#discovery_type}
  */
  readonly discoveryType?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#duration_seconds PackSource#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access EC2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_assume_role PackSource#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint PackSource#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * How often in seconds to scrape targets for metrics. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputEdgePrometheusMetadata[] | cdktf.IResolvable;
  /**
  * List of DNS names to resolve. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name_list PackSource#name_list}
  */
  readonly nameList?: string[];
  /**
  * Password for Prometheus Basic authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#password PackSource#password}
  */
  readonly password?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#persistence PackSource#persistence}
  */
  readonly persistence?: PackSourceInputEdgePrometheusPersistence;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Add rules to decide which pods to discover for metrics.
  *   Pods are searched if no rules are given or of all the rules'
  *   expressions evaluate to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pod_filter PackSource#pod_filter}
  */
  readonly podFilter?: PackSourceInputEdgePrometheusPodFilter[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputEdgePrometheusPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * DNS Record type to resolve. Default: "SRV"; must be one of ["SRV", "A", "AAAA"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#record_type PackSource#record_type}
  */
  readonly recordType?: string;
  /**
  * Region where the EC2 is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#region PackSource#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reuse_connections PackSource#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Path to use when collecting metrics from discovered targets. Default: "/metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#scrape_path PackSource#scrape_path}
  */
  readonly scrapePath?: string;
  /**
  * Path to use when collecting metrics from discovered targets. Default: "metadata.annotations['prometheus.io/path'] || '/metrics'"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#scrape_path_expr PackSource#scrape_path_expr}
  */
  readonly scrapePathExpr?: string;
  /**
  * The port number in the metrics URL for discovered targets. Default: 9090
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#scrape_port PackSource#scrape_port}
  */
  readonly scrapePort?: number;
  /**
  * The port number in the metrics URL for discovered targets. Default: "metadata.annotations['prometheus.io/port'] || 9090"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#scrape_port_expr PackSource#scrape_port_expr}
  */
  readonly scrapePortExpr?: string;
  /**
  * Protocol to use when collecting metrics. Default: "http"; must be one of ["http", "https"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#scrape_protocol PackSource#scrape_protocol}
  */
  readonly scrapeProtocol?: string;
  /**
  * Protocol to use when collecting metrics. Default: "metadata.annotations['prometheus.io/scheme'] || 'http'"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#scrape_protocol_expr PackSource#scrape_protocol_expr}
  */
  readonly scrapeProtocolExpr?: string;
  /**
  * EC2 Instance Search Filter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#search_filter PackSource#search_filter}
  */
  readonly searchFilter?: PackSourceInputEdgePrometheusSearchFilter[] | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing EC2 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#signature_version PackSource#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#targets PackSource#targets}
  */
  readonly targets?: PackSourceInputEdgePrometheusTargets[] | cdktf.IResolvable;
  /**
  * Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable. Default: 5000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#timeout PackSource#timeout}
  */
  readonly timeout?: number;
  /**
  * must be "edge_prometheus"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * Use public IP address for discovered targets. Set to false if the private IP address should be used. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#use_public_ip PackSource#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
  /**
  * Username for Prometheus Basic authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#username PackSource#username}
  */
  readonly username?: string;
}

export function packSourceInputEdgePrometheusToTerraform(struct?: PackSourceInputEdgePrometheus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    connections: cdktf.listMapper(packSourceInputEdgePrometheusConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    dimension_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.dimensionList),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    discovery_type: cdktf.stringToTerraform(struct!.discoveryType),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    metadata: cdktf.listMapper(packSourceInputEdgePrometheusMetadataToTerraform, false)(struct!.metadata),
    name_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameList),
    password: cdktf.stringToTerraform(struct!.password),
    persistence: packSourceInputEdgePrometheusPersistenceToTerraform(struct!.persistence),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pod_filter: cdktf.listMapper(packSourceInputEdgePrometheusPodFilterToTerraform, false)(struct!.podFilter),
    pq: packSourceInputEdgePrometheusPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    record_type: cdktf.stringToTerraform(struct!.recordType),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    scrape_path: cdktf.stringToTerraform(struct!.scrapePath),
    scrape_path_expr: cdktf.stringToTerraform(struct!.scrapePathExpr),
    scrape_port: cdktf.numberToTerraform(struct!.scrapePort),
    scrape_port_expr: cdktf.stringToTerraform(struct!.scrapePortExpr),
    scrape_protocol: cdktf.stringToTerraform(struct!.scrapeProtocol),
    scrape_protocol_expr: cdktf.stringToTerraform(struct!.scrapeProtocolExpr),
    search_filter: cdktf.listMapper(packSourceInputEdgePrometheusSearchFilterToTerraform, false)(struct!.searchFilter),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    targets: cdktf.listMapper(packSourceInputEdgePrometheusTargetsToTerraform, false)(struct!.targets),
    timeout: cdktf.numberToTerraform(struct!.timeout),
    type: cdktf.stringToTerraform(struct!.type),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packSourceInputEdgePrometheusToHclTerraform(struct?: PackSourceInputEdgePrometheus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputEdgePrometheusConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputEdgePrometheusConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dimension_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.dimensionList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    discovery_type: {
      value: cdktf.stringToHclTerraform(struct!.discoveryType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputEdgePrometheusMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputEdgePrometheusMetadataList",
    },
    name_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    persistence: {
      value: packSourceInputEdgePrometheusPersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputEdgePrometheusPersistence",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pod_filter: {
      value: cdktf.listMapperHcl(packSourceInputEdgePrometheusPodFilterToHclTerraform, false)(struct!.podFilter),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputEdgePrometheusPodFilterList",
    },
    pq: {
      value: packSourceInputEdgePrometheusPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputEdgePrometheusPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    record_type: {
      value: cdktf.stringToHclTerraform(struct!.recordType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    scrape_path: {
      value: cdktf.stringToHclTerraform(struct!.scrapePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scrape_path_expr: {
      value: cdktf.stringToHclTerraform(struct!.scrapePathExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scrape_port: {
      value: cdktf.numberToHclTerraform(struct!.scrapePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    scrape_port_expr: {
      value: cdktf.stringToHclTerraform(struct!.scrapePortExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scrape_protocol: {
      value: cdktf.stringToHclTerraform(struct!.scrapeProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scrape_protocol_expr: {
      value: cdktf.stringToHclTerraform(struct!.scrapeProtocolExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    search_filter: {
      value: cdktf.listMapperHcl(packSourceInputEdgePrometheusSearchFilterToHclTerraform, false)(struct!.searchFilter),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputEdgePrometheusSearchFilterList",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    targets: {
      value: cdktf.listMapperHcl(packSourceInputEdgePrometheusTargetsToHclTerraform, false)(struct!.targets),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputEdgePrometheusTargetsList",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEdgePrometheusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputEdgePrometheus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dimensionList !== undefined) {
      hasAnyValues = true;
      internalValueResult.dimensionList = this._dimensionList;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._discoveryType !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryType = this._discoveryType;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._nameList !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameList = this._nameList;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._podFilter?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podFilter = this._podFilter?.internalValue;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._recordType !== undefined) {
      hasAnyValues = true;
      internalValueResult.recordType = this._recordType;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._scrapePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapePath = this._scrapePath;
    }
    if (this._scrapePathExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapePathExpr = this._scrapePathExpr;
    }
    if (this._scrapePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapePort = this._scrapePort;
    }
    if (this._scrapePortExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapePortExpr = this._scrapePortExpr;
    }
    if (this._scrapeProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapeProtocol = this._scrapeProtocol;
    }
    if (this._scrapeProtocolExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapeProtocolExpr = this._scrapeProtocolExpr;
    }
    if (this._searchFilter?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchFilter = this._searchFilter?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._targets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.targets = this._targets?.internalValue;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEdgePrometheus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._authType = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecretKey = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._dimensionList = undefined;
      this._disabled = undefined;
      this._discoveryType = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._metadata.internalValue = undefined;
      this._nameList = undefined;
      this._password = undefined;
      this._persistence.internalValue = undefined;
      this._pipeline = undefined;
      this._podFilter.internalValue = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._recordType = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._scrapePath = undefined;
      this._scrapePathExpr = undefined;
      this._scrapePort = undefined;
      this._scrapePortExpr = undefined;
      this._scrapeProtocol = undefined;
      this._scrapeProtocolExpr = undefined;
      this._searchFilter.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._targets.internalValue = undefined;
      this._timeout = undefined;
      this._type = undefined;
      this._usePublicIp = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._authType = value.authType;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecretKey = value.awsSecretKey;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._dimensionList = value.dimensionList;
      this._disabled = value.disabled;
      this._discoveryType = value.discoveryType;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._id = value.id;
      this._interval = value.interval;
      this._metadata.internalValue = value.metadata;
      this._nameList = value.nameList;
      this._password = value.password;
      this._persistence.internalValue = value.persistence;
      this._pipeline = value.pipeline;
      this._podFilter.internalValue = value.podFilter;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._recordType = value.recordType;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._scrapePath = value.scrapePath;
      this._scrapePathExpr = value.scrapePathExpr;
      this._scrapePort = value.scrapePort;
      this._scrapePortExpr = value.scrapePortExpr;
      this._scrapeProtocol = value.scrapeProtocol;
      this._scrapeProtocolExpr = value.scrapeProtocolExpr;
      this._searchFilter.internalValue = value.searchFilter;
      this._sendToRoutes = value.sendToRoutes;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._targets.internalValue = value.targets;
      this._timeout = value.timeout;
      this._type = value.type;
      this._usePublicIp = value.usePublicIp;
      this._username = value.username;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputEdgePrometheusConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputEdgePrometheusConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dimension_list - computed: true, optional: true, required: false
  private _dimensionList?: string[]; 
  public get dimensionList() {
    return this.getListAttribute('dimension_list');
  }
  public set dimensionList(value: string[]) {
    this._dimensionList = value;
  }
  public resetDimensionList() {
    this._dimensionList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dimensionListInput() {
    return this._dimensionList;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // discovery_type - computed: true, optional: true, required: false
  private _discoveryType?: string; 
  public get discoveryType() {
    return this.getStringAttribute('discovery_type');
  }
  public set discoveryType(value: string) {
    this._discoveryType = value;
  }
  public resetDiscoveryType() {
    this._discoveryType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryTypeInput() {
    return this._discoveryType;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputEdgePrometheusMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputEdgePrometheusMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // name_list - computed: true, optional: true, required: false
  private _nameList?: string[]; 
  public get nameList() {
    return this.getListAttribute('name_list');
  }
  public set nameList(value: string[]) {
    this._nameList = value;
  }
  public resetNameList() {
    this._nameList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameListInput() {
    return this._nameList;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // persistence - computed: false, optional: true, required: false
  private _persistence = new PackSourceInputEdgePrometheusPersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: PackSourceInputEdgePrometheusPersistence) {
    this._persistence.internalValue = value;
  }
  public resetPersistence() {
    this._persistence.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pod_filter - computed: false, optional: true, required: false
  private _podFilter = new PackSourceInputEdgePrometheusPodFilterList(this, "pod_filter", false);
  public get podFilter() {
    return this._podFilter;
  }
  public putPodFilter(value: PackSourceInputEdgePrometheusPodFilter[] | cdktf.IResolvable) {
    this._podFilter.internalValue = value;
  }
  public resetPodFilter() {
    this._podFilter.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podFilterInput() {
    return this._podFilter.internalValue;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputEdgePrometheusPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputEdgePrometheusPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // record_type - computed: true, optional: true, required: false
  private _recordType?: string; 
  public get recordType() {
    return this.getStringAttribute('record_type');
  }
  public set recordType(value: string) {
    this._recordType = value;
  }
  public resetRecordType() {
    this._recordType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recordTypeInput() {
    return this._recordType;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // scrape_path - computed: true, optional: true, required: false
  private _scrapePath?: string; 
  public get scrapePath() {
    return this.getStringAttribute('scrape_path');
  }
  public set scrapePath(value: string) {
    this._scrapePath = value;
  }
  public resetScrapePath() {
    this._scrapePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapePathInput() {
    return this._scrapePath;
  }

  // scrape_path_expr - computed: true, optional: true, required: false
  private _scrapePathExpr?: string; 
  public get scrapePathExpr() {
    return this.getStringAttribute('scrape_path_expr');
  }
  public set scrapePathExpr(value: string) {
    this._scrapePathExpr = value;
  }
  public resetScrapePathExpr() {
    this._scrapePathExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapePathExprInput() {
    return this._scrapePathExpr;
  }

  // scrape_port - computed: true, optional: true, required: false
  private _scrapePort?: number; 
  public get scrapePort() {
    return this.getNumberAttribute('scrape_port');
  }
  public set scrapePort(value: number) {
    this._scrapePort = value;
  }
  public resetScrapePort() {
    this._scrapePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapePortInput() {
    return this._scrapePort;
  }

  // scrape_port_expr - computed: true, optional: true, required: false
  private _scrapePortExpr?: string; 
  public get scrapePortExpr() {
    return this.getStringAttribute('scrape_port_expr');
  }
  public set scrapePortExpr(value: string) {
    this._scrapePortExpr = value;
  }
  public resetScrapePortExpr() {
    this._scrapePortExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapePortExprInput() {
    return this._scrapePortExpr;
  }

  // scrape_protocol - computed: true, optional: true, required: false
  private _scrapeProtocol?: string; 
  public get scrapeProtocol() {
    return this.getStringAttribute('scrape_protocol');
  }
  public set scrapeProtocol(value: string) {
    this._scrapeProtocol = value;
  }
  public resetScrapeProtocol() {
    this._scrapeProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapeProtocolInput() {
    return this._scrapeProtocol;
  }

  // scrape_protocol_expr - computed: true, optional: true, required: false
  private _scrapeProtocolExpr?: string; 
  public get scrapeProtocolExpr() {
    return this.getStringAttribute('scrape_protocol_expr');
  }
  public set scrapeProtocolExpr(value: string) {
    this._scrapeProtocolExpr = value;
  }
  public resetScrapeProtocolExpr() {
    this._scrapeProtocolExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapeProtocolExprInput() {
    return this._scrapeProtocolExpr;
  }

  // search_filter - computed: false, optional: true, required: false
  private _searchFilter = new PackSourceInputEdgePrometheusSearchFilterList(this, "search_filter", false);
  public get searchFilter() {
    return this._searchFilter;
  }
  public putSearchFilter(value: PackSourceInputEdgePrometheusSearchFilter[] | cdktf.IResolvable) {
    this._searchFilter.internalValue = value;
  }
  public resetSearchFilter() {
    this._searchFilter.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get searchFilterInput() {
    return this._searchFilter.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // targets - computed: false, optional: true, required: false
  private _targets = new PackSourceInputEdgePrometheusTargetsList(this, "targets", false);
  public get targets() {
    return this._targets;
  }
  public putTargets(value: PackSourceInputEdgePrometheusTargets[] | cdktf.IResolvable) {
    this._targets.internalValue = value;
  }
  public resetTargets() {
    this._targets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetsInput() {
    return this._targets.internalValue;
  }

  // timeout - computed: true, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_public_ip - computed: true, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackSourceInputElasticConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputElasticConnectionsToTerraform(struct?: PackSourceInputElasticConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputElasticConnectionsToHclTerraform(struct?: PackSourceInputElasticConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputElasticConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputElasticConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputElasticConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputElasticConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputElasticConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputElasticConnectionsOutputReference {
    return new PackSourceInputElasticConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputElasticExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputElasticExtraHttpHeadersToTerraform(struct?: PackSourceInputElasticExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputElasticExtraHttpHeadersToHclTerraform(struct?: PackSourceInputElasticExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputElasticExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputElasticExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputElasticExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputElasticExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputElasticExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputElasticExtraHttpHeadersOutputReference {
    return new PackSourceInputElasticExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputElasticMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputElasticMetadataToTerraform(struct?: PackSourceInputElasticMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputElasticMetadataToHclTerraform(struct?: PackSourceInputElasticMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputElasticMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputElasticMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputElasticMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputElasticMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputElasticMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputElasticMetadataOutputReference {
    return new PackSourceInputElasticMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputElasticPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputElasticPqToTerraform(struct?: PackSourceInputElasticPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputElasticPqToHclTerraform(struct?: PackSourceInputElasticPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputElasticPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputElasticPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputElasticPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputElasticProxyMode {
  /**
  * Enter credentials directly, or select a stored secret. Default: "none"; must be one of ["none", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Enable proxying of non-bulk API requests to an external Elastic server. Enable this only if you understand the implications. See [Cribl Docs](https://docs.cribl.io/stream/sources-elastic/#proxy-mode) for more details. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enabled PackSource#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * List of headers to remove from the request to proxy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#remove_headers PackSource#remove_headers}
  */
  readonly removeHeaders?: string[];
  /**
  * Amount of time, in seconds, to wait for a proxy request to complete before canceling it. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#timeout_sec PackSource#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * URL of the Elastic server to proxy non-bulk requests to, such as http://elastic:9200
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#url PackSource#url}
  */
  readonly url?: string;
}

export function packSourceInputElasticProxyModeToTerraform(struct?: PackSourceInputElasticProxyMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.removeHeaders),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function packSourceInputElasticProxyModeToHclTerraform(struct?: PackSourceInputElasticProxyMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.removeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputElasticProxyModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputElasticProxyMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeHeaders = this._removeHeaders;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputElasticProxyMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._enabled = undefined;
      this._rejectUnauthorized = undefined;
      this._removeHeaders = undefined;
      this._timeoutSec = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._enabled = value.enabled;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeHeaders = value.removeHeaders;
      this._timeoutSec = value.timeoutSec;
      this._url = value.url;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_headers - computed: false, optional: true, required: false
  private _removeHeaders?: string[]; 
  public get removeHeaders() {
    return this.getListAttribute('remove_headers');
  }
  public set removeHeaders(value: string[]) {
    this._removeHeaders = value;
  }
  public resetRemoveHeaders() {
    this._removeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeHeadersInput() {
    return this._removeHeaders;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface PackSourceInputElasticTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputElasticTlsToTerraform(struct?: PackSourceInputElasticTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputElasticTlsToHclTerraform(struct?: PackSourceInputElasticTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputElasticTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputElasticTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputElasticTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputElastic {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * The API version to use for communicating with the server. Default: "8.3.2"; must be one of ["6.8.4", "8.3.2", "custom"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#api_version PackSource#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Bearer tokens to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_tokens PackSource#auth_tokens}
  */
  readonly authTokens?: string[];
  /**
  * Default: "none"; must be one of ["none", "basic", "credentialsSecret", "authTokens"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputElasticConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Custom version information to respond to requests. Default: "{\n    \"name\": \"AzU84iL\",\n    \"cluster_name\": \"cribl\",\n    \"cluster_uuid\": \"Js6_Z2VKS3KbfRSxPmPbaw\",\n    \"version\": {\n        \"number\": \"8.3.2\",\n        \"build_type\": \"tar\",\n        \"build_hash\": \"bca0c8d\",\n        \"build_date\": \"2019-10-16T06:19:49.319352Z\",\n        \"build_snapshot\": false,\n        \"lucene_version\": \"9.7.2\",\n        \"minimum_wire_compatibility_version\": \"7.17.0\",\n        \"minimum_index_compatibility_version\": \"7.0.0\"\n    },\n    \"tagline\": \"You Know, for Search\"\n}"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#custom_api_version PackSource#custom_api_version}
  */
  readonly customApiVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success. Default: "/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#elastic_api PackSource#elastic_api}
  */
  readonly elasticApi?: string;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#extra_http_headers PackSource#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackSourceInputElasticExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputElasticMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#password PackSource#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputElasticPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#proxy_mode PackSource#proxy_mode}
  */
  readonly proxyMode?: PackSourceInputElasticProxyMode;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputElasticTls;
  /**
  * must be "elastic"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#username PackSource#username}
  */
  readonly username?: string;
}

export function packSourceInputElasticToTerraform(struct?: PackSourceInputElastic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    auth_tokens: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.authTokens),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputElasticConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    custom_api_version: cdktf.stringToTerraform(struct!.customApiVersion),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    elastic_api: cdktf.stringToTerraform(struct!.elasticApi),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packSourceInputElasticExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputElasticMetadataToTerraform, false)(struct!.metadata),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputElasticPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    proxy_mode: packSourceInputElasticProxyModeToTerraform(struct!.proxyMode),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputElasticTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packSourceInputElasticToHclTerraform(struct?: PackSourceInputElastic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.authTokens),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputElasticConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputElasticConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_api_version: {
      value: cdktf.stringToHclTerraform(struct!.customApiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    elastic_api: {
      value: cdktf.stringToHclTerraform(struct!.elasticApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packSourceInputElasticExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputElasticExtraHttpHeadersList",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputElasticMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputElasticMetadataList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputElasticPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputElasticPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy_mode: {
      value: packSourceInputElasticProxyModeToHclTerraform(struct!.proxyMode),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputElasticProxyMode",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputElasticTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputElasticTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputElasticOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputElastic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._authTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._customApiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.customApiVersion = this._customApiVersion;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._elasticApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.elasticApi = this._elasticApi;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._proxyMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyMode = this._proxyMode?.internalValue;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputElastic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._apiVersion = undefined;
      this._authTokens = undefined;
      this._authType = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._customApiVersion = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._elasticApi = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._proxyMode.internalValue = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._apiVersion = value.apiVersion;
      this._authTokens = value.authTokens;
      this._authType = value.authType;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._customApiVersion = value.customApiVersion;
      this._description = value.description;
      this._disabled = value.disabled;
      this._elasticApi = value.elasticApi;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._proxyMode.internalValue = value.proxyMode;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._username = value.username;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // api_version - computed: true, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens?: string[]; 
  public get authTokens() {
    return this.getListAttribute('auth_tokens');
  }
  public set authTokens(value: string[]) {
    this._authTokens = value;
  }
  public resetAuthTokens() {
    this._authTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputElasticConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputElasticConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // custom_api_version - computed: true, optional: true, required: false
  private _customApiVersion?: string; 
  public get customApiVersion() {
    return this.getStringAttribute('custom_api_version');
  }
  public set customApiVersion(value: string) {
    this._customApiVersion = value;
  }
  public resetCustomApiVersion() {
    this._customApiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customApiVersionInput() {
    return this._customApiVersion;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // elastic_api - computed: true, optional: true, required: false
  private _elasticApi?: string; 
  public get elasticApi() {
    return this.getStringAttribute('elastic_api');
  }
  public set elasticApi(value: string) {
    this._elasticApi = value;
  }
  public resetElasticApi() {
    this._elasticApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticApiInput() {
    return this._elasticApi;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackSourceInputElasticExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackSourceInputElasticExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputElasticMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputElasticMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputElasticPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputElasticPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // proxy_mode - computed: false, optional: true, required: false
  private _proxyMode = new PackSourceInputElasticProxyModeOutputReference(this, "proxy_mode");
  public get proxyMode() {
    return this._proxyMode;
  }
  public putProxyMode(value: PackSourceInputElasticProxyMode) {
    this._proxyMode.internalValue = value;
  }
  public resetProxyMode() {
    this._proxyMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyModeInput() {
    return this._proxyMode.internalValue;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputElasticTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputElasticTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackSourceInputEventhubConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputEventhubConnectionsToTerraform(struct?: PackSourceInputEventhubConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputEventhubConnectionsToHclTerraform(struct?: PackSourceInputEventhubConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEventhubConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputEventhubConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEventhubConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputEventhubConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputEventhubConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputEventhubConnectionsOutputReference {
    return new PackSourceInputEventhubConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputEventhubMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputEventhubMetadataToTerraform(struct?: PackSourceInputEventhubMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputEventhubMetadataToHclTerraform(struct?: PackSourceInputEventhubMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEventhubMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputEventhubMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEventhubMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputEventhubMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputEventhubMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputEventhubMetadataOutputReference {
    return new PackSourceInputEventhubMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputEventhubPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputEventhubPqToTerraform(struct?: PackSourceInputEventhubPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputEventhubPqToHclTerraform(struct?: PackSourceInputEventhubPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEventhubPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputEventhubPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEventhubPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputEventhubSasl {
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Default: "plain"; must be one of ["plain", "oauthbearer"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mechanism PackSource#mechanism}
  */
  readonly mechanism?: string;
}

export function packSourceInputEventhubSaslToTerraform(struct?: PackSourceInputEventhubSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    mechanism: cdktf.stringToTerraform(struct!.mechanism),
  }
}


export function packSourceInputEventhubSaslToHclTerraform(struct?: PackSourceInputEventhubSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mechanism: {
      value: cdktf.stringToHclTerraform(struct!.mechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEventhubSaslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputEventhubSasl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._mechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.mechanism = this._mechanism;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEventhubSasl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._mechanism = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._mechanism = value.mechanism;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // mechanism - computed: true, optional: true, required: false
  private _mechanism?: string; 
  public get mechanism() {
    return this.getStringAttribute('mechanism');
  }
  public set mechanism(value: string) {
    this._mechanism = value;
  }
  public resetMechanism() {
    this._mechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mechanismInput() {
    return this._mechanism;
  }
}
export interface PackSourceInputEventhubTls {
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another trusted CA (such as the system's). Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
}

export function packSourceInputEventhubTlsToTerraform(struct?: PackSourceInputEventhubTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
  }
}


export function packSourceInputEventhubTlsToHclTerraform(struct?: PackSourceInputEventhubTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEventhubTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputEventhubTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEventhubTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._rejectUnauthorized = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._rejectUnauthorized = value.rejectUnauthorized;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }
}
export interface PackSourceInputEventhub {
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#authentication_timeout PackSource#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auto_commit_interval PackSource#auto_commit_interval}
  */
  readonly autoCommitInterval?: number;
  /**
  * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auto_commit_threshold PackSource#auto_commit_threshold}
  */
  readonly autoCommitThreshold?: number;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#backoff_rate PackSource#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#brokers PackSource#brokers}
  */
  readonly brokers: string[];
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connection_timeout PackSource#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputEventhubConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Start reading from earliest available data; relevant only during initial subscription. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#from_beginning PackSource#from_beginning}
  */
  readonly fromBeginning?: boolean | cdktf.IResolvable;
  /**
  * The consumer group this instance belongs to. Default is 'Cribl'. Default: "Cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#group_id PackSource#group_id}
  */
  readonly groupId?: string;
  /**
  * Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
  *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
  *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
  * Default: 3000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#heartbeat_interval PackSource#heartbeat_interval}
  */
  readonly heartbeatInterval?: number;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#initial_backoff PackSource#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_back_off PackSource#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB). Default: 10485760
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_bytes PackSource#max_bytes}
  */
  readonly maxBytes?: number;
  /**
  * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB). Default: 1048576
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_bytes_per_partition PackSource#max_bytes_per_partition}
  */
  readonly maxBytesPerPartition?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_retries PackSource#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum number of network errors before the consumer re-creates a socket. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_socket_errors PackSource#max_socket_errors}
  */
  readonly maxSocketErrors?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputEventhubMetadata[] | cdktf.IResolvable;
  /**
  * Minimize duplicate events by starting only one consumer for each topic partition. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#minimize_duplicates PackSource#minimize_duplicates}
  */
  readonly minimizeDuplicates?: boolean | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputEventhubPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reauthentication_threshold PackSource#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
  *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
  *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
  * Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#rebalance_timeout PackSource#rebalance_timeout}
  */
  readonly rebalanceTimeout?: number;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#sasl PackSource#sasl}
  */
  readonly sasl?: PackSourceInputEventhubSasl;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
  *       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
  *       Value must be lower than rebalanceTimeout.
  *       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
  * Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#session_timeout PackSource#session_timeout}
  */
  readonly sessionTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputEventhubTls;
  /**
  * The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#topics PackSource#topics}
  */
  readonly topics?: string[];
  /**
  * must be "eventhub"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputEventhubToTerraform(struct?: PackSourceInputEventhub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    auto_commit_interval: cdktf.numberToTerraform(struct!.autoCommitInterval),
    auto_commit_threshold: cdktf.numberToTerraform(struct!.autoCommitThreshold),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    connections: cdktf.listMapper(packSourceInputEventhubConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    from_beginning: cdktf.booleanToTerraform(struct!.fromBeginning),
    group_id: cdktf.stringToTerraform(struct!.groupId),
    heartbeat_interval: cdktf.numberToTerraform(struct!.heartbeatInterval),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_bytes: cdktf.numberToTerraform(struct!.maxBytes),
    max_bytes_per_partition: cdktf.numberToTerraform(struct!.maxBytesPerPartition),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    max_socket_errors: cdktf.numberToTerraform(struct!.maxSocketErrors),
    metadata: cdktf.listMapper(packSourceInputEventhubMetadataToTerraform, false)(struct!.metadata),
    minimize_duplicates: cdktf.booleanToTerraform(struct!.minimizeDuplicates),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputEventhubPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    rebalance_timeout: cdktf.numberToTerraform(struct!.rebalanceTimeout),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    sasl: packSourceInputEventhubSaslToTerraform(struct!.sasl),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    session_timeout: cdktf.numberToTerraform(struct!.sessionTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputEventhubTlsToTerraform(struct!.tls),
    topics: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.topics),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputEventhubToHclTerraform(struct?: PackSourceInputEventhub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_commit_interval: {
      value: cdktf.numberToHclTerraform(struct!.autoCommitInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_commit_threshold: {
      value: cdktf.numberToHclTerraform(struct!.autoCommitThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputEventhubConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputEventhubConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    from_beginning: {
      value: cdktf.booleanToHclTerraform(struct!.fromBeginning),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    group_id: {
      value: cdktf.stringToHclTerraform(struct!.groupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    heartbeat_interval: {
      value: cdktf.numberToHclTerraform(struct!.heartbeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_bytes_per_partition: {
      value: cdktf.numberToHclTerraform(struct!.maxBytesPerPartition),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_socket_errors: {
      value: cdktf.numberToHclTerraform(struct!.maxSocketErrors),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputEventhubMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputEventhubMetadataList",
    },
    minimize_duplicates: {
      value: cdktf.booleanToHclTerraform(struct!.minimizeDuplicates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputEventhubPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputEventhubPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rebalance_timeout: {
      value: cdktf.numberToHclTerraform(struct!.rebalanceTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sasl: {
      value: packSourceInputEventhubSaslToHclTerraform(struct!.sasl),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputEventhubSasl",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    session_timeout: {
      value: cdktf.numberToHclTerraform(struct!.sessionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputEventhubTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputEventhubTls",
    },
    topics: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.topics),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputEventhubOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputEventhub | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._autoCommitInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCommitInterval = this._autoCommitInterval;
    }
    if (this._autoCommitThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCommitThreshold = this._autoCommitThreshold;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fromBeginning !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromBeginning = this._fromBeginning;
    }
    if (this._groupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupId = this._groupId;
    }
    if (this._heartbeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.heartbeatInterval = this._heartbeatInterval;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBytes = this._maxBytes;
    }
    if (this._maxBytesPerPartition !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBytesPerPartition = this._maxBytesPerPartition;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._maxSocketErrors !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSocketErrors = this._maxSocketErrors;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._minimizeDuplicates !== undefined) {
      hasAnyValues = true;
      internalValueResult.minimizeDuplicates = this._minimizeDuplicates;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._rebalanceTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.rebalanceTimeout = this._rebalanceTimeout;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sasl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sasl = this._sasl?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._sessionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionTimeout = this._sessionTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topics !== undefined) {
      hasAnyValues = true;
      internalValueResult.topics = this._topics;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputEventhub | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authenticationTimeout = undefined;
      this._autoCommitInterval = undefined;
      this._autoCommitThreshold = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._connectionTimeout = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._fromBeginning = undefined;
      this._groupId = undefined;
      this._heartbeatInterval = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._maxBackOff = undefined;
      this._maxBytes = undefined;
      this._maxBytesPerPartition = undefined;
      this._maxRetries = undefined;
      this._maxSocketErrors = undefined;
      this._metadata.internalValue = undefined;
      this._minimizeDuplicates = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._reauthenticationThreshold = undefined;
      this._rebalanceTimeout = undefined;
      this._requestTimeout = undefined;
      this._sasl.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._sessionTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._topics = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authenticationTimeout = value.authenticationTimeout;
      this._autoCommitInterval = value.autoCommitInterval;
      this._autoCommitThreshold = value.autoCommitThreshold;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._connectionTimeout = value.connectionTimeout;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._fromBeginning = value.fromBeginning;
      this._groupId = value.groupId;
      this._heartbeatInterval = value.heartbeatInterval;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._maxBackOff = value.maxBackOff;
      this._maxBytes = value.maxBytes;
      this._maxBytesPerPartition = value.maxBytesPerPartition;
      this._maxRetries = value.maxRetries;
      this._maxSocketErrors = value.maxSocketErrors;
      this._metadata.internalValue = value.metadata;
      this._minimizeDuplicates = value.minimizeDuplicates;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._rebalanceTimeout = value.rebalanceTimeout;
      this._requestTimeout = value.requestTimeout;
      this._sasl.internalValue = value.sasl;
      this._sendToRoutes = value.sendToRoutes;
      this._sessionTimeout = value.sessionTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._topics = value.topics;
      this._type = value.type;
    }
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // auto_commit_interval - computed: false, optional: true, required: false
  private _autoCommitInterval?: number; 
  public get autoCommitInterval() {
    return this.getNumberAttribute('auto_commit_interval');
  }
  public set autoCommitInterval(value: number) {
    this._autoCommitInterval = value;
  }
  public resetAutoCommitInterval() {
    this._autoCommitInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCommitIntervalInput() {
    return this._autoCommitInterval;
  }

  // auto_commit_threshold - computed: false, optional: true, required: false
  private _autoCommitThreshold?: number; 
  public get autoCommitThreshold() {
    return this.getNumberAttribute('auto_commit_threshold');
  }
  public set autoCommitThreshold(value: number) {
    this._autoCommitThreshold = value;
  }
  public resetAutoCommitThreshold() {
    this._autoCommitThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCommitThresholdInput() {
    return this._autoCommitThreshold;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputEventhubConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputEventhubConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // from_beginning - computed: true, optional: true, required: false
  private _fromBeginning?: boolean | cdktf.IResolvable; 
  public get fromBeginning() {
    return this.getBooleanAttribute('from_beginning');
  }
  public set fromBeginning(value: boolean | cdktf.IResolvable) {
    this._fromBeginning = value;
  }
  public resetFromBeginning() {
    this._fromBeginning = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromBeginningInput() {
    return this._fromBeginning;
  }

  // group_id - computed: true, optional: true, required: false
  private _groupId?: string; 
  public get groupId() {
    return this.getStringAttribute('group_id');
  }
  public set groupId(value: string) {
    this._groupId = value;
  }
  public resetGroupId() {
    this._groupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupIdInput() {
    return this._groupId;
  }

  // heartbeat_interval - computed: true, optional: true, required: false
  private _heartbeatInterval?: number; 
  public get heartbeatInterval() {
    return this.getNumberAttribute('heartbeat_interval');
  }
  public set heartbeatInterval(value: number) {
    this._heartbeatInterval = value;
  }
  public resetHeartbeatInterval() {
    this._heartbeatInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get heartbeatIntervalInput() {
    return this._heartbeatInterval;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_bytes - computed: true, optional: true, required: false
  private _maxBytes?: number; 
  public get maxBytes() {
    return this.getNumberAttribute('max_bytes');
  }
  public set maxBytes(value: number) {
    this._maxBytes = value;
  }
  public resetMaxBytes() {
    this._maxBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBytesInput() {
    return this._maxBytes;
  }

  // max_bytes_per_partition - computed: true, optional: true, required: false
  private _maxBytesPerPartition?: number; 
  public get maxBytesPerPartition() {
    return this.getNumberAttribute('max_bytes_per_partition');
  }
  public set maxBytesPerPartition(value: number) {
    this._maxBytesPerPartition = value;
  }
  public resetMaxBytesPerPartition() {
    this._maxBytesPerPartition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBytesPerPartitionInput() {
    return this._maxBytesPerPartition;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // max_socket_errors - computed: true, optional: true, required: false
  private _maxSocketErrors?: number; 
  public get maxSocketErrors() {
    return this.getNumberAttribute('max_socket_errors');
  }
  public set maxSocketErrors(value: number) {
    this._maxSocketErrors = value;
  }
  public resetMaxSocketErrors() {
    this._maxSocketErrors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSocketErrorsInput() {
    return this._maxSocketErrors;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputEventhubMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputEventhubMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // minimize_duplicates - computed: true, optional: true, required: false
  private _minimizeDuplicates?: boolean | cdktf.IResolvable; 
  public get minimizeDuplicates() {
    return this.getBooleanAttribute('minimize_duplicates');
  }
  public set minimizeDuplicates(value: boolean | cdktf.IResolvable) {
    this._minimizeDuplicates = value;
  }
  public resetMinimizeDuplicates() {
    this._minimizeDuplicates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minimizeDuplicatesInput() {
    return this._minimizeDuplicates;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputEventhubPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputEventhubPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // rebalance_timeout - computed: true, optional: true, required: false
  private _rebalanceTimeout?: number; 
  public get rebalanceTimeout() {
    return this.getNumberAttribute('rebalance_timeout');
  }
  public set rebalanceTimeout(value: number) {
    this._rebalanceTimeout = value;
  }
  public resetRebalanceTimeout() {
    this._rebalanceTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rebalanceTimeoutInput() {
    return this._rebalanceTimeout;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // sasl - computed: false, optional: true, required: false
  private _sasl = new PackSourceInputEventhubSaslOutputReference(this, "sasl");
  public get sasl() {
    return this._sasl;
  }
  public putSasl(value: PackSourceInputEventhubSasl) {
    this._sasl.internalValue = value;
  }
  public resetSasl() {
    this._sasl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saslInput() {
    return this._sasl.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // session_timeout - computed: true, optional: true, required: false
  private _sessionTimeout?: number; 
  public get sessionTimeout() {
    return this.getNumberAttribute('session_timeout');
  }
  public set sessionTimeout(value: number) {
    this._sessionTimeout = value;
  }
  public resetSessionTimeout() {
    this._sessionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTimeoutInput() {
    return this._sessionTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputEventhubTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputEventhubTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topics - computed: true, optional: true, required: false
  private _topics?: string[]; 
  public get topics() {
    return this.getListAttribute('topics');
  }
  public set topics(value: string[]) {
    this._topics = value;
  }
  public resetTopics() {
    this._topics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicsInput() {
    return this._topics;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputExecConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputExecConnectionsToTerraform(struct?: PackSourceInputExecConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputExecConnectionsToHclTerraform(struct?: PackSourceInputExecConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputExecConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputExecConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputExecConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputExecConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputExecConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputExecConnectionsOutputReference {
    return new PackSourceInputExecConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputExecMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputExecMetadataToTerraform(struct?: PackSourceInputExecMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputExecMetadataToHclTerraform(struct?: PackSourceInputExecMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputExecMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputExecMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputExecMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputExecMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputExecMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputExecMetadataOutputReference {
    return new PackSourceInputExecMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputExecPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputExecPqToTerraform(struct?: PackSourceInputExecPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputExecPqToHclTerraform(struct?: PackSourceInputExecPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputExecPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputExecPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputExecPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputExec {
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Command to execute; supports Bourne shell (or CMD on Windows) syntax
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#command PackSource#command}
  */
  readonly command: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputExecConnections[] | cdktf.IResolvable;
  /**
  * Cron schedule to execute the command on. Default: "* * * * *"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cron_schedule PackSource#cron_schedule}
  */
  readonly cronSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Interval between command executions in seconds. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputExecMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputExecPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of retry attempts in the event that the command fails. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retries PackSource#retries}
  */
  readonly retries?: number;
  /**
  * Select a schedule type; either an interval (in seconds) or a cron-style schedule. Default: "interval"; must be one of ["interval", "cronSchedule"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#schedule_type PackSource#schedule_type}
  */
  readonly scheduleType?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "exec"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
}

export function packSourceInputExecToTerraform(struct?: PackSourceInputExec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    command: cdktf.stringToTerraform(struct!.command),
    connections: cdktf.listMapper(packSourceInputExecConnectionsToTerraform, false)(struct!.connections),
    cron_schedule: cdktf.stringToTerraform(struct!.cronSchedule),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    metadata: cdktf.listMapper(packSourceInputExecMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputExecPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    retries: cdktf.numberToTerraform(struct!.retries),
    schedule_type: cdktf.stringToTerraform(struct!.scheduleType),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputExecToHclTerraform(struct?: PackSourceInputExec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.stringToHclTerraform(struct!.command),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputExecConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputExecConnectionsList",
    },
    cron_schedule: {
      value: cdktf.stringToHclTerraform(struct!.cronSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputExecMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputExecMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputExecPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputExecPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retries: {
      value: cdktf.numberToHclTerraform(struct!.retries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schedule_type: {
      value: cdktf.stringToHclTerraform(struct!.scheduleType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputExecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputExec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._cronSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.cronSchedule = this._cronSchedule;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._retries !== undefined) {
      hasAnyValues = true;
      internalValueResult.retries = this._retries;
    }
    if (this._scheduleType !== undefined) {
      hasAnyValues = true;
      internalValueResult.scheduleType = this._scheduleType;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputExec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._breakerRulesets = undefined;
      this._command = undefined;
      this._connections.internalValue = undefined;
      this._cronSchedule = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._retries = undefined;
      this._scheduleType = undefined;
      this._sendToRoutes = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._breakerRulesets = value.breakerRulesets;
      this._command = value.command;
      this._connections.internalValue = value.connections;
      this._cronSchedule = value.cronSchedule;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._interval = value.interval;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._retries = value.retries;
      this._scheduleType = value.scheduleType;
      this._sendToRoutes = value.sendToRoutes;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // command - computed: false, optional: false, required: true
  private _command?: string; 
  public get command() {
    return this.getStringAttribute('command');
  }
  public set command(value: string) {
    this._command = value;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputExecConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputExecConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // cron_schedule - computed: true, optional: true, required: false
  private _cronSchedule?: string; 
  public get cronSchedule() {
    return this.getStringAttribute('cron_schedule');
  }
  public set cronSchedule(value: string) {
    this._cronSchedule = value;
  }
  public resetCronSchedule() {
    this._cronSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cronScheduleInput() {
    return this._cronSchedule;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputExecMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputExecMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputExecPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputExecPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // retries - computed: true, optional: true, required: false
  private _retries?: number; 
  public get retries() {
    return this.getNumberAttribute('retries');
  }
  public set retries(value: number) {
    this._retries = value;
  }
  public resetRetries() {
    this._retries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retriesInput() {
    return this._retries;
  }

  // schedule_type - computed: true, optional: true, required: false
  private _scheduleType?: string; 
  public get scheduleType() {
    return this.getStringAttribute('schedule_type');
  }
  public set scheduleType(value: string) {
    this._scheduleType = value;
  }
  public resetScheduleType() {
    this._scheduleType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scheduleTypeInput() {
    return this._scheduleType;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputFileConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputFileConnectionsToTerraform(struct?: PackSourceInputFileConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputFileConnectionsToHclTerraform(struct?: PackSourceInputFileConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputFileConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputFileConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputFileConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputFileConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputFileConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputFileConnectionsOutputReference {
    return new PackSourceInputFileConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputFileMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputFileMetadataToTerraform(struct?: PackSourceInputFileMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputFileMetadataToHclTerraform(struct?: PackSourceInputFileMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputFileMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputFileMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputFileMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputFileMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputFileMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputFileMetadataOutputReference {
    return new PackSourceInputFileMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputFilePq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputFilePqToTerraform(struct?: PackSourceInputFilePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputFilePqToHclTerraform(struct?: PackSourceInputFilePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputFilePqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputFilePq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputFilePq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputFile {
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Skip files with modification times earlier than the maximum age duration. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#check_file_mod_time PackSource#check_file_mod_time}
  */
  readonly checkFileModTime?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputFileConnections[] | cdktf.IResolvable;
  /**
  * Delete files after they have been collected. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#delete_files PackSource#delete_files}
  */
  readonly deleteFiles?: boolean | cdktf.IResolvable;
  /**
  * Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#depth PackSource#depth}
  */
  readonly depth?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * The full path of discovered files are matched against this wildcard list. Default: ["* /log/*","*log"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#filenames PackSource#filenames}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly filenames?: string[];
  /**
  * Forces files containing binary data to be streamed as text. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#force_text PackSource#force_text}
  */
  readonly forceText?: boolean | cdktf.IResolvable;
  /**
  * Length of file header bytes to use in hash for unique file identification. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#hash_len PackSource#hash_len}
  */
  readonly hashLen?: number;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Time, in seconds, before an idle file is closed. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#idle_timeout PackSource#idle_timeout}
  */
  readonly idleTimeout?: number;
  /**
  * Stream binary files as Base64-encoded chunks. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#include_unidentifiable_binary PackSource#include_unidentifiable_binary}
  */
  readonly includeUnidentifiableBinary?: boolean | cdktf.IResolvable;
  /**
  * Time, in seconds, between scanning for files. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * The maximum age of files to monitor. Format examples: 60s, 4h, 3d, 1w. Age is relative to file modification time. Leave empty to apply no age filters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_age_dur PackSource#max_age_dur}
  */
  readonly maxAgeDur?: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputFileMetadata[] | cdktf.IResolvable;
  /**
  * Choose how to discover files to monitor. Default: "auto"; must be one of ["auto", "manual"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputFilePq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#suppress_missing_path_errors PackSource#suppress_missing_path_errors}
  */
  readonly suppressMissingPathErrors?: boolean | cdktf.IResolvable;
  /**
  * Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tail_only PackSource#tail_only}
  */
  readonly tailOnly?: boolean | cdktf.IResolvable;
  /**
  * must be "file"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
}

export function packSourceInputFileToTerraform(struct?: PackSourceInputFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    check_file_mod_time: cdktf.booleanToTerraform(struct!.checkFileModTime),
    connections: cdktf.listMapper(packSourceInputFileConnectionsToTerraform, false)(struct!.connections),
    delete_files: cdktf.booleanToTerraform(struct!.deleteFiles),
    depth: cdktf.numberToTerraform(struct!.depth),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    filenames: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.filenames),
    force_text: cdktf.booleanToTerraform(struct!.forceText),
    hash_len: cdktf.numberToTerraform(struct!.hashLen),
    id: cdktf.stringToTerraform(struct!.id),
    idle_timeout: cdktf.numberToTerraform(struct!.idleTimeout),
    include_unidentifiable_binary: cdktf.booleanToTerraform(struct!.includeUnidentifiableBinary),
    interval: cdktf.numberToTerraform(struct!.interval),
    max_age_dur: cdktf.stringToTerraform(struct!.maxAgeDur),
    metadata: cdktf.listMapper(packSourceInputFileMetadataToTerraform, false)(struct!.metadata),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputFilePqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    suppress_missing_path_errors: cdktf.booleanToTerraform(struct!.suppressMissingPathErrors),
    tail_only: cdktf.booleanToTerraform(struct!.tailOnly),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputFileToHclTerraform(struct?: PackSourceInputFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    check_file_mod_time: {
      value: cdktf.booleanToHclTerraform(struct!.checkFileModTime),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputFileConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputFileConnectionsList",
    },
    delete_files: {
      value: cdktf.booleanToHclTerraform(struct!.deleteFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    depth: {
      value: cdktf.numberToHclTerraform(struct!.depth),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filenames: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.filenames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    force_text: {
      value: cdktf.booleanToHclTerraform(struct!.forceText),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hash_len: {
      value: cdktf.numberToHclTerraform(struct!.hashLen),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.idleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    include_unidentifiable_binary: {
      value: cdktf.booleanToHclTerraform(struct!.includeUnidentifiableBinary),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_age_dur: {
      value: cdktf.stringToHclTerraform(struct!.maxAgeDur),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputFileMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputFileMetadataList",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputFilePqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputFilePq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    suppress_missing_path_errors: {
      value: cdktf.booleanToHclTerraform(struct!.suppressMissingPathErrors),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tail_only: {
      value: cdktf.booleanToHclTerraform(struct!.tailOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._checkFileModTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.checkFileModTime = this._checkFileModTime;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._deleteFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.deleteFiles = this._deleteFiles;
    }
    if (this._depth !== undefined) {
      hasAnyValues = true;
      internalValueResult.depth = this._depth;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._filenames !== undefined) {
      hasAnyValues = true;
      internalValueResult.filenames = this._filenames;
    }
    if (this._forceText !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceText = this._forceText;
    }
    if (this._hashLen !== undefined) {
      hasAnyValues = true;
      internalValueResult.hashLen = this._hashLen;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._idleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.idleTimeout = this._idleTimeout;
    }
    if (this._includeUnidentifiableBinary !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeUnidentifiableBinary = this._includeUnidentifiableBinary;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._maxAgeDur !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxAgeDur = this._maxAgeDur;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._suppressMissingPathErrors !== undefined) {
      hasAnyValues = true;
      internalValueResult.suppressMissingPathErrors = this._suppressMissingPathErrors;
    }
    if (this._tailOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.tailOnly = this._tailOnly;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._breakerRulesets = undefined;
      this._checkFileModTime = undefined;
      this._connections.internalValue = undefined;
      this._deleteFiles = undefined;
      this._depth = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._filenames = undefined;
      this._forceText = undefined;
      this._hashLen = undefined;
      this._id = undefined;
      this._idleTimeout = undefined;
      this._includeUnidentifiableBinary = undefined;
      this._interval = undefined;
      this._maxAgeDur = undefined;
      this._metadata.internalValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._suppressMissingPathErrors = undefined;
      this._tailOnly = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._breakerRulesets = value.breakerRulesets;
      this._checkFileModTime = value.checkFileModTime;
      this._connections.internalValue = value.connections;
      this._deleteFiles = value.deleteFiles;
      this._depth = value.depth;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._filenames = value.filenames;
      this._forceText = value.forceText;
      this._hashLen = value.hashLen;
      this._id = value.id;
      this._idleTimeout = value.idleTimeout;
      this._includeUnidentifiableBinary = value.includeUnidentifiableBinary;
      this._interval = value.interval;
      this._maxAgeDur = value.maxAgeDur;
      this._metadata.internalValue = value.metadata;
      this._mode = value.mode;
      this._path = value.path;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._suppressMissingPathErrors = value.suppressMissingPathErrors;
      this._tailOnly = value.tailOnly;
      this._type = value.type;
    }
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // check_file_mod_time - computed: true, optional: true, required: false
  private _checkFileModTime?: boolean | cdktf.IResolvable; 
  public get checkFileModTime() {
    return this.getBooleanAttribute('check_file_mod_time');
  }
  public set checkFileModTime(value: boolean | cdktf.IResolvable) {
    this._checkFileModTime = value;
  }
  public resetCheckFileModTime() {
    this._checkFileModTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkFileModTimeInput() {
    return this._checkFileModTime;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputFileConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputFileConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // delete_files - computed: true, optional: true, required: false
  private _deleteFiles?: boolean | cdktf.IResolvable; 
  public get deleteFiles() {
    return this.getBooleanAttribute('delete_files');
  }
  public set deleteFiles(value: boolean | cdktf.IResolvable) {
    this._deleteFiles = value;
  }
  public resetDeleteFiles() {
    this._deleteFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deleteFilesInput() {
    return this._deleteFiles;
  }

  // depth - computed: false, optional: true, required: false
  private _depth?: number; 
  public get depth() {
    return this.getNumberAttribute('depth');
  }
  public set depth(value: number) {
    this._depth = value;
  }
  public resetDepth() {
    this._depth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get depthInput() {
    return this._depth;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // filenames - computed: true, optional: true, required: false
  private _filenames?: string[]; 
  public get filenames() {
    return this.getListAttribute('filenames');
  }
  public set filenames(value: string[]) {
    this._filenames = value;
  }
  public resetFilenames() {
    this._filenames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filenamesInput() {
    return this._filenames;
  }

  // force_text - computed: true, optional: true, required: false
  private _forceText?: boolean | cdktf.IResolvable; 
  public get forceText() {
    return this.getBooleanAttribute('force_text');
  }
  public set forceText(value: boolean | cdktf.IResolvable) {
    this._forceText = value;
  }
  public resetForceText() {
    this._forceText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceTextInput() {
    return this._forceText;
  }

  // hash_len - computed: true, optional: true, required: false
  private _hashLen?: number; 
  public get hashLen() {
    return this.getNumberAttribute('hash_len');
  }
  public set hashLen(value: number) {
    this._hashLen = value;
  }
  public resetHashLen() {
    this._hashLen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hashLenInput() {
    return this._hashLen;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // idle_timeout - computed: true, optional: true, required: false
  private _idleTimeout?: number; 
  public get idleTimeout() {
    return this.getNumberAttribute('idle_timeout');
  }
  public set idleTimeout(value: number) {
    this._idleTimeout = value;
  }
  public resetIdleTimeout() {
    this._idleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idleTimeoutInput() {
    return this._idleTimeout;
  }

  // include_unidentifiable_binary - computed: true, optional: true, required: false
  private _includeUnidentifiableBinary?: boolean | cdktf.IResolvable; 
  public get includeUnidentifiableBinary() {
    return this.getBooleanAttribute('include_unidentifiable_binary');
  }
  public set includeUnidentifiableBinary(value: boolean | cdktf.IResolvable) {
    this._includeUnidentifiableBinary = value;
  }
  public resetIncludeUnidentifiableBinary() {
    this._includeUnidentifiableBinary = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeUnidentifiableBinaryInput() {
    return this._includeUnidentifiableBinary;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // max_age_dur - computed: false, optional: true, required: false
  private _maxAgeDur?: string; 
  public get maxAgeDur() {
    return this.getStringAttribute('max_age_dur');
  }
  public set maxAgeDur(value: string) {
    this._maxAgeDur = value;
  }
  public resetMaxAgeDur() {
    this._maxAgeDur = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxAgeDurInput() {
    return this._maxAgeDur;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputFileMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputFileMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputFilePqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputFilePq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // suppress_missing_path_errors - computed: true, optional: true, required: false
  private _suppressMissingPathErrors?: boolean | cdktf.IResolvable; 
  public get suppressMissingPathErrors() {
    return this.getBooleanAttribute('suppress_missing_path_errors');
  }
  public set suppressMissingPathErrors(value: boolean | cdktf.IResolvable) {
    this._suppressMissingPathErrors = value;
  }
  public resetSuppressMissingPathErrors() {
    this._suppressMissingPathErrors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suppressMissingPathErrorsInput() {
    return this._suppressMissingPathErrors;
  }

  // tail_only - computed: true, optional: true, required: false
  private _tailOnly?: boolean | cdktf.IResolvable; 
  public get tailOnly() {
    return this.getBooleanAttribute('tail_only');
  }
  public set tailOnly(value: boolean | cdktf.IResolvable) {
    this._tailOnly = value;
  }
  public resetTailOnly() {
    this._tailOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tailOnlyInput() {
    return this._tailOnly;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputFirehoseConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputFirehoseConnectionsToTerraform(struct?: PackSourceInputFirehoseConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputFirehoseConnectionsToHclTerraform(struct?: PackSourceInputFirehoseConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputFirehoseConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputFirehoseConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputFirehoseConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputFirehoseConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputFirehoseConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputFirehoseConnectionsOutputReference {
    return new PackSourceInputFirehoseConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputFirehoseMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputFirehoseMetadataToTerraform(struct?: PackSourceInputFirehoseMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputFirehoseMetadataToHclTerraform(struct?: PackSourceInputFirehoseMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputFirehoseMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputFirehoseMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputFirehoseMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputFirehoseMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputFirehoseMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputFirehoseMetadataOutputReference {
    return new PackSourceInputFirehoseMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputFirehosePq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputFirehosePqToTerraform(struct?: PackSourceInputFirehosePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputFirehosePqToHclTerraform(struct?: PackSourceInputFirehosePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputFirehosePqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputFirehosePq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputFirehosePq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputFirehoseTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputFirehoseTlsToTerraform(struct?: PackSourceInputFirehoseTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputFirehoseTlsToHclTerraform(struct?: PackSourceInputFirehoseTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputFirehoseTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputFirehoseTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputFirehoseTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputFirehose {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_tokens PackSource#auth_tokens}
  */
  readonly authTokens?: string[];
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputFirehoseConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputFirehoseMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputFirehosePq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputFirehoseTls;
  /**
  * must be "firehose"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputFirehoseToTerraform(struct?: PackSourceInputFirehose | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    auth_tokens: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.authTokens),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputFirehoseConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputFirehoseMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputFirehosePqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputFirehoseTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputFirehoseToHclTerraform(struct?: PackSourceInputFirehose | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.authTokens),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputFirehoseConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputFirehoseConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputFirehoseMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputFirehoseMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputFirehosePqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputFirehosePq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputFirehoseTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputFirehoseTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputFirehoseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputFirehose | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._authTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputFirehose | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._authTokens = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._authTokens = value.authTokens;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens?: string[]; 
  public get authTokens() {
    return this.getListAttribute('auth_tokens');
  }
  public set authTokens(value: string[]) {
    this._authTokens = value;
  }
  public resetAuthTokens() {
    this._authTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputFirehoseConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputFirehoseConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputFirehoseMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputFirehoseMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputFirehosePqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputFirehosePq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputFirehoseTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputFirehoseTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputGooglePubsubConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputGooglePubsubConnectionsToTerraform(struct?: PackSourceInputGooglePubsubConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputGooglePubsubConnectionsToHclTerraform(struct?: PackSourceInputGooglePubsubConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGooglePubsubConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGooglePubsubConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGooglePubsubConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputGooglePubsubConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGooglePubsubConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGooglePubsubConnectionsOutputReference {
    return new PackSourceInputGooglePubsubConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGooglePubsubMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputGooglePubsubMetadataToTerraform(struct?: PackSourceInputGooglePubsubMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputGooglePubsubMetadataToHclTerraform(struct?: PackSourceInputGooglePubsubMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGooglePubsubMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGooglePubsubMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGooglePubsubMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputGooglePubsubMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGooglePubsubMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGooglePubsubMetadataOutputReference {
    return new PackSourceInputGooglePubsubMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGooglePubsubPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputGooglePubsubPqToTerraform(struct?: PackSourceInputGooglePubsubPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputGooglePubsubPqToHclTerraform(struct?: PackSourceInputGooglePubsubPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGooglePubsubPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGooglePubsubPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGooglePubsubPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputGooglePubsub {
  /**
  * How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#concurrency PackSource#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputGooglePubsubConnections[] | cdktf.IResolvable;
  /**
  * Create subscription if it does not exist. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#create_subscription PackSource#create_subscription}
  */
  readonly createSubscription?: boolean | cdktf.IResolvable;
  /**
  * Create topic if it does not exist. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#create_topic PackSource#create_topic}
  */
  readonly createTopic?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials. Default: "manual"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#google_auth_method PackSource#google_auth_method}
  */
  readonly googleAuthMethod?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_backlog PackSource#max_backlog}
  */
  readonly maxBacklog?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputGooglePubsubMetadata[] | cdktf.IResolvable;
  /**
  * Receive events in the order they were added to the queue. The process sending events must have ordering enabled. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ordered_delivery PackSource#ordered_delivery}
  */
  readonly orderedDelivery?: boolean | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputGooglePubsubPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#region PackSource#region}
  */
  readonly region?: string;
  /**
  * Pull request timeout, in milliseconds. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret PackSource#secret}
  */
  readonly secret?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#service_account_credentials PackSource#service_account_credentials}
  */
  readonly serviceAccountCredentials?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * ID of the subscription to use when receiving events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#subscription_name PackSource#subscription_name}
  */
  readonly subscriptionName: string;
  /**
  * ID of the topic to receive events from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#topic_name PackSource#topic_name}
  */
  readonly topicName: string;
  /**
  * must be "google_pubsub"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputGooglePubsubToTerraform(struct?: PackSourceInputGooglePubsub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    connections: cdktf.listMapper(packSourceInputGooglePubsubConnectionsToTerraform, false)(struct!.connections),
    create_subscription: cdktf.booleanToTerraform(struct!.createSubscription),
    create_topic: cdktf.booleanToTerraform(struct!.createTopic),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    google_auth_method: cdktf.stringToTerraform(struct!.googleAuthMethod),
    id: cdktf.stringToTerraform(struct!.id),
    max_backlog: cdktf.numberToTerraform(struct!.maxBacklog),
    metadata: cdktf.listMapper(packSourceInputGooglePubsubMetadataToTerraform, false)(struct!.metadata),
    ordered_delivery: cdktf.booleanToTerraform(struct!.orderedDelivery),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputGooglePubsubPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    region: cdktf.stringToTerraform(struct!.region),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    secret: cdktf.stringToTerraform(struct!.secret),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    service_account_credentials: cdktf.stringToTerraform(struct!.serviceAccountCredentials),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    subscription_name: cdktf.stringToTerraform(struct!.subscriptionName),
    topic_name: cdktf.stringToTerraform(struct!.topicName),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputGooglePubsubToHclTerraform(struct?: PackSourceInputGooglePubsub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputGooglePubsubConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGooglePubsubConnectionsList",
    },
    create_subscription: {
      value: cdktf.booleanToHclTerraform(struct!.createSubscription),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    create_topic: {
      value: cdktf.booleanToHclTerraform(struct!.createTopic),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    google_auth_method: {
      value: cdktf.stringToHclTerraform(struct!.googleAuthMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_backlog: {
      value: cdktf.numberToHclTerraform(struct!.maxBacklog),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputGooglePubsubMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGooglePubsubMetadataList",
    },
    ordered_delivery: {
      value: cdktf.booleanToHclTerraform(struct!.orderedDelivery),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputGooglePubsubPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputGooglePubsubPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    service_account_credentials: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    subscription_name: {
      value: cdktf.stringToHclTerraform(struct!.subscriptionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    topic_name: {
      value: cdktf.stringToHclTerraform(struct!.topicName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGooglePubsubOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGooglePubsub | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._createSubscription !== undefined) {
      hasAnyValues = true;
      internalValueResult.createSubscription = this._createSubscription;
    }
    if (this._createTopic !== undefined) {
      hasAnyValues = true;
      internalValueResult.createTopic = this._createTopic;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._googleAuthMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleAuthMethod = this._googleAuthMethod;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxBacklog !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBacklog = this._maxBacklog;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._orderedDelivery !== undefined) {
      hasAnyValues = true;
      internalValueResult.orderedDelivery = this._orderedDelivery;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._serviceAccountCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountCredentials = this._serviceAccountCredentials;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._subscriptionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.subscriptionName = this._subscriptionName;
    }
    if (this._topicName !== undefined) {
      hasAnyValues = true;
      internalValueResult.topicName = this._topicName;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGooglePubsub | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._concurrency = undefined;
      this._connections.internalValue = undefined;
      this._createSubscription = undefined;
      this._createTopic = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._googleAuthMethod = undefined;
      this._id = undefined;
      this._maxBacklog = undefined;
      this._metadata.internalValue = undefined;
      this._orderedDelivery = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._region = undefined;
      this._requestTimeout = undefined;
      this._secret = undefined;
      this._sendToRoutes = undefined;
      this._serviceAccountCredentials = undefined;
      this._streamtags = undefined;
      this._subscriptionName = undefined;
      this._topicName = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._concurrency = value.concurrency;
      this._connections.internalValue = value.connections;
      this._createSubscription = value.createSubscription;
      this._createTopic = value.createTopic;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._googleAuthMethod = value.googleAuthMethod;
      this._id = value.id;
      this._maxBacklog = value.maxBacklog;
      this._metadata.internalValue = value.metadata;
      this._orderedDelivery = value.orderedDelivery;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._region = value.region;
      this._requestTimeout = value.requestTimeout;
      this._secret = value.secret;
      this._sendToRoutes = value.sendToRoutes;
      this._serviceAccountCredentials = value.serviceAccountCredentials;
      this._streamtags = value.streamtags;
      this._subscriptionName = value.subscriptionName;
      this._topicName = value.topicName;
      this._type = value.type;
    }
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputGooglePubsubConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputGooglePubsubConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // create_subscription - computed: true, optional: true, required: false
  private _createSubscription?: boolean | cdktf.IResolvable; 
  public get createSubscription() {
    return this.getBooleanAttribute('create_subscription');
  }
  public set createSubscription(value: boolean | cdktf.IResolvable) {
    this._createSubscription = value;
  }
  public resetCreateSubscription() {
    this._createSubscription = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createSubscriptionInput() {
    return this._createSubscription;
  }

  // create_topic - computed: true, optional: true, required: false
  private _createTopic?: boolean | cdktf.IResolvable; 
  public get createTopic() {
    return this.getBooleanAttribute('create_topic');
  }
  public set createTopic(value: boolean | cdktf.IResolvable) {
    this._createTopic = value;
  }
  public resetCreateTopic() {
    this._createTopic = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createTopicInput() {
    return this._createTopic;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // google_auth_method - computed: true, optional: true, required: false
  private _googleAuthMethod?: string; 
  public get googleAuthMethod() {
    return this.getStringAttribute('google_auth_method');
  }
  public set googleAuthMethod(value: string) {
    this._googleAuthMethod = value;
  }
  public resetGoogleAuthMethod() {
    this._googleAuthMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleAuthMethodInput() {
    return this._googleAuthMethod;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_backlog - computed: true, optional: true, required: false
  private _maxBacklog?: number; 
  public get maxBacklog() {
    return this.getNumberAttribute('max_backlog');
  }
  public set maxBacklog(value: number) {
    this._maxBacklog = value;
  }
  public resetMaxBacklog() {
    this._maxBacklog = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBacklogInput() {
    return this._maxBacklog;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputGooglePubsubMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputGooglePubsubMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // ordered_delivery - computed: true, optional: true, required: false
  private _orderedDelivery?: boolean | cdktf.IResolvable; 
  public get orderedDelivery() {
    return this.getBooleanAttribute('ordered_delivery');
  }
  public set orderedDelivery(value: boolean | cdktf.IResolvable) {
    this._orderedDelivery = value;
  }
  public resetOrderedDelivery() {
    this._orderedDelivery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orderedDeliveryInput() {
    return this._orderedDelivery;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputGooglePubsubPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputGooglePubsubPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // service_account_credentials - computed: false, optional: true, required: false
  private _serviceAccountCredentials?: string; 
  public get serviceAccountCredentials() {
    return this.getStringAttribute('service_account_credentials');
  }
  public set serviceAccountCredentials(value: string) {
    this._serviceAccountCredentials = value;
  }
  public resetServiceAccountCredentials() {
    this._serviceAccountCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountCredentialsInput() {
    return this._serviceAccountCredentials;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // subscription_name - computed: false, optional: false, required: true
  private _subscriptionName?: string; 
  public get subscriptionName() {
    return this.getStringAttribute('subscription_name');
  }
  public set subscriptionName(value: string) {
    this._subscriptionName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subscriptionNameInput() {
    return this._subscriptionName;
  }

  // topic_name - computed: false, optional: false, required: true
  private _topicName?: string; 
  public get topicName() {
    return this.getStringAttribute('topic_name');
  }
  public set topicName(value: string) {
    this._topicName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicNameInput() {
    return this._topicName;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana1Connections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana1ConnectionsToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana1ConnectionsToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana1ConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana1Connections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana1Connections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputGrafanaInputGrafanaGrafana1ConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGrafanaInputGrafanaGrafana1Connections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGrafanaInputGrafanaGrafana1ConnectionsOutputReference {
    return new PackSourceInputGrafanaInputGrafanaGrafana1ConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeadersToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeadersToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeadersOutputReference {
    return new PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParamsToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParamsToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParamsOutputReference {
    return new PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana1LokiAuth {
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_header_expr PackSource#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Loki logs authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#login_url PackSource#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_headers PackSource#oauth_headers}
  */
  readonly oauthHeaders?: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_params PackSource#oauth_params}
  */
  readonly oauthParams?: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParams[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#password PackSource#password}
  */
  readonly password?: string;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret PackSource#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret_param_name PackSource#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_attribute_name PackSource#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_timeout_secs PackSource#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#username PackSource#username}
  */
  readonly username?: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana1LokiAuthToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    oauth_headers: cdktf.listMapper(packSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParamsToTerraform, false)(struct!.oauthParams),
    password: cdktf.stringToTerraform(struct!.password),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana1LokiAuthToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParamsList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana1LokiAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._credentialsSecret = undefined;
      this._loginUrl = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._password = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._credentialsSecret = value.credentialsSecret;
      this._loginUrl = value.loginUrl;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._password = value.password;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._username = value.username;
    }
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana1Metadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana1MetadataToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana1MetadataToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana1MetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana1Metadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana1Metadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputGrafanaInputGrafanaGrafana1MetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGrafanaInputGrafanaGrafana1Metadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGrafanaInputGrafanaGrafana1MetadataOutputReference {
    return new PackSourceInputGrafanaInputGrafanaGrafana1MetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana1Pq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana1PqToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana1PqToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana1PqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana1Pq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana1Pq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeadersToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeadersToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeadersOutputReference {
    return new PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParamsToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParamsToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParamsOutputReference {
    return new PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuth {
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_header_expr PackSource#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Remote Write authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#login_url PackSource#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_headers PackSource#oauth_headers}
  */
  readonly oauthHeaders?: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_params PackSource#oauth_params}
  */
  readonly oauthParams?: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParams[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#password PackSource#password}
  */
  readonly password?: string;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret PackSource#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret_param_name PackSource#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_attribute_name PackSource#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_timeout_secs PackSource#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#username PackSource#username}
  */
  readonly username?: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    oauth_headers: cdktf.listMapper(packSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParamsToTerraform, false)(struct!.oauthParams),
    password: cdktf.stringToTerraform(struct!.password),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParamsList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._credentialsSecret = undefined;
      this._loginUrl = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._password = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._credentialsSecret = value.credentialsSecret;
      this._loginUrl = value.loginUrl;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._password = value.password;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._username = value.username;
    }
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana1Tls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputGrafanaInputGrafanaGrafana1TlsToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana1TlsToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana1TlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana1Tls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana1Tls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana1 {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputGrafanaInputGrafanaGrafana1Connections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured. Default: "/loki/api/v1/push"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#loki_api PackSource#loki_api}
  */
  readonly lokiApi?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#loki_auth PackSource#loki_auth}
  */
  readonly lokiAuth?: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuth;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputGrafanaInputGrafanaGrafana1Metadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputGrafanaInputGrafanaGrafana1Pq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<your‑upstream‑URL>:<your‑port>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured. Default: "/api/prom/push"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#prometheus_api PackSource#prometheus_api}
  */
  readonly prometheusApi?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#prometheus_auth PackSource#prometheus_auth}
  */
  readonly prometheusAuth?: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuth;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputGrafanaInputGrafanaGrafana1Tls;
  /**
  * must be "grafana"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana1ToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputGrafanaInputGrafanaGrafana1ConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    loki_api: cdktf.stringToTerraform(struct!.lokiApi),
    loki_auth: packSourceInputGrafanaInputGrafanaGrafana1LokiAuthToTerraform(struct!.lokiAuth),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputGrafanaInputGrafanaGrafana1MetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputGrafanaInputGrafanaGrafana1PqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    prometheus_api: cdktf.stringToTerraform(struct!.prometheusApi),
    prometheus_auth: packSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthToTerraform(struct!.prometheusAuth),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputGrafanaInputGrafanaGrafana1TlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana1ToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana1 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputGrafanaInputGrafanaGrafana1ConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana1ConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    loki_api: {
      value: cdktf.stringToHclTerraform(struct!.lokiApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loki_auth: {
      value: packSourceInputGrafanaInputGrafanaGrafana1LokiAuthToHclTerraform(struct!.lokiAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana1LokiAuth",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputGrafanaInputGrafanaGrafana1MetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana1MetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputGrafanaInputGrafanaGrafana1PqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana1Pq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prometheus_api: {
      value: cdktf.stringToHclTerraform(struct!.prometheusApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prometheus_auth: {
      value: packSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthToHclTerraform(struct!.prometheusAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuth",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputGrafanaInputGrafanaGrafana1TlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana1Tls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana1OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana1 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._lokiApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiApi = this._lokiApi;
    }
    if (this._lokiAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiAuth = this._lokiAuth?.internalValue;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._prometheusApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusApi = this._prometheusApi;
    }
    if (this._prometheusAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusAuth = this._prometheusAuth?.internalValue;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana1 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._lokiApi = undefined;
      this._lokiAuth.internalValue = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._prometheusApi = undefined;
      this._prometheusAuth.internalValue = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._lokiApi = value.lokiApi;
      this._lokiAuth.internalValue = value.lokiAuth;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._prometheusApi = value.prometheusApi;
      this._prometheusAuth.internalValue = value.prometheusAuth;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputGrafanaInputGrafanaGrafana1ConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputGrafanaInputGrafanaGrafana1Connections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // loki_api - computed: true, optional: true, required: false
  private _lokiApi?: string; 
  public get lokiApi() {
    return this.getStringAttribute('loki_api');
  }
  public set lokiApi(value: string) {
    this._lokiApi = value;
  }
  public resetLokiApi() {
    this._lokiApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiApiInput() {
    return this._lokiApi;
  }

  // loki_auth - computed: false, optional: true, required: false
  private _lokiAuth = new PackSourceInputGrafanaInputGrafanaGrafana1LokiAuthOutputReference(this, "loki_auth");
  public get lokiAuth() {
    return this._lokiAuth;
  }
  public putLokiAuth(value: PackSourceInputGrafanaInputGrafanaGrafana1LokiAuth) {
    this._lokiAuth.internalValue = value;
  }
  public resetLokiAuth() {
    this._lokiAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiAuthInput() {
    return this._lokiAuth.internalValue;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputGrafanaInputGrafanaGrafana1MetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputGrafanaInputGrafanaGrafana1Metadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputGrafanaInputGrafanaGrafana1PqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputGrafanaInputGrafanaGrafana1Pq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // prometheus_api - computed: true, optional: true, required: false
  private _prometheusApi?: string; 
  public get prometheusApi() {
    return this.getStringAttribute('prometheus_api');
  }
  public set prometheusApi(value: string) {
    this._prometheusApi = value;
  }
  public resetPrometheusApi() {
    this._prometheusApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusApiInput() {
    return this._prometheusApi;
  }

  // prometheus_auth - computed: false, optional: true, required: false
  private _prometheusAuth = new PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuthOutputReference(this, "prometheus_auth");
  public get prometheusAuth() {
    return this._prometheusAuth;
  }
  public putPrometheusAuth(value: PackSourceInputGrafanaInputGrafanaGrafana1PrometheusAuth) {
    this._prometheusAuth.internalValue = value;
  }
  public resetPrometheusAuth() {
    this._prometheusAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusAuthInput() {
    return this._prometheusAuth.internalValue;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputGrafanaInputGrafanaGrafana1TlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputGrafanaInputGrafanaGrafana1Tls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana2Connections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana2ConnectionsToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana2ConnectionsToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana2ConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana2Connections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana2Connections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputGrafanaInputGrafanaGrafana2ConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGrafanaInputGrafanaGrafana2Connections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGrafanaInputGrafanaGrafana2ConnectionsOutputReference {
    return new PackSourceInputGrafanaInputGrafanaGrafana2ConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeadersToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeadersToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeadersOutputReference {
    return new PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParamsToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParamsToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParamsOutputReference {
    return new PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana2LokiAuth {
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_header_expr PackSource#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Loki logs authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#login_url PackSource#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_headers PackSource#oauth_headers}
  */
  readonly oauthHeaders?: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_params PackSource#oauth_params}
  */
  readonly oauthParams?: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParams[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#password PackSource#password}
  */
  readonly password?: string;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret PackSource#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret_param_name PackSource#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_attribute_name PackSource#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_timeout_secs PackSource#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#username PackSource#username}
  */
  readonly username?: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana2LokiAuthToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    oauth_headers: cdktf.listMapper(packSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParamsToTerraform, false)(struct!.oauthParams),
    password: cdktf.stringToTerraform(struct!.password),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana2LokiAuthToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParamsList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana2LokiAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._credentialsSecret = undefined;
      this._loginUrl = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._password = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._credentialsSecret = value.credentialsSecret;
      this._loginUrl = value.loginUrl;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._password = value.password;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._username = value.username;
    }
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana2Metadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana2MetadataToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana2MetadataToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana2MetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana2Metadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana2Metadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputGrafanaInputGrafanaGrafana2MetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGrafanaInputGrafanaGrafana2Metadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGrafanaInputGrafanaGrafana2MetadataOutputReference {
    return new PackSourceInputGrafanaInputGrafanaGrafana2MetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana2Pq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana2PqToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana2PqToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana2PqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana2Pq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana2Pq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeadersToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeadersToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeadersOutputReference {
    return new PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParamsToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParamsToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParamsOutputReference {
    return new PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuth {
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_header_expr PackSource#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Remote Write authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#login_url PackSource#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_headers PackSource#oauth_headers}
  */
  readonly oauthHeaders?: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_params PackSource#oauth_params}
  */
  readonly oauthParams?: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParams[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#password PackSource#password}
  */
  readonly password?: string;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret PackSource#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret_param_name PackSource#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_attribute_name PackSource#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_timeout_secs PackSource#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#username PackSource#username}
  */
  readonly username?: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    oauth_headers: cdktf.listMapper(packSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParamsToTerraform, false)(struct!.oauthParams),
    password: cdktf.stringToTerraform(struct!.password),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParamsList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._credentialsSecret = undefined;
      this._loginUrl = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._password = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._credentialsSecret = value.credentialsSecret;
      this._loginUrl = value.loginUrl;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._password = value.password;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._username = value.username;
    }
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana2Tls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputGrafanaInputGrafanaGrafana2TlsToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana2TlsToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana2TlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana2Tls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana2Tls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputGrafanaInputGrafanaGrafana2 {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputGrafanaInputGrafanaGrafana2Connections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured. Default: "/loki/api/v1/push"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#loki_api PackSource#loki_api}
  */
  readonly lokiApi?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#loki_auth PackSource#loki_auth}
  */
  readonly lokiAuth?: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuth;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputGrafanaInputGrafanaGrafana2Metadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputGrafanaInputGrafanaGrafana2Pq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<your‑upstream‑URL>:<your‑port>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured. Default: "/api/prom/push"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#prometheus_api PackSource#prometheus_api}
  */
  readonly prometheusApi?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#prometheus_auth PackSource#prometheus_auth}
  */
  readonly prometheusAuth?: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuth;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputGrafanaInputGrafanaGrafana2Tls;
  /**
  * must be "grafana"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputGrafanaInputGrafanaGrafana2ToTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputGrafanaInputGrafanaGrafana2ConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    loki_api: cdktf.stringToTerraform(struct!.lokiApi),
    loki_auth: packSourceInputGrafanaInputGrafanaGrafana2LokiAuthToTerraform(struct!.lokiAuth),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputGrafanaInputGrafanaGrafana2MetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputGrafanaInputGrafanaGrafana2PqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    prometheus_api: cdktf.stringToTerraform(struct!.prometheusApi),
    prometheus_auth: packSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthToTerraform(struct!.prometheusAuth),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputGrafanaInputGrafanaGrafana2TlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputGrafanaInputGrafanaGrafana2ToHclTerraform(struct?: PackSourceInputGrafanaInputGrafanaGrafana2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputGrafanaInputGrafanaGrafana2ConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana2ConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    loki_api: {
      value: cdktf.stringToHclTerraform(struct!.lokiApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loki_auth: {
      value: packSourceInputGrafanaInputGrafanaGrafana2LokiAuthToHclTerraform(struct!.lokiAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana2LokiAuth",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputGrafanaInputGrafanaGrafana2MetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana2MetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputGrafanaInputGrafanaGrafana2PqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana2Pq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prometheus_api: {
      value: cdktf.stringToHclTerraform(struct!.prometheusApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prometheus_auth: {
      value: packSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthToHclTerraform(struct!.prometheusAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuth",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputGrafanaInputGrafanaGrafana2TlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana2Tls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaInputGrafanaGrafana2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGrafanaInputGrafanaGrafana2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._lokiApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiApi = this._lokiApi;
    }
    if (this._lokiAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiAuth = this._lokiAuth?.internalValue;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._prometheusApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusApi = this._prometheusApi;
    }
    if (this._prometheusAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusAuth = this._prometheusAuth?.internalValue;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafanaInputGrafanaGrafana2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._lokiApi = undefined;
      this._lokiAuth.internalValue = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._prometheusApi = undefined;
      this._prometheusAuth.internalValue = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._lokiApi = value.lokiApi;
      this._lokiAuth.internalValue = value.lokiAuth;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._prometheusApi = value.prometheusApi;
      this._prometheusAuth.internalValue = value.prometheusAuth;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputGrafanaInputGrafanaGrafana2ConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputGrafanaInputGrafanaGrafana2Connections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // loki_api - computed: true, optional: true, required: false
  private _lokiApi?: string; 
  public get lokiApi() {
    return this.getStringAttribute('loki_api');
  }
  public set lokiApi(value: string) {
    this._lokiApi = value;
  }
  public resetLokiApi() {
    this._lokiApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiApiInput() {
    return this._lokiApi;
  }

  // loki_auth - computed: false, optional: true, required: false
  private _lokiAuth = new PackSourceInputGrafanaInputGrafanaGrafana2LokiAuthOutputReference(this, "loki_auth");
  public get lokiAuth() {
    return this._lokiAuth;
  }
  public putLokiAuth(value: PackSourceInputGrafanaInputGrafanaGrafana2LokiAuth) {
    this._lokiAuth.internalValue = value;
  }
  public resetLokiAuth() {
    this._lokiAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiAuthInput() {
    return this._lokiAuth.internalValue;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputGrafanaInputGrafanaGrafana2MetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputGrafanaInputGrafanaGrafana2Metadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputGrafanaInputGrafanaGrafana2PqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputGrafanaInputGrafanaGrafana2Pq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // prometheus_api - computed: true, optional: true, required: false
  private _prometheusApi?: string; 
  public get prometheusApi() {
    return this.getStringAttribute('prometheus_api');
  }
  public set prometheusApi(value: string) {
    this._prometheusApi = value;
  }
  public resetPrometheusApi() {
    this._prometheusApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusApiInput() {
    return this._prometheusApi;
  }

  // prometheus_auth - computed: false, optional: true, required: false
  private _prometheusAuth = new PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuthOutputReference(this, "prometheus_auth");
  public get prometheusAuth() {
    return this._prometheusAuth;
  }
  public putPrometheusAuth(value: PackSourceInputGrafanaInputGrafanaGrafana2PrometheusAuth) {
    this._prometheusAuth.internalValue = value;
  }
  public resetPrometheusAuth() {
    this._prometheusAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusAuthInput() {
    return this._prometheusAuth.internalValue;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputGrafanaInputGrafanaGrafana2TlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputGrafanaInputGrafanaGrafana2Tls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputGrafana {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#input_grafana_grafana1 PackSource#input_grafana_grafana1}
  */
  readonly inputGrafanaGrafana1?: PackSourceInputGrafanaInputGrafanaGrafana1;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#input_grafana_grafana2 PackSource#input_grafana_grafana2}
  */
  readonly inputGrafanaGrafana2?: PackSourceInputGrafanaInputGrafanaGrafana2;
}

export function packSourceInputGrafanaToTerraform(struct?: PackSourceInputGrafana | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    input_grafana_grafana1: packSourceInputGrafanaInputGrafanaGrafana1ToTerraform(struct!.inputGrafanaGrafana1),
    input_grafana_grafana2: packSourceInputGrafanaInputGrafanaGrafana2ToTerraform(struct!.inputGrafanaGrafana2),
  }
}


export function packSourceInputGrafanaToHclTerraform(struct?: PackSourceInputGrafana | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    input_grafana_grafana1: {
      value: packSourceInputGrafanaInputGrafanaGrafana1ToHclTerraform(struct!.inputGrafanaGrafana1),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana1",
    },
    input_grafana_grafana2: {
      value: packSourceInputGrafanaInputGrafanaGrafana2ToHclTerraform(struct!.inputGrafanaGrafana2),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputGrafanaInputGrafanaGrafana2",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputGrafanaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputGrafana | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inputGrafanaGrafana1?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.inputGrafanaGrafana1 = this._inputGrafanaGrafana1?.internalValue;
    }
    if (this._inputGrafanaGrafana2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.inputGrafanaGrafana2 = this._inputGrafanaGrafana2?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputGrafana | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inputGrafanaGrafana1.internalValue = undefined;
      this._inputGrafanaGrafana2.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inputGrafanaGrafana1.internalValue = value.inputGrafanaGrafana1;
      this._inputGrafanaGrafana2.internalValue = value.inputGrafanaGrafana2;
    }
  }

  // input_grafana_grafana1 - computed: false, optional: true, required: false
  private _inputGrafanaGrafana1 = new PackSourceInputGrafanaInputGrafanaGrafana1OutputReference(this, "input_grafana_grafana1");
  public get inputGrafanaGrafana1() {
    return this._inputGrafanaGrafana1;
  }
  public putInputGrafanaGrafana1(value: PackSourceInputGrafanaInputGrafanaGrafana1) {
    this._inputGrafanaGrafana1.internalValue = value;
  }
  public resetInputGrafanaGrafana1() {
    this._inputGrafanaGrafana1.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputGrafanaGrafana1Input() {
    return this._inputGrafanaGrafana1.internalValue;
  }

  // input_grafana_grafana2 - computed: false, optional: true, required: false
  private _inputGrafanaGrafana2 = new PackSourceInputGrafanaInputGrafanaGrafana2OutputReference(this, "input_grafana_grafana2");
  public get inputGrafanaGrafana2() {
    return this._inputGrafanaGrafana2;
  }
  public putInputGrafanaGrafana2(value: PackSourceInputGrafanaInputGrafanaGrafana2) {
    this._inputGrafanaGrafana2.internalValue = value;
  }
  public resetInputGrafanaGrafana2() {
    this._inputGrafanaGrafana2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputGrafanaGrafana2Input() {
    return this._inputGrafanaGrafana2.internalValue;
  }
}
export interface PackSourceInputHttpAuthTokensExtMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputHttpAuthTokensExtMetadataToTerraform(struct?: PackSourceInputHttpAuthTokensExtMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputHttpAuthTokensExtMetadataToHclTerraform(struct?: PackSourceInputHttpAuthTokensExtMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpAuthTokensExtMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputHttpAuthTokensExtMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpAuthTokensExtMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputHttpAuthTokensExtMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputHttpAuthTokensExtMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputHttpAuthTokensExtMetadataOutputReference {
    return new PackSourceInputHttpAuthTokensExtMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputHttpAuthTokensExt {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Fields to add to events referencing this token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputHttpAuthTokensExtMetadata[] | cdktf.IResolvable;
  /**
  * Shared secret to be provided by any client (Authorization: <token>)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token: string;
}

export function packSourceInputHttpAuthTokensExtToTerraform(struct?: PackSourceInputHttpAuthTokensExt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    metadata: cdktf.listMapper(packSourceInputHttpAuthTokensExtMetadataToTerraform, false)(struct!.metadata),
    token: cdktf.stringToTerraform(struct!.token),
  }
}


export function packSourceInputHttpAuthTokensExtToHclTerraform(struct?: PackSourceInputHttpAuthTokensExt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputHttpAuthTokensExtMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputHttpAuthTokensExtMetadataList",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpAuthTokensExtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputHttpAuthTokensExt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpAuthTokensExt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._metadata.internalValue = undefined;
      this._token = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._metadata.internalValue = value.metadata;
      this._token = value.token;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputHttpAuthTokensExtMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputHttpAuthTokensExtMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // token - computed: false, optional: false, required: true
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }
}

export class PackSourceInputHttpAuthTokensExtList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputHttpAuthTokensExt[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputHttpAuthTokensExtOutputReference {
    return new PackSourceInputHttpAuthTokensExtOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputHttpConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputHttpConnectionsToTerraform(struct?: PackSourceInputHttpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputHttpConnectionsToHclTerraform(struct?: PackSourceInputHttpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputHttpConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputHttpConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputHttpConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputHttpConnectionsOutputReference {
    return new PackSourceInputHttpConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputHttpMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputHttpMetadataToTerraform(struct?: PackSourceInputHttpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputHttpMetadataToHclTerraform(struct?: PackSourceInputHttpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputHttpMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputHttpMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputHttpMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputHttpMetadataOutputReference {
    return new PackSourceInputHttpMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputHttpPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputHttpPqToTerraform(struct?: PackSourceInputHttpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputHttpPqToHclTerraform(struct?: PackSourceInputHttpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputHttpPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputHttpTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputHttpTlsToTerraform(struct?: PackSourceInputHttpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputHttpTlsToHclTerraform(struct?: PackSourceInputHttpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputHttpTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputHttp {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_tokens PackSource#auth_tokens}
  */
  readonly authTokens?: string[];
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_tokens_ext PackSource#auth_tokens_ext}
  */
  readonly authTokensExt?: PackSourceInputHttpAuthTokensExt[] | cdktf.IResolvable;
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputHttpConnections[] | cdktf.IResolvable;
  /**
  * Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable. Default: "/cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cribl_api PackSource#cribl_api}
  */
  readonly criblApi?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable. Default: "/elastic"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#elastic_api PackSource#elastic_api}
  */
  readonly elasticApi?: string;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputHttpMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputHttpPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#splunk_hec_acks PackSource#splunk_hec_acks}
  */
  readonly splunkHecAcks?: boolean | cdktf.IResolvable;
  /**
  * Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable. Default: "/services/collector"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#splunk_hec_api PackSource#splunk_hec_api}
  */
  readonly splunkHecApi?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputHttpTls;
  /**
  * must be "http"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputHttpToTerraform(struct?: PackSourceInputHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    auth_tokens: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.authTokens),
    auth_tokens_ext: cdktf.listMapper(packSourceInputHttpAuthTokensExtToTerraform, false)(struct!.authTokensExt),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputHttpConnectionsToTerraform, false)(struct!.connections),
    cribl_api: cdktf.stringToTerraform(struct!.criblApi),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    elastic_api: cdktf.stringToTerraform(struct!.elasticApi),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputHttpMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputHttpPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    splunk_hec_acks: cdktf.booleanToTerraform(struct!.splunkHecAcks),
    splunk_hec_api: cdktf.stringToTerraform(struct!.splunkHecApi),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputHttpTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputHttpToHclTerraform(struct?: PackSourceInputHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.authTokens),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_tokens_ext: {
      value: cdktf.listMapperHcl(packSourceInputHttpAuthTokensExtToHclTerraform, false)(struct!.authTokensExt),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputHttpAuthTokensExtList",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputHttpConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputHttpConnectionsList",
    },
    cribl_api: {
      value: cdktf.stringToHclTerraform(struct!.criblApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    elastic_api: {
      value: cdktf.stringToHclTerraform(struct!.elasticApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputHttpMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputHttpMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputHttpPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputHttpPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    splunk_hec_acks: {
      value: cdktf.booleanToHclTerraform(struct!.splunkHecAcks),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    splunk_hec_api: {
      value: cdktf.stringToHclTerraform(struct!.splunkHecApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputHttpTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputHttpTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._authTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens;
    }
    if (this._authTokensExt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokensExt = this._authTokensExt?.internalValue;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._criblApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.criblApi = this._criblApi;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._elasticApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.elasticApi = this._elasticApi;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._splunkHecAcks !== undefined) {
      hasAnyValues = true;
      internalValueResult.splunkHecAcks = this._splunkHecAcks;
    }
    if (this._splunkHecApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.splunkHecApi = this._splunkHecApi;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._authTokens = undefined;
      this._authTokensExt.internalValue = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._criblApi = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._elasticApi = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._splunkHecAcks = undefined;
      this._splunkHecApi = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._authTokens = value.authTokens;
      this._authTokensExt.internalValue = value.authTokensExt;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._criblApi = value.criblApi;
      this._description = value.description;
      this._disabled = value.disabled;
      this._elasticApi = value.elasticApi;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._splunkHecAcks = value.splunkHecAcks;
      this._splunkHecApi = value.splunkHecApi;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens?: string[]; 
  public get authTokens() {
    return this.getListAttribute('auth_tokens');
  }
  public set authTokens(value: string[]) {
    this._authTokens = value;
  }
  public resetAuthTokens() {
    this._authTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens;
  }

  // auth_tokens_ext - computed: false, optional: true, required: false
  private _authTokensExt = new PackSourceInputHttpAuthTokensExtList(this, "auth_tokens_ext", false);
  public get authTokensExt() {
    return this._authTokensExt;
  }
  public putAuthTokensExt(value: PackSourceInputHttpAuthTokensExt[] | cdktf.IResolvable) {
    this._authTokensExt.internalValue = value;
  }
  public resetAuthTokensExt() {
    this._authTokensExt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensExtInput() {
    return this._authTokensExt.internalValue;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputHttpConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputHttpConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // cribl_api - computed: true, optional: true, required: false
  private _criblApi?: string; 
  public get criblApi() {
    return this.getStringAttribute('cribl_api');
  }
  public set criblApi(value: string) {
    this._criblApi = value;
  }
  public resetCriblApi() {
    this._criblApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get criblApiInput() {
    return this._criblApi;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // elastic_api - computed: true, optional: true, required: false
  private _elasticApi?: string; 
  public get elasticApi() {
    return this.getStringAttribute('elastic_api');
  }
  public set elasticApi(value: string) {
    this._elasticApi = value;
  }
  public resetElasticApi() {
    this._elasticApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticApiInput() {
    return this._elasticApi;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputHttpMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputHttpMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputHttpPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputHttpPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // splunk_hec_acks - computed: true, optional: true, required: false
  private _splunkHecAcks?: boolean | cdktf.IResolvable; 
  public get splunkHecAcks() {
    return this.getBooleanAttribute('splunk_hec_acks');
  }
  public set splunkHecAcks(value: boolean | cdktf.IResolvable) {
    this._splunkHecAcks = value;
  }
  public resetSplunkHecAcks() {
    this._splunkHecAcks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get splunkHecAcksInput() {
    return this._splunkHecAcks;
  }

  // splunk_hec_api - computed: true, optional: true, required: false
  private _splunkHecApi?: string; 
  public get splunkHecApi() {
    return this.getStringAttribute('splunk_hec_api');
  }
  public set splunkHecApi(value: string) {
    this._splunkHecApi = value;
  }
  public resetSplunkHecApi() {
    this._splunkHecApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get splunkHecApiInput() {
    return this._splunkHecApi;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputHttpTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputHttpTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputHttpRawAuthTokensExtMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputHttpRawAuthTokensExtMetadataToTerraform(struct?: PackSourceInputHttpRawAuthTokensExtMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputHttpRawAuthTokensExtMetadataToHclTerraform(struct?: PackSourceInputHttpRawAuthTokensExtMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpRawAuthTokensExtMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputHttpRawAuthTokensExtMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpRawAuthTokensExtMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputHttpRawAuthTokensExtMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputHttpRawAuthTokensExtMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputHttpRawAuthTokensExtMetadataOutputReference {
    return new PackSourceInputHttpRawAuthTokensExtMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputHttpRawAuthTokensExt {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Fields to add to events referencing this token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputHttpRawAuthTokensExtMetadata[] | cdktf.IResolvable;
  /**
  * Shared secret to be provided by any client (Authorization: <token>)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token: string;
}

export function packSourceInputHttpRawAuthTokensExtToTerraform(struct?: PackSourceInputHttpRawAuthTokensExt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    metadata: cdktf.listMapper(packSourceInputHttpRawAuthTokensExtMetadataToTerraform, false)(struct!.metadata),
    token: cdktf.stringToTerraform(struct!.token),
  }
}


export function packSourceInputHttpRawAuthTokensExtToHclTerraform(struct?: PackSourceInputHttpRawAuthTokensExt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputHttpRawAuthTokensExtMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputHttpRawAuthTokensExtMetadataList",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpRawAuthTokensExtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputHttpRawAuthTokensExt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpRawAuthTokensExt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._metadata.internalValue = undefined;
      this._token = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._metadata.internalValue = value.metadata;
      this._token = value.token;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputHttpRawAuthTokensExtMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputHttpRawAuthTokensExtMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // token - computed: false, optional: false, required: true
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }
}

export class PackSourceInputHttpRawAuthTokensExtList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputHttpRawAuthTokensExt[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputHttpRawAuthTokensExtOutputReference {
    return new PackSourceInputHttpRawAuthTokensExtOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
