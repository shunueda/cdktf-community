import * as cdktf from 'cdktf';
import { PackSourceInputHttpRawAuthTokensExt,
packSourceInputHttpRawAuthTokensExtToTerraform,
packSourceInputHttpRawAuthTokensExtToHclTerraform,
PackSourceInputHttpRawAuthTokensExtList } from './structs0'
export interface PackSourceInputHttpRawConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputHttpRawConnectionsToTerraform(struct?: PackSourceInputHttpRawConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputHttpRawConnectionsToHclTerraform(struct?: PackSourceInputHttpRawConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpRawConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputHttpRawConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpRawConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputHttpRawConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputHttpRawConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputHttpRawConnectionsOutputReference {
    return new PackSourceInputHttpRawConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputHttpRawMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputHttpRawMetadataToTerraform(struct?: PackSourceInputHttpRawMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputHttpRawMetadataToHclTerraform(struct?: PackSourceInputHttpRawMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpRawMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputHttpRawMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpRawMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputHttpRawMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputHttpRawMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputHttpRawMetadataOutputReference {
    return new PackSourceInputHttpRawMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputHttpRawPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputHttpRawPqToTerraform(struct?: PackSourceInputHttpRawPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputHttpRawPqToHclTerraform(struct?: PackSourceInputHttpRawPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpRawPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputHttpRawPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpRawPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputHttpRawTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputHttpRawTlsToTerraform(struct?: PackSourceInputHttpRawTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputHttpRawTlsToHclTerraform(struct?: PackSourceInputHttpRawTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpRawTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputHttpRawTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpRawTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputHttpRaw {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all. Default: ["*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#allowed_methods PackSource#allowed_methods}
  */
  readonly allowedMethods?: string[];
  /**
  * List of URI paths accepted by this input, wildcards are supported, e.g /api/v* /hook. Defaults to allow all. Default: ["*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#allowed_paths PackSource#allowed_paths}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly allowedPaths?: string[];
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_tokens PackSource#auth_tokens}
  */
  readonly authTokens?: string[];
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_tokens_ext PackSource#auth_tokens_ext}
  */
  readonly authTokensExt?: PackSourceInputHttpRawAuthTokensExt[] | cdktf.IResolvable;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputHttpRawConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputHttpRawMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputHttpRawPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputHttpRawTls;
  /**
  * must be "http_raw"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputHttpRawToTerraform(struct?: PackSourceInputHttpRaw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    allowed_methods: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedMethods),
    allowed_paths: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedPaths),
    auth_tokens: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.authTokens),
    auth_tokens_ext: cdktf.listMapper(packSourceInputHttpRawAuthTokensExtToTerraform, false)(struct!.authTokensExt),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputHttpRawConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputHttpRawMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputHttpRawPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputHttpRawTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputHttpRawToHclTerraform(struct?: PackSourceInputHttpRaw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    allowed_methods: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedMethods),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allowed_paths: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedPaths),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.authTokens),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_tokens_ext: {
      value: cdktf.listMapperHcl(packSourceInputHttpRawAuthTokensExtToHclTerraform, false)(struct!.authTokensExt),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputHttpRawAuthTokensExtList",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputHttpRawConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputHttpRawConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputHttpRawMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputHttpRawMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputHttpRawPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputHttpRawPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputHttpRawTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputHttpRawTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputHttpRawOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputHttpRaw | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._allowedMethods !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedMethods = this._allowedMethods;
    }
    if (this._allowedPaths !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedPaths = this._allowedPaths;
    }
    if (this._authTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens;
    }
    if (this._authTokensExt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokensExt = this._authTokensExt?.internalValue;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputHttpRaw | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._allowedMethods = undefined;
      this._allowedPaths = undefined;
      this._authTokens = undefined;
      this._authTokensExt.internalValue = undefined;
      this._breakerRulesets = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._allowedMethods = value.allowedMethods;
      this._allowedPaths = value.allowedPaths;
      this._authTokens = value.authTokens;
      this._authTokensExt.internalValue = value.authTokensExt;
      this._breakerRulesets = value.breakerRulesets;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // allowed_methods - computed: true, optional: true, required: false
  private _allowedMethods?: string[]; 
  public get allowedMethods() {
    return this.getListAttribute('allowed_methods');
  }
  public set allowedMethods(value: string[]) {
    this._allowedMethods = value;
  }
  public resetAllowedMethods() {
    this._allowedMethods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedMethodsInput() {
    return this._allowedMethods;
  }

  // allowed_paths - computed: true, optional: true, required: false
  private _allowedPaths?: string[]; 
  public get allowedPaths() {
    return this.getListAttribute('allowed_paths');
  }
  public set allowedPaths(value: string[]) {
    this._allowedPaths = value;
  }
  public resetAllowedPaths() {
    this._allowedPaths = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedPathsInput() {
    return this._allowedPaths;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens?: string[]; 
  public get authTokens() {
    return this.getListAttribute('auth_tokens');
  }
  public set authTokens(value: string[]) {
    this._authTokens = value;
  }
  public resetAuthTokens() {
    this._authTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens;
  }

  // auth_tokens_ext - computed: false, optional: true, required: false
  private _authTokensExt = new PackSourceInputHttpRawAuthTokensExtList(this, "auth_tokens_ext", false);
  public get authTokensExt() {
    return this._authTokensExt;
  }
  public putAuthTokensExt(value: PackSourceInputHttpRawAuthTokensExt[] | cdktf.IResolvable) {
    this._authTokensExt.internalValue = value;
  }
  public resetAuthTokensExt() {
    this._authTokensExt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensExtInput() {
    return this._authTokensExt.internalValue;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputHttpRawConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputHttpRawConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputHttpRawMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputHttpRawMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputHttpRawPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputHttpRawPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputHttpRawTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputHttpRawTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputJournalFilesConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputJournalFilesConnectionsToTerraform(struct?: PackSourceInputJournalFilesConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputJournalFilesConnectionsToHclTerraform(struct?: PackSourceInputJournalFilesConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputJournalFilesConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputJournalFilesConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputJournalFilesConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputJournalFilesConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputJournalFilesConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputJournalFilesConnectionsOutputReference {
    return new PackSourceInputJournalFilesConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputJournalFilesMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputJournalFilesMetadataToTerraform(struct?: PackSourceInputJournalFilesMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputJournalFilesMetadataToHclTerraform(struct?: PackSourceInputJournalFilesMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputJournalFilesMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputJournalFilesMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputJournalFilesMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputJournalFilesMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputJournalFilesMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputJournalFilesMetadataOutputReference {
    return new PackSourceInputJournalFilesMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputJournalFilesPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputJournalFilesPqToTerraform(struct?: PackSourceInputJournalFilesPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputJournalFilesPqToHclTerraform(struct?: PackSourceInputJournalFilesPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputJournalFilesPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputJournalFilesPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputJournalFilesPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputJournalFilesRules {
  /**
  * Optional description of this rule's purpose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * JavaScript expression applied to Journal objects. Return 'true' to include it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#filter PackSource#filter}
  */
  readonly filter: string;
}

export function packSourceInputJournalFilesRulesToTerraform(struct?: PackSourceInputJournalFilesRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
  }
}


export function packSourceInputJournalFilesRulesToHclTerraform(struct?: PackSourceInputJournalFilesRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputJournalFilesRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputJournalFilesRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputJournalFilesRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._filter = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._filter = value.filter;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }
}

export class PackSourceInputJournalFilesRulesList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputJournalFilesRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputJournalFilesRulesOutputReference {
    return new PackSourceInputJournalFilesRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputJournalFiles {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputJournalFilesConnections[] | cdktf.IResolvable;
  /**
  * Skip log messages that are not part of the current boot session. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#current_boot PackSource#current_boot}
  */
  readonly currentBoot?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Time, in seconds, between scanning for journals. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * The full path of discovered journals are matched against this wildcard list. Default: ["system"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#journals PackSource#journals}
  */
  readonly journals?: string[];
  /**
  * The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_age_dur PackSource#max_age_dur}
  */
  readonly maxAgeDur?: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputJournalFilesMetadata[] | cdktf.IResolvable;
  /**
  * Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputJournalFilesPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#rules PackSource#rules}
  */
  readonly rules?: PackSourceInputJournalFilesRules[] | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "journal_files"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputJournalFilesToTerraform(struct?: PackSourceInputJournalFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputJournalFilesConnectionsToTerraform, false)(struct!.connections),
    current_boot: cdktf.booleanToTerraform(struct!.currentBoot),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    journals: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.journals),
    max_age_dur: cdktf.stringToTerraform(struct!.maxAgeDur),
    metadata: cdktf.listMapper(packSourceInputJournalFilesMetadataToTerraform, false)(struct!.metadata),
    path: cdktf.stringToTerraform(struct!.path),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputJournalFilesPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    rules: cdktf.listMapper(packSourceInputJournalFilesRulesToTerraform, false)(struct!.rules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputJournalFilesToHclTerraform(struct?: PackSourceInputJournalFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputJournalFilesConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputJournalFilesConnectionsList",
    },
    current_boot: {
      value: cdktf.booleanToHclTerraform(struct!.currentBoot),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    journals: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.journals),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_age_dur: {
      value: cdktf.stringToHclTerraform(struct!.maxAgeDur),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputJournalFilesMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputJournalFilesMetadataList",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputJournalFilesPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputJournalFilesPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rules: {
      value: cdktf.listMapperHcl(packSourceInputJournalFilesRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputJournalFilesRulesList",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputJournalFilesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputJournalFiles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._currentBoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.currentBoot = this._currentBoot;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._journals !== undefined) {
      hasAnyValues = true;
      internalValueResult.journals = this._journals;
    }
    if (this._maxAgeDur !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxAgeDur = this._maxAgeDur;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputJournalFiles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._currentBoot = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._journals = undefined;
      this._maxAgeDur = undefined;
      this._metadata.internalValue = undefined;
      this._path = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._rules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._currentBoot = value.currentBoot;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._interval = value.interval;
      this._journals = value.journals;
      this._maxAgeDur = value.maxAgeDur;
      this._metadata.internalValue = value.metadata;
      this._path = value.path;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._rules.internalValue = value.rules;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputJournalFilesConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputJournalFilesConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // current_boot - computed: true, optional: true, required: false
  private _currentBoot?: boolean | cdktf.IResolvable; 
  public get currentBoot() {
    return this.getBooleanAttribute('current_boot');
  }
  public set currentBoot(value: boolean | cdktf.IResolvable) {
    this._currentBoot = value;
  }
  public resetCurrentBoot() {
    this._currentBoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get currentBootInput() {
    return this._currentBoot;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // journals - computed: true, optional: true, required: false
  private _journals?: string[]; 
  public get journals() {
    return this.getListAttribute('journals');
  }
  public set journals(value: string[]) {
    this._journals = value;
  }
  public resetJournals() {
    this._journals = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get journalsInput() {
    return this._journals;
  }

  // max_age_dur - computed: false, optional: true, required: false
  private _maxAgeDur?: string; 
  public get maxAgeDur() {
    return this.getStringAttribute('max_age_dur');
  }
  public set maxAgeDur(value: string) {
    this._maxAgeDur = value;
  }
  public resetMaxAgeDur() {
    this._maxAgeDur = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxAgeDurInput() {
    return this._maxAgeDur;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputJournalFilesMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputJournalFilesMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputJournalFilesPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputJournalFilesPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new PackSourceInputJournalFilesRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: PackSourceInputJournalFilesRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputKafkaConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputKafkaConnectionsToTerraform(struct?: PackSourceInputKafkaConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputKafkaConnectionsToHclTerraform(struct?: PackSourceInputKafkaConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKafkaConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKafkaConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKafkaConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputKafkaConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKafkaConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKafkaConnectionsOutputReference {
    return new PackSourceInputKafkaConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKafkaKafkaSchemaRegistryAuth {
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packSourceInputKafkaKafkaSchemaRegistryAuthToTerraform(struct?: PackSourceInputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packSourceInputKafkaKafkaSchemaRegistryAuthToHclTerraform(struct?: PackSourceInputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKafkaKafkaSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsSecret = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsSecret = value.credentialsSecret;
      this._disabled = value.disabled;
    }
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackSourceInputKafkaKafkaSchemaRegistryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#servername PackSource#servername}
  */
  readonly servername?: string;
}

export function packSourceInputKafkaKafkaSchemaRegistryTlsToTerraform(struct?: PackSourceInputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packSourceInputKafkaKafkaSchemaRegistryTlsToHclTerraform(struct?: PackSourceInputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKafkaKafkaSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackSourceInputKafkaKafkaSchemaRegistry {
  /**
  * Credentials to use when authenticating with the schema registry using basic HTTP authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth PackSource#auth}
  */
  readonly auth?: PackSourceInputKafkaKafkaSchemaRegistryAuth;
  /**
  * Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connection_timeout PackSource#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times to try fetching schemas from the Schema Registry. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_retries PackSource#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum time to wait for the Schema Registry to respond to a request. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#schema_registry_url PackSource#schema_registry_url}
  */
  readonly schemaRegistryUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputKafkaKafkaSchemaRegistryTls;
}

export function packSourceInputKafkaKafkaSchemaRegistryToTerraform(struct?: PackSourceInputKafkaKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: packSourceInputKafkaKafkaSchemaRegistryAuthToTerraform(struct!.auth),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    schema_registry_url: cdktf.stringToTerraform(struct!.schemaRegistryUrl),
    tls: packSourceInputKafkaKafkaSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function packSourceInputKafkaKafkaSchemaRegistryToHclTerraform(struct?: PackSourceInputKafkaKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: packSourceInputKafkaKafkaSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputKafkaKafkaSchemaRegistryAuth",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schema_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.schemaRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packSourceInputKafkaKafkaSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputKafkaKafkaSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKafkaKafkaSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKafkaKafkaSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._schemaRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistryUrl = this._schemaRegistryUrl;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKafkaKafkaSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectionTimeout = undefined;
      this._disabled = undefined;
      this._maxRetries = undefined;
      this._requestTimeout = undefined;
      this._schemaRegistryUrl = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectionTimeout = value.connectionTimeout;
      this._disabled = value.disabled;
      this._maxRetries = value.maxRetries;
      this._requestTimeout = value.requestTimeout;
      this._schemaRegistryUrl = value.schemaRegistryUrl;
      this._tls.internalValue = value.tls;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new PackSourceInputKafkaKafkaSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: PackSourceInputKafkaKafkaSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // schema_registry_url - computed: true, optional: true, required: false
  private _schemaRegistryUrl?: string; 
  public get schemaRegistryUrl() {
    return this.getStringAttribute('schema_registry_url');
  }
  public set schemaRegistryUrl(value: string) {
    this._schemaRegistryUrl = value;
  }
  public resetSchemaRegistryUrl() {
    this._schemaRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryUrlInput() {
    return this._schemaRegistryUrl;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputKafkaKafkaSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputKafkaKafkaSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface PackSourceInputKafkaMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputKafkaMetadataToTerraform(struct?: PackSourceInputKafkaMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputKafkaMetadataToHclTerraform(struct?: PackSourceInputKafkaMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKafkaMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKafkaMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKafkaMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputKafkaMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKafkaMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKafkaMetadataOutputReference {
    return new PackSourceInputKafkaMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKafkaPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputKafkaPqToTerraform(struct?: PackSourceInputKafkaPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputKafkaPqToHclTerraform(struct?: PackSourceInputKafkaPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKafkaPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKafkaPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKafkaPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputKafkaSasl {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Default: "plain"; must be one of ["plain", "scram-sha-256", "scram-sha-512", "kerberos"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mechanism PackSource#mechanism}
  */
  readonly mechanism?: string;
}

export function packSourceInputKafkaSaslToTerraform(struct?: PackSourceInputKafkaSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    mechanism: cdktf.stringToTerraform(struct!.mechanism),
  }
}


export function packSourceInputKafkaSaslToHclTerraform(struct?: PackSourceInputKafkaSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mechanism: {
      value: cdktf.stringToHclTerraform(struct!.mechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKafkaSaslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKafkaSasl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._mechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.mechanism = this._mechanism;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKafkaSasl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._mechanism = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._mechanism = value.mechanism;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // mechanism - computed: true, optional: true, required: false
  private _mechanism?: string; 
  public get mechanism() {
    return this.getStringAttribute('mechanism');
  }
  public set mechanism(value: string) {
    this._mechanism = value;
  }
  public resetMechanism() {
    this._mechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mechanismInput() {
    return this._mechanism;
  }
}
export interface PackSourceInputKafkaTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#servername PackSource#servername}
  */
  readonly servername?: string;
}

export function packSourceInputKafkaTlsToTerraform(struct?: PackSourceInputKafkaTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packSourceInputKafkaTlsToHclTerraform(struct?: PackSourceInputKafkaTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKafkaTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKafkaTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKafkaTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackSourceInputKafka {
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#authentication_timeout PackSource#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auto_commit_interval PackSource#auto_commit_interval}
  */
  readonly autoCommitInterval?: number;
  /**
  * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auto_commit_threshold PackSource#auto_commit_threshold}
  */
  readonly autoCommitThreshold?: number;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#backoff_rate PackSource#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#brokers PackSource#brokers}
  */
  readonly brokers: string[];
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connection_timeout PackSource#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputKafkaConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#from_beginning PackSource#from_beginning}
  */
  readonly fromBeginning?: boolean | cdktf.IResolvable;
  /**
  * The consumer group to which this instance belongs. Defaults to 'Cribl'. Default: "Cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#group_id PackSource#group_id}
  */
  readonly groupId?: string;
  /**
  * Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
  *     Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
  *     See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
  * Default: 3000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#heartbeat_interval PackSource#heartbeat_interval}
  */
  readonly heartbeatInterval?: number;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#initial_backoff PackSource#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#kafka_schema_registry PackSource#kafka_schema_registry}
  */
  readonly kafkaSchemaRegistry?: PackSourceInputKafkaKafkaSchemaRegistry;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_back_off PackSource#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB). Default: 10485760
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_bytes PackSource#max_bytes}
  */
  readonly maxBytes?: number;
  /**
  * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB). Default: 1048576
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_bytes_per_partition PackSource#max_bytes_per_partition}
  */
  readonly maxBytesPerPartition?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_retries PackSource#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum number of network errors before the consumer re-creates a socket. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_socket_errors PackSource#max_socket_errors}
  */
  readonly maxSocketErrors?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputKafkaMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputKafkaPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reauthentication_threshold PackSource#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Maximum allowed time for each worker to join the group after a rebalance begins.
  *     If the timeout is exceeded, the coordinator broker will remove the worker from the group.
  *     See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
  * Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#rebalance_timeout PackSource#rebalance_timeout}
  */
  readonly rebalanceTimeout?: number;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#sasl PackSource#sasl}
  */
  readonly sasl?: PackSourceInputKafkaSasl;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Timeout used to detect client failures when using Kafka's group-management facilities.
  *     If the client sends no heartbeats to the broker before the timeout expires, 
  *     the broker will remove the client from the group and initiate a rebalance.
  *     Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
  *     See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
  * Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#session_timeout PackSource#session_timeout}
  */
  readonly sessionTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputKafkaTls;
  /**
  * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#topics PackSource#topics}
  */
  readonly topics?: string[];
  /**
  * must be "kafka"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputKafkaToTerraform(struct?: PackSourceInputKafka | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    auto_commit_interval: cdktf.numberToTerraform(struct!.autoCommitInterval),
    auto_commit_threshold: cdktf.numberToTerraform(struct!.autoCommitThreshold),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    connections: cdktf.listMapper(packSourceInputKafkaConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    from_beginning: cdktf.booleanToTerraform(struct!.fromBeginning),
    group_id: cdktf.stringToTerraform(struct!.groupId),
    heartbeat_interval: cdktf.numberToTerraform(struct!.heartbeatInterval),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    kafka_schema_registry: packSourceInputKafkaKafkaSchemaRegistryToTerraform(struct!.kafkaSchemaRegistry),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_bytes: cdktf.numberToTerraform(struct!.maxBytes),
    max_bytes_per_partition: cdktf.numberToTerraform(struct!.maxBytesPerPartition),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    max_socket_errors: cdktf.numberToTerraform(struct!.maxSocketErrors),
    metadata: cdktf.listMapper(packSourceInputKafkaMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputKafkaPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    rebalance_timeout: cdktf.numberToTerraform(struct!.rebalanceTimeout),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    sasl: packSourceInputKafkaSaslToTerraform(struct!.sasl),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    session_timeout: cdktf.numberToTerraform(struct!.sessionTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputKafkaTlsToTerraform(struct!.tls),
    topics: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.topics),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputKafkaToHclTerraform(struct?: PackSourceInputKafka | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_commit_interval: {
      value: cdktf.numberToHclTerraform(struct!.autoCommitInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_commit_threshold: {
      value: cdktf.numberToHclTerraform(struct!.autoCommitThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputKafkaConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKafkaConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    from_beginning: {
      value: cdktf.booleanToHclTerraform(struct!.fromBeginning),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    group_id: {
      value: cdktf.stringToHclTerraform(struct!.groupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    heartbeat_interval: {
      value: cdktf.numberToHclTerraform(struct!.heartbeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kafka_schema_registry: {
      value: packSourceInputKafkaKafkaSchemaRegistryToHclTerraform(struct!.kafkaSchemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputKafkaKafkaSchemaRegistry",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_bytes_per_partition: {
      value: cdktf.numberToHclTerraform(struct!.maxBytesPerPartition),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_socket_errors: {
      value: cdktf.numberToHclTerraform(struct!.maxSocketErrors),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputKafkaMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKafkaMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputKafkaPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputKafkaPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rebalance_timeout: {
      value: cdktf.numberToHclTerraform(struct!.rebalanceTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sasl: {
      value: packSourceInputKafkaSaslToHclTerraform(struct!.sasl),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputKafkaSasl",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    session_timeout: {
      value: cdktf.numberToHclTerraform(struct!.sessionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputKafkaTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputKafkaTls",
    },
    topics: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.topics),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKafkaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKafka | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._autoCommitInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCommitInterval = this._autoCommitInterval;
    }
    if (this._autoCommitThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCommitThreshold = this._autoCommitThreshold;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fromBeginning !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromBeginning = this._fromBeginning;
    }
    if (this._groupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupId = this._groupId;
    }
    if (this._heartbeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.heartbeatInterval = this._heartbeatInterval;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._kafkaSchemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaSchemaRegistry = this._kafkaSchemaRegistry?.internalValue;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBytes = this._maxBytes;
    }
    if (this._maxBytesPerPartition !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBytesPerPartition = this._maxBytesPerPartition;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._maxSocketErrors !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSocketErrors = this._maxSocketErrors;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._rebalanceTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.rebalanceTimeout = this._rebalanceTimeout;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sasl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sasl = this._sasl?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._sessionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionTimeout = this._sessionTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topics !== undefined) {
      hasAnyValues = true;
      internalValueResult.topics = this._topics;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKafka | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authenticationTimeout = undefined;
      this._autoCommitInterval = undefined;
      this._autoCommitThreshold = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._connectionTimeout = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._fromBeginning = undefined;
      this._groupId = undefined;
      this._heartbeatInterval = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._kafkaSchemaRegistry.internalValue = undefined;
      this._maxBackOff = undefined;
      this._maxBytes = undefined;
      this._maxBytesPerPartition = undefined;
      this._maxRetries = undefined;
      this._maxSocketErrors = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._reauthenticationThreshold = undefined;
      this._rebalanceTimeout = undefined;
      this._requestTimeout = undefined;
      this._sasl.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._sessionTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._topics = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authenticationTimeout = value.authenticationTimeout;
      this._autoCommitInterval = value.autoCommitInterval;
      this._autoCommitThreshold = value.autoCommitThreshold;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._connectionTimeout = value.connectionTimeout;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._fromBeginning = value.fromBeginning;
      this._groupId = value.groupId;
      this._heartbeatInterval = value.heartbeatInterval;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._kafkaSchemaRegistry.internalValue = value.kafkaSchemaRegistry;
      this._maxBackOff = value.maxBackOff;
      this._maxBytes = value.maxBytes;
      this._maxBytesPerPartition = value.maxBytesPerPartition;
      this._maxRetries = value.maxRetries;
      this._maxSocketErrors = value.maxSocketErrors;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._rebalanceTimeout = value.rebalanceTimeout;
      this._requestTimeout = value.requestTimeout;
      this._sasl.internalValue = value.sasl;
      this._sendToRoutes = value.sendToRoutes;
      this._sessionTimeout = value.sessionTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._topics = value.topics;
      this._type = value.type;
    }
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // auto_commit_interval - computed: false, optional: true, required: false
  private _autoCommitInterval?: number; 
  public get autoCommitInterval() {
    return this.getNumberAttribute('auto_commit_interval');
  }
  public set autoCommitInterval(value: number) {
    this._autoCommitInterval = value;
  }
  public resetAutoCommitInterval() {
    this._autoCommitInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCommitIntervalInput() {
    return this._autoCommitInterval;
  }

  // auto_commit_threshold - computed: false, optional: true, required: false
  private _autoCommitThreshold?: number; 
  public get autoCommitThreshold() {
    return this.getNumberAttribute('auto_commit_threshold');
  }
  public set autoCommitThreshold(value: number) {
    this._autoCommitThreshold = value;
  }
  public resetAutoCommitThreshold() {
    this._autoCommitThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCommitThresholdInput() {
    return this._autoCommitThreshold;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputKafkaConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputKafkaConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // from_beginning - computed: true, optional: true, required: false
  private _fromBeginning?: boolean | cdktf.IResolvable; 
  public get fromBeginning() {
    return this.getBooleanAttribute('from_beginning');
  }
  public set fromBeginning(value: boolean | cdktf.IResolvable) {
    this._fromBeginning = value;
  }
  public resetFromBeginning() {
    this._fromBeginning = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromBeginningInput() {
    return this._fromBeginning;
  }

  // group_id - computed: true, optional: true, required: false
  private _groupId?: string; 
  public get groupId() {
    return this.getStringAttribute('group_id');
  }
  public set groupId(value: string) {
    this._groupId = value;
  }
  public resetGroupId() {
    this._groupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupIdInput() {
    return this._groupId;
  }

  // heartbeat_interval - computed: true, optional: true, required: false
  private _heartbeatInterval?: number; 
  public get heartbeatInterval() {
    return this.getNumberAttribute('heartbeat_interval');
  }
  public set heartbeatInterval(value: number) {
    this._heartbeatInterval = value;
  }
  public resetHeartbeatInterval() {
    this._heartbeatInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get heartbeatIntervalInput() {
    return this._heartbeatInterval;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // kafka_schema_registry - computed: false, optional: true, required: false
  private _kafkaSchemaRegistry = new PackSourceInputKafkaKafkaSchemaRegistryOutputReference(this, "kafka_schema_registry");
  public get kafkaSchemaRegistry() {
    return this._kafkaSchemaRegistry;
  }
  public putKafkaSchemaRegistry(value: PackSourceInputKafkaKafkaSchemaRegistry) {
    this._kafkaSchemaRegistry.internalValue = value;
  }
  public resetKafkaSchemaRegistry() {
    this._kafkaSchemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaSchemaRegistryInput() {
    return this._kafkaSchemaRegistry.internalValue;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_bytes - computed: true, optional: true, required: false
  private _maxBytes?: number; 
  public get maxBytes() {
    return this.getNumberAttribute('max_bytes');
  }
  public set maxBytes(value: number) {
    this._maxBytes = value;
  }
  public resetMaxBytes() {
    this._maxBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBytesInput() {
    return this._maxBytes;
  }

  // max_bytes_per_partition - computed: true, optional: true, required: false
  private _maxBytesPerPartition?: number; 
  public get maxBytesPerPartition() {
    return this.getNumberAttribute('max_bytes_per_partition');
  }
  public set maxBytesPerPartition(value: number) {
    this._maxBytesPerPartition = value;
  }
  public resetMaxBytesPerPartition() {
    this._maxBytesPerPartition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBytesPerPartitionInput() {
    return this._maxBytesPerPartition;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // max_socket_errors - computed: true, optional: true, required: false
  private _maxSocketErrors?: number; 
  public get maxSocketErrors() {
    return this.getNumberAttribute('max_socket_errors');
  }
  public set maxSocketErrors(value: number) {
    this._maxSocketErrors = value;
  }
  public resetMaxSocketErrors() {
    this._maxSocketErrors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSocketErrorsInput() {
    return this._maxSocketErrors;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputKafkaMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputKafkaMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputKafkaPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputKafkaPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // rebalance_timeout - computed: true, optional: true, required: false
  private _rebalanceTimeout?: number; 
  public get rebalanceTimeout() {
    return this.getNumberAttribute('rebalance_timeout');
  }
  public set rebalanceTimeout(value: number) {
    this._rebalanceTimeout = value;
  }
  public resetRebalanceTimeout() {
    this._rebalanceTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rebalanceTimeoutInput() {
    return this._rebalanceTimeout;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // sasl - computed: false, optional: true, required: false
  private _sasl = new PackSourceInputKafkaSaslOutputReference(this, "sasl");
  public get sasl() {
    return this._sasl;
  }
  public putSasl(value: PackSourceInputKafkaSasl) {
    this._sasl.internalValue = value;
  }
  public resetSasl() {
    this._sasl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saslInput() {
    return this._sasl.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // session_timeout - computed: true, optional: true, required: false
  private _sessionTimeout?: number; 
  public get sessionTimeout() {
    return this.getNumberAttribute('session_timeout');
  }
  public set sessionTimeout(value: number) {
    this._sessionTimeout = value;
  }
  public resetSessionTimeout() {
    this._sessionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTimeoutInput() {
    return this._sessionTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputKafkaTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputKafkaTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topics - computed: true, optional: true, required: false
  private _topics?: string[]; 
  public get topics() {
    return this.getListAttribute('topics');
  }
  public set topics(value: string[]) {
    this._topics = value;
  }
  public resetTopics() {
    this._topics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicsInput() {
    return this._topics;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputKinesisConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputKinesisConnectionsToTerraform(struct?: PackSourceInputKinesisConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputKinesisConnectionsToHclTerraform(struct?: PackSourceInputKinesisConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKinesisConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKinesisConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKinesisConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputKinesisConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKinesisConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKinesisConnectionsOutputReference {
    return new PackSourceInputKinesisConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKinesisMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputKinesisMetadataToTerraform(struct?: PackSourceInputKinesisMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputKinesisMetadataToHclTerraform(struct?: PackSourceInputKinesisMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKinesisMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKinesisMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKinesisMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputKinesisMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKinesisMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKinesisMetadataOutputReference {
    return new PackSourceInputKinesisMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKinesisPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputKinesisPqToTerraform(struct?: PackSourceInputKinesisPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputKinesisPqToHclTerraform(struct?: PackSourceInputKinesisPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKinesisPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKinesisPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKinesisPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputKinesis {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_arn PackSource#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_external_id PackSource#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#avoid_duplicates PackSource#avoid_duplicates}
  */
  readonly avoidDuplicates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_api_key PackSource#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_authentication_method PackSource#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret PackSource#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret_key PackSource#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputKinesisConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#duration_seconds PackSource#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access Kinesis stream. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_assume_role PackSource#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint PackSource#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Maximum number of records per getRecords call. Default: 5000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#get_records_limit PackSource#get_records_limit}
  */
  readonly fetchRecordsLimit?: number;
  /**
  * Maximum number of records, across all shards, to pull down at once per Worker Process. Default: 20000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#get_records_limit_total PackSource#get_records_limit_total}
  */
  readonly fetchRecordsLimitTotal?: number;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes. Default: "ConsistentHashing"; must be one of ["ConsistentHashing", "RoundRobin"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#load_balancing_algorithm PackSource#load_balancing_algorithm}
  */
  readonly loadBalancingAlgorithm?: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputKinesisMetadata[] | cdktf.IResolvable;
  /**
  * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected. Default: "cribl"; must be one of ["cribl", "ndjson", "cloudwatch", "line"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#payload_format PackSource#payload_format}
  */
  readonly payloadFormat?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputKinesisPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Region where the Kinesis stream is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#region PackSource#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reuse_connections PackSource#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Time interval in minutes between consecutive service calls. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#service_interval PackSource#service_interval}
  */
  readonly serviceInterval?: number;
  /**
  * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed. Default: "true"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#shard_expr PackSource#shard_expr}
  */
  readonly shardExpr?: string;
  /**
  * Location at which to start reading a shard for the first time. Default: "TRIM_HORIZON"; must be one of ["TRIM_HORIZON", "LATEST"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#shard_iterator_type PackSource#shard_iterator_type}
  */
  readonly shardIteratorType?: string;
  /**
  * Signature version to use for signing Kinesis stream requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#signature_version PackSource#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Kinesis Data Stream to read data from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stream_name PackSource#stream_name}
  */
  readonly streamName: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "kinesis"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * Verify Kinesis Producer Library (KPL) event checksums. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#verify_kpl_check_sums PackSource#verify_kpl_check_sums}
  */
  readonly verifyKplCheckSums?: boolean | cdktf.IResolvable;
}

export function packSourceInputKinesisToTerraform(struct?: PackSourceInputKinesis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    avoid_duplicates: cdktf.booleanToTerraform(struct!.avoidDuplicates),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    connections: cdktf.listMapper(packSourceInputKinesisConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    get_records_limit: cdktf.numberToTerraform(struct!.fetchRecordsLimit),
    get_records_limit_total: cdktf.numberToTerraform(struct!.fetchRecordsLimitTotal),
    id: cdktf.stringToTerraform(struct!.id),
    load_balancing_algorithm: cdktf.stringToTerraform(struct!.loadBalancingAlgorithm),
    metadata: cdktf.listMapper(packSourceInputKinesisMetadataToTerraform, false)(struct!.metadata),
    payload_format: cdktf.stringToTerraform(struct!.payloadFormat),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputKinesisPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    service_interval: cdktf.numberToTerraform(struct!.serviceInterval),
    shard_expr: cdktf.stringToTerraform(struct!.shardExpr),
    shard_iterator_type: cdktf.stringToTerraform(struct!.shardIteratorType),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stream_name: cdktf.stringToTerraform(struct!.streamName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
    verify_kpl_check_sums: cdktf.booleanToTerraform(struct!.verifyKplCheckSums),
  }
}


export function packSourceInputKinesisToHclTerraform(struct?: PackSourceInputKinesis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    avoid_duplicates: {
      value: cdktf.booleanToHclTerraform(struct!.avoidDuplicates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputKinesisConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKinesisConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    get_records_limit: {
      value: cdktf.numberToHclTerraform(struct!.fetchRecordsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    get_records_limit_total: {
      value: cdktf.numberToHclTerraform(struct!.fetchRecordsLimitTotal),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balancing_algorithm: {
      value: cdktf.stringToHclTerraform(struct!.loadBalancingAlgorithm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputKinesisMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKinesisMetadataList",
    },
    payload_format: {
      value: cdktf.stringToHclTerraform(struct!.payloadFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputKinesisPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputKinesisPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    service_interval: {
      value: cdktf.numberToHclTerraform(struct!.serviceInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    shard_expr: {
      value: cdktf.stringToHclTerraform(struct!.shardExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    shard_iterator_type: {
      value: cdktf.stringToHclTerraform(struct!.shardIteratorType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stream_name: {
      value: cdktf.stringToHclTerraform(struct!.streamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_kpl_check_sums: {
      value: cdktf.booleanToHclTerraform(struct!.verifyKplCheckSums),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKinesisOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKinesis | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._avoidDuplicates !== undefined) {
      hasAnyValues = true;
      internalValueResult.avoidDuplicates = this._avoidDuplicates;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._getRecordsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.fetchRecordsLimit = this._getRecordsLimit;
    }
    if (this._getRecordsLimitTotal !== undefined) {
      hasAnyValues = true;
      internalValueResult.fetchRecordsLimitTotal = this._getRecordsLimitTotal;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalancingAlgorithm !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancingAlgorithm = this._loadBalancingAlgorithm;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._payloadFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.payloadFormat = this._payloadFormat;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._serviceInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceInterval = this._serviceInterval;
    }
    if (this._shardExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.shardExpr = this._shardExpr;
    }
    if (this._shardIteratorType !== undefined) {
      hasAnyValues = true;
      internalValueResult.shardIteratorType = this._shardIteratorType;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamName = this._streamName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._verifyKplCheckSums !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyKplCheckSums = this._verifyKplCheckSums;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKinesis | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._avoidDuplicates = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._getRecordsLimit = undefined;
      this._getRecordsLimitTotal = undefined;
      this._id = undefined;
      this._loadBalancingAlgorithm = undefined;
      this._metadata.internalValue = undefined;
      this._payloadFormat = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._serviceInterval = undefined;
      this._shardExpr = undefined;
      this._shardIteratorType = undefined;
      this._signatureVersion = undefined;
      this._streamName = undefined;
      this._streamtags = undefined;
      this._type = undefined;
      this._verifyKplCheckSums = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._avoidDuplicates = value.avoidDuplicates;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._getRecordsLimit = value.fetchRecordsLimit;
      this._getRecordsLimitTotal = value.fetchRecordsLimitTotal;
      this._id = value.id;
      this._loadBalancingAlgorithm = value.loadBalancingAlgorithm;
      this._metadata.internalValue = value.metadata;
      this._payloadFormat = value.payloadFormat;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._serviceInterval = value.serviceInterval;
      this._shardExpr = value.shardExpr;
      this._shardIteratorType = value.shardIteratorType;
      this._signatureVersion = value.signatureVersion;
      this._streamName = value.streamName;
      this._streamtags = value.streamtags;
      this._type = value.type;
      this._verifyKplCheckSums = value.verifyKplCheckSums;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // avoid_duplicates - computed: true, optional: true, required: false
  private _avoidDuplicates?: boolean | cdktf.IResolvable; 
  public get avoidDuplicates() {
    return this.getBooleanAttribute('avoid_duplicates');
  }
  public set avoidDuplicates(value: boolean | cdktf.IResolvable) {
    this._avoidDuplicates = value;
  }
  public resetAvoidDuplicates() {
    this._avoidDuplicates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get avoidDuplicatesInput() {
    return this._avoidDuplicates;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputKinesisConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputKinesisConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // get_records_limit - computed: true, optional: true, required: false
  private _getRecordsLimit?: number; 
  public get fetchRecordsLimit() {
    return this.getNumberAttribute('get_records_limit');
  }
  public set fetchRecordsLimit(value: number) {
    this._getRecordsLimit = value;
  }
  public resetFetchRecordsLimit() {
    this._getRecordsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fetchRecordsLimitInput() {
    return this._getRecordsLimit;
  }

  // get_records_limit_total - computed: true, optional: true, required: false
  private _getRecordsLimitTotal?: number; 
  public get fetchRecordsLimitTotal() {
    return this.getNumberAttribute('get_records_limit_total');
  }
  public set fetchRecordsLimitTotal(value: number) {
    this._getRecordsLimitTotal = value;
  }
  public resetFetchRecordsLimitTotal() {
    this._getRecordsLimitTotal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fetchRecordsLimitTotalInput() {
    return this._getRecordsLimitTotal;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balancing_algorithm - computed: true, optional: true, required: false
  private _loadBalancingAlgorithm?: string; 
  public get loadBalancingAlgorithm() {
    return this.getStringAttribute('load_balancing_algorithm');
  }
  public set loadBalancingAlgorithm(value: string) {
    this._loadBalancingAlgorithm = value;
  }
  public resetLoadBalancingAlgorithm() {
    this._loadBalancingAlgorithm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancingAlgorithmInput() {
    return this._loadBalancingAlgorithm;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputKinesisMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputKinesisMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // payload_format - computed: true, optional: true, required: false
  private _payloadFormat?: string; 
  public get payloadFormat() {
    return this.getStringAttribute('payload_format');
  }
  public set payloadFormat(value: string) {
    this._payloadFormat = value;
  }
  public resetPayloadFormat() {
    this._payloadFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get payloadFormatInput() {
    return this._payloadFormat;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputKinesisPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputKinesisPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // service_interval - computed: true, optional: true, required: false
  private _serviceInterval?: number; 
  public get serviceInterval() {
    return this.getNumberAttribute('service_interval');
  }
  public set serviceInterval(value: number) {
    this._serviceInterval = value;
  }
  public resetServiceInterval() {
    this._serviceInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceIntervalInput() {
    return this._serviceInterval;
  }

  // shard_expr - computed: true, optional: true, required: false
  private _shardExpr?: string; 
  public get shardExpr() {
    return this.getStringAttribute('shard_expr');
  }
  public set shardExpr(value: string) {
    this._shardExpr = value;
  }
  public resetShardExpr() {
    this._shardExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shardExprInput() {
    return this._shardExpr;
  }

  // shard_iterator_type - computed: true, optional: true, required: false
  private _shardIteratorType?: string; 
  public get shardIteratorType() {
    return this.getStringAttribute('shard_iterator_type');
  }
  public set shardIteratorType(value: string) {
    this._shardIteratorType = value;
  }
  public resetShardIteratorType() {
    this._shardIteratorType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shardIteratorTypeInput() {
    return this._shardIteratorType;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stream_name - computed: false, optional: false, required: true
  private _streamName?: string; 
  public get streamName() {
    return this.getStringAttribute('stream_name');
  }
  public set streamName(value: string) {
    this._streamName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get streamNameInput() {
    return this._streamName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // verify_kpl_check_sums - computed: true, optional: true, required: false
  private _verifyKplCheckSums?: boolean | cdktf.IResolvable; 
  public get verifyKplCheckSums() {
    return this.getBooleanAttribute('verify_kpl_check_sums');
  }
  public set verifyKplCheckSums(value: boolean | cdktf.IResolvable) {
    this._verifyKplCheckSums = value;
  }
  public resetVerifyKplCheckSums() {
    this._verifyKplCheckSums = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyKplCheckSumsInput() {
    return this._verifyKplCheckSums;
  }
}
export interface PackSourceInputKubeEventsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputKubeEventsConnectionsToTerraform(struct?: PackSourceInputKubeEventsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputKubeEventsConnectionsToHclTerraform(struct?: PackSourceInputKubeEventsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeEventsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKubeEventsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeEventsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputKubeEventsConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKubeEventsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKubeEventsConnectionsOutputReference {
    return new PackSourceInputKubeEventsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKubeEventsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputKubeEventsMetadataToTerraform(struct?: PackSourceInputKubeEventsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputKubeEventsMetadataToHclTerraform(struct?: PackSourceInputKubeEventsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeEventsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKubeEventsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeEventsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputKubeEventsMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKubeEventsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKubeEventsMetadataOutputReference {
    return new PackSourceInputKubeEventsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKubeEventsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputKubeEventsPqToTerraform(struct?: PackSourceInputKubeEventsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputKubeEventsPqToHclTerraform(struct?: PackSourceInputKubeEventsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeEventsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKubeEventsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeEventsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputKubeEventsRules {
  /**
  * Optional description of this rule's purpose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * JavaScript expression applied to Kubernetes objects. Return 'true' to include it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#filter PackSource#filter}
  */
  readonly filter: string;
}

export function packSourceInputKubeEventsRulesToTerraform(struct?: PackSourceInputKubeEventsRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
  }
}


export function packSourceInputKubeEventsRulesToHclTerraform(struct?: PackSourceInputKubeEventsRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeEventsRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKubeEventsRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeEventsRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._filter = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._filter = value.filter;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }
}

export class PackSourceInputKubeEventsRulesList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKubeEventsRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKubeEventsRulesOutputReference {
    return new PackSourceInputKubeEventsRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKubeEvents {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputKubeEventsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputKubeEventsMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputKubeEventsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Filtering on event fields
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#rules PackSource#rules}
  */
  readonly rules?: PackSourceInputKubeEventsRules[] | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "kube_events"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
}

export function packSourceInputKubeEventsToTerraform(struct?: PackSourceInputKubeEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputKubeEventsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    metadata: cdktf.listMapper(packSourceInputKubeEventsMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputKubeEventsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    rules: cdktf.listMapper(packSourceInputKubeEventsRulesToTerraform, false)(struct!.rules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputKubeEventsToHclTerraform(struct?: PackSourceInputKubeEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputKubeEventsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKubeEventsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputKubeEventsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKubeEventsMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputKubeEventsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputKubeEventsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rules: {
      value: cdktf.listMapperHcl(packSourceInputKubeEventsRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKubeEventsRulesList",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeEventsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKubeEvents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeEvents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._rules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._rules.internalValue = value.rules;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputKubeEventsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputKubeEventsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputKubeEventsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputKubeEventsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputKubeEventsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputKubeEventsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new PackSourceInputKubeEventsRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: PackSourceInputKubeEventsRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputKubeLogsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputKubeLogsConnectionsToTerraform(struct?: PackSourceInputKubeLogsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputKubeLogsConnectionsToHclTerraform(struct?: PackSourceInputKubeLogsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeLogsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKubeLogsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeLogsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputKubeLogsConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKubeLogsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKubeLogsConnectionsOutputReference {
    return new PackSourceInputKubeLogsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKubeLogsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputKubeLogsMetadataToTerraform(struct?: PackSourceInputKubeLogsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputKubeLogsMetadataToHclTerraform(struct?: PackSourceInputKubeLogsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeLogsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKubeLogsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeLogsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputKubeLogsMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKubeLogsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKubeLogsMetadataOutputReference {
    return new PackSourceInputKubeLogsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKubeLogsPersistence {
  /**
  * Data compression format. Default is gzip. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * Spool events on disk for Cribl Edge and Search. Default is disabled. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_size PackSource#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_time PackSource#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * Time period for grouping spooled events. Default is 10m. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#time_window PackSource#time_window}
  */
  readonly timeWindow?: string;
}

export function packSourceInputKubeLogsPersistenceToTerraform(struct?: PackSourceInputKubeLogsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
  }
}


export function packSourceInputKubeLogsPersistenceToHclTerraform(struct?: PackSourceInputKubeLogsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeLogsPersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKubeLogsPersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeLogsPersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._enable = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._timeWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._enable = value.enable;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._timeWindow = value.timeWindow;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }
}
export interface PackSourceInputKubeLogsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputKubeLogsPqToTerraform(struct?: PackSourceInputKubeLogsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputKubeLogsPqToHclTerraform(struct?: PackSourceInputKubeLogsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeLogsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKubeLogsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeLogsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputKubeLogsRules {
  /**
  * Optional description of this rule's purpose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * JavaScript expression applied to Pod objects. Return 'true' to include it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#filter PackSource#filter}
  */
  readonly filter: string;
}

export function packSourceInputKubeLogsRulesToTerraform(struct?: PackSourceInputKubeLogsRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
  }
}


export function packSourceInputKubeLogsRulesToHclTerraform(struct?: PackSourceInputKubeLogsRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeLogsRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKubeLogsRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeLogsRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._filter = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._filter = value.filter;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }
}

export class PackSourceInputKubeLogsRulesList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKubeLogsRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKubeLogsRulesOutputReference {
    return new PackSourceInputKubeLogsRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKubeLogs {
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputKubeLogsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Load balance traffic across all Worker Processes. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_load_balancing PackSource#enable_load_balancing}
  */
  readonly enableLoadBalancing?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Time, in seconds, between checks for new containers. Default is 15 secs. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputKubeLogsMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#persistence PackSource#persistence}
  */
  readonly persistence?: PackSourceInputKubeLogsPersistence;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputKubeLogsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#rules PackSource#rules}
  */
  readonly rules?: PackSourceInputKubeLogsRules[] | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#timestamps PackSource#timestamps}
  */
  readonly timestamps?: boolean | cdktf.IResolvable;
  /**
  * must be "kube_logs"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
}

export function packSourceInputKubeLogsToTerraform(struct?: PackSourceInputKubeLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    connections: cdktf.listMapper(packSourceInputKubeLogsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_load_balancing: cdktf.booleanToTerraform(struct!.enableLoadBalancing),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    metadata: cdktf.listMapper(packSourceInputKubeLogsMetadataToTerraform, false)(struct!.metadata),
    persistence: packSourceInputKubeLogsPersistenceToTerraform(struct!.persistence),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputKubeLogsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    rules: cdktf.listMapper(packSourceInputKubeLogsRulesToTerraform, false)(struct!.rules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    timestamps: cdktf.booleanToTerraform(struct!.timestamps),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputKubeLogsToHclTerraform(struct?: PackSourceInputKubeLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputKubeLogsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKubeLogsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_load_balancing: {
      value: cdktf.booleanToHclTerraform(struct!.enableLoadBalancing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputKubeLogsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKubeLogsMetadataList",
    },
    persistence: {
      value: packSourceInputKubeLogsPersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputKubeLogsPersistence",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputKubeLogsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputKubeLogsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rules: {
      value: cdktf.listMapperHcl(packSourceInputKubeLogsRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKubeLogsRulesList",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timestamps: {
      value: cdktf.booleanToHclTerraform(struct!.timestamps),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKubeLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableLoadBalancing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLoadBalancing = this._enableLoadBalancing;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._timestamps !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestamps = this._timestamps;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._breakerRulesets = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableLoadBalancing = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._metadata.internalValue = undefined;
      this._persistence.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._rules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._timestamps = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._breakerRulesets = value.breakerRulesets;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableLoadBalancing = value.enableLoadBalancing;
      this._environment = value.environment;
      this._id = value.id;
      this._interval = value.interval;
      this._metadata.internalValue = value.metadata;
      this._persistence.internalValue = value.persistence;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._rules.internalValue = value.rules;
      this._sendToRoutes = value.sendToRoutes;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._timestamps = value.timestamps;
      this._type = value.type;
    }
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputKubeLogsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputKubeLogsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_load_balancing - computed: true, optional: true, required: false
  private _enableLoadBalancing?: boolean | cdktf.IResolvable; 
  public get enableLoadBalancing() {
    return this.getBooleanAttribute('enable_load_balancing');
  }
  public set enableLoadBalancing(value: boolean | cdktf.IResolvable) {
    this._enableLoadBalancing = value;
  }
  public resetEnableLoadBalancing() {
    this._enableLoadBalancing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoadBalancingInput() {
    return this._enableLoadBalancing;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputKubeLogsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputKubeLogsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // persistence - computed: false, optional: true, required: false
  private _persistence = new PackSourceInputKubeLogsPersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: PackSourceInputKubeLogsPersistence) {
    this._persistence.internalValue = value;
  }
  public resetPersistence() {
    this._persistence.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputKubeLogsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputKubeLogsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new PackSourceInputKubeLogsRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: PackSourceInputKubeLogsRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // timestamps - computed: true, optional: true, required: false
  private _timestamps?: boolean | cdktf.IResolvable; 
  public get timestamps() {
    return this.getBooleanAttribute('timestamps');
  }
  public set timestamps(value: boolean | cdktf.IResolvable) {
    this._timestamps = value;
  }
  public resetTimestamps() {
    this._timestamps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampsInput() {
    return this._timestamps;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputKubeMetricsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputKubeMetricsConnectionsToTerraform(struct?: PackSourceInputKubeMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputKubeMetricsConnectionsToHclTerraform(struct?: PackSourceInputKubeMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeMetricsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKubeMetricsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeMetricsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputKubeMetricsConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKubeMetricsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKubeMetricsConnectionsOutputReference {
    return new PackSourceInputKubeMetricsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKubeMetricsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputKubeMetricsMetadataToTerraform(struct?: PackSourceInputKubeMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputKubeMetricsMetadataToHclTerraform(struct?: PackSourceInputKubeMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeMetricsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKubeMetricsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeMetricsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputKubeMetricsMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKubeMetricsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKubeMetricsMetadataOutputReference {
    return new PackSourceInputKubeMetricsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKubeMetricsPersistence {
  /**
  * Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>. Default: "$CRIBL_HOME/state/kube_metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#dest_path PackSource#dest_path}
  */
  readonly destPath?: string;
  /**
  * Spool metrics on disk for Cribl Search. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_size PackSource#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_time PackSource#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * Time span for each file bucket. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#time_window PackSource#time_window}
  */
  readonly timeWindow?: string;
}

export function packSourceInputKubeMetricsPersistenceToTerraform(struct?: PackSourceInputKubeMetricsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
  }
}


export function packSourceInputKubeMetricsPersistenceToHclTerraform(struct?: PackSourceInputKubeMetricsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeMetricsPersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKubeMetricsPersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeMetricsPersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._destPath = undefined;
      this._enable = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._timeWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._destPath = value.destPath;
      this._enable = value.enable;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._timeWindow = value.timeWindow;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }
}
export interface PackSourceInputKubeMetricsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputKubeMetricsPqToTerraform(struct?: PackSourceInputKubeMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputKubeMetricsPqToHclTerraform(struct?: PackSourceInputKubeMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeMetricsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKubeMetricsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeMetricsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputKubeMetricsRules {
  /**
  * Optional description of this rule's purpose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * JavaScript expression applied to Kubernetes objects. Return 'true' to include it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#filter PackSource#filter}
  */
  readonly filter: string;
}

export function packSourceInputKubeMetricsRulesToTerraform(struct?: PackSourceInputKubeMetricsRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
  }
}


export function packSourceInputKubeMetricsRulesToHclTerraform(struct?: PackSourceInputKubeMetricsRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeMetricsRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputKubeMetricsRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeMetricsRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._filter = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._filter = value.filter;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }
}

export class PackSourceInputKubeMetricsRulesList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputKubeMetricsRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputKubeMetricsRulesOutputReference {
    return new PackSourceInputKubeMetricsRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputKubeMetrics {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputKubeMetricsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Time, in seconds, between consecutive metrics collections. Default is 15 secs. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputKubeMetricsMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#persistence PackSource#persistence}
  */
  readonly persistence?: PackSourceInputKubeMetricsPersistence;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputKubeMetricsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#rules PackSource#rules}
  */
  readonly rules?: PackSourceInputKubeMetricsRules[] | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "kube_metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
}

export function packSourceInputKubeMetricsToTerraform(struct?: PackSourceInputKubeMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputKubeMetricsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    metadata: cdktf.listMapper(packSourceInputKubeMetricsMetadataToTerraform, false)(struct!.metadata),
    persistence: packSourceInputKubeMetricsPersistenceToTerraform(struct!.persistence),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputKubeMetricsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    rules: cdktf.listMapper(packSourceInputKubeMetricsRulesToTerraform, false)(struct!.rules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputKubeMetricsToHclTerraform(struct?: PackSourceInputKubeMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputKubeMetricsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKubeMetricsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputKubeMetricsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKubeMetricsMetadataList",
    },
    persistence: {
      value: packSourceInputKubeMetricsPersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputKubeMetricsPersistence",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputKubeMetricsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputKubeMetricsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rules: {
      value: cdktf.listMapperHcl(packSourceInputKubeMetricsRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputKubeMetricsRulesList",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputKubeMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputKubeMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputKubeMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._metadata.internalValue = undefined;
      this._persistence.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._rules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._interval = value.interval;
      this._metadata.internalValue = value.metadata;
      this._persistence.internalValue = value.persistence;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._rules.internalValue = value.rules;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputKubeMetricsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputKubeMetricsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputKubeMetricsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputKubeMetricsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // persistence - computed: false, optional: true, required: false
  private _persistence = new PackSourceInputKubeMetricsPersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: PackSourceInputKubeMetricsPersistence) {
    this._persistence.internalValue = value;
  }
  public resetPersistence() {
    this._persistence.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputKubeMetricsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputKubeMetricsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new PackSourceInputKubeMetricsRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: PackSourceInputKubeMetricsRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputLokiConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputLokiConnectionsToTerraform(struct?: PackSourceInputLokiConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputLokiConnectionsToHclTerraform(struct?: PackSourceInputLokiConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputLokiConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputLokiConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputLokiConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputLokiConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputLokiConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputLokiConnectionsOutputReference {
    return new PackSourceInputLokiConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputLokiMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputLokiMetadataToTerraform(struct?: PackSourceInputLokiMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputLokiMetadataToHclTerraform(struct?: PackSourceInputLokiMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputLokiMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputLokiMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputLokiMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputLokiMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputLokiMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputLokiMetadataOutputReference {
    return new PackSourceInputLokiMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputLokiOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputLokiOauthHeadersToTerraform(struct?: PackSourceInputLokiOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputLokiOauthHeadersToHclTerraform(struct?: PackSourceInputLokiOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputLokiOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputLokiOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputLokiOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputLokiOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputLokiOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputLokiOauthHeadersOutputReference {
    return new PackSourceInputLokiOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputLokiOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputLokiOauthParamsToTerraform(struct?: PackSourceInputLokiOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputLokiOauthParamsToHclTerraform(struct?: PackSourceInputLokiOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputLokiOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputLokiOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputLokiOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputLokiOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputLokiOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputLokiOauthParamsOutputReference {
    return new PackSourceInputLokiOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputLokiPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputLokiPqToTerraform(struct?: PackSourceInputLokiPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputLokiPqToHclTerraform(struct?: PackSourceInputLokiPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputLokiPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputLokiPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputLokiPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputLokiTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputLokiTlsToTerraform(struct?: PackSourceInputLokiTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputLokiTlsToHclTerraform(struct?: PackSourceInputLokiTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputLokiTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputLokiTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputLokiTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputLoki {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_header_expr PackSource#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Loki logs authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputLokiConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#login_url PackSource#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'. Default: "/loki/api/v1/push"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#loki_api PackSource#loki_api}
  */
  readonly lokiApi?: string;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputLokiMetadata[] | cdktf.IResolvable;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_headers PackSource#oauth_headers}
  */
  readonly oauthHeaders?: PackSourceInputLokiOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_params PackSource#oauth_params}
  */
  readonly oauthParams?: PackSourceInputLokiOauthParams[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#password PackSource#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputLokiPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret PackSource#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret_param_name PackSource#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputLokiTls;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_attribute_name PackSource#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_timeout_secs PackSource#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "loki"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#username PackSource#username}
  */
  readonly username?: string;
}

export function packSourceInputLokiToTerraform(struct?: PackSourceInputLoki | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputLokiConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    loki_api: cdktf.stringToTerraform(struct!.lokiApi),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputLokiMetadataToTerraform, false)(struct!.metadata),
    oauth_headers: cdktf.listMapper(packSourceInputLokiOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packSourceInputLokiOauthParamsToTerraform, false)(struct!.oauthParams),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputLokiPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    tls: packSourceInputLokiTlsToTerraform(struct!.tls),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packSourceInputLokiToHclTerraform(struct?: PackSourceInputLoki | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputLokiConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputLokiConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loki_api: {
      value: cdktf.stringToHclTerraform(struct!.lokiApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputLokiMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputLokiMetadataList",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packSourceInputLokiOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputLokiOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packSourceInputLokiOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputLokiOauthParamsList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputLokiPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputLokiPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packSourceInputLokiTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputLokiTls",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputLokiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputLoki | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._lokiApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiApi = this._lokiApi;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputLoki | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._loginUrl = undefined;
      this._lokiApi = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._tls.internalValue = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._loginUrl = value.loginUrl;
      this._lokiApi = value.lokiApi;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._tls.internalValue = value.tls;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._username = value.username;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputLokiConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputLokiConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // loki_api - computed: true, optional: true, required: false
  private _lokiApi?: string; 
  public get lokiApi() {
    return this.getStringAttribute('loki_api');
  }
  public set lokiApi(value: string) {
    this._lokiApi = value;
  }
  public resetLokiApi() {
    this._lokiApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiApiInput() {
    return this._lokiApi;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputLokiMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputLokiMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackSourceInputLokiOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackSourceInputLokiOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackSourceInputLokiOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackSourceInputLokiOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputLokiPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputLokiPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputLokiTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputLokiTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackSourceInputMetricsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputMetricsConnectionsToTerraform(struct?: PackSourceInputMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputMetricsConnectionsToHclTerraform(struct?: PackSourceInputMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMetricsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputMetricsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMetricsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputMetricsConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputMetricsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputMetricsConnectionsOutputReference {
    return new PackSourceInputMetricsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputMetricsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputMetricsMetadataToTerraform(struct?: PackSourceInputMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputMetricsMetadataToHclTerraform(struct?: PackSourceInputMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMetricsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputMetricsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMetricsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputMetricsMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputMetricsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputMetricsMetadataOutputReference {
    return new PackSourceInputMetricsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputMetricsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputMetricsPqToTerraform(struct?: PackSourceInputMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputMetricsPqToHclTerraform(struct?: PackSourceInputMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMetricsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputMetricsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMetricsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputMetricsTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputMetricsTlsToTerraform(struct?: PackSourceInputMetricsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputMetricsTlsToHclTerraform(struct?: PackSourceInputMetricsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMetricsTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputMetricsTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMetricsTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputMetrics {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputMetricsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Regex matching IP addresses that are allowed to send data. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_whitelist_regex PackSource#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of events to buffer when downstream is blocking. Only applies to UDP. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputMetricsMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputMetricsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Enter TCP port number to listen on. Not required if listening on UDP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tcp_port PackSource#tcp_port}
  */
  readonly tcpPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputMetricsTls;
  /**
  * must be "metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
  /**
  * Enter UDP port number to listen on. Not required if listening on TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#udp_port PackSource#udp_port}
  */
  readonly udpPort?: number;
  /**
  * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#udp_socket_rx_buf_size PackSource#udp_socket_rx_buf_size}
  */
  readonly udpSocketRxBufSize?: number;
}

export function packSourceInputMetricsToTerraform(struct?: PackSourceInputMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputMetricsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    metadata: cdktf.listMapper(packSourceInputMetricsMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputMetricsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tcp_port: cdktf.numberToTerraform(struct!.tcpPort),
    tls: packSourceInputMetricsTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    udp_port: cdktf.numberToTerraform(struct!.udpPort),
    udp_socket_rx_buf_size: cdktf.numberToTerraform(struct!.udpSocketRxBufSize),
  }
}


export function packSourceInputMetricsToHclTerraform(struct?: PackSourceInputMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputMetricsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputMetricsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputMetricsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputMetricsMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputMetricsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputMetricsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tcp_port: {
      value: cdktf.numberToHclTerraform(struct!.tcpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: packSourceInputMetricsTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputMetricsTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_port: {
      value: cdktf.numberToHclTerraform(struct!.udpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    udp_socket_rx_buf_size: {
      value: cdktf.numberToHclTerraform(struct!.udpSocketRxBufSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tcpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpPort = this._tcpPort;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpPort = this._udpPort;
    }
    if (this._udpSocketRxBufSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpSocketRxBufSize = this._udpSocketRxBufSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxBufferSize = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._tcpPort = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._udpPort = undefined;
      this._udpSocketRxBufSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxBufferSize = value.maxBufferSize;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._tcpPort = value.tcpPort;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._udpPort = value.udpPort;
      this._udpSocketRxBufSize = value.udpSocketRxBufSize;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputMetricsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputMetricsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputMetricsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputMetricsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputMetricsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputMetricsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tcp_port - computed: false, optional: true, required: false
  private _tcpPort?: number; 
  public get tcpPort() {
    return this.getNumberAttribute('tcp_port');
  }
  public set tcpPort(value: number) {
    this._tcpPort = value;
  }
  public resetTcpPort() {
    this._tcpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpPortInput() {
    return this._tcpPort;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputMetricsTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputMetricsTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_port - computed: false, optional: true, required: false
  private _udpPort?: number; 
  public get udpPort() {
    return this.getNumberAttribute('udp_port');
  }
  public set udpPort(value: number) {
    this._udpPort = value;
  }
  public resetUdpPort() {
    this._udpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpPortInput() {
    return this._udpPort;
  }

  // udp_socket_rx_buf_size - computed: false, optional: true, required: false
  private _udpSocketRxBufSize?: number; 
  public get udpSocketRxBufSize() {
    return this.getNumberAttribute('udp_socket_rx_buf_size');
  }
  public set udpSocketRxBufSize(value: number) {
    this._udpSocketRxBufSize = value;
  }
  public resetUdpSocketRxBufSize() {
    this._udpSocketRxBufSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpSocketRxBufSizeInput() {
    return this._udpSocketRxBufSize;
  }
}
export interface PackSourceInputModelDrivenTelemetryConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputModelDrivenTelemetryConnectionsToTerraform(struct?: PackSourceInputModelDrivenTelemetryConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputModelDrivenTelemetryConnectionsToHclTerraform(struct?: PackSourceInputModelDrivenTelemetryConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputModelDrivenTelemetryConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputModelDrivenTelemetryConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputModelDrivenTelemetryConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputModelDrivenTelemetryConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputModelDrivenTelemetryConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputModelDrivenTelemetryConnectionsOutputReference {
    return new PackSourceInputModelDrivenTelemetryConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputModelDrivenTelemetryMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputModelDrivenTelemetryMetadataToTerraform(struct?: PackSourceInputModelDrivenTelemetryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputModelDrivenTelemetryMetadataToHclTerraform(struct?: PackSourceInputModelDrivenTelemetryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputModelDrivenTelemetryMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputModelDrivenTelemetryMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputModelDrivenTelemetryMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputModelDrivenTelemetryMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputModelDrivenTelemetryMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputModelDrivenTelemetryMetadataOutputReference {
    return new PackSourceInputModelDrivenTelemetryMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputModelDrivenTelemetryPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputModelDrivenTelemetryPqToTerraform(struct?: PackSourceInputModelDrivenTelemetryPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputModelDrivenTelemetryPqToHclTerraform(struct?: PackSourceInputModelDrivenTelemetryPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputModelDrivenTelemetryPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputModelDrivenTelemetryPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputModelDrivenTelemetryPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputModelDrivenTelemetryTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputModelDrivenTelemetryTlsToTerraform(struct?: PackSourceInputModelDrivenTelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputModelDrivenTelemetryTlsToHclTerraform(struct?: PackSourceInputModelDrivenTelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputModelDrivenTelemetryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputModelDrivenTelemetryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputModelDrivenTelemetryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputModelDrivenTelemetry {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputModelDrivenTelemetryConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_cxn PackSource#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputModelDrivenTelemetryMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on. Default: 57000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputModelDrivenTelemetryPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000. Default: 5000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#shutdown_timeout_ms PackSource#shutdown_timeout_ms}
  */
  readonly shutdownTimeoutMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputModelDrivenTelemetryTls;
  /**
  * must be "model_driven_telemetry"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputModelDrivenTelemetryToTerraform(struct?: PackSourceInputModelDrivenTelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputModelDrivenTelemetryConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    metadata: cdktf.listMapper(packSourceInputModelDrivenTelemetryMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputModelDrivenTelemetryPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    shutdown_timeout_ms: cdktf.numberToTerraform(struct!.shutdownTimeoutMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputModelDrivenTelemetryTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputModelDrivenTelemetryToHclTerraform(struct?: PackSourceInputModelDrivenTelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputModelDrivenTelemetryConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputModelDrivenTelemetryConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputModelDrivenTelemetryMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputModelDrivenTelemetryMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputModelDrivenTelemetryPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputModelDrivenTelemetryPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    shutdown_timeout_ms: {
      value: cdktf.numberToHclTerraform(struct!.shutdownTimeoutMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputModelDrivenTelemetryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputModelDrivenTelemetryTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputModelDrivenTelemetryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputModelDrivenTelemetry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._shutdownTimeoutMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.shutdownTimeoutMs = this._shutdownTimeoutMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputModelDrivenTelemetry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._maxActiveCxn = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._shutdownTimeoutMs = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._maxActiveCxn = value.maxActiveCxn;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._shutdownTimeoutMs = value.shutdownTimeoutMs;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputModelDrivenTelemetryConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputModelDrivenTelemetryConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputModelDrivenTelemetryMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputModelDrivenTelemetryMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputModelDrivenTelemetryPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputModelDrivenTelemetryPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // shutdown_timeout_ms - computed: true, optional: true, required: false
  private _shutdownTimeoutMs?: number; 
  public get shutdownTimeoutMs() {
    return this.getNumberAttribute('shutdown_timeout_ms');
  }
  public set shutdownTimeoutMs(value: number) {
    this._shutdownTimeoutMs = value;
  }
  public resetShutdownTimeoutMs() {
    this._shutdownTimeoutMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shutdownTimeoutMsInput() {
    return this._shutdownTimeoutMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputModelDrivenTelemetryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputModelDrivenTelemetryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputMskConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputMskConnectionsToTerraform(struct?: PackSourceInputMskConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputMskConnectionsToHclTerraform(struct?: PackSourceInputMskConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMskConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputMskConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMskConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputMskConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputMskConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputMskConnectionsOutputReference {
    return new PackSourceInputMskConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputMskKafkaSchemaRegistryAuth {
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packSourceInputMskKafkaSchemaRegistryAuthToTerraform(struct?: PackSourceInputMskKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packSourceInputMskKafkaSchemaRegistryAuthToHclTerraform(struct?: PackSourceInputMskKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMskKafkaSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputMskKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMskKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsSecret = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsSecret = value.credentialsSecret;
      this._disabled = value.disabled;
    }
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackSourceInputMskKafkaSchemaRegistryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#servername PackSource#servername}
  */
  readonly servername?: string;
}

export function packSourceInputMskKafkaSchemaRegistryTlsToTerraform(struct?: PackSourceInputMskKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packSourceInputMskKafkaSchemaRegistryTlsToHclTerraform(struct?: PackSourceInputMskKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMskKafkaSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputMskKafkaSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMskKafkaSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackSourceInputMskKafkaSchemaRegistry {
  /**
  * Credentials to use when authenticating with the schema registry using basic HTTP authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth PackSource#auth}
  */
  readonly auth?: PackSourceInputMskKafkaSchemaRegistryAuth;
  /**
  * Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connection_timeout PackSource#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times to try fetching schemas from the Schema Registry. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_retries PackSource#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum time to wait for the Schema Registry to respond to a request. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#schema_registry_url PackSource#schema_registry_url}
  */
  readonly schemaRegistryUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputMskKafkaSchemaRegistryTls;
}

export function packSourceInputMskKafkaSchemaRegistryToTerraform(struct?: PackSourceInputMskKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: packSourceInputMskKafkaSchemaRegistryAuthToTerraform(struct!.auth),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    schema_registry_url: cdktf.stringToTerraform(struct!.schemaRegistryUrl),
    tls: packSourceInputMskKafkaSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function packSourceInputMskKafkaSchemaRegistryToHclTerraform(struct?: PackSourceInputMskKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: packSourceInputMskKafkaSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputMskKafkaSchemaRegistryAuth",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schema_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.schemaRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packSourceInputMskKafkaSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputMskKafkaSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMskKafkaSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputMskKafkaSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._schemaRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistryUrl = this._schemaRegistryUrl;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMskKafkaSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectionTimeout = undefined;
      this._disabled = undefined;
      this._maxRetries = undefined;
      this._requestTimeout = undefined;
      this._schemaRegistryUrl = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectionTimeout = value.connectionTimeout;
      this._disabled = value.disabled;
      this._maxRetries = value.maxRetries;
      this._requestTimeout = value.requestTimeout;
      this._schemaRegistryUrl = value.schemaRegistryUrl;
      this._tls.internalValue = value.tls;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new PackSourceInputMskKafkaSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: PackSourceInputMskKafkaSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // schema_registry_url - computed: true, optional: true, required: false
  private _schemaRegistryUrl?: string; 
  public get schemaRegistryUrl() {
    return this.getStringAttribute('schema_registry_url');
  }
  public set schemaRegistryUrl(value: string) {
    this._schemaRegistryUrl = value;
  }
  public resetSchemaRegistryUrl() {
    this._schemaRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryUrlInput() {
    return this._schemaRegistryUrl;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputMskKafkaSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputMskKafkaSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface PackSourceInputMskMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputMskMetadataToTerraform(struct?: PackSourceInputMskMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputMskMetadataToHclTerraform(struct?: PackSourceInputMskMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMskMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputMskMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMskMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputMskMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputMskMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputMskMetadataOutputReference {
    return new PackSourceInputMskMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputMskPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputMskPqToTerraform(struct?: PackSourceInputMskPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputMskPqToHclTerraform(struct?: PackSourceInputMskPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMskPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputMskPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMskPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputMskTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
  * 
  * 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#servername PackSource#servername}
  */
  readonly servername?: string;
}

export function packSourceInputMskTlsToTerraform(struct?: PackSourceInputMskTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packSourceInputMskTlsToHclTerraform(struct?: PackSourceInputMskTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMskTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputMskTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMskTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackSourceInputMsk {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_arn PackSource#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_external_id PackSource#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#authentication_timeout PackSource#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auto_commit_interval PackSource#auto_commit_interval}
  */
  readonly autoCommitInterval?: number;
  /**
  * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auto_commit_threshold PackSource#auto_commit_threshold}
  */
  readonly autoCommitThreshold?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_api_key PackSource#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_authentication_method PackSource#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret PackSource#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret_key PackSource#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#backoff_rate PackSource#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#brokers PackSource#brokers}
  */
  readonly brokers: string[];
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connection_timeout PackSource#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputMskConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#duration_seconds PackSource#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access MSK. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_assume_role PackSource#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint PackSource#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#from_beginning PackSource#from_beginning}
  */
  readonly fromBeginning?: boolean | cdktf.IResolvable;
  /**
  * The consumer group to which this instance belongs. Defaults to 'Cribl'. Default: "Cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#group_id PackSource#group_id}
  */
  readonly groupId?: string;
  /**
  * Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
  *     Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
  *     See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
  * Default: 3000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#heartbeat_interval PackSource#heartbeat_interval}
  */
  readonly heartbeatInterval?: number;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#initial_backoff PackSource#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#kafka_schema_registry PackSource#kafka_schema_registry}
  */
  readonly kafkaSchemaRegistry?: PackSourceInputMskKafkaSchemaRegistry;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_back_off PackSource#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB). Default: 10485760
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_bytes PackSource#max_bytes}
  */
  readonly maxBytes?: number;
  /**
  * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB). Default: 1048576
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_bytes_per_partition PackSource#max_bytes_per_partition}
  */
  readonly maxBytesPerPartition?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_retries PackSource#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum number of network errors before the consumer re-creates a socket. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_socket_errors PackSource#max_socket_errors}
  */
  readonly maxSocketErrors?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputMskMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputMskPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reauthentication_threshold PackSource#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Maximum allowed time for each worker to join the group after a rebalance begins.
  *     If the timeout is exceeded, the coordinator broker will remove the worker from the group.
  *     See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
  * Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#rebalance_timeout PackSource#rebalance_timeout}
  */
  readonly rebalanceTimeout?: number;
  /**
  * Region where the MSK cluster is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#region PackSource#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reuse_connections PackSource#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Timeout used to detect client failures when using Kafka's group-management facilities.
  *     If the client sends no heartbeats to the broker before the timeout expires, 
  *     the broker will remove the client from the group and initiate a rebalance.
  *     Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
  *     See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
  * Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#session_timeout PackSource#session_timeout}
  */
  readonly sessionTimeout?: number;
  /**
  * Signature version to use for signing MSK cluster requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#signature_version PackSource#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputMskTls;
  /**
  * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#topics PackSource#topics}
  */
  readonly topics?: string[];
  /**
  * must be "msk"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputMskToTerraform(struct?: PackSourceInputMsk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    auto_commit_interval: cdktf.numberToTerraform(struct!.autoCommitInterval),
    auto_commit_threshold: cdktf.numberToTerraform(struct!.autoCommitThreshold),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    connections: cdktf.listMapper(packSourceInputMskConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    from_beginning: cdktf.booleanToTerraform(struct!.fromBeginning),
    group_id: cdktf.stringToTerraform(struct!.groupId),
    heartbeat_interval: cdktf.numberToTerraform(struct!.heartbeatInterval),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    kafka_schema_registry: packSourceInputMskKafkaSchemaRegistryToTerraform(struct!.kafkaSchemaRegistry),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_bytes: cdktf.numberToTerraform(struct!.maxBytes),
    max_bytes_per_partition: cdktf.numberToTerraform(struct!.maxBytesPerPartition),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    max_socket_errors: cdktf.numberToTerraform(struct!.maxSocketErrors),
    metadata: cdktf.listMapper(packSourceInputMskMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputMskPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    rebalance_timeout: cdktf.numberToTerraform(struct!.rebalanceTimeout),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    session_timeout: cdktf.numberToTerraform(struct!.sessionTimeout),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputMskTlsToTerraform(struct!.tls),
    topics: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.topics),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputMskToHclTerraform(struct?: PackSourceInputMsk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_commit_interval: {
      value: cdktf.numberToHclTerraform(struct!.autoCommitInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_commit_threshold: {
      value: cdktf.numberToHclTerraform(struct!.autoCommitThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputMskConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputMskConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    from_beginning: {
      value: cdktf.booleanToHclTerraform(struct!.fromBeginning),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    group_id: {
      value: cdktf.stringToHclTerraform(struct!.groupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    heartbeat_interval: {
      value: cdktf.numberToHclTerraform(struct!.heartbeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kafka_schema_registry: {
      value: packSourceInputMskKafkaSchemaRegistryToHclTerraform(struct!.kafkaSchemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputMskKafkaSchemaRegistry",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_bytes_per_partition: {
      value: cdktf.numberToHclTerraform(struct!.maxBytesPerPartition),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_socket_errors: {
      value: cdktf.numberToHclTerraform(struct!.maxSocketErrors),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputMskMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputMskMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputMskPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputMskPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rebalance_timeout: {
      value: cdktf.numberToHclTerraform(struct!.rebalanceTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    session_timeout: {
      value: cdktf.numberToHclTerraform(struct!.sessionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputMskTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputMskTls",
    },
    topics: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.topics),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputMskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputMsk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._autoCommitInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCommitInterval = this._autoCommitInterval;
    }
    if (this._autoCommitThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCommitThreshold = this._autoCommitThreshold;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fromBeginning !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromBeginning = this._fromBeginning;
    }
    if (this._groupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupId = this._groupId;
    }
    if (this._heartbeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.heartbeatInterval = this._heartbeatInterval;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._kafkaSchemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaSchemaRegistry = this._kafkaSchemaRegistry?.internalValue;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBytes = this._maxBytes;
    }
    if (this._maxBytesPerPartition !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBytesPerPartition = this._maxBytesPerPartition;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._maxSocketErrors !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSocketErrors = this._maxSocketErrors;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._rebalanceTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.rebalanceTimeout = this._rebalanceTimeout;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._sessionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionTimeout = this._sessionTimeout;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topics !== undefined) {
      hasAnyValues = true;
      internalValueResult.topics = this._topics;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputMsk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._authenticationTimeout = undefined;
      this._autoCommitInterval = undefined;
      this._autoCommitThreshold = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._connectionTimeout = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fromBeginning = undefined;
      this._groupId = undefined;
      this._heartbeatInterval = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._kafkaSchemaRegistry.internalValue = undefined;
      this._maxBackOff = undefined;
      this._maxBytes = undefined;
      this._maxBytesPerPartition = undefined;
      this._maxRetries = undefined;
      this._maxSocketErrors = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._reauthenticationThreshold = undefined;
      this._rebalanceTimeout = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._requestTimeout = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._sessionTimeout = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._topics = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._authenticationTimeout = value.authenticationTimeout;
      this._autoCommitInterval = value.autoCommitInterval;
      this._autoCommitThreshold = value.autoCommitThreshold;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._connectionTimeout = value.connectionTimeout;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fromBeginning = value.fromBeginning;
      this._groupId = value.groupId;
      this._heartbeatInterval = value.heartbeatInterval;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._kafkaSchemaRegistry.internalValue = value.kafkaSchemaRegistry;
      this._maxBackOff = value.maxBackOff;
      this._maxBytes = value.maxBytes;
      this._maxBytesPerPartition = value.maxBytesPerPartition;
      this._maxRetries = value.maxRetries;
      this._maxSocketErrors = value.maxSocketErrors;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._rebalanceTimeout = value.rebalanceTimeout;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestTimeout = value.requestTimeout;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._sessionTimeout = value.sessionTimeout;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._topics = value.topics;
      this._type = value.type;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // auto_commit_interval - computed: false, optional: true, required: false
  private _autoCommitInterval?: number; 
  public get autoCommitInterval() {
    return this.getNumberAttribute('auto_commit_interval');
  }
  public set autoCommitInterval(value: number) {
    this._autoCommitInterval = value;
  }
  public resetAutoCommitInterval() {
    this._autoCommitInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCommitIntervalInput() {
    return this._autoCommitInterval;
  }

  // auto_commit_threshold - computed: false, optional: true, required: false
  private _autoCommitThreshold?: number; 
  public get autoCommitThreshold() {
    return this.getNumberAttribute('auto_commit_threshold');
  }
  public set autoCommitThreshold(value: number) {
    this._autoCommitThreshold = value;
  }
  public resetAutoCommitThreshold() {
    this._autoCommitThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCommitThresholdInput() {
    return this._autoCommitThreshold;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputMskConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputMskConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // from_beginning - computed: true, optional: true, required: false
  private _fromBeginning?: boolean | cdktf.IResolvable; 
  public get fromBeginning() {
    return this.getBooleanAttribute('from_beginning');
  }
  public set fromBeginning(value: boolean | cdktf.IResolvable) {
    this._fromBeginning = value;
  }
  public resetFromBeginning() {
    this._fromBeginning = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromBeginningInput() {
    return this._fromBeginning;
  }

  // group_id - computed: true, optional: true, required: false
  private _groupId?: string; 
  public get groupId() {
    return this.getStringAttribute('group_id');
  }
  public set groupId(value: string) {
    this._groupId = value;
  }
  public resetGroupId() {
    this._groupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupIdInput() {
    return this._groupId;
  }

  // heartbeat_interval - computed: true, optional: true, required: false
  private _heartbeatInterval?: number; 
  public get heartbeatInterval() {
    return this.getNumberAttribute('heartbeat_interval');
  }
  public set heartbeatInterval(value: number) {
    this._heartbeatInterval = value;
  }
  public resetHeartbeatInterval() {
    this._heartbeatInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get heartbeatIntervalInput() {
    return this._heartbeatInterval;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // kafka_schema_registry - computed: false, optional: true, required: false
  private _kafkaSchemaRegistry = new PackSourceInputMskKafkaSchemaRegistryOutputReference(this, "kafka_schema_registry");
  public get kafkaSchemaRegistry() {
    return this._kafkaSchemaRegistry;
  }
  public putKafkaSchemaRegistry(value: PackSourceInputMskKafkaSchemaRegistry) {
    this._kafkaSchemaRegistry.internalValue = value;
  }
  public resetKafkaSchemaRegistry() {
    this._kafkaSchemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaSchemaRegistryInput() {
    return this._kafkaSchemaRegistry.internalValue;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_bytes - computed: true, optional: true, required: false
  private _maxBytes?: number; 
  public get maxBytes() {
    return this.getNumberAttribute('max_bytes');
  }
  public set maxBytes(value: number) {
    this._maxBytes = value;
  }
  public resetMaxBytes() {
    this._maxBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBytesInput() {
    return this._maxBytes;
  }

  // max_bytes_per_partition - computed: true, optional: true, required: false
  private _maxBytesPerPartition?: number; 
  public get maxBytesPerPartition() {
    return this.getNumberAttribute('max_bytes_per_partition');
  }
  public set maxBytesPerPartition(value: number) {
    this._maxBytesPerPartition = value;
  }
  public resetMaxBytesPerPartition() {
    this._maxBytesPerPartition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBytesPerPartitionInput() {
    return this._maxBytesPerPartition;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // max_socket_errors - computed: true, optional: true, required: false
  private _maxSocketErrors?: number; 
  public get maxSocketErrors() {
    return this.getNumberAttribute('max_socket_errors');
  }
  public set maxSocketErrors(value: number) {
    this._maxSocketErrors = value;
  }
  public resetMaxSocketErrors() {
    this._maxSocketErrors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSocketErrorsInput() {
    return this._maxSocketErrors;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputMskMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputMskMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputMskPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputMskPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // rebalance_timeout - computed: true, optional: true, required: false
  private _rebalanceTimeout?: number; 
  public get rebalanceTimeout() {
    return this.getNumberAttribute('rebalance_timeout');
  }
  public set rebalanceTimeout(value: number) {
    this._rebalanceTimeout = value;
  }
  public resetRebalanceTimeout() {
    this._rebalanceTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rebalanceTimeoutInput() {
    return this._rebalanceTimeout;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // session_timeout - computed: true, optional: true, required: false
  private _sessionTimeout?: number; 
  public get sessionTimeout() {
    return this.getNumberAttribute('session_timeout');
  }
  public set sessionTimeout(value: number) {
    this._sessionTimeout = value;
  }
  public resetSessionTimeout() {
    this._sessionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTimeoutInput() {
    return this._sessionTimeout;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputMskTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputMskTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topics - computed: true, optional: true, required: false
  private _topics?: string[]; 
  public get topics() {
    return this.getListAttribute('topics');
  }
  public set topics(value: string[]) {
    this._topics = value;
  }
  public resetTopics() {
    this._topics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicsInput() {
    return this._topics;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputNetflowConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputNetflowConnectionsToTerraform(struct?: PackSourceInputNetflowConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputNetflowConnectionsToHclTerraform(struct?: PackSourceInputNetflowConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputNetflowConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputNetflowConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputNetflowConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputNetflowConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputNetflowConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputNetflowConnectionsOutputReference {
    return new PackSourceInputNetflowConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputNetflowMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputNetflowMetadataToTerraform(struct?: PackSourceInputNetflowMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputNetflowMetadataToHclTerraform(struct?: PackSourceInputNetflowMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputNetflowMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputNetflowMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputNetflowMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputNetflowMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputNetflowMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputNetflowMetadataOutputReference {
    return new PackSourceInputNetflowMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputNetflowPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputNetflowPqToTerraform(struct?: PackSourceInputNetflowPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputNetflowPqToHclTerraform(struct?: PackSourceInputNetflowPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputNetflowPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputNetflowPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputNetflowPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputNetflow {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputNetflowConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_pass_through PackSource#enable_pass_through}
  */
  readonly enablePassThrough?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * Accept messages in IPFIX format. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ipfix_enabled PackSource#ipfix_enabled}
  */
  readonly ipfixEnabled?: boolean | cdktf.IResolvable;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputNetflowMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on. Default: 2055
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputNetflowPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#template_cache_minutes PackSource#template_cache_minutes}
  */
  readonly templateCacheMinutes?: number;
  /**
  * must be "netflow"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#udp_socket_rx_buf_size PackSource#udp_socket_rx_buf_size}
  */
  readonly udpSocketRxBufSize?: number;
  /**
  * Accept messages in Netflow V5 format. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#v5_enabled PackSource#v5_enabled}
  */
  readonly v5Enabled?: boolean | cdktf.IResolvable;
  /**
  * Accept messages in Netflow V9 format. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#v9_enabled PackSource#v9_enabled}
  */
  readonly v9Enabled?: boolean | cdktf.IResolvable;
}

export function packSourceInputNetflowToTerraform(struct?: PackSourceInputNetflow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputNetflowConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_pass_through: cdktf.booleanToTerraform(struct!.enablePassThrough),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    ipfix_enabled: cdktf.booleanToTerraform(struct!.ipfixEnabled),
    metadata: cdktf.listMapper(packSourceInputNetflowMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputNetflowPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    template_cache_minutes: cdktf.numberToTerraform(struct!.templateCacheMinutes),
    type: cdktf.stringToTerraform(struct!.type),
    udp_socket_rx_buf_size: cdktf.numberToTerraform(struct!.udpSocketRxBufSize),
    v5_enabled: cdktf.booleanToTerraform(struct!.v5Enabled),
    v9_enabled: cdktf.booleanToTerraform(struct!.v9Enabled),
  }
}


export function packSourceInputNetflowToHclTerraform(struct?: PackSourceInputNetflow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputNetflowConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputNetflowConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_pass_through: {
      value: cdktf.booleanToHclTerraform(struct!.enablePassThrough),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipfix_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.ipfixEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputNetflowMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputNetflowMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputNetflowPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputNetflowPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    template_cache_minutes: {
      value: cdktf.numberToHclTerraform(struct!.templateCacheMinutes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_socket_rx_buf_size: {
      value: cdktf.numberToHclTerraform(struct!.udpSocketRxBufSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    v5_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.v5Enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    v9_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.v9Enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputNetflowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputNetflow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enablePassThrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePassThrough = this._enablePassThrough;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._ipfixEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipfixEnabled = this._ipfixEnabled;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._templateCacheMinutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.templateCacheMinutes = this._templateCacheMinutes;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpSocketRxBufSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpSocketRxBufSize = this._udpSocketRxBufSize;
    }
    if (this._v5Enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.v5Enabled = this._v5Enabled;
    }
    if (this._v9Enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.v9Enabled = this._v9Enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputNetflow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enablePassThrough = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._ipfixEnabled = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._templateCacheMinutes = undefined;
      this._type = undefined;
      this._udpSocketRxBufSize = undefined;
      this._v5Enabled = undefined;
      this._v9Enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enablePassThrough = value.enablePassThrough;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._ipfixEnabled = value.ipfixEnabled;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._templateCacheMinutes = value.templateCacheMinutes;
      this._type = value.type;
      this._udpSocketRxBufSize = value.udpSocketRxBufSize;
      this._v5Enabled = value.v5Enabled;
      this._v9Enabled = value.v9Enabled;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputNetflowConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputNetflowConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_pass_through - computed: true, optional: true, required: false
  private _enablePassThrough?: boolean | cdktf.IResolvable; 
  public get enablePassThrough() {
    return this.getBooleanAttribute('enable_pass_through');
  }
  public set enablePassThrough(value: boolean | cdktf.IResolvable) {
    this._enablePassThrough = value;
  }
  public resetEnablePassThrough() {
    this._enablePassThrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePassThroughInput() {
    return this._enablePassThrough;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // ipfix_enabled - computed: true, optional: true, required: false
  private _ipfixEnabled?: boolean | cdktf.IResolvable; 
  public get ipfixEnabled() {
    return this.getBooleanAttribute('ipfix_enabled');
  }
  public set ipfixEnabled(value: boolean | cdktf.IResolvable) {
    this._ipfixEnabled = value;
  }
  public resetIpfixEnabled() {
    this._ipfixEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipfixEnabledInput() {
    return this._ipfixEnabled;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputNetflowMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputNetflowMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputNetflowPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputNetflowPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // template_cache_minutes - computed: true, optional: true, required: false
  private _templateCacheMinutes?: number; 
  public get templateCacheMinutes() {
    return this.getNumberAttribute('template_cache_minutes');
  }
  public set templateCacheMinutes(value: number) {
    this._templateCacheMinutes = value;
  }
  public resetTemplateCacheMinutes() {
    this._templateCacheMinutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateCacheMinutesInput() {
    return this._templateCacheMinutes;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_socket_rx_buf_size - computed: false, optional: true, required: false
  private _udpSocketRxBufSize?: number; 
  public get udpSocketRxBufSize() {
    return this.getNumberAttribute('udp_socket_rx_buf_size');
  }
  public set udpSocketRxBufSize(value: number) {
    this._udpSocketRxBufSize = value;
  }
  public resetUdpSocketRxBufSize() {
    this._udpSocketRxBufSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpSocketRxBufSizeInput() {
    return this._udpSocketRxBufSize;
  }

  // v5_enabled - computed: true, optional: true, required: false
  private _v5Enabled?: boolean | cdktf.IResolvable; 
  public get v5Enabled() {
    return this.getBooleanAttribute('v5_enabled');
  }
  public set v5Enabled(value: boolean | cdktf.IResolvable) {
    this._v5Enabled = value;
  }
  public resetV5Enabled() {
    this._v5Enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get v5EnabledInput() {
    return this._v5Enabled;
  }

  // v9_enabled - computed: true, optional: true, required: false
  private _v9Enabled?: boolean | cdktf.IResolvable; 
  public get v9Enabled() {
    return this.getBooleanAttribute('v9_enabled');
  }
  public set v9Enabled(value: boolean | cdktf.IResolvable) {
    this._v9Enabled = value;
  }
  public resetV9Enabled() {
    this._v9Enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get v9EnabledInput() {
    return this._v9Enabled;
  }
}
export interface PackSourceInputOffice365MgmtConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputOffice365MgmtConnectionsToTerraform(struct?: PackSourceInputOffice365MgmtConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputOffice365MgmtConnectionsToHclTerraform(struct?: PackSourceInputOffice365MgmtConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365MgmtConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputOffice365MgmtConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365MgmtConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputOffice365MgmtConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputOffice365MgmtConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputOffice365MgmtConnectionsOutputReference {
    return new PackSourceInputOffice365MgmtConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputOffice365MgmtContentConfig {
  /**
  * Office 365 Management Activity API Content Type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#content_type PackSource#content_type}
  */
  readonly contentType: string;
  /**
  * If interval type is minutes the value entered must evenly divisible by 60 or save will fail
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enabled PackSource#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
  /**
  * Interval, in minutes, between polls
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval: number;
  /**
  * must be one of ["error", "warn", "info", "debug"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#log_level PackSource#log_level}
  */
  readonly logLevel: string;
}

export function packSourceInputOffice365MgmtContentConfigToTerraform(struct?: PackSourceInputOffice365MgmtContentConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    content_type: cdktf.stringToTerraform(struct!.contentType),
    description: cdktf.stringToTerraform(struct!.description),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    interval: cdktf.numberToTerraform(struct!.interval),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
  }
}


export function packSourceInputOffice365MgmtContentConfigToHclTerraform(struct?: PackSourceInputOffice365MgmtContentConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    content_type: {
      value: cdktf.stringToHclTerraform(struct!.contentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365MgmtContentConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputOffice365MgmtContentConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365MgmtContentConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._contentType = undefined;
      this._description = undefined;
      this._enabled = undefined;
      this._interval = undefined;
      this._logLevel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._contentType = value.contentType;
      this._description = value.description;
      this._enabled = value.enabled;
      this._interval = value.interval;
      this._logLevel = value.logLevel;
    }
  }

  // content_type - computed: false, optional: false, required: true
  private _contentType?: string; 
  public get contentType() {
    return this.getStringAttribute('content_type');
  }
  public set contentType(value: string) {
    this._contentType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // interval - computed: false, optional: false, required: true
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // log_level - computed: false, optional: false, required: true
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }
}

export class PackSourceInputOffice365MgmtContentConfigList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputOffice365MgmtContentConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputOffice365MgmtContentConfigOutputReference {
    return new PackSourceInputOffice365MgmtContentConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputOffice365MgmtMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputOffice365MgmtMetadataToTerraform(struct?: PackSourceInputOffice365MgmtMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputOffice365MgmtMetadataToHclTerraform(struct?: PackSourceInputOffice365MgmtMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365MgmtMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputOffice365MgmtMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365MgmtMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputOffice365MgmtMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputOffice365MgmtMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputOffice365MgmtMetadataOutputReference {
    return new PackSourceInputOffice365MgmtMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputOffice365MgmtPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputOffice365MgmtPqToTerraform(struct?: PackSourceInputOffice365MgmtPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputOffice365MgmtPqToHclTerraform(struct?: PackSourceInputOffice365MgmtPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365MgmtPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOffice365MgmtPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365MgmtPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputOffice365MgmtRetryRules {
  /**
  * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503. Default: [429,500,503]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#codes PackSource#codes}
  */
  readonly codes?: number[];
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_header PackSource#enable_header}
  */
  readonly enableHeader?: boolean | cdktf.IResolvable;
  /**
  * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * The maximum number of times to retry a failed HTTP request. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#limit PackSource#limit}
  */
  readonly limit?: number;
  /**
  * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#multiplier PackSource#multiplier}
  */
  readonly multiplier?: number;
  /**
  * Retry request when a connection reset (ECONNRESET) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_connect_reset PackSource#retry_connect_reset}
  */
  readonly retryConnectReset?: boolean | cdktf.IResolvable;
  /**
  * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_connect_timeout PackSource#retry_connect_timeout}
  */
  readonly retryConnectTimeout?: boolean | cdktf.IResolvable;
  /**
  * The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputOffice365MgmtRetryRulesToTerraform(struct?: PackSourceInputOffice365MgmtRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    codes: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.codes),
    enable_header: cdktf.booleanToTerraform(struct!.enableHeader),
    interval: cdktf.numberToTerraform(struct!.interval),
    limit: cdktf.numberToTerraform(struct!.limit),
    multiplier: cdktf.numberToTerraform(struct!.multiplier),
    retry_connect_reset: cdktf.booleanToTerraform(struct!.retryConnectReset),
    retry_connect_timeout: cdktf.booleanToTerraform(struct!.retryConnectTimeout),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputOffice365MgmtRetryRulesToHclTerraform(struct?: PackSourceInputOffice365MgmtRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    codes: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.codes),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    enable_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    limit: {
      value: cdktf.numberToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multiplier: {
      value: cdktf.numberToHclTerraform(struct!.multiplier),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_connect_reset: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectReset),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retry_connect_timeout: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365MgmtRetryRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOffice365MgmtRetryRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._codes !== undefined) {
      hasAnyValues = true;
      internalValueResult.codes = this._codes;
    }
    if (this._enableHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHeader = this._enableHeader;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._multiplier !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiplier = this._multiplier;
    }
    if (this._retryConnectReset !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectReset = this._retryConnectReset;
    }
    if (this._retryConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectTimeout = this._retryConnectTimeout;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365MgmtRetryRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._codes = undefined;
      this._enableHeader = undefined;
      this._interval = undefined;
      this._limit = undefined;
      this._multiplier = undefined;
      this._retryConnectReset = undefined;
      this._retryConnectTimeout = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._codes = value.codes;
      this._enableHeader = value.enableHeader;
      this._interval = value.interval;
      this._limit = value.limit;
      this._multiplier = value.multiplier;
      this._retryConnectReset = value.retryConnectReset;
      this._retryConnectTimeout = value.retryConnectTimeout;
      this._type = value.type;
    }
  }

  // codes - computed: true, optional: true, required: false
  private _codes?: number[]; 
  public get codes() {
    return this.getNumberListAttribute('codes');
  }
  public set codes(value: number[]) {
    this._codes = value;
  }
  public resetCodes() {
    this._codes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codesInput() {
    return this._codes;
  }

  // enable_header - computed: true, optional: true, required: false
  private _enableHeader?: boolean | cdktf.IResolvable; 
  public get enableHeader() {
    return this.getBooleanAttribute('enable_header');
  }
  public set enableHeader(value: boolean | cdktf.IResolvable) {
    this._enableHeader = value;
  }
  public resetEnableHeader() {
    this._enableHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHeaderInput() {
    return this._enableHeader;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // limit - computed: true, optional: true, required: false
  private _limit?: number; 
  public get limit() {
    return this.getNumberAttribute('limit');
  }
  public set limit(value: number) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // multiplier - computed: true, optional: true, required: false
  private _multiplier?: number; 
  public get multiplier() {
    return this.getNumberAttribute('multiplier');
  }
  public set multiplier(value: number) {
    this._multiplier = value;
  }
  public resetMultiplier() {
    this._multiplier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiplierInput() {
    return this._multiplier;
  }

  // retry_connect_reset - computed: true, optional: true, required: false
  private _retryConnectReset?: boolean | cdktf.IResolvable; 
  public get retryConnectReset() {
    return this.getBooleanAttribute('retry_connect_reset');
  }
  public set retryConnectReset(value: boolean | cdktf.IResolvable) {
    this._retryConnectReset = value;
  }
  public resetRetryConnectReset() {
    this._retryConnectReset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectResetInput() {
    return this._retryConnectReset;
  }

  // retry_connect_timeout - computed: true, optional: true, required: false
  private _retryConnectTimeout?: boolean | cdktf.IResolvable; 
  public get retryConnectTimeout() {
    return this.getBooleanAttribute('retry_connect_timeout');
  }
  public set retryConnectTimeout(value: boolean | cdktf.IResolvable) {
    this._retryConnectTimeout = value;
  }
  public resetRetryConnectTimeout() {
    this._retryConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectTimeoutInput() {
    return this._retryConnectTimeout;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputOffice365Mgmt {
  /**
  * Office 365 Azure Application ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#app_id PackSource#app_id}
  */
  readonly appId: string;
  /**
  * Enter client secret directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Office 365 Azure client secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#client_secret PackSource#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputOffice365MgmtConnections[] | cdktf.IResolvable;
  /**
  * Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#content_config PackSource#content_config}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly contentConfig?: PackSourceInputOffice365MgmtContentConfig[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ignore_group_jobs_limit PackSource#ignore_group_jobs_limit}
  */
  readonly ignoreGroupJobsLimit?: boolean | cdktf.IResolvable;
  /**
  * Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ingestion_lag PackSource#ingestion_lag}
  */
  readonly ingestionLag?: number;
  /**
  * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#job_timeout PackSource#job_timeout}
  */
  readonly jobTimeout?: string;
  /**
  * How often workers should check in with the scheduler to keep job subscription alive. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_time PackSource#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_missed_keep_alives PackSource#max_missed_keep_alives}
  */
  readonly maxMissedKeepAlives?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputOffice365MgmtMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Office 365 subscription plan for your organization, typically Office 365 Enterprise. Default: "enterprise_gcc"; must be one of ["enterprise_gcc", "gcc", "gcc_high", "dod"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#plan_type PackSource#plan_type}
  */
  readonly planType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputOffice365MgmtPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#publisher_identifier PackSource#publisher_identifier}
  */
  readonly publisherIdentifier?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_rules PackSource#retry_rules}
  */
  readonly retryRules?: PackSourceInputOffice365MgmtRetryRules;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Office 365 Azure Tenant ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tenant_id PackSource#tenant_id}
  */
  readonly tenantId: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * HTTP request inactivity timeout, use 0 to disable. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#timeout PackSource#timeout}
  */
  readonly timeout?: number;
  /**
  * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ttl PackSource#ttl}
  */
  readonly ttl?: string;
  /**
  * must be "office365_mgmt"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputOffice365MgmtToTerraform(struct?: PackSourceInputOffice365Mgmt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_id: cdktf.stringToTerraform(struct!.appId),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    connections: cdktf.listMapper(packSourceInputOffice365MgmtConnectionsToTerraform, false)(struct!.connections),
    content_config: cdktf.listMapper(packSourceInputOffice365MgmtContentConfigToTerraform, false)(struct!.contentConfig),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    ignore_group_jobs_limit: cdktf.booleanToTerraform(struct!.ignoreGroupJobsLimit),
    ingestion_lag: cdktf.numberToTerraform(struct!.ingestionLag),
    job_timeout: cdktf.stringToTerraform(struct!.jobTimeout),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    max_missed_keep_alives: cdktf.numberToTerraform(struct!.maxMissedKeepAlives),
    metadata: cdktf.listMapper(packSourceInputOffice365MgmtMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    plan_type: cdktf.stringToTerraform(struct!.planType),
    pq: packSourceInputOffice365MgmtPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    publisher_identifier: cdktf.stringToTerraform(struct!.publisherIdentifier),
    retry_rules: packSourceInputOffice365MgmtRetryRulesToTerraform(struct!.retryRules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout: cdktf.numberToTerraform(struct!.timeout),
    ttl: cdktf.stringToTerraform(struct!.ttl),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputOffice365MgmtToHclTerraform(struct?: PackSourceInputOffice365Mgmt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_id: {
      value: cdktf.stringToHclTerraform(struct!.appId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputOffice365MgmtConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputOffice365MgmtConnectionsList",
    },
    content_config: {
      value: cdktf.listMapperHcl(packSourceInputOffice365MgmtContentConfigToHclTerraform, false)(struct!.contentConfig),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputOffice365MgmtContentConfigList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_group_jobs_limit: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreGroupJobsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ingestion_lag: {
      value: cdktf.numberToHclTerraform(struct!.ingestionLag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    job_timeout: {
      value: cdktf.stringToHclTerraform(struct!.jobTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_missed_keep_alives: {
      value: cdktf.numberToHclTerraform(struct!.maxMissedKeepAlives),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputOffice365MgmtMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputOffice365MgmtMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plan_type: {
      value: cdktf.stringToHclTerraform(struct!.planType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputOffice365MgmtPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputOffice365MgmtPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    publisher_identifier: {
      value: cdktf.stringToHclTerraform(struct!.publisherIdentifier),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    retry_rules: {
      value: packSourceInputOffice365MgmtRetryRulesToHclTerraform(struct!.retryRules),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputOffice365MgmtRetryRules",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365MgmtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOffice365Mgmt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appId !== undefined) {
      hasAnyValues = true;
      internalValueResult.appId = this._appId;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._contentConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentConfig = this._contentConfig?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ignoreGroupJobsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreGroupJobsLimit = this._ignoreGroupJobsLimit;
    }
    if (this._ingestionLag !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingestionLag = this._ingestionLag;
    }
    if (this._jobTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobTimeout = this._jobTimeout;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._maxMissedKeepAlives !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMissedKeepAlives = this._maxMissedKeepAlives;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._planType !== undefined) {
      hasAnyValues = true;
      internalValueResult.planType = this._planType;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._publisherIdentifier !== undefined) {
      hasAnyValues = true;
      internalValueResult.publisherIdentifier = this._publisherIdentifier;
    }
    if (this._retryRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryRules = this._retryRules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365Mgmt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appId = undefined;
      this._authType = undefined;
      this._clientSecret = undefined;
      this._connections.internalValue = undefined;
      this._contentConfig.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._ignoreGroupJobsLimit = undefined;
      this._ingestionLag = undefined;
      this._jobTimeout = undefined;
      this._keepAliveTime = undefined;
      this._maxMissedKeepAlives = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._planType = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._publisherIdentifier = undefined;
      this._retryRules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._tenantId = undefined;
      this._textSecret = undefined;
      this._timeout = undefined;
      this._ttl = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appId = value.appId;
      this._authType = value.authType;
      this._clientSecret = value.clientSecret;
      this._connections.internalValue = value.connections;
      this._contentConfig.internalValue = value.contentConfig;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._ignoreGroupJobsLimit = value.ignoreGroupJobsLimit;
      this._ingestionLag = value.ingestionLag;
      this._jobTimeout = value.jobTimeout;
      this._keepAliveTime = value.keepAliveTime;
      this._maxMissedKeepAlives = value.maxMissedKeepAlives;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._planType = value.planType;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._publisherIdentifier = value.publisherIdentifier;
      this._retryRules.internalValue = value.retryRules;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._tenantId = value.tenantId;
      this._textSecret = value.textSecret;
      this._timeout = value.timeout;
      this._ttl = value.ttl;
      this._type = value.type;
    }
  }

  // app_id - computed: false, optional: false, required: true
  private _appId?: string; 
  public get appId() {
    return this.getStringAttribute('app_id');
  }
  public set appId(value: string) {
    this._appId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get appIdInput() {
    return this._appId;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputOffice365MgmtConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputOffice365MgmtConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // content_config - computed: false, optional: true, required: false
  private _contentConfig = new PackSourceInputOffice365MgmtContentConfigList(this, "content_config", false);
  public get contentConfig() {
    return this._contentConfig;
  }
  public putContentConfig(value: PackSourceInputOffice365MgmtContentConfig[] | cdktf.IResolvable) {
    this._contentConfig.internalValue = value;
  }
  public resetContentConfig() {
    this._contentConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentConfigInput() {
    return this._contentConfig.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ignore_group_jobs_limit - computed: true, optional: true, required: false
  private _ignoreGroupJobsLimit?: boolean | cdktf.IResolvable; 
  public get ignoreGroupJobsLimit() {
    return this.getBooleanAttribute('ignore_group_jobs_limit');
  }
  public set ignoreGroupJobsLimit(value: boolean | cdktf.IResolvable) {
    this._ignoreGroupJobsLimit = value;
  }
  public resetIgnoreGroupJobsLimit() {
    this._ignoreGroupJobsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreGroupJobsLimitInput() {
    return this._ignoreGroupJobsLimit;
  }

  // ingestion_lag - computed: true, optional: true, required: false
  private _ingestionLag?: number; 
  public get ingestionLag() {
    return this.getNumberAttribute('ingestion_lag');
  }
  public set ingestionLag(value: number) {
    this._ingestionLag = value;
  }
  public resetIngestionLag() {
    this._ingestionLag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingestionLagInput() {
    return this._ingestionLag;
  }

  // job_timeout - computed: true, optional: true, required: false
  private _jobTimeout?: string; 
  public get jobTimeout() {
    return this.getStringAttribute('job_timeout');
  }
  public set jobTimeout(value: string) {
    this._jobTimeout = value;
  }
  public resetJobTimeout() {
    this._jobTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobTimeoutInput() {
    return this._jobTimeout;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // max_missed_keep_alives - computed: true, optional: true, required: false
  private _maxMissedKeepAlives?: number; 
  public get maxMissedKeepAlives() {
    return this.getNumberAttribute('max_missed_keep_alives');
  }
  public set maxMissedKeepAlives(value: number) {
    this._maxMissedKeepAlives = value;
  }
  public resetMaxMissedKeepAlives() {
    this._maxMissedKeepAlives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMissedKeepAlivesInput() {
    return this._maxMissedKeepAlives;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputOffice365MgmtMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputOffice365MgmtMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // plan_type - computed: true, optional: true, required: false
  private _planType?: string; 
  public get planType() {
    return this.getStringAttribute('plan_type');
  }
  public set planType(value: string) {
    this._planType = value;
  }
  public resetPlanType() {
    this._planType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get planTypeInput() {
    return this._planType;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputOffice365MgmtPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputOffice365MgmtPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // publisher_identifier - computed: false, optional: true, required: false
  private _publisherIdentifier?: string; 
  public get publisherIdentifier() {
    return this.getStringAttribute('publisher_identifier');
  }
  public set publisherIdentifier(value: string) {
    this._publisherIdentifier = value;
  }
  public resetPublisherIdentifier() {
    this._publisherIdentifier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publisherIdentifierInput() {
    return this._publisherIdentifier;
  }

  // retry_rules - computed: false, optional: true, required: false
  private _retryRules = new PackSourceInputOffice365MgmtRetryRulesOutputReference(this, "retry_rules");
  public get retryRules() {
    return this._retryRules;
  }
  public putRetryRules(value: PackSourceInputOffice365MgmtRetryRules) {
    this._retryRules.internalValue = value;
  }
  public resetRetryRules() {
    this._retryRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryRulesInput() {
    return this._retryRules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tenant_id - computed: false, optional: false, required: true
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout - computed: true, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // ttl - computed: true, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputOffice365MsgTraceCertOptions {
  /**
  * Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath: string;
  /**
  * The name of the predefined certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Passphrase to use to decrypt the private key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath: string;
}

export function packSourceInputOffice365MsgTraceCertOptionsToTerraform(struct?: PackSourceInputOffice365MsgTraceCertOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
  }
}


export function packSourceInputOffice365MsgTraceCertOptionsToHclTerraform(struct?: PackSourceInputOffice365MsgTraceCertOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365MsgTraceCertOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOffice365MsgTraceCertOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365MsgTraceCertOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
    }
  }

  // cert_path - computed: false, optional: false, required: true
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: false, required: true
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }
}
export interface PackSourceInputOffice365MsgTraceConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputOffice365MsgTraceConnectionsToTerraform(struct?: PackSourceInputOffice365MsgTraceConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputOffice365MsgTraceConnectionsToHclTerraform(struct?: PackSourceInputOffice365MsgTraceConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365MsgTraceConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputOffice365MsgTraceConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365MsgTraceConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputOffice365MsgTraceConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputOffice365MsgTraceConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputOffice365MsgTraceConnectionsOutputReference {
    return new PackSourceInputOffice365MsgTraceConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputOffice365MsgTraceMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputOffice365MsgTraceMetadataToTerraform(struct?: PackSourceInputOffice365MsgTraceMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputOffice365MsgTraceMetadataToHclTerraform(struct?: PackSourceInputOffice365MsgTraceMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365MsgTraceMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputOffice365MsgTraceMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365MsgTraceMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputOffice365MsgTraceMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputOffice365MsgTraceMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputOffice365MsgTraceMetadataOutputReference {
    return new PackSourceInputOffice365MsgTraceMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputOffice365MsgTracePq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputOffice365MsgTracePqToTerraform(struct?: PackSourceInputOffice365MsgTracePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputOffice365MsgTracePqToHclTerraform(struct?: PackSourceInputOffice365MsgTracePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365MsgTracePqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOffice365MsgTracePq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365MsgTracePq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputOffice365MsgTraceRetryRules {
  /**
  * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503. Default: [429,500,503]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#codes PackSource#codes}
  */
  readonly codes?: number[];
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_header PackSource#enable_header}
  */
  readonly enableHeader?: boolean | cdktf.IResolvable;
  /**
  * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * The maximum number of times to retry a failed HTTP request. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#limit PackSource#limit}
  */
  readonly limit?: number;
  /**
  * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#multiplier PackSource#multiplier}
  */
  readonly multiplier?: number;
  /**
  * Retry request when a connection reset (ECONNRESET) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_connect_reset PackSource#retry_connect_reset}
  */
  readonly retryConnectReset?: boolean | cdktf.IResolvable;
  /**
  * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_connect_timeout PackSource#retry_connect_timeout}
  */
  readonly retryConnectTimeout?: boolean | cdktf.IResolvable;
  /**
  * The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputOffice365MsgTraceRetryRulesToTerraform(struct?: PackSourceInputOffice365MsgTraceRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    codes: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.codes),
    enable_header: cdktf.booleanToTerraform(struct!.enableHeader),
    interval: cdktf.numberToTerraform(struct!.interval),
    limit: cdktf.numberToTerraform(struct!.limit),
    multiplier: cdktf.numberToTerraform(struct!.multiplier),
    retry_connect_reset: cdktf.booleanToTerraform(struct!.retryConnectReset),
    retry_connect_timeout: cdktf.booleanToTerraform(struct!.retryConnectTimeout),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputOffice365MsgTraceRetryRulesToHclTerraform(struct?: PackSourceInputOffice365MsgTraceRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    codes: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.codes),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    enable_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    limit: {
      value: cdktf.numberToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multiplier: {
      value: cdktf.numberToHclTerraform(struct!.multiplier),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_connect_reset: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectReset),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retry_connect_timeout: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365MsgTraceRetryRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOffice365MsgTraceRetryRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._codes !== undefined) {
      hasAnyValues = true;
      internalValueResult.codes = this._codes;
    }
    if (this._enableHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHeader = this._enableHeader;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._multiplier !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiplier = this._multiplier;
    }
    if (this._retryConnectReset !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectReset = this._retryConnectReset;
    }
    if (this._retryConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectTimeout = this._retryConnectTimeout;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365MsgTraceRetryRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._codes = undefined;
      this._enableHeader = undefined;
      this._interval = undefined;
      this._limit = undefined;
      this._multiplier = undefined;
      this._retryConnectReset = undefined;
      this._retryConnectTimeout = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._codes = value.codes;
      this._enableHeader = value.enableHeader;
      this._interval = value.interval;
      this._limit = value.limit;
      this._multiplier = value.multiplier;
      this._retryConnectReset = value.retryConnectReset;
      this._retryConnectTimeout = value.retryConnectTimeout;
      this._type = value.type;
    }
  }

  // codes - computed: true, optional: true, required: false
  private _codes?: number[]; 
  public get codes() {
    return this.getNumberListAttribute('codes');
  }
  public set codes(value: number[]) {
    this._codes = value;
  }
  public resetCodes() {
    this._codes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codesInput() {
    return this._codes;
  }

  // enable_header - computed: true, optional: true, required: false
  private _enableHeader?: boolean | cdktf.IResolvable; 
  public get enableHeader() {
    return this.getBooleanAttribute('enable_header');
  }
  public set enableHeader(value: boolean | cdktf.IResolvable) {
    this._enableHeader = value;
  }
  public resetEnableHeader() {
    this._enableHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHeaderInput() {
    return this._enableHeader;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // limit - computed: true, optional: true, required: false
  private _limit?: number; 
  public get limit() {
    return this.getNumberAttribute('limit');
  }
  public set limit(value: number) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // multiplier - computed: true, optional: true, required: false
  private _multiplier?: number; 
  public get multiplier() {
    return this.getNumberAttribute('multiplier');
  }
  public set multiplier(value: number) {
    this._multiplier = value;
  }
  public resetMultiplier() {
    this._multiplier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiplierInput() {
    return this._multiplier;
  }

  // retry_connect_reset - computed: true, optional: true, required: false
  private _retryConnectReset?: boolean | cdktf.IResolvable; 
  public get retryConnectReset() {
    return this.getBooleanAttribute('retry_connect_reset');
  }
  public set retryConnectReset(value: boolean | cdktf.IResolvable) {
    this._retryConnectReset = value;
  }
  public resetRetryConnectReset() {
    this._retryConnectReset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectResetInput() {
    return this._retryConnectReset;
  }

  // retry_connect_timeout - computed: true, optional: true, required: false
  private _retryConnectTimeout?: boolean | cdktf.IResolvable; 
  public get retryConnectTimeout() {
    return this.getBooleanAttribute('retry_connect_timeout');
  }
  public set retryConnectTimeout(value: boolean | cdktf.IResolvable) {
    this._retryConnectTimeout = value;
  }
  public resetRetryConnectTimeout() {
    this._retryConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectTimeoutInput() {
    return this._retryConnectTimeout;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputOffice365MsgTrace {
  /**
  * Select authentication method. Default: "oauth"; must be one of ["manual", "secret", "oauth", "oauthSecret", "oauthCert"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_options PackSource#cert_options}
  */
  readonly certOptions?: PackSourceInputOffice365MsgTraceCertOptions;
  /**
  * client_id to pass in the OAuth request parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#client_id PackSource#client_id}
  */
  readonly clientId?: string;
  /**
  * client_secret to pass in the OAuth request parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#client_secret PackSource#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputOffice365MsgTraceConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Disables time filtering of events when a date range is specified. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disable_time_filter PackSource#disable_time_filter}
  */
  readonly disableTimeFilter?: boolean | cdktf.IResolvable;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#end_date PackSource#end_date}
  */
  readonly endDate?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ignore_group_jobs_limit PackSource#ignore_group_jobs_limit}
  */
  readonly ignoreGroupJobsLimit?: boolean | cdktf.IResolvable;
  /**
  * How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#job_timeout PackSource#job_timeout}
  */
  readonly jobTimeout?: string;
  /**
  * How often workers should check in with the scheduler to keep job subscription alive. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_time PackSource#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * Log Level (verbosity) for collection runtime behavior. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#log_level PackSource#log_level}
  */
  readonly logLevel?: string;
  /**
  * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_missed_keep_alives PackSource#max_missed_keep_alives}
  */
  readonly maxMissedKeepAlives?: number;
  /**
  * Maximum number of times a task can be rescheduled. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_task_reschedule PackSource#max_task_reschedule}
  */
  readonly maxTaskReschedule?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputOffice365MsgTraceMetadata[] | cdktf.IResolvable;
  /**
  * Password to run Message Trace API call.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#password PackSource#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Office 365 subscription plan for your organization, typically Office 365 Enterprise. Default: "enterprise_gcc"; must be one of ["enterprise_gcc", "gcc", "gcc_high", "dod"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#plan_type PackSource#plan_type}
  */
  readonly planType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputOffice365MsgTracePq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Reschedule tasks that failed with non-fatal errors. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reschedule_dropped_tasks PackSource#reschedule_dropped_tasks}
  */
  readonly rescheduleDroppedTasks?: boolean | cdktf.IResolvable;
  /**
  * Resource to pass in the OAuth request parameter. Default: "https://outlook.office365.com"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#resource PackSource#resource}
  */
  readonly resource?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_rules PackSource#retry_rules}
  */
  readonly retryRules?: PackSourceInputOffice365MsgTraceRetryRules;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#start_date PackSource#start_date}
  */
  readonly startDate?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Directory ID (tenant identifier) in Azure Active Directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tenant_id PackSource#tenant_id}
  */
  readonly tenantId?: string;
  /**
  * Select or create a secret that references your client_secret to pass in the OAuth request parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#timeout PackSource#timeout}
  */
  readonly timeout?: number;
  /**
  * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ttl PackSource#ttl}
  */
  readonly ttl?: string;
  /**
  * must be "office365_msg_trace"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * URL to use when retrieving report data. Default: "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#url PackSource#url}
  */
  readonly url?: string;
  /**
  * Username to run Message Trace API call.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#username PackSource#username}
  */
  readonly username?: string;
}

export function packSourceInputOffice365MsgTraceToTerraform(struct?: PackSourceInputOffice365MsgTrace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    cert_options: packSourceInputOffice365MsgTraceCertOptionsToTerraform(struct!.certOptions),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    connections: cdktf.listMapper(packSourceInputOffice365MsgTraceConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    disable_time_filter: cdktf.booleanToTerraform(struct!.disableTimeFilter),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    end_date: cdktf.stringToTerraform(struct!.endDate),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    ignore_group_jobs_limit: cdktf.booleanToTerraform(struct!.ignoreGroupJobsLimit),
    interval: cdktf.numberToTerraform(struct!.interval),
    job_timeout: cdktf.stringToTerraform(struct!.jobTimeout),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    max_missed_keep_alives: cdktf.numberToTerraform(struct!.maxMissedKeepAlives),
    max_task_reschedule: cdktf.numberToTerraform(struct!.maxTaskReschedule),
    metadata: cdktf.listMapper(packSourceInputOffice365MsgTraceMetadataToTerraform, false)(struct!.metadata),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    plan_type: cdktf.stringToTerraform(struct!.planType),
    pq: packSourceInputOffice365MsgTracePqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    reschedule_dropped_tasks: cdktf.booleanToTerraform(struct!.rescheduleDroppedTasks),
    resource: cdktf.stringToTerraform(struct!.resource),
    retry_rules: packSourceInputOffice365MsgTraceRetryRulesToTerraform(struct!.retryRules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    start_date: cdktf.stringToTerraform(struct!.startDate),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout: cdktf.numberToTerraform(struct!.timeout),
    ttl: cdktf.stringToTerraform(struct!.ttl),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packSourceInputOffice365MsgTraceToHclTerraform(struct?: PackSourceInputOffice365MsgTrace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_options: {
      value: packSourceInputOffice365MsgTraceCertOptionsToHclTerraform(struct!.certOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputOffice365MsgTraceCertOptions",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputOffice365MsgTraceConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputOffice365MsgTraceConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_time_filter: {
      value: cdktf.booleanToHclTerraform(struct!.disableTimeFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    end_date: {
      value: cdktf.stringToHclTerraform(struct!.endDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_group_jobs_limit: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreGroupJobsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    job_timeout: {
      value: cdktf.stringToHclTerraform(struct!.jobTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_missed_keep_alives: {
      value: cdktf.numberToHclTerraform(struct!.maxMissedKeepAlives),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_task_reschedule: {
      value: cdktf.numberToHclTerraform(struct!.maxTaskReschedule),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputOffice365MsgTraceMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputOffice365MsgTraceMetadataList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plan_type: {
      value: cdktf.stringToHclTerraform(struct!.planType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputOffice365MsgTracePqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputOffice365MsgTracePq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reschedule_dropped_tasks: {
      value: cdktf.booleanToHclTerraform(struct!.rescheduleDroppedTasks),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    retry_rules: {
      value: packSourceInputOffice365MsgTraceRetryRulesToHclTerraform(struct!.retryRules),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputOffice365MsgTraceRetryRules",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    start_date: {
      value: cdktf.stringToHclTerraform(struct!.startDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365MsgTraceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOffice365MsgTrace | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._certOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certOptions = this._certOptions?.internalValue;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disableTimeFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTimeFilter = this._disableTimeFilter;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._endDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.endDate = this._endDate;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ignoreGroupJobsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreGroupJobsLimit = this._ignoreGroupJobsLimit;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._jobTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobTimeout = this._jobTimeout;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._maxMissedKeepAlives !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMissedKeepAlives = this._maxMissedKeepAlives;
    }
    if (this._maxTaskReschedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTaskReschedule = this._maxTaskReschedule;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._planType !== undefined) {
      hasAnyValues = true;
      internalValueResult.planType = this._planType;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._rescheduleDroppedTasks !== undefined) {
      hasAnyValues = true;
      internalValueResult.rescheduleDroppedTasks = this._rescheduleDroppedTasks;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    if (this._retryRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryRules = this._retryRules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._startDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.startDate = this._startDate;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365MsgTrace | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._certOptions.internalValue = undefined;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._disableTimeFilter = undefined;
      this._disabled = undefined;
      this._endDate = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._ignoreGroupJobsLimit = undefined;
      this._interval = undefined;
      this._jobTimeout = undefined;
      this._keepAliveTime = undefined;
      this._logLevel = undefined;
      this._maxMissedKeepAlives = undefined;
      this._maxTaskReschedule = undefined;
      this._metadata.internalValue = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._planType = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._rescheduleDroppedTasks = undefined;
      this._resource = undefined;
      this._retryRules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._startDate = undefined;
      this._streamtags = undefined;
      this._tenantId = undefined;
      this._textSecret = undefined;
      this._timeout = undefined;
      this._ttl = undefined;
      this._type = undefined;
      this._url = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._certOptions.internalValue = value.certOptions;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._disableTimeFilter = value.disableTimeFilter;
      this._disabled = value.disabled;
      this._endDate = value.endDate;
      this._environment = value.environment;
      this._id = value.id;
      this._ignoreGroupJobsLimit = value.ignoreGroupJobsLimit;
      this._interval = value.interval;
      this._jobTimeout = value.jobTimeout;
      this._keepAliveTime = value.keepAliveTime;
      this._logLevel = value.logLevel;
      this._maxMissedKeepAlives = value.maxMissedKeepAlives;
      this._maxTaskReschedule = value.maxTaskReschedule;
      this._metadata.internalValue = value.metadata;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._planType = value.planType;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._rescheduleDroppedTasks = value.rescheduleDroppedTasks;
      this._resource = value.resource;
      this._retryRules.internalValue = value.retryRules;
      this._sendToRoutes = value.sendToRoutes;
      this._startDate = value.startDate;
      this._streamtags = value.streamtags;
      this._tenantId = value.tenantId;
      this._textSecret = value.textSecret;
      this._timeout = value.timeout;
      this._ttl = value.ttl;
      this._type = value.type;
      this._url = value.url;
      this._username = value.username;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // cert_options - computed: false, optional: true, required: false
  private _certOptions = new PackSourceInputOffice365MsgTraceCertOptionsOutputReference(this, "cert_options");
  public get certOptions() {
    return this._certOptions;
  }
  public putCertOptions(value: PackSourceInputOffice365MsgTraceCertOptions) {
    this._certOptions.internalValue = value;
  }
  public resetCertOptions() {
    this._certOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certOptionsInput() {
    return this._certOptions.internalValue;
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputOffice365MsgTraceConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputOffice365MsgTraceConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disable_time_filter - computed: true, optional: true, required: false
  private _disableTimeFilter?: boolean | cdktf.IResolvable; 
  public get disableTimeFilter() {
    return this.getBooleanAttribute('disable_time_filter');
  }
  public set disableTimeFilter(value: boolean | cdktf.IResolvable) {
    this._disableTimeFilter = value;
  }
  public resetDisableTimeFilter() {
    this._disableTimeFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTimeFilterInput() {
    return this._disableTimeFilter;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // end_date - computed: false, optional: true, required: false
  private _endDate?: string; 
  public get endDate() {
    return this.getStringAttribute('end_date');
  }
  public set endDate(value: string) {
    this._endDate = value;
  }
  public resetEndDate() {
    this._endDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endDateInput() {
    return this._endDate;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ignore_group_jobs_limit - computed: true, optional: true, required: false
  private _ignoreGroupJobsLimit?: boolean | cdktf.IResolvable; 
  public get ignoreGroupJobsLimit() {
    return this.getBooleanAttribute('ignore_group_jobs_limit');
  }
  public set ignoreGroupJobsLimit(value: boolean | cdktf.IResolvable) {
    this._ignoreGroupJobsLimit = value;
  }
  public resetIgnoreGroupJobsLimit() {
    this._ignoreGroupJobsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreGroupJobsLimitInput() {
    return this._ignoreGroupJobsLimit;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // job_timeout - computed: true, optional: true, required: false
  private _jobTimeout?: string; 
  public get jobTimeout() {
    return this.getStringAttribute('job_timeout');
  }
  public set jobTimeout(value: string) {
    this._jobTimeout = value;
  }
  public resetJobTimeout() {
    this._jobTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobTimeoutInput() {
    return this._jobTimeout;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // log_level - computed: true, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // max_missed_keep_alives - computed: true, optional: true, required: false
  private _maxMissedKeepAlives?: number; 
  public get maxMissedKeepAlives() {
    return this.getNumberAttribute('max_missed_keep_alives');
  }
  public set maxMissedKeepAlives(value: number) {
    this._maxMissedKeepAlives = value;
  }
  public resetMaxMissedKeepAlives() {
    this._maxMissedKeepAlives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMissedKeepAlivesInput() {
    return this._maxMissedKeepAlives;
  }

  // max_task_reschedule - computed: true, optional: true, required: false
  private _maxTaskReschedule?: number; 
  public get maxTaskReschedule() {
    return this.getNumberAttribute('max_task_reschedule');
  }
  public set maxTaskReschedule(value: number) {
    this._maxTaskReschedule = value;
  }
  public resetMaxTaskReschedule() {
    this._maxTaskReschedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTaskRescheduleInput() {
    return this._maxTaskReschedule;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputOffice365MsgTraceMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputOffice365MsgTraceMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // plan_type - computed: true, optional: true, required: false
  private _planType?: string; 
  public get planType() {
    return this.getStringAttribute('plan_type');
  }
  public set planType(value: string) {
    this._planType = value;
  }
  public resetPlanType() {
    this._planType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get planTypeInput() {
    return this._planType;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputOffice365MsgTracePqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputOffice365MsgTracePq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // reschedule_dropped_tasks - computed: true, optional: true, required: false
  private _rescheduleDroppedTasks?: boolean | cdktf.IResolvable; 
  public get rescheduleDroppedTasks() {
    return this.getBooleanAttribute('reschedule_dropped_tasks');
  }
  public set rescheduleDroppedTasks(value: boolean | cdktf.IResolvable) {
    this._rescheduleDroppedTasks = value;
  }
  public resetRescheduleDroppedTasks() {
    this._rescheduleDroppedTasks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rescheduleDroppedTasksInput() {
    return this._rescheduleDroppedTasks;
  }

  // resource - computed: true, optional: true, required: false
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  public resetResource() {
    this._resource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }

  // retry_rules - computed: false, optional: true, required: false
  private _retryRules = new PackSourceInputOffice365MsgTraceRetryRulesOutputReference(this, "retry_rules");
  public get retryRules() {
    return this._retryRules;
  }
  public putRetryRules(value: PackSourceInputOffice365MsgTraceRetryRules) {
    this._retryRules.internalValue = value;
  }
  public resetRetryRules() {
    this._retryRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryRulesInput() {
    return this._retryRules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // start_date - computed: false, optional: true, required: false
  private _startDate?: string; 
  public get startDate() {
    return this.getStringAttribute('start_date');
  }
  public set startDate(value: string) {
    this._startDate = value;
  }
  public resetStartDate() {
    this._startDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startDateInput() {
    return this._startDate;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout - computed: true, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // ttl - computed: true, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: true, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackSourceInputOffice365ServiceConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputOffice365ServiceConnectionsToTerraform(struct?: PackSourceInputOffice365ServiceConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputOffice365ServiceConnectionsToHclTerraform(struct?: PackSourceInputOffice365ServiceConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365ServiceConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputOffice365ServiceConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365ServiceConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputOffice365ServiceConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputOffice365ServiceConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputOffice365ServiceConnectionsOutputReference {
    return new PackSourceInputOffice365ServiceConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputOffice365ServiceContentConfig {
  /**
  * Office 365 Services API Content Type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#content_type PackSource#content_type}
  */
  readonly contentType?: string;
  /**
  * If interval type is minutes the value entered must evenly divisible by 60 or save will fail
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enabled PackSource#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * Collector runtime Log Level. must be one of ["error", "warn", "info", "debug"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#log_level PackSource#log_level}
  */
  readonly logLevel?: string;
}

export function packSourceInputOffice365ServiceContentConfigToTerraform(struct?: PackSourceInputOffice365ServiceContentConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    content_type: cdktf.stringToTerraform(struct!.contentType),
    description: cdktf.stringToTerraform(struct!.description),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    interval: cdktf.numberToTerraform(struct!.interval),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
  }
}


export function packSourceInputOffice365ServiceContentConfigToHclTerraform(struct?: PackSourceInputOffice365ServiceContentConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    content_type: {
      value: cdktf.stringToHclTerraform(struct!.contentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365ServiceContentConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputOffice365ServiceContentConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365ServiceContentConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._contentType = undefined;
      this._description = undefined;
      this._enabled = undefined;
      this._interval = undefined;
      this._logLevel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._contentType = value.contentType;
      this._description = value.description;
      this._enabled = value.enabled;
      this._interval = value.interval;
      this._logLevel = value.logLevel;
    }
  }

  // content_type - computed: false, optional: true, required: false
  private _contentType?: string; 
  public get contentType() {
    return this.getStringAttribute('content_type');
  }
  public set contentType(value: string) {
    this._contentType = value;
  }
  public resetContentType() {
    this._contentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // interval - computed: false, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }
}

export class PackSourceInputOffice365ServiceContentConfigList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputOffice365ServiceContentConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputOffice365ServiceContentConfigOutputReference {
    return new PackSourceInputOffice365ServiceContentConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputOffice365ServiceMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputOffice365ServiceMetadataToTerraform(struct?: PackSourceInputOffice365ServiceMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputOffice365ServiceMetadataToHclTerraform(struct?: PackSourceInputOffice365ServiceMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365ServiceMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputOffice365ServiceMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365ServiceMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputOffice365ServiceMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputOffice365ServiceMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputOffice365ServiceMetadataOutputReference {
    return new PackSourceInputOffice365ServiceMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputOffice365ServicePq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputOffice365ServicePqToTerraform(struct?: PackSourceInputOffice365ServicePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputOffice365ServicePqToHclTerraform(struct?: PackSourceInputOffice365ServicePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365ServicePqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOffice365ServicePq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365ServicePq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputOffice365ServiceRetryRules {
  /**
  * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503. Default: [429,500,503]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#codes PackSource#codes}
  */
  readonly codes?: number[];
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_header PackSource#enable_header}
  */
  readonly enableHeader?: boolean | cdktf.IResolvable;
  /**
  * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * The maximum number of times to retry a failed HTTP request. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#limit PackSource#limit}
  */
  readonly limit?: number;
  /**
  * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#multiplier PackSource#multiplier}
  */
  readonly multiplier?: number;
  /**
  * Retry request when a connection reset (ECONNRESET) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_connect_reset PackSource#retry_connect_reset}
  */
  readonly retryConnectReset?: boolean | cdktf.IResolvable;
  /**
  * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_connect_timeout PackSource#retry_connect_timeout}
  */
  readonly retryConnectTimeout?: boolean | cdktf.IResolvable;
  /**
  * The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputOffice365ServiceRetryRulesToTerraform(struct?: PackSourceInputOffice365ServiceRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    codes: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.codes),
    enable_header: cdktf.booleanToTerraform(struct!.enableHeader),
    interval: cdktf.numberToTerraform(struct!.interval),
    limit: cdktf.numberToTerraform(struct!.limit),
    multiplier: cdktf.numberToTerraform(struct!.multiplier),
    retry_connect_reset: cdktf.booleanToTerraform(struct!.retryConnectReset),
    retry_connect_timeout: cdktf.booleanToTerraform(struct!.retryConnectTimeout),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputOffice365ServiceRetryRulesToHclTerraform(struct?: PackSourceInputOffice365ServiceRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    codes: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.codes),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    enable_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    limit: {
      value: cdktf.numberToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multiplier: {
      value: cdktf.numberToHclTerraform(struct!.multiplier),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_connect_reset: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectReset),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retry_connect_timeout: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365ServiceRetryRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOffice365ServiceRetryRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._codes !== undefined) {
      hasAnyValues = true;
      internalValueResult.codes = this._codes;
    }
    if (this._enableHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHeader = this._enableHeader;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._multiplier !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiplier = this._multiplier;
    }
    if (this._retryConnectReset !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectReset = this._retryConnectReset;
    }
    if (this._retryConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectTimeout = this._retryConnectTimeout;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365ServiceRetryRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._codes = undefined;
      this._enableHeader = undefined;
      this._interval = undefined;
      this._limit = undefined;
      this._multiplier = undefined;
      this._retryConnectReset = undefined;
      this._retryConnectTimeout = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._codes = value.codes;
      this._enableHeader = value.enableHeader;
      this._interval = value.interval;
      this._limit = value.limit;
      this._multiplier = value.multiplier;
      this._retryConnectReset = value.retryConnectReset;
      this._retryConnectTimeout = value.retryConnectTimeout;
      this._type = value.type;
    }
  }

  // codes - computed: true, optional: true, required: false
  private _codes?: number[]; 
  public get codes() {
    return this.getNumberListAttribute('codes');
  }
  public set codes(value: number[]) {
    this._codes = value;
  }
  public resetCodes() {
    this._codes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codesInput() {
    return this._codes;
  }

  // enable_header - computed: true, optional: true, required: false
  private _enableHeader?: boolean | cdktf.IResolvable; 
  public get enableHeader() {
    return this.getBooleanAttribute('enable_header');
  }
  public set enableHeader(value: boolean | cdktf.IResolvable) {
    this._enableHeader = value;
  }
  public resetEnableHeader() {
    this._enableHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHeaderInput() {
    return this._enableHeader;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // limit - computed: true, optional: true, required: false
  private _limit?: number; 
  public get limit() {
    return this.getNumberAttribute('limit');
  }
  public set limit(value: number) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // multiplier - computed: true, optional: true, required: false
  private _multiplier?: number; 
  public get multiplier() {
    return this.getNumberAttribute('multiplier');
  }
  public set multiplier(value: number) {
    this._multiplier = value;
  }
  public resetMultiplier() {
    this._multiplier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiplierInput() {
    return this._multiplier;
  }

  // retry_connect_reset - computed: true, optional: true, required: false
  private _retryConnectReset?: boolean | cdktf.IResolvable; 
  public get retryConnectReset() {
    return this.getBooleanAttribute('retry_connect_reset');
  }
  public set retryConnectReset(value: boolean | cdktf.IResolvable) {
    this._retryConnectReset = value;
  }
  public resetRetryConnectReset() {
    this._retryConnectReset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectResetInput() {
    return this._retryConnectReset;
  }

  // retry_connect_timeout - computed: true, optional: true, required: false
  private _retryConnectTimeout?: boolean | cdktf.IResolvable; 
  public get retryConnectTimeout() {
    return this.getBooleanAttribute('retry_connect_timeout');
  }
  public set retryConnectTimeout(value: boolean | cdktf.IResolvable) {
    this._retryConnectTimeout = value;
  }
  public resetRetryConnectTimeout() {
    this._retryConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectTimeoutInput() {
    return this._retryConnectTimeout;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputOffice365Service {
  /**
  * Office 365 Azure Application ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#app_id PackSource#app_id}
  */
  readonly appId: string;
  /**
  * Enter client secret directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Office 365 Azure client secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#client_secret PackSource#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputOffice365ServiceConnections[] | cdktf.IResolvable;
  /**
  * Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#content_config PackSource#content_config}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly contentConfig?: PackSourceInputOffice365ServiceContentConfig[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ignore_group_jobs_limit PackSource#ignore_group_jobs_limit}
  */
  readonly ignoreGroupJobsLimit?: boolean | cdktf.IResolvable;
  /**
  * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#job_timeout PackSource#job_timeout}
  */
  readonly jobTimeout?: string;
  /**
  * How often workers should check in with the scheduler to keep job subscription alive. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_time PackSource#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_missed_keep_alives PackSource#max_missed_keep_alives}
  */
  readonly maxMissedKeepAlives?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputOffice365ServiceMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Office 365 subscription plan for your organization, typically Office 365 Enterprise. Default: "enterprise_gcc"; must be one of ["enterprise_gcc", "gcc", "gcc_high", "dod"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#plan_type PackSource#plan_type}
  */
  readonly planType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputOffice365ServicePq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_rules PackSource#retry_rules}
  */
  readonly retryRules?: PackSourceInputOffice365ServiceRetryRules;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Office 365 Azure Tenant ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tenant_id PackSource#tenant_id}
  */
  readonly tenantId: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * HTTP request inactivity timeout, use 0 to disable. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#timeout PackSource#timeout}
  */
  readonly timeout?: number;
  /**
  * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ttl PackSource#ttl}
  */
  readonly ttl?: string;
  /**
  * must be "office365_service"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputOffice365ServiceToTerraform(struct?: PackSourceInputOffice365Service | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_id: cdktf.stringToTerraform(struct!.appId),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    connections: cdktf.listMapper(packSourceInputOffice365ServiceConnectionsToTerraform, false)(struct!.connections),
    content_config: cdktf.listMapper(packSourceInputOffice365ServiceContentConfigToTerraform, false)(struct!.contentConfig),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    ignore_group_jobs_limit: cdktf.booleanToTerraform(struct!.ignoreGroupJobsLimit),
    job_timeout: cdktf.stringToTerraform(struct!.jobTimeout),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    max_missed_keep_alives: cdktf.numberToTerraform(struct!.maxMissedKeepAlives),
    metadata: cdktf.listMapper(packSourceInputOffice365ServiceMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    plan_type: cdktf.stringToTerraform(struct!.planType),
    pq: packSourceInputOffice365ServicePqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    retry_rules: packSourceInputOffice365ServiceRetryRulesToTerraform(struct!.retryRules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout: cdktf.numberToTerraform(struct!.timeout),
    ttl: cdktf.stringToTerraform(struct!.ttl),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputOffice365ServiceToHclTerraform(struct?: PackSourceInputOffice365Service | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_id: {
      value: cdktf.stringToHclTerraform(struct!.appId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputOffice365ServiceConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputOffice365ServiceConnectionsList",
    },
    content_config: {
      value: cdktf.listMapperHcl(packSourceInputOffice365ServiceContentConfigToHclTerraform, false)(struct!.contentConfig),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputOffice365ServiceContentConfigList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_group_jobs_limit: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreGroupJobsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    job_timeout: {
      value: cdktf.stringToHclTerraform(struct!.jobTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_missed_keep_alives: {
      value: cdktf.numberToHclTerraform(struct!.maxMissedKeepAlives),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputOffice365ServiceMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputOffice365ServiceMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plan_type: {
      value: cdktf.stringToHclTerraform(struct!.planType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputOffice365ServicePqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputOffice365ServicePq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retry_rules: {
      value: packSourceInputOffice365ServiceRetryRulesToHclTerraform(struct!.retryRules),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputOffice365ServiceRetryRules",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOffice365ServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOffice365Service | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appId !== undefined) {
      hasAnyValues = true;
      internalValueResult.appId = this._appId;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._contentConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentConfig = this._contentConfig?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ignoreGroupJobsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreGroupJobsLimit = this._ignoreGroupJobsLimit;
    }
    if (this._jobTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobTimeout = this._jobTimeout;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._maxMissedKeepAlives !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMissedKeepAlives = this._maxMissedKeepAlives;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._planType !== undefined) {
      hasAnyValues = true;
      internalValueResult.planType = this._planType;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._retryRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryRules = this._retryRules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOffice365Service | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appId = undefined;
      this._authType = undefined;
      this._clientSecret = undefined;
      this._connections.internalValue = undefined;
      this._contentConfig.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._ignoreGroupJobsLimit = undefined;
      this._jobTimeout = undefined;
      this._keepAliveTime = undefined;
      this._maxMissedKeepAlives = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._planType = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._retryRules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._tenantId = undefined;
      this._textSecret = undefined;
      this._timeout = undefined;
      this._ttl = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appId = value.appId;
      this._authType = value.authType;
      this._clientSecret = value.clientSecret;
      this._connections.internalValue = value.connections;
      this._contentConfig.internalValue = value.contentConfig;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._ignoreGroupJobsLimit = value.ignoreGroupJobsLimit;
      this._jobTimeout = value.jobTimeout;
      this._keepAliveTime = value.keepAliveTime;
      this._maxMissedKeepAlives = value.maxMissedKeepAlives;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._planType = value.planType;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._retryRules.internalValue = value.retryRules;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._tenantId = value.tenantId;
      this._textSecret = value.textSecret;
      this._timeout = value.timeout;
      this._ttl = value.ttl;
      this._type = value.type;
    }
  }

  // app_id - computed: false, optional: false, required: true
  private _appId?: string; 
  public get appId() {
    return this.getStringAttribute('app_id');
  }
  public set appId(value: string) {
    this._appId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get appIdInput() {
    return this._appId;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputOffice365ServiceConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputOffice365ServiceConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // content_config - computed: false, optional: true, required: false
  private _contentConfig = new PackSourceInputOffice365ServiceContentConfigList(this, "content_config", false);
  public get contentConfig() {
    return this._contentConfig;
  }
  public putContentConfig(value: PackSourceInputOffice365ServiceContentConfig[] | cdktf.IResolvable) {
    this._contentConfig.internalValue = value;
  }
  public resetContentConfig() {
    this._contentConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentConfigInput() {
    return this._contentConfig.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ignore_group_jobs_limit - computed: true, optional: true, required: false
  private _ignoreGroupJobsLimit?: boolean | cdktf.IResolvable; 
  public get ignoreGroupJobsLimit() {
    return this.getBooleanAttribute('ignore_group_jobs_limit');
  }
  public set ignoreGroupJobsLimit(value: boolean | cdktf.IResolvable) {
    this._ignoreGroupJobsLimit = value;
  }
  public resetIgnoreGroupJobsLimit() {
    this._ignoreGroupJobsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreGroupJobsLimitInput() {
    return this._ignoreGroupJobsLimit;
  }

  // job_timeout - computed: true, optional: true, required: false
  private _jobTimeout?: string; 
  public get jobTimeout() {
    return this.getStringAttribute('job_timeout');
  }
  public set jobTimeout(value: string) {
    this._jobTimeout = value;
  }
  public resetJobTimeout() {
    this._jobTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobTimeoutInput() {
    return this._jobTimeout;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // max_missed_keep_alives - computed: true, optional: true, required: false
  private _maxMissedKeepAlives?: number; 
  public get maxMissedKeepAlives() {
    return this.getNumberAttribute('max_missed_keep_alives');
  }
  public set maxMissedKeepAlives(value: number) {
    this._maxMissedKeepAlives = value;
  }
  public resetMaxMissedKeepAlives() {
    this._maxMissedKeepAlives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMissedKeepAlivesInput() {
    return this._maxMissedKeepAlives;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputOffice365ServiceMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputOffice365ServiceMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // plan_type - computed: true, optional: true, required: false
  private _planType?: string; 
  public get planType() {
    return this.getStringAttribute('plan_type');
  }
  public set planType(value: string) {
    this._planType = value;
  }
  public resetPlanType() {
    this._planType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get planTypeInput() {
    return this._planType;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputOffice365ServicePqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputOffice365ServicePq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // retry_rules - computed: false, optional: true, required: false
  private _retryRules = new PackSourceInputOffice365ServiceRetryRulesOutputReference(this, "retry_rules");
  public get retryRules() {
    return this._retryRules;
  }
  public putRetryRules(value: PackSourceInputOffice365ServiceRetryRules) {
    this._retryRules.internalValue = value;
  }
  public resetRetryRules() {
    this._retryRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryRulesInput() {
    return this._retryRules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tenant_id - computed: false, optional: false, required: true
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout - computed: true, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // ttl - computed: true, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputOpenTelemetryConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputOpenTelemetryConnectionsToTerraform(struct?: PackSourceInputOpenTelemetryConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputOpenTelemetryConnectionsToHclTerraform(struct?: PackSourceInputOpenTelemetryConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOpenTelemetryConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputOpenTelemetryConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOpenTelemetryConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputOpenTelemetryConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputOpenTelemetryConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputOpenTelemetryConnectionsOutputReference {
    return new PackSourceInputOpenTelemetryConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputOpenTelemetryMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputOpenTelemetryMetadataToTerraform(struct?: PackSourceInputOpenTelemetryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputOpenTelemetryMetadataToHclTerraform(struct?: PackSourceInputOpenTelemetryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOpenTelemetryMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputOpenTelemetryMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOpenTelemetryMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputOpenTelemetryMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputOpenTelemetryMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputOpenTelemetryMetadataOutputReference {
    return new PackSourceInputOpenTelemetryMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputOpenTelemetryOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputOpenTelemetryOauthHeadersToTerraform(struct?: PackSourceInputOpenTelemetryOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputOpenTelemetryOauthHeadersToHclTerraform(struct?: PackSourceInputOpenTelemetryOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOpenTelemetryOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputOpenTelemetryOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOpenTelemetryOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputOpenTelemetryOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputOpenTelemetryOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputOpenTelemetryOauthHeadersOutputReference {
    return new PackSourceInputOpenTelemetryOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputOpenTelemetryOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputOpenTelemetryOauthParamsToTerraform(struct?: PackSourceInputOpenTelemetryOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputOpenTelemetryOauthParamsToHclTerraform(struct?: PackSourceInputOpenTelemetryOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOpenTelemetryOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputOpenTelemetryOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOpenTelemetryOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputOpenTelemetryOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputOpenTelemetryOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputOpenTelemetryOauthParamsOutputReference {
    return new PackSourceInputOpenTelemetryOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputOpenTelemetryPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputOpenTelemetryPqToTerraform(struct?: PackSourceInputOpenTelemetryPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputOpenTelemetryPqToHclTerraform(struct?: PackSourceInputOpenTelemetryPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOpenTelemetryPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOpenTelemetryPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOpenTelemetryPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputOpenTelemetryTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputOpenTelemetryTlsToTerraform(struct?: PackSourceInputOpenTelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputOpenTelemetryTlsToHclTerraform(struct?: PackSourceInputOpenTelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOpenTelemetryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOpenTelemetryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOpenTelemetryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputOpenTelemetry {
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: string;
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_header_expr PackSource#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * OpenTelemetry authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputOpenTelemetryConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Enable to extract each incoming log record to a separate event. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#extract_logs PackSource#extract_logs}
  */
  readonly extractLogs?: boolean | cdktf.IResolvable;
  /**
  * Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#extract_metrics PackSource#extract_metrics}
  */
  readonly extractMetrics?: boolean | cdktf.IResolvable;
  /**
  * Enable to extract each incoming span to a separate event. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#extract_spans PackSource#extract_spans}
  */
  readonly extractSpans?: boolean | cdktf.IResolvable;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.). Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#login_url PackSource#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_cxn PackSource#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputOpenTelemetryMetadata[] | cdktf.IResolvable;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_headers PackSource#oauth_headers}
  */
  readonly oauthHeaders?: PackSourceInputOpenTelemetryOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_params PackSource#oauth_params}
  */
  readonly oauthParams?: PackSourceInputOpenTelemetryOauthParams[] | cdktf.IResolvable;
  /**
  * The version of OTLP Protobuf definitions to use when interpreting received data. Default: "0.10.0"; must be one of ["0.10.0", "1.3.1"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#otlp_version PackSource#otlp_version}
  */
  readonly otlpVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#password PackSource#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on. Default: 4317
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputOpenTelemetryPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to leverage gRPC or HTTP for OpenTelemetry. Default: "grpc"; must be one of ["grpc", "http"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#protocol PackSource#protocol}
  */
  readonly protocol?: string;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret PackSource#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret_param_name PackSource#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputOpenTelemetryTls;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_attribute_name PackSource#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_timeout_secs PackSource#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "open_telemetry"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#username PackSource#username}
  */
  readonly username?: string;
}

export function packSourceInputOpenTelemetryToTerraform(struct?: PackSourceInputOpenTelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.stringToTerraform(struct!.activityLogSampleRate),
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    capture_headers: cdktf.stringToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputOpenTelemetryConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.stringToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    extract_logs: cdktf.booleanToTerraform(struct!.extractLogs),
    extract_metrics: cdktf.booleanToTerraform(struct!.extractMetrics),
    extract_spans: cdktf.booleanToTerraform(struct!.extractSpans),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputOpenTelemetryMetadataToTerraform, false)(struct!.metadata),
    oauth_headers: cdktf.listMapper(packSourceInputOpenTelemetryOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packSourceInputOpenTelemetryOauthParamsToTerraform, false)(struct!.oauthParams),
    otlp_version: cdktf.stringToTerraform(struct!.otlpVersion),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputOpenTelemetryPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    tls: packSourceInputOpenTelemetryTlsToTerraform(struct!.tls),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packSourceInputOpenTelemetryToHclTerraform(struct?: PackSourceInputOpenTelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.stringToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    capture_headers: {
      value: cdktf.stringToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputOpenTelemetryConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputOpenTelemetryConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.stringToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extract_logs: {
      value: cdktf.booleanToHclTerraform(struct!.extractLogs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extract_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.extractMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extract_spans: {
      value: cdktf.booleanToHclTerraform(struct!.extractSpans),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputOpenTelemetryMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputOpenTelemetryMetadataList",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packSourceInputOpenTelemetryOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputOpenTelemetryOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packSourceInputOpenTelemetryOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputOpenTelemetryOauthParamsList",
    },
    otlp_version: {
      value: cdktf.stringToHclTerraform(struct!.otlpVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputOpenTelemetryPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputOpenTelemetryPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packSourceInputOpenTelemetryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputOpenTelemetryTls",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputOpenTelemetryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputOpenTelemetry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extractLogs !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractLogs = this._extractLogs;
    }
    if (this._extractMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractMetrics = this._extractMetrics;
    }
    if (this._extractSpans !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractSpans = this._extractSpans;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._otlpVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.otlpVersion = this._otlpVersion;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputOpenTelemetry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._extractLogs = undefined;
      this._extractMetrics = undefined;
      this._extractSpans = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._loginUrl = undefined;
      this._maxActiveCxn = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._otlpVersion = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._protocol = undefined;
      this._requestTimeout = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._tls.internalValue = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._extractLogs = value.extractLogs;
      this._extractMetrics = value.extractMetrics;
      this._extractSpans = value.extractSpans;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._loginUrl = value.loginUrl;
      this._maxActiveCxn = value.maxActiveCxn;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._otlpVersion = value.otlpVersion;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._protocol = value.protocol;
      this._requestTimeout = value.requestTimeout;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._tls.internalValue = value.tls;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._username = value.username;
    }
  }

  // activity_log_sample_rate - computed: false, optional: true, required: false
  private _activityLogSampleRate?: string; 
  public get activityLogSampleRate() {
    return this.getStringAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: string) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // capture_headers - computed: false, optional: true, required: false
  private _captureHeaders?: string; 
  public get captureHeaders() {
    return this.getStringAttribute('capture_headers');
  }
  public set captureHeaders(value: string) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputOpenTelemetryConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputOpenTelemetryConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: false, optional: true, required: false
  private _enableProxyHeader?: string; 
  public get enableProxyHeader() {
    return this.getStringAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: string) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extract_logs - computed: true, optional: true, required: false
  private _extractLogs?: boolean | cdktf.IResolvable; 
  public get extractLogs() {
    return this.getBooleanAttribute('extract_logs');
  }
  public set extractLogs(value: boolean | cdktf.IResolvable) {
    this._extractLogs = value;
  }
  public resetExtractLogs() {
    this._extractLogs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractLogsInput() {
    return this._extractLogs;
  }

  // extract_metrics - computed: true, optional: true, required: false
  private _extractMetrics?: boolean | cdktf.IResolvable; 
  public get extractMetrics() {
    return this.getBooleanAttribute('extract_metrics');
  }
  public set extractMetrics(value: boolean | cdktf.IResolvable) {
    this._extractMetrics = value;
  }
  public resetExtractMetrics() {
    this._extractMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractMetricsInput() {
    return this._extractMetrics;
  }

  // extract_spans - computed: true, optional: true, required: false
  private _extractSpans?: boolean | cdktf.IResolvable; 
  public get extractSpans() {
    return this.getBooleanAttribute('extract_spans');
  }
  public set extractSpans(value: boolean | cdktf.IResolvable) {
    this._extractSpans = value;
  }
  public resetExtractSpans() {
    this._extractSpans = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractSpansInput() {
    return this._extractSpans;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputOpenTelemetryMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputOpenTelemetryMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackSourceInputOpenTelemetryOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackSourceInputOpenTelemetryOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackSourceInputOpenTelemetryOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackSourceInputOpenTelemetryOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // otlp_version - computed: true, optional: true, required: false
  private _otlpVersion?: string; 
  public get otlpVersion() {
    return this.getStringAttribute('otlp_version');
  }
  public set otlpVersion(value: string) {
    this._otlpVersion = value;
  }
  public resetOtlpVersion() {
    this._otlpVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get otlpVersionInput() {
    return this._otlpVersion;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputOpenTelemetryPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputOpenTelemetryPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputOpenTelemetryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputOpenTelemetryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackSourceInputPrometheusConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputPrometheusConnectionsToTerraform(struct?: PackSourceInputPrometheusConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputPrometheusConnectionsToHclTerraform(struct?: PackSourceInputPrometheusConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputPrometheusConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputPrometheusConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputPrometheusConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputPrometheusConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputPrometheusConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputPrometheusConnectionsOutputReference {
    return new PackSourceInputPrometheusConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputPrometheusMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputPrometheusMetadataToTerraform(struct?: PackSourceInputPrometheusMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputPrometheusMetadataToHclTerraform(struct?: PackSourceInputPrometheusMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputPrometheusMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputPrometheusMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputPrometheusMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputPrometheusMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputPrometheusMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputPrometheusMetadataOutputReference {
    return new PackSourceInputPrometheusMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputPrometheusPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputPrometheusPqToTerraform(struct?: PackSourceInputPrometheusPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputPrometheusPqToHclTerraform(struct?: PackSourceInputPrometheusPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputPrometheusPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputPrometheusPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputPrometheusPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputPrometheusSearchFilter {
  /**
  * Search filter attribute name, see: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html for more information. Attributes can be manually entered if not present in the drop down list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * Search Filter Values, if empty only "running" EC2 instances will be returned. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#values PackSource#values}
  */
  readonly values?: string[];
}

export function packSourceInputPrometheusSearchFilterToTerraform(struct?: PackSourceInputPrometheusSearchFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function packSourceInputPrometheusSearchFilterToHclTerraform(struct?: PackSourceInputPrometheusSearchFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputPrometheusSearchFilterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputPrometheusSearchFilter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputPrometheusSearchFilter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._values = value.values;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // values - computed: true, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class PackSourceInputPrometheusSearchFilterList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputPrometheusSearchFilter[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputPrometheusSearchFilterOutputReference {
    return new PackSourceInputPrometheusSearchFilterOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputPrometheus {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_arn PackSource#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_external_id PackSource#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Enter credentials directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_authentication_method PackSource#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret_key PackSource#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputPrometheusConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Other dimensions to include in events. Default: ["host","source"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#dimension_list PackSource#dimension_list}
  */
  readonly dimensionList?: string[];
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Target discovery mechanism. Use static to manually enter a list of targets. Default: "static"; must be one of ["static", "dns", "ec2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#discovery_type PackSource#discovery_type}
  */
  readonly discoveryType?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#duration_seconds PackSource#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access EC2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_assume_role PackSource#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint PackSource#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ignore_group_jobs_limit PackSource#ignore_group_jobs_limit}
  */
  readonly ignoreGroupJobsLimit?: boolean | cdktf.IResolvable;
  /**
  * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#job_timeout PackSource#job_timeout}
  */
  readonly jobTimeout?: string;
  /**
  * How often workers should check in with the scheduler to keep job subscription alive. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_time PackSource#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * Collector runtime Log Level. Default: "info"; must be one of ["error", "warn", "info", "debug"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#log_level PackSource#log_level}
  */
  readonly logLevel?: string;
  /**
  * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_missed_keep_alives PackSource#max_missed_keep_alives}
  */
  readonly maxMissedKeepAlives?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputPrometheusMetadata[] | cdktf.IResolvable;
  /**
  * List of DNS names to resolve. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name_list PackSource#name_list}
  */
  readonly nameList?: string[];
  /**
  * Password for Prometheus Basic authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#password PackSource#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputPrometheusPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * DNS Record type to resolve. Default: "SRV"; must be one of ["SRV", "A", "AAAA"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#record_type PackSource#record_type}
  */
  readonly recordType?: string;
  /**
  * Region where the EC2 is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#region PackSource#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reuse_connections PackSource#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Path to use when collecting metrics from discovered targets. Default: "/metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#scrape_path PackSource#scrape_path}
  */
  readonly scrapePath?: string;
  /**
  * The port number in the metrics URL for discovered targets. Default: 9090
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#scrape_port PackSource#scrape_port}
  */
  readonly scrapePort?: number;
  /**
  * Protocol to use when collecting metrics. Default: "http"; must be one of ["http", "https"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#scrape_protocol PackSource#scrape_protocol}
  */
  readonly scrapeProtocol?: string;
  /**
  * EC2 Instance Search Filter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#search_filter PackSource#search_filter}
  */
  readonly searchFilter?: PackSourceInputPrometheusSearchFilter[] | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing EC2 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#signature_version PackSource#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#target_list PackSource#target_list}
  */
  readonly targetList?: string[];
  /**
  * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ttl PackSource#ttl}
  */
  readonly ttl?: string;
  /**
  * must be "prometheus"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * Use public IP address for discovered targets. Set to false if the private IP address should be used. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#use_public_ip PackSource#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
  /**
  * Username for Prometheus Basic authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#username PackSource#username}
  */
  readonly username?: string;
}

export function packSourceInputPrometheusToTerraform(struct?: PackSourceInputPrometheus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    connections: cdktf.listMapper(packSourceInputPrometheusConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    dimension_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.dimensionList),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    discovery_type: cdktf.stringToTerraform(struct!.discoveryType),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    ignore_group_jobs_limit: cdktf.booleanToTerraform(struct!.ignoreGroupJobsLimit),
    interval: cdktf.numberToTerraform(struct!.interval),
    job_timeout: cdktf.stringToTerraform(struct!.jobTimeout),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    max_missed_keep_alives: cdktf.numberToTerraform(struct!.maxMissedKeepAlives),
    metadata: cdktf.listMapper(packSourceInputPrometheusMetadataToTerraform, false)(struct!.metadata),
    name_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameList),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputPrometheusPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    record_type: cdktf.stringToTerraform(struct!.recordType),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    scrape_path: cdktf.stringToTerraform(struct!.scrapePath),
    scrape_port: cdktf.numberToTerraform(struct!.scrapePort),
    scrape_protocol: cdktf.stringToTerraform(struct!.scrapeProtocol),
    search_filter: cdktf.listMapper(packSourceInputPrometheusSearchFilterToTerraform, false)(struct!.searchFilter),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    target_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.targetList),
    ttl: cdktf.stringToTerraform(struct!.ttl),
    type: cdktf.stringToTerraform(struct!.type),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packSourceInputPrometheusToHclTerraform(struct?: PackSourceInputPrometheus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputPrometheusConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputPrometheusConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dimension_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.dimensionList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    discovery_type: {
      value: cdktf.stringToHclTerraform(struct!.discoveryType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_group_jobs_limit: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreGroupJobsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    job_timeout: {
      value: cdktf.stringToHclTerraform(struct!.jobTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_missed_keep_alives: {
      value: cdktf.numberToHclTerraform(struct!.maxMissedKeepAlives),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputPrometheusMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputPrometheusMetadataList",
    },
    name_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputPrometheusPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputPrometheusPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    record_type: {
      value: cdktf.stringToHclTerraform(struct!.recordType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    scrape_path: {
      value: cdktf.stringToHclTerraform(struct!.scrapePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scrape_port: {
      value: cdktf.numberToHclTerraform(struct!.scrapePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    scrape_protocol: {
      value: cdktf.stringToHclTerraform(struct!.scrapeProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    search_filter: {
      value: cdktf.listMapperHcl(packSourceInputPrometheusSearchFilterToHclTerraform, false)(struct!.searchFilter),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputPrometheusSearchFilterList",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    target_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.targetList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputPrometheusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputPrometheus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dimensionList !== undefined) {
      hasAnyValues = true;
      internalValueResult.dimensionList = this._dimensionList;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._discoveryType !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryType = this._discoveryType;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ignoreGroupJobsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreGroupJobsLimit = this._ignoreGroupJobsLimit;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._jobTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobTimeout = this._jobTimeout;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._maxMissedKeepAlives !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMissedKeepAlives = this._maxMissedKeepAlives;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._nameList !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameList = this._nameList;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._recordType !== undefined) {
      hasAnyValues = true;
      internalValueResult.recordType = this._recordType;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._scrapePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapePath = this._scrapePath;
    }
    if (this._scrapePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapePort = this._scrapePort;
    }
    if (this._scrapeProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapeProtocol = this._scrapeProtocol;
    }
    if (this._searchFilter?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchFilter = this._searchFilter?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._targetList !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetList = this._targetList;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputPrometheus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._authType = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecretKey = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._dimensionList = undefined;
      this._disabled = undefined;
      this._discoveryType = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._ignoreGroupJobsLimit = undefined;
      this._interval = undefined;
      this._jobTimeout = undefined;
      this._keepAliveTime = undefined;
      this._logLevel = undefined;
      this._maxMissedKeepAlives = undefined;
      this._metadata.internalValue = undefined;
      this._nameList = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._recordType = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._scrapePath = undefined;
      this._scrapePort = undefined;
      this._scrapeProtocol = undefined;
      this._searchFilter.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._targetList = undefined;
      this._ttl = undefined;
      this._type = undefined;
      this._usePublicIp = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._authType = value.authType;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecretKey = value.awsSecretKey;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._dimensionList = value.dimensionList;
      this._disabled = value.disabled;
      this._discoveryType = value.discoveryType;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._id = value.id;
      this._ignoreGroupJobsLimit = value.ignoreGroupJobsLimit;
      this._interval = value.interval;
      this._jobTimeout = value.jobTimeout;
      this._keepAliveTime = value.keepAliveTime;
      this._logLevel = value.logLevel;
      this._maxMissedKeepAlives = value.maxMissedKeepAlives;
      this._metadata.internalValue = value.metadata;
      this._nameList = value.nameList;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._recordType = value.recordType;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._scrapePath = value.scrapePath;
      this._scrapePort = value.scrapePort;
      this._scrapeProtocol = value.scrapeProtocol;
      this._searchFilter.internalValue = value.searchFilter;
      this._sendToRoutes = value.sendToRoutes;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._targetList = value.targetList;
      this._ttl = value.ttl;
      this._type = value.type;
      this._usePublicIp = value.usePublicIp;
      this._username = value.username;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputPrometheusConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputPrometheusConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dimension_list - computed: true, optional: true, required: false
  private _dimensionList?: string[]; 
  public get dimensionList() {
    return this.getListAttribute('dimension_list');
  }
  public set dimensionList(value: string[]) {
    this._dimensionList = value;
  }
  public resetDimensionList() {
    this._dimensionList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dimensionListInput() {
    return this._dimensionList;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // discovery_type - computed: true, optional: true, required: false
  private _discoveryType?: string; 
  public get discoveryType() {
    return this.getStringAttribute('discovery_type');
  }
  public set discoveryType(value: string) {
    this._discoveryType = value;
  }
  public resetDiscoveryType() {
    this._discoveryType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryTypeInput() {
    return this._discoveryType;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ignore_group_jobs_limit - computed: true, optional: true, required: false
  private _ignoreGroupJobsLimit?: boolean | cdktf.IResolvable; 
  public get ignoreGroupJobsLimit() {
    return this.getBooleanAttribute('ignore_group_jobs_limit');
  }
  public set ignoreGroupJobsLimit(value: boolean | cdktf.IResolvable) {
    this._ignoreGroupJobsLimit = value;
  }
  public resetIgnoreGroupJobsLimit() {
    this._ignoreGroupJobsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreGroupJobsLimitInput() {
    return this._ignoreGroupJobsLimit;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // job_timeout - computed: true, optional: true, required: false
  private _jobTimeout?: string; 
  public get jobTimeout() {
    return this.getStringAttribute('job_timeout');
  }
  public set jobTimeout(value: string) {
    this._jobTimeout = value;
  }
  public resetJobTimeout() {
    this._jobTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobTimeoutInput() {
    return this._jobTimeout;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // log_level - computed: true, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // max_missed_keep_alives - computed: true, optional: true, required: false
  private _maxMissedKeepAlives?: number; 
  public get maxMissedKeepAlives() {
    return this.getNumberAttribute('max_missed_keep_alives');
  }
  public set maxMissedKeepAlives(value: number) {
    this._maxMissedKeepAlives = value;
  }
  public resetMaxMissedKeepAlives() {
    this._maxMissedKeepAlives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMissedKeepAlivesInput() {
    return this._maxMissedKeepAlives;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputPrometheusMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputPrometheusMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // name_list - computed: true, optional: true, required: false
  private _nameList?: string[]; 
  public get nameList() {
    return this.getListAttribute('name_list');
  }
  public set nameList(value: string[]) {
    this._nameList = value;
  }
  public resetNameList() {
    this._nameList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameListInput() {
    return this._nameList;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputPrometheusPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputPrometheusPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // record_type - computed: true, optional: true, required: false
  private _recordType?: string; 
  public get recordType() {
    return this.getStringAttribute('record_type');
  }
  public set recordType(value: string) {
    this._recordType = value;
  }
  public resetRecordType() {
    this._recordType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recordTypeInput() {
    return this._recordType;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // scrape_path - computed: true, optional: true, required: false
  private _scrapePath?: string; 
  public get scrapePath() {
    return this.getStringAttribute('scrape_path');
  }
  public set scrapePath(value: string) {
    this._scrapePath = value;
  }
  public resetScrapePath() {
    this._scrapePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapePathInput() {
    return this._scrapePath;
  }

  // scrape_port - computed: true, optional: true, required: false
  private _scrapePort?: number; 
  public get scrapePort() {
    return this.getNumberAttribute('scrape_port');
  }
  public set scrapePort(value: number) {
    this._scrapePort = value;
  }
  public resetScrapePort() {
    this._scrapePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapePortInput() {
    return this._scrapePort;
  }

  // scrape_protocol - computed: true, optional: true, required: false
  private _scrapeProtocol?: string; 
  public get scrapeProtocol() {
    return this.getStringAttribute('scrape_protocol');
  }
  public set scrapeProtocol(value: string) {
    this._scrapeProtocol = value;
  }
  public resetScrapeProtocol() {
    this._scrapeProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapeProtocolInput() {
    return this._scrapeProtocol;
  }

  // search_filter - computed: false, optional: true, required: false
  private _searchFilter = new PackSourceInputPrometheusSearchFilterList(this, "search_filter", false);
  public get searchFilter() {
    return this._searchFilter;
  }
  public putSearchFilter(value: PackSourceInputPrometheusSearchFilter[] | cdktf.IResolvable) {
    this._searchFilter.internalValue = value;
  }
  public resetSearchFilter() {
    this._searchFilter.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get searchFilterInput() {
    return this._searchFilter.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // target_list - computed: true, optional: true, required: false
  private _targetList?: string[]; 
  public get targetList() {
    return this.getListAttribute('target_list');
  }
  public set targetList(value: string[]) {
    this._targetList = value;
  }
  public resetTargetList() {
    this._targetList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetListInput() {
    return this._targetList;
  }

  // ttl - computed: true, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_public_ip - computed: true, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackSourceInputPrometheusRwConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputPrometheusRwConnectionsToTerraform(struct?: PackSourceInputPrometheusRwConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputPrometheusRwConnectionsToHclTerraform(struct?: PackSourceInputPrometheusRwConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputPrometheusRwConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputPrometheusRwConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputPrometheusRwConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputPrometheusRwConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputPrometheusRwConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputPrometheusRwConnectionsOutputReference {
    return new PackSourceInputPrometheusRwConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputPrometheusRwMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputPrometheusRwMetadataToTerraform(struct?: PackSourceInputPrometheusRwMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputPrometheusRwMetadataToHclTerraform(struct?: PackSourceInputPrometheusRwMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputPrometheusRwMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputPrometheusRwMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputPrometheusRwMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputPrometheusRwMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputPrometheusRwMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputPrometheusRwMetadataOutputReference {
    return new PackSourceInputPrometheusRwMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputPrometheusRwOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputPrometheusRwOauthHeadersToTerraform(struct?: PackSourceInputPrometheusRwOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputPrometheusRwOauthHeadersToHclTerraform(struct?: PackSourceInputPrometheusRwOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputPrometheusRwOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputPrometheusRwOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputPrometheusRwOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputPrometheusRwOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputPrometheusRwOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputPrometheusRwOauthHeadersOutputReference {
    return new PackSourceInputPrometheusRwOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputPrometheusRwOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputPrometheusRwOauthParamsToTerraform(struct?: PackSourceInputPrometheusRwOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputPrometheusRwOauthParamsToHclTerraform(struct?: PackSourceInputPrometheusRwOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputPrometheusRwOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputPrometheusRwOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputPrometheusRwOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputPrometheusRwOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputPrometheusRwOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputPrometheusRwOauthParamsOutputReference {
    return new PackSourceInputPrometheusRwOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputPrometheusRwPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputPrometheusRwPqToTerraform(struct?: PackSourceInputPrometheusRwPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputPrometheusRwPqToHclTerraform(struct?: PackSourceInputPrometheusRwPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputPrometheusRwPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputPrometheusRwPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputPrometheusRwPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputPrometheusRwTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputPrometheusRwTlsToTerraform(struct?: PackSourceInputPrometheusRwTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputPrometheusRwTlsToHclTerraform(struct?: PackSourceInputPrometheusRwTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputPrometheusRwTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputPrometheusRwTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputPrometheusRwTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputPrometheusRw {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_header_expr PackSource#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Remote Write authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputPrometheusRwConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#login_url PackSource#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputPrometheusRwMetadata[] | cdktf.IResolvable;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_headers PackSource#oauth_headers}
  */
  readonly oauthHeaders?: PackSourceInputPrometheusRwOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_params PackSource#oauth_params}
  */
  readonly oauthParams?: PackSourceInputPrometheusRwOauthParams[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#password PackSource#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputPrometheusRwPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<your‑upstream‑URL>:<your‑port>/write. Default: "/write"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#prometheus_api PackSource#prometheus_api}
  */
  readonly prometheusApi?: string;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret PackSource#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret_param_name PackSource#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputPrometheusRwTls;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_attribute_name PackSource#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_timeout_secs PackSource#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "prometheus_rw"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#username PackSource#username}
  */
  readonly username?: string;
}

export function packSourceInputPrometheusRwToTerraform(struct?: PackSourceInputPrometheusRw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputPrometheusRwConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputPrometheusRwMetadataToTerraform, false)(struct!.metadata),
    oauth_headers: cdktf.listMapper(packSourceInputPrometheusRwOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packSourceInputPrometheusRwOauthParamsToTerraform, false)(struct!.oauthParams),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputPrometheusRwPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    prometheus_api: cdktf.stringToTerraform(struct!.prometheusApi),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    tls: packSourceInputPrometheusRwTlsToTerraform(struct!.tls),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packSourceInputPrometheusRwToHclTerraform(struct?: PackSourceInputPrometheusRw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputPrometheusRwConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputPrometheusRwConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputPrometheusRwMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputPrometheusRwMetadataList",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packSourceInputPrometheusRwOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputPrometheusRwOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packSourceInputPrometheusRwOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputPrometheusRwOauthParamsList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputPrometheusRwPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputPrometheusRwPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prometheus_api: {
      value: cdktf.stringToHclTerraform(struct!.prometheusApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packSourceInputPrometheusRwTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputPrometheusRwTls",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputPrometheusRwOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputPrometheusRw | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._prometheusApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusApi = this._prometheusApi;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputPrometheusRw | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._loginUrl = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._prometheusApi = undefined;
      this._requestTimeout = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._tls.internalValue = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._loginUrl = value.loginUrl;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._prometheusApi = value.prometheusApi;
      this._requestTimeout = value.requestTimeout;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._tls.internalValue = value.tls;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._username = value.username;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputPrometheusRwConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputPrometheusRwConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputPrometheusRwMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputPrometheusRwMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackSourceInputPrometheusRwOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackSourceInputPrometheusRwOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackSourceInputPrometheusRwOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackSourceInputPrometheusRwOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputPrometheusRwPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputPrometheusRwPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // prometheus_api - computed: true, optional: true, required: false
  private _prometheusApi?: string; 
  public get prometheusApi() {
    return this.getStringAttribute('prometheus_api');
  }
  public set prometheusApi(value: string) {
    this._prometheusApi = value;
  }
  public resetPrometheusApi() {
    this._prometheusApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusApiInput() {
    return this._prometheusApi;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputPrometheusRwTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputPrometheusRwTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackSourceInputRawUdpConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputRawUdpConnectionsToTerraform(struct?: PackSourceInputRawUdpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputRawUdpConnectionsToHclTerraform(struct?: PackSourceInputRawUdpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputRawUdpConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputRawUdpConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputRawUdpConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputRawUdpConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputRawUdpConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputRawUdpConnectionsOutputReference {
    return new PackSourceInputRawUdpConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputRawUdpMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputRawUdpMetadataToTerraform(struct?: PackSourceInputRawUdpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputRawUdpMetadataToHclTerraform(struct?: PackSourceInputRawUdpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputRawUdpMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputRawUdpMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputRawUdpMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputRawUdpMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputRawUdpMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputRawUdpMetadataOutputReference {
    return new PackSourceInputRawUdpMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputRawUdpPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputRawUdpPqToTerraform(struct?: PackSourceInputRawUdpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputRawUdpPqToHclTerraform(struct?: PackSourceInputRawUdpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputRawUdpPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputRawUdpPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputRawUdpPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputRawUdp {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputRawUdpConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ingest_raw_bytes PackSource#ingest_raw_bytes}
  */
  readonly ingestRawBytes?: boolean | cdktf.IResolvable;
  /**
  * Regex matching IP addresses that are allowed to send data. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_whitelist_regex PackSource#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of events to buffer when downstream is blocking. Only applies to UDP. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputRawUdpMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputRawUdpPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#single_msg_udp_packets PackSource#single_msg_udp_packets}
  */
  readonly singleMsgUdpPackets?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "raw_udp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#udp_socket_rx_buf_size PackSource#udp_socket_rx_buf_size}
  */
  readonly udpSocketRxBufSize?: number;
}

export function packSourceInputRawUdpToTerraform(struct?: PackSourceInputRawUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputRawUdpConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ingest_raw_bytes: cdktf.booleanToTerraform(struct!.ingestRawBytes),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    metadata: cdktf.listMapper(packSourceInputRawUdpMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputRawUdpPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    single_msg_udp_packets: cdktf.booleanToTerraform(struct!.singleMsgUdpPackets),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
    udp_socket_rx_buf_size: cdktf.numberToTerraform(struct!.udpSocketRxBufSize),
  }
}


export function packSourceInputRawUdpToHclTerraform(struct?: PackSourceInputRawUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputRawUdpConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputRawUdpConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingest_raw_bytes: {
      value: cdktf.booleanToHclTerraform(struct!.ingestRawBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputRawUdpMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputRawUdpMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputRawUdpPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputRawUdpPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    single_msg_udp_packets: {
      value: cdktf.booleanToHclTerraform(struct!.singleMsgUdpPackets),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_socket_rx_buf_size: {
      value: cdktf.numberToHclTerraform(struct!.udpSocketRxBufSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputRawUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputRawUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ingestRawBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingestRawBytes = this._ingestRawBytes;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._singleMsgUdpPackets !== undefined) {
      hasAnyValues = true;
      internalValueResult.singleMsgUdpPackets = this._singleMsgUdpPackets;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpSocketRxBufSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpSocketRxBufSize = this._udpSocketRxBufSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputRawUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ingestRawBytes = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxBufferSize = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._singleMsgUdpPackets = undefined;
      this._streamtags = undefined;
      this._type = undefined;
      this._udpSocketRxBufSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ingestRawBytes = value.ingestRawBytes;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxBufferSize = value.maxBufferSize;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._singleMsgUdpPackets = value.singleMsgUdpPackets;
      this._streamtags = value.streamtags;
      this._type = value.type;
      this._udpSocketRxBufSize = value.udpSocketRxBufSize;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputRawUdpConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputRawUdpConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ingest_raw_bytes - computed: true, optional: true, required: false
  private _ingestRawBytes?: boolean | cdktf.IResolvable; 
  public get ingestRawBytes() {
    return this.getBooleanAttribute('ingest_raw_bytes');
  }
  public set ingestRawBytes(value: boolean | cdktf.IResolvable) {
    this._ingestRawBytes = value;
  }
  public resetIngestRawBytes() {
    this._ingestRawBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingestRawBytesInput() {
    return this._ingestRawBytes;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputRawUdpMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputRawUdpMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputRawUdpPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputRawUdpPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // single_msg_udp_packets - computed: true, optional: true, required: false
  private _singleMsgUdpPackets?: boolean | cdktf.IResolvable; 
  public get singleMsgUdpPackets() {
    return this.getBooleanAttribute('single_msg_udp_packets');
  }
  public set singleMsgUdpPackets(value: boolean | cdktf.IResolvable) {
    this._singleMsgUdpPackets = value;
  }
  public resetSingleMsgUdpPackets() {
    this._singleMsgUdpPackets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get singleMsgUdpPacketsInput() {
    return this._singleMsgUdpPackets;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_socket_rx_buf_size - computed: false, optional: true, required: false
  private _udpSocketRxBufSize?: number; 
  public get udpSocketRxBufSize() {
    return this.getNumberAttribute('udp_socket_rx_buf_size');
  }
  public set udpSocketRxBufSize(value: number) {
    this._udpSocketRxBufSize = value;
  }
  public resetUdpSocketRxBufSize() {
    this._udpSocketRxBufSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpSocketRxBufSizeInput() {
    return this._udpSocketRxBufSize;
  }
}
export interface PackSourceInputS3Checkpointing {
  /**
  * Resume processing files after an interruption. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enabled PackSource#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retries PackSource#retries}
  */
  readonly retries?: number;
}

export function packSourceInputS3CheckpointingToTerraform(struct?: PackSourceInputS3Checkpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    retries: cdktf.numberToTerraform(struct!.retries),
  }
}


export function packSourceInputS3CheckpointingToHclTerraform(struct?: PackSourceInputS3Checkpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retries: {
      value: cdktf.numberToHclTerraform(struct!.retries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputS3CheckpointingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputS3Checkpointing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._retries !== undefined) {
      hasAnyValues = true;
      internalValueResult.retries = this._retries;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputS3Checkpointing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._retries = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._retries = value.retries;
    }
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // retries - computed: true, optional: true, required: false
  private _retries?: number; 
  public get retries() {
    return this.getNumberAttribute('retries');
  }
  public set retries(value: number) {
    this._retries = value;
  }
  public resetRetries() {
    this._retries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retriesInput() {
    return this._retries;
  }
}
export interface PackSourceInputS3Connections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputS3ConnectionsToTerraform(struct?: PackSourceInputS3Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputS3ConnectionsToHclTerraform(struct?: PackSourceInputS3Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputS3ConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputS3Connections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputS3Connections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputS3ConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputS3Connections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputS3ConnectionsOutputReference {
    return new PackSourceInputS3ConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputS3Metadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputS3MetadataToTerraform(struct?: PackSourceInputS3Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputS3MetadataToHclTerraform(struct?: PackSourceInputS3Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputS3MetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputS3Metadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputS3Metadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputS3MetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputS3Metadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputS3MetadataOutputReference {
    return new PackSourceInputS3MetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputS3Pq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputS3PqToTerraform(struct?: PackSourceInputS3Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputS3PqToHclTerraform(struct?: PackSourceInputS3Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputS3PqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputS3Pq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputS3Pq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputS3Preprocess {
  /**
  * Arguments to be added to the custom command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#args PackSource#args}
  */
  readonly args?: string[];
  /**
  * Command to feed the data through (via stdin) and process its output (stdout)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#command PackSource#command}
  */
  readonly command?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packSourceInputS3PreprocessToTerraform(struct?: PackSourceInputS3Preprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.stringToTerraform(struct!.command),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packSourceInputS3PreprocessToHclTerraform(struct?: PackSourceInputS3Preprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.stringToHclTerraform(struct!.command),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputS3PreprocessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputS3Preprocess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputS3Preprocess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._command = value.command;
      this._disabled = value.disabled;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string; 
  public get command() {
    return this.getStringAttribute('command');
  }
  public set command(value: string) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackSourceInputS3 {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_arn PackSource#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_external_id PackSource#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_account_id PackSource#aws_account_id}
  */
  readonly awsAccountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_api_key PackSource#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_authentication_method PackSource#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret PackSource#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret_key PackSource#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#checkpointing PackSource#checkpointing}
  */
  readonly checkpointing?: PackSourceInputS3Checkpointing;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputS3Connections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#duration_seconds PackSource#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access Amazon S3. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_assume_role PackSource#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Use Assume Role credentials when accessing Amazon SQS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_sqs_assume_role PackSource#enable_sqs_assume_role}
  */
  readonly enableSqsAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#encoding PackSource#encoding}
  */
  readonly encoding?: string;
  /**
  * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint PackSource#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Regex matching file names to download and process. Defaults to: .*. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#file_filter PackSource#file_filter}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly fileFilter?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_messages PackSource#max_messages}
  */
  readonly maxMessages?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputS3Metadata[] | cdktf.IResolvable;
  /**
  * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#num_receivers PackSource#num_receivers}
  */
  readonly numReceivers?: number;
  /**
  * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#parquet_chunk_download_timeout PackSource#parquet_chunk_download_timeout}
  */
  readonly parquetChunkDownloadTimeout?: number;
  /**
  * Maximum file size for each Parquet chunk. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#parquet_chunk_size_mb PackSource#parquet_chunk_size_mb}
  */
  readonly parquetChunkSizeMb?: number;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#poll_timeout PackSource#poll_timeout}
  */
  readonly pollTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputS3Pq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#preprocess PackSource#preprocess}
  */
  readonly preprocess?: PackSourceInputS3Preprocess;
  /**
  * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#processed_tag_key PackSource#processed_tag_key}
  */
  readonly processedTagKey?: string;
  /**
  * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#processed_tag_value PackSource#processed_tag_value}
  */
  readonly processedTagValue?: string;
  /**
  * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#queue_name PackSource#queue_name}
  */
  readonly queueName: string;
  /**
  * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#region PackSource#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reuse_connections PackSource#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#signature_version PackSource#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#skip_on_error PackSource#skip_on_error}
  */
  readonly skipOnError?: boolean | cdktf.IResolvable;
  /**
  * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tag_after_processing PackSource#tag_after_processing}
  */
  readonly tagAfterProcessing?: boolean | cdktf.IResolvable;
  /**
  * must be "s3"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
  /**
  * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#visibility_timeout PackSource#visibility_timeout}
  */
  readonly visibilityTimeout?: number;
}

export function packSourceInputS3ToTerraform(struct?: PackSourceInputS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_account_id: cdktf.stringToTerraform(struct!.awsAccountId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    checkpointing: packSourceInputS3CheckpointingToTerraform(struct!.checkpointing),
    connections: cdktf.listMapper(packSourceInputS3ConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_sqs_assume_role: cdktf.booleanToTerraform(struct!.enableSqsAssumeRole),
    encoding: cdktf.stringToTerraform(struct!.encoding),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_filter: cdktf.stringToTerraform(struct!.fileFilter),
    id: cdktf.stringToTerraform(struct!.id),
    max_messages: cdktf.numberToTerraform(struct!.maxMessages),
    metadata: cdktf.listMapper(packSourceInputS3MetadataToTerraform, false)(struct!.metadata),
    num_receivers: cdktf.numberToTerraform(struct!.numReceivers),
    parquet_chunk_download_timeout: cdktf.numberToTerraform(struct!.parquetChunkDownloadTimeout),
    parquet_chunk_size_mb: cdktf.numberToTerraform(struct!.parquetChunkSizeMb),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    poll_timeout: cdktf.numberToTerraform(struct!.pollTimeout),
    pq: packSourceInputS3PqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    preprocess: packSourceInputS3PreprocessToTerraform(struct!.preprocess),
    processed_tag_key: cdktf.stringToTerraform(struct!.processedTagKey),
    processed_tag_value: cdktf.stringToTerraform(struct!.processedTagValue),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    skip_on_error: cdktf.booleanToTerraform(struct!.skipOnError),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tag_after_processing: cdktf.booleanToTerraform(struct!.tagAfterProcessing),
    type: cdktf.stringToTerraform(struct!.type),
    visibility_timeout: cdktf.numberToTerraform(struct!.visibilityTimeout),
  }
}


export function packSourceInputS3ToHclTerraform(struct?: PackSourceInputS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_account_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    checkpointing: {
      value: packSourceInputS3CheckpointingToHclTerraform(struct!.checkpointing),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputS3Checkpointing",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputS3ConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputS3ConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sqs_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableSqsAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    encoding: {
      value: cdktf.stringToHclTerraform(struct!.encoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_filter: {
      value: cdktf.stringToHclTerraform(struct!.fileFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_messages: {
      value: cdktf.numberToHclTerraform(struct!.maxMessages),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputS3MetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputS3MetadataList",
    },
    num_receivers: {
      value: cdktf.numberToHclTerraform(struct!.numReceivers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_download_timeout: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkDownloadTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    poll_timeout: {
      value: cdktf.numberToHclTerraform(struct!.pollTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputS3PqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputS3Pq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preprocess: {
      value: packSourceInputS3PreprocessToHclTerraform(struct!.preprocess),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputS3Preprocess",
    },
    processed_tag_key: {
      value: cdktf.stringToHclTerraform(struct!.processedTagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    processed_tag_value: {
      value: cdktf.stringToHclTerraform(struct!.processedTagValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_on_error: {
      value: cdktf.booleanToHclTerraform(struct!.skipOnError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag_after_processing: {
      value: cdktf.booleanToHclTerraform(struct!.tagAfterProcessing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    visibility_timeout: {
      value: cdktf.numberToHclTerraform(struct!.visibilityTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputS3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputS3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccountId = this._awsAccountId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._checkpointing?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.checkpointing = this._checkpointing?.internalValue;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enableSqsAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSqsAssumeRole = this._enableSqsAssumeRole;
    }
    if (this._encoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.encoding = this._encoding;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileFilter = this._fileFilter;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxMessages !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMessages = this._maxMessages;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._numReceivers !== undefined) {
      hasAnyValues = true;
      internalValueResult.numReceivers = this._numReceivers;
    }
    if (this._parquetChunkDownloadTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkDownloadTimeout = this._parquetChunkDownloadTimeout;
    }
    if (this._parquetChunkSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkSizeMb = this._parquetChunkSizeMb;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pollTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollTimeout = this._pollTimeout;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._preprocess?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preprocess = this._preprocess?.internalValue;
    }
    if (this._processedTagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagKey = this._processedTagKey;
    }
    if (this._processedTagValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagValue = this._processedTagValue;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._skipOnError !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipOnError = this._skipOnError;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tagAfterProcessing !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagAfterProcessing = this._tagAfterProcessing;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._visibilityTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibilityTimeout = this._visibilityTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputS3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsAccountId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._breakerRulesets = undefined;
      this._checkpointing.internalValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._enableSqsAssumeRole = undefined;
      this._encoding = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileFilter = undefined;
      this._id = undefined;
      this._maxMessages = undefined;
      this._metadata.internalValue = undefined;
      this._numReceivers = undefined;
      this._parquetChunkDownloadTimeout = undefined;
      this._parquetChunkSizeMb = undefined;
      this._pipeline = undefined;
      this._pollTimeout = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._preprocess.internalValue = undefined;
      this._processedTagKey = undefined;
      this._processedTagValue = undefined;
      this._queueName = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._signatureVersion = undefined;
      this._skipOnError = undefined;
      this._socketTimeout = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tagAfterProcessing = undefined;
      this._type = undefined;
      this._visibilityTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsAccountId = value.awsAccountId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._breakerRulesets = value.breakerRulesets;
      this._checkpointing.internalValue = value.checkpointing;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enableSqsAssumeRole = value.enableSqsAssumeRole;
      this._encoding = value.encoding;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileFilter = value.fileFilter;
      this._id = value.id;
      this._maxMessages = value.maxMessages;
      this._metadata.internalValue = value.metadata;
      this._numReceivers = value.numReceivers;
      this._parquetChunkDownloadTimeout = value.parquetChunkDownloadTimeout;
      this._parquetChunkSizeMb = value.parquetChunkSizeMb;
      this._pipeline = value.pipeline;
      this._pollTimeout = value.pollTimeout;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._preprocess.internalValue = value.preprocess;
      this._processedTagKey = value.processedTagKey;
      this._processedTagValue = value.processedTagValue;
      this._queueName = value.queueName;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._signatureVersion = value.signatureVersion;
      this._skipOnError = value.skipOnError;
      this._socketTimeout = value.socketTimeout;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tagAfterProcessing = value.tagAfterProcessing;
      this._type = value.type;
      this._visibilityTimeout = value.visibilityTimeout;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_account_id - computed: false, optional: true, required: false
  private _awsAccountId?: string; 
  public get awsAccountId() {
    return this.getStringAttribute('aws_account_id');
  }
  public set awsAccountId(value: string) {
    this._awsAccountId = value;
  }
  public resetAwsAccountId() {
    this._awsAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccountIdInput() {
    return this._awsAccountId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // checkpointing - computed: false, optional: true, required: false
  private _checkpointing = new PackSourceInputS3CheckpointingOutputReference(this, "checkpointing");
  public get checkpointing() {
    return this._checkpointing;
  }
  public putCheckpointing(value: PackSourceInputS3Checkpointing) {
    this._checkpointing.internalValue = value;
  }
  public resetCheckpointing() {
    this._checkpointing.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkpointingInput() {
    return this._checkpointing.internalValue;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputS3ConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputS3Connections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_sqs_assume_role - computed: true, optional: true, required: false
  private _enableSqsAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableSqsAssumeRole() {
    return this.getBooleanAttribute('enable_sqs_assume_role');
  }
  public set enableSqsAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableSqsAssumeRole = value;
  }
  public resetEnableSqsAssumeRole() {
    this._enableSqsAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSqsAssumeRoleInput() {
    return this._enableSqsAssumeRole;
  }

  // encoding - computed: false, optional: true, required: false
  private _encoding?: string; 
  public get encoding() {
    return this.getStringAttribute('encoding');
  }
  public set encoding(value: string) {
    this._encoding = value;
  }
  public resetEncoding() {
    this._encoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encodingInput() {
    return this._encoding;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_filter - computed: true, optional: true, required: false
  private _fileFilter?: string; 
  public get fileFilter() {
    return this.getStringAttribute('file_filter');
  }
  public set fileFilter(value: string) {
    this._fileFilter = value;
  }
  public resetFileFilter() {
    this._fileFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileFilterInput() {
    return this._fileFilter;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_messages - computed: true, optional: true, required: false
  private _maxMessages?: number; 
  public get maxMessages() {
    return this.getNumberAttribute('max_messages');
  }
  public set maxMessages(value: number) {
    this._maxMessages = value;
  }
  public resetMaxMessages() {
    this._maxMessages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMessagesInput() {
    return this._maxMessages;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputS3MetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputS3Metadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // num_receivers - computed: true, optional: true, required: false
  private _numReceivers?: number; 
  public get numReceivers() {
    return this.getNumberAttribute('num_receivers');
  }
  public set numReceivers(value: number) {
    this._numReceivers = value;
  }
  public resetNumReceivers() {
    this._numReceivers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numReceiversInput() {
    return this._numReceivers;
  }

  // parquet_chunk_download_timeout - computed: true, optional: true, required: false
  private _parquetChunkDownloadTimeout?: number; 
  public get parquetChunkDownloadTimeout() {
    return this.getNumberAttribute('parquet_chunk_download_timeout');
  }
  public set parquetChunkDownloadTimeout(value: number) {
    this._parquetChunkDownloadTimeout = value;
  }
  public resetParquetChunkDownloadTimeout() {
    this._parquetChunkDownloadTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkDownloadTimeoutInput() {
    return this._parquetChunkDownloadTimeout;
  }

  // parquet_chunk_size_mb - computed: true, optional: true, required: false
  private _parquetChunkSizeMb?: number; 
  public get parquetChunkSizeMb() {
    return this.getNumberAttribute('parquet_chunk_size_mb');
  }
  public set parquetChunkSizeMb(value: number) {
    this._parquetChunkSizeMb = value;
  }
  public resetParquetChunkSizeMb() {
    this._parquetChunkSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkSizeMbInput() {
    return this._parquetChunkSizeMb;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // poll_timeout - computed: true, optional: true, required: false
  private _pollTimeout?: number; 
  public get pollTimeout() {
    return this.getNumberAttribute('poll_timeout');
  }
  public set pollTimeout(value: number) {
    this._pollTimeout = value;
  }
  public resetPollTimeout() {
    this._pollTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollTimeoutInput() {
    return this._pollTimeout;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputS3PqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputS3Pq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // preprocess - computed: false, optional: true, required: false
  private _preprocess = new PackSourceInputS3PreprocessOutputReference(this, "preprocess");
  public get preprocess() {
    return this._preprocess;
  }
  public putPreprocess(value: PackSourceInputS3Preprocess) {
    this._preprocess.internalValue = value;
  }
  public resetPreprocess() {
    this._preprocess.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preprocessInput() {
    return this._preprocess.internalValue;
  }

  // processed_tag_key - computed: false, optional: true, required: false
  private _processedTagKey?: string; 
  public get processedTagKey() {
    return this.getStringAttribute('processed_tag_key');
  }
  public set processedTagKey(value: string) {
    this._processedTagKey = value;
  }
  public resetProcessedTagKey() {
    this._processedTagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagKeyInput() {
    return this._processedTagKey;
  }

  // processed_tag_value - computed: false, optional: true, required: false
  private _processedTagValue?: string; 
  public get processedTagValue() {
    return this.getStringAttribute('processed_tag_value');
  }
  public set processedTagValue(value: string) {
    this._processedTagValue = value;
  }
  public resetProcessedTagValue() {
    this._processedTagValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagValueInput() {
    return this._processedTagValue;
  }

  // queue_name - computed: false, optional: false, required: true
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // skip_on_error - computed: true, optional: true, required: false
  private _skipOnError?: boolean | cdktf.IResolvable; 
  public get skipOnError() {
    return this.getBooleanAttribute('skip_on_error');
  }
  public set skipOnError(value: boolean | cdktf.IResolvable) {
    this._skipOnError = value;
  }
  public resetSkipOnError() {
    this._skipOnError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipOnErrorInput() {
    return this._skipOnError;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tag_after_processing - computed: true, optional: true, required: false
  private _tagAfterProcessing?: boolean | cdktf.IResolvable; 
  public get tagAfterProcessing() {
    return this.getBooleanAttribute('tag_after_processing');
  }
  public set tagAfterProcessing(value: boolean | cdktf.IResolvable) {
    this._tagAfterProcessing = value;
  }
  public resetTagAfterProcessing() {
    this._tagAfterProcessing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagAfterProcessingInput() {
    return this._tagAfterProcessing;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // visibility_timeout - computed: true, optional: true, required: false
  private _visibilityTimeout?: number; 
  public get visibilityTimeout() {
    return this.getNumberAttribute('visibility_timeout');
  }
  public set visibilityTimeout(value: number) {
    this._visibilityTimeout = value;
  }
  public resetVisibilityTimeout() {
    this._visibilityTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityTimeoutInput() {
    return this._visibilityTimeout;
  }
}
export interface PackSourceInputS3InventoryCheckpointing {
  /**
  * Resume processing files after an interruption. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enabled PackSource#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retries PackSource#retries}
  */
  readonly retries?: number;
}

export function packSourceInputS3InventoryCheckpointingToTerraform(struct?: PackSourceInputS3InventoryCheckpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    retries: cdktf.numberToTerraform(struct!.retries),
  }
}


export function packSourceInputS3InventoryCheckpointingToHclTerraform(struct?: PackSourceInputS3InventoryCheckpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retries: {
      value: cdktf.numberToHclTerraform(struct!.retries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputS3InventoryCheckpointingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputS3InventoryCheckpointing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._retries !== undefined) {
      hasAnyValues = true;
      internalValueResult.retries = this._retries;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputS3InventoryCheckpointing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._retries = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._retries = value.retries;
    }
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // retries - computed: true, optional: true, required: false
  private _retries?: number; 
  public get retries() {
    return this.getNumberAttribute('retries');
  }
  public set retries(value: number) {
    this._retries = value;
  }
  public resetRetries() {
    this._retries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retriesInput() {
    return this._retries;
  }
}
export interface PackSourceInputS3InventoryConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputS3InventoryConnectionsToTerraform(struct?: PackSourceInputS3InventoryConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputS3InventoryConnectionsToHclTerraform(struct?: PackSourceInputS3InventoryConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputS3InventoryConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputS3InventoryConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputS3InventoryConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputS3InventoryConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputS3InventoryConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputS3InventoryConnectionsOutputReference {
    return new PackSourceInputS3InventoryConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputS3InventoryMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputS3InventoryMetadataToTerraform(struct?: PackSourceInputS3InventoryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputS3InventoryMetadataToHclTerraform(struct?: PackSourceInputS3InventoryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputS3InventoryMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputS3InventoryMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputS3InventoryMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputS3InventoryMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputS3InventoryMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputS3InventoryMetadataOutputReference {
    return new PackSourceInputS3InventoryMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputS3InventoryPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputS3InventoryPqToTerraform(struct?: PackSourceInputS3InventoryPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputS3InventoryPqToHclTerraform(struct?: PackSourceInputS3InventoryPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputS3InventoryPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputS3InventoryPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputS3InventoryPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputS3InventoryPreprocess {
  /**
  * Arguments to be added to the custom command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#args PackSource#args}
  */
  readonly args?: string[];
  /**
  * Command to feed the data through (via stdin) and process its output (stdout)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#command PackSource#command}
  */
  readonly command?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packSourceInputS3InventoryPreprocessToTerraform(struct?: PackSourceInputS3InventoryPreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.stringToTerraform(struct!.command),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packSourceInputS3InventoryPreprocessToHclTerraform(struct?: PackSourceInputS3InventoryPreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.stringToHclTerraform(struct!.command),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputS3InventoryPreprocessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputS3InventoryPreprocess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputS3InventoryPreprocess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._command = value.command;
      this._disabled = value.disabled;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string; 
  public get command() {
    return this.getStringAttribute('command');
  }
  public set command(value: string) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackSourceInputS3Inventory {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_arn PackSource#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_external_id PackSource#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_account_id PackSource#aws_account_id}
  */
  readonly awsAccountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_api_key PackSource#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_authentication_method PackSource#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret PackSource#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret_key PackSource#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#checkpointing PackSource#checkpointing}
  */
  readonly checkpointing?: PackSourceInputS3InventoryCheckpointing;
  /**
  * Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum". Default: "checksum"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#checksum_suffix PackSource#checksum_suffix}
  */
  readonly checksumSuffix?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputS3InventoryConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#duration_seconds PackSource#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access Amazon S3. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_assume_role PackSource#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Use Assume Role credentials when accessing Amazon SQS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_sqs_assume_role PackSource#enable_sqs_assume_role}
  */
  readonly enableSqsAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint PackSource#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Regex matching file names to download and process. Defaults to: .*. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#file_filter PackSource#file_filter}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly fileFilter?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_manifest_size_kb PackSource#max_manifest_size_kb}
  */
  readonly maxManifestSizeKb?: number;
  /**
  * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_messages PackSource#max_messages}
  */
  readonly maxMessages?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputS3InventoryMetadata[] | cdktf.IResolvable;
  /**
  * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#num_receivers PackSource#num_receivers}
  */
  readonly numReceivers?: number;
  /**
  * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#parquet_chunk_download_timeout PackSource#parquet_chunk_download_timeout}
  */
  readonly parquetChunkDownloadTimeout?: number;
  /**
  * Maximum file size for each Parquet chunk. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#parquet_chunk_size_mb PackSource#parquet_chunk_size_mb}
  */
  readonly parquetChunkSizeMb?: number;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#poll_timeout PackSource#poll_timeout}
  */
  readonly pollTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputS3InventoryPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#preprocess PackSource#preprocess}
  */
  readonly preprocess?: PackSourceInputS3InventoryPreprocess;
  /**
  * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#processed_tag_key PackSource#processed_tag_key}
  */
  readonly processedTagKey?: string;
  /**
  * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#processed_tag_value PackSource#processed_tag_value}
  */
  readonly processedTagValue?: string;
  /**
  * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#queue_name PackSource#queue_name}
  */
  readonly queueName: string;
  /**
  * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#region PackSource#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reuse_connections PackSource#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#signature_version PackSource#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#skip_on_error PackSource#skip_on_error}
  */
  readonly skipOnError?: boolean | cdktf.IResolvable;
  /**
  * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be one of ["false", "true"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tag_after_processing PackSource#tag_after_processing}
  */
  readonly tagAfterProcessing?: string;
  /**
  * must be "s3_inventory"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
  /**
  * If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#validate_inventory_files PackSource#validate_inventory_files}
  */
  readonly validateInventoryFiles?: boolean | cdktf.IResolvable;
  /**
  * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#visibility_timeout PackSource#visibility_timeout}
  */
  readonly visibilityTimeout?: number;
}

export function packSourceInputS3InventoryToTerraform(struct?: PackSourceInputS3Inventory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_account_id: cdktf.stringToTerraform(struct!.awsAccountId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    checkpointing: packSourceInputS3InventoryCheckpointingToTerraform(struct!.checkpointing),
    checksum_suffix: cdktf.stringToTerraform(struct!.checksumSuffix),
    connections: cdktf.listMapper(packSourceInputS3InventoryConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_sqs_assume_role: cdktf.booleanToTerraform(struct!.enableSqsAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_filter: cdktf.stringToTerraform(struct!.fileFilter),
    id: cdktf.stringToTerraform(struct!.id),
    max_manifest_size_kb: cdktf.numberToTerraform(struct!.maxManifestSizeKb),
    max_messages: cdktf.numberToTerraform(struct!.maxMessages),
    metadata: cdktf.listMapper(packSourceInputS3InventoryMetadataToTerraform, false)(struct!.metadata),
    num_receivers: cdktf.numberToTerraform(struct!.numReceivers),
    parquet_chunk_download_timeout: cdktf.numberToTerraform(struct!.parquetChunkDownloadTimeout),
    parquet_chunk_size_mb: cdktf.numberToTerraform(struct!.parquetChunkSizeMb),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    poll_timeout: cdktf.numberToTerraform(struct!.pollTimeout),
    pq: packSourceInputS3InventoryPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    preprocess: packSourceInputS3InventoryPreprocessToTerraform(struct!.preprocess),
    processed_tag_key: cdktf.stringToTerraform(struct!.processedTagKey),
    processed_tag_value: cdktf.stringToTerraform(struct!.processedTagValue),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    skip_on_error: cdktf.booleanToTerraform(struct!.skipOnError),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tag_after_processing: cdktf.stringToTerraform(struct!.tagAfterProcessing),
    type: cdktf.stringToTerraform(struct!.type),
    validate_inventory_files: cdktf.booleanToTerraform(struct!.validateInventoryFiles),
    visibility_timeout: cdktf.numberToTerraform(struct!.visibilityTimeout),
  }
}


export function packSourceInputS3InventoryToHclTerraform(struct?: PackSourceInputS3Inventory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_account_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    checkpointing: {
      value: packSourceInputS3InventoryCheckpointingToHclTerraform(struct!.checkpointing),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputS3InventoryCheckpointing",
    },
    checksum_suffix: {
      value: cdktf.stringToHclTerraform(struct!.checksumSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputS3InventoryConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputS3InventoryConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sqs_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableSqsAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_filter: {
      value: cdktf.stringToHclTerraform(struct!.fileFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_manifest_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxManifestSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_messages: {
      value: cdktf.numberToHclTerraform(struct!.maxMessages),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputS3InventoryMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputS3InventoryMetadataList",
    },
    num_receivers: {
      value: cdktf.numberToHclTerraform(struct!.numReceivers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_download_timeout: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkDownloadTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    poll_timeout: {
      value: cdktf.numberToHclTerraform(struct!.pollTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputS3InventoryPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputS3InventoryPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preprocess: {
      value: packSourceInputS3InventoryPreprocessToHclTerraform(struct!.preprocess),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputS3InventoryPreprocess",
    },
    processed_tag_key: {
      value: cdktf.stringToHclTerraform(struct!.processedTagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    processed_tag_value: {
      value: cdktf.stringToHclTerraform(struct!.processedTagValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_on_error: {
      value: cdktf.booleanToHclTerraform(struct!.skipOnError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag_after_processing: {
      value: cdktf.stringToHclTerraform(struct!.tagAfterProcessing),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    validate_inventory_files: {
      value: cdktf.booleanToHclTerraform(struct!.validateInventoryFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    visibility_timeout: {
      value: cdktf.numberToHclTerraform(struct!.visibilityTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputS3InventoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputS3Inventory | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccountId = this._awsAccountId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._checkpointing?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.checkpointing = this._checkpointing?.internalValue;
    }
    if (this._checksumSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.checksumSuffix = this._checksumSuffix;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enableSqsAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSqsAssumeRole = this._enableSqsAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileFilter = this._fileFilter;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxManifestSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxManifestSizeKb = this._maxManifestSizeKb;
    }
    if (this._maxMessages !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMessages = this._maxMessages;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._numReceivers !== undefined) {
      hasAnyValues = true;
      internalValueResult.numReceivers = this._numReceivers;
    }
    if (this._parquetChunkDownloadTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkDownloadTimeout = this._parquetChunkDownloadTimeout;
    }
    if (this._parquetChunkSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkSizeMb = this._parquetChunkSizeMb;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pollTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollTimeout = this._pollTimeout;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._preprocess?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preprocess = this._preprocess?.internalValue;
    }
    if (this._processedTagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagKey = this._processedTagKey;
    }
    if (this._processedTagValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagValue = this._processedTagValue;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._skipOnError !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipOnError = this._skipOnError;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tagAfterProcessing !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagAfterProcessing = this._tagAfterProcessing;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._validateInventoryFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.validateInventoryFiles = this._validateInventoryFiles;
    }
    if (this._visibilityTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibilityTimeout = this._visibilityTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputS3Inventory | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsAccountId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._breakerRulesets = undefined;
      this._checkpointing.internalValue = undefined;
      this._checksumSuffix = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._enableSqsAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileFilter = undefined;
      this._id = undefined;
      this._maxManifestSizeKb = undefined;
      this._maxMessages = undefined;
      this._metadata.internalValue = undefined;
      this._numReceivers = undefined;
      this._parquetChunkDownloadTimeout = undefined;
      this._parquetChunkSizeMb = undefined;
      this._pipeline = undefined;
      this._pollTimeout = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._preprocess.internalValue = undefined;
      this._processedTagKey = undefined;
      this._processedTagValue = undefined;
      this._queueName = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._signatureVersion = undefined;
      this._skipOnError = undefined;
      this._socketTimeout = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tagAfterProcessing = undefined;
      this._type = undefined;
      this._validateInventoryFiles = undefined;
      this._visibilityTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsAccountId = value.awsAccountId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._breakerRulesets = value.breakerRulesets;
      this._checkpointing.internalValue = value.checkpointing;
      this._checksumSuffix = value.checksumSuffix;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enableSqsAssumeRole = value.enableSqsAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileFilter = value.fileFilter;
      this._id = value.id;
      this._maxManifestSizeKb = value.maxManifestSizeKb;
      this._maxMessages = value.maxMessages;
      this._metadata.internalValue = value.metadata;
      this._numReceivers = value.numReceivers;
      this._parquetChunkDownloadTimeout = value.parquetChunkDownloadTimeout;
      this._parquetChunkSizeMb = value.parquetChunkSizeMb;
      this._pipeline = value.pipeline;
      this._pollTimeout = value.pollTimeout;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._preprocess.internalValue = value.preprocess;
      this._processedTagKey = value.processedTagKey;
      this._processedTagValue = value.processedTagValue;
      this._queueName = value.queueName;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._signatureVersion = value.signatureVersion;
      this._skipOnError = value.skipOnError;
      this._socketTimeout = value.socketTimeout;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tagAfterProcessing = value.tagAfterProcessing;
      this._type = value.type;
      this._validateInventoryFiles = value.validateInventoryFiles;
      this._visibilityTimeout = value.visibilityTimeout;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_account_id - computed: false, optional: true, required: false
  private _awsAccountId?: string; 
  public get awsAccountId() {
    return this.getStringAttribute('aws_account_id');
  }
  public set awsAccountId(value: string) {
    this._awsAccountId = value;
  }
  public resetAwsAccountId() {
    this._awsAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccountIdInput() {
    return this._awsAccountId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // checkpointing - computed: false, optional: true, required: false
  private _checkpointing = new PackSourceInputS3InventoryCheckpointingOutputReference(this, "checkpointing");
  public get checkpointing() {
    return this._checkpointing;
  }
  public putCheckpointing(value: PackSourceInputS3InventoryCheckpointing) {
    this._checkpointing.internalValue = value;
  }
  public resetCheckpointing() {
    this._checkpointing.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkpointingInput() {
    return this._checkpointing.internalValue;
  }

  // checksum_suffix - computed: true, optional: true, required: false
  private _checksumSuffix?: string; 
  public get checksumSuffix() {
    return this.getStringAttribute('checksum_suffix');
  }
  public set checksumSuffix(value: string) {
    this._checksumSuffix = value;
  }
  public resetChecksumSuffix() {
    this._checksumSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checksumSuffixInput() {
    return this._checksumSuffix;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputS3InventoryConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputS3InventoryConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_sqs_assume_role - computed: true, optional: true, required: false
  private _enableSqsAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableSqsAssumeRole() {
    return this.getBooleanAttribute('enable_sqs_assume_role');
  }
  public set enableSqsAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableSqsAssumeRole = value;
  }
  public resetEnableSqsAssumeRole() {
    this._enableSqsAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSqsAssumeRoleInput() {
    return this._enableSqsAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_filter - computed: true, optional: true, required: false
  private _fileFilter?: string; 
  public get fileFilter() {
    return this.getStringAttribute('file_filter');
  }
  public set fileFilter(value: string) {
    this._fileFilter = value;
  }
  public resetFileFilter() {
    this._fileFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileFilterInput() {
    return this._fileFilter;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_manifest_size_kb - computed: true, optional: true, required: false
  private _maxManifestSizeKb?: number; 
  public get maxManifestSizeKb() {
    return this.getNumberAttribute('max_manifest_size_kb');
  }
  public set maxManifestSizeKb(value: number) {
    this._maxManifestSizeKb = value;
  }
  public resetMaxManifestSizeKb() {
    this._maxManifestSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxManifestSizeKbInput() {
    return this._maxManifestSizeKb;
  }

  // max_messages - computed: true, optional: true, required: false
  private _maxMessages?: number; 
  public get maxMessages() {
    return this.getNumberAttribute('max_messages');
  }
  public set maxMessages(value: number) {
    this._maxMessages = value;
  }
  public resetMaxMessages() {
    this._maxMessages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMessagesInput() {
    return this._maxMessages;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputS3InventoryMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputS3InventoryMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // num_receivers - computed: true, optional: true, required: false
  private _numReceivers?: number; 
  public get numReceivers() {
    return this.getNumberAttribute('num_receivers');
  }
  public set numReceivers(value: number) {
    this._numReceivers = value;
  }
  public resetNumReceivers() {
    this._numReceivers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numReceiversInput() {
    return this._numReceivers;
  }

  // parquet_chunk_download_timeout - computed: true, optional: true, required: false
  private _parquetChunkDownloadTimeout?: number; 
  public get parquetChunkDownloadTimeout() {
    return this.getNumberAttribute('parquet_chunk_download_timeout');
  }
  public set parquetChunkDownloadTimeout(value: number) {
    this._parquetChunkDownloadTimeout = value;
  }
  public resetParquetChunkDownloadTimeout() {
    this._parquetChunkDownloadTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkDownloadTimeoutInput() {
    return this._parquetChunkDownloadTimeout;
  }

  // parquet_chunk_size_mb - computed: true, optional: true, required: false
  private _parquetChunkSizeMb?: number; 
  public get parquetChunkSizeMb() {
    return this.getNumberAttribute('parquet_chunk_size_mb');
  }
  public set parquetChunkSizeMb(value: number) {
    this._parquetChunkSizeMb = value;
  }
  public resetParquetChunkSizeMb() {
    this._parquetChunkSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkSizeMbInput() {
    return this._parquetChunkSizeMb;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // poll_timeout - computed: true, optional: true, required: false
  private _pollTimeout?: number; 
  public get pollTimeout() {
    return this.getNumberAttribute('poll_timeout');
  }
  public set pollTimeout(value: number) {
    this._pollTimeout = value;
  }
  public resetPollTimeout() {
    this._pollTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollTimeoutInput() {
    return this._pollTimeout;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputS3InventoryPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputS3InventoryPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // preprocess - computed: false, optional: true, required: false
  private _preprocess = new PackSourceInputS3InventoryPreprocessOutputReference(this, "preprocess");
  public get preprocess() {
    return this._preprocess;
  }
  public putPreprocess(value: PackSourceInputS3InventoryPreprocess) {
    this._preprocess.internalValue = value;
  }
  public resetPreprocess() {
    this._preprocess.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preprocessInput() {
    return this._preprocess.internalValue;
  }

  // processed_tag_key - computed: false, optional: true, required: false
  private _processedTagKey?: string; 
  public get processedTagKey() {
    return this.getStringAttribute('processed_tag_key');
  }
  public set processedTagKey(value: string) {
    this._processedTagKey = value;
  }
  public resetProcessedTagKey() {
    this._processedTagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagKeyInput() {
    return this._processedTagKey;
  }

  // processed_tag_value - computed: false, optional: true, required: false
  private _processedTagValue?: string; 
  public get processedTagValue() {
    return this.getStringAttribute('processed_tag_value');
  }
  public set processedTagValue(value: string) {
    this._processedTagValue = value;
  }
  public resetProcessedTagValue() {
    this._processedTagValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagValueInput() {
    return this._processedTagValue;
  }

  // queue_name - computed: false, optional: false, required: true
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // skip_on_error - computed: true, optional: true, required: false
  private _skipOnError?: boolean | cdktf.IResolvable; 
  public get skipOnError() {
    return this.getBooleanAttribute('skip_on_error');
  }
  public set skipOnError(value: boolean | cdktf.IResolvable) {
    this._skipOnError = value;
  }
  public resetSkipOnError() {
    this._skipOnError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipOnErrorInput() {
    return this._skipOnError;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tag_after_processing - computed: false, optional: true, required: false
  private _tagAfterProcessing?: string; 
  public get tagAfterProcessing() {
    return this.getStringAttribute('tag_after_processing');
  }
  public set tagAfterProcessing(value: string) {
    this._tagAfterProcessing = value;
  }
  public resetTagAfterProcessing() {
    this._tagAfterProcessing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagAfterProcessingInput() {
    return this._tagAfterProcessing;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // validate_inventory_files - computed: true, optional: true, required: false
  private _validateInventoryFiles?: boolean | cdktf.IResolvable; 
  public get validateInventoryFiles() {
    return this.getBooleanAttribute('validate_inventory_files');
  }
  public set validateInventoryFiles(value: boolean | cdktf.IResolvable) {
    this._validateInventoryFiles = value;
  }
  public resetValidateInventoryFiles() {
    this._validateInventoryFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validateInventoryFilesInput() {
    return this._validateInventoryFiles;
  }

  // visibility_timeout - computed: true, optional: true, required: false
  private _visibilityTimeout?: number; 
  public get visibilityTimeout() {
    return this.getNumberAttribute('visibility_timeout');
  }
  public set visibilityTimeout(value: number) {
    this._visibilityTimeout = value;
  }
  public resetVisibilityTimeout() {
    this._visibilityTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityTimeoutInput() {
    return this._visibilityTimeout;
  }
}
export interface PackSourceInputSecurityLakeCheckpointing {
  /**
  * Resume processing files after an interruption. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enabled PackSource#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retries PackSource#retries}
  */
  readonly retries?: number;
}

export function packSourceInputSecurityLakeCheckpointingToTerraform(struct?: PackSourceInputSecurityLakeCheckpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    retries: cdktf.numberToTerraform(struct!.retries),
  }
}


export function packSourceInputSecurityLakeCheckpointingToHclTerraform(struct?: PackSourceInputSecurityLakeCheckpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retries: {
      value: cdktf.numberToHclTerraform(struct!.retries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSecurityLakeCheckpointingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSecurityLakeCheckpointing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._retries !== undefined) {
      hasAnyValues = true;
      internalValueResult.retries = this._retries;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSecurityLakeCheckpointing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._retries = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._retries = value.retries;
    }
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // retries - computed: true, optional: true, required: false
  private _retries?: number; 
  public get retries() {
    return this.getNumberAttribute('retries');
  }
  public set retries(value: number) {
    this._retries = value;
  }
  public resetRetries() {
    this._retries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retriesInput() {
    return this._retries;
  }
}
export interface PackSourceInputSecurityLakeConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputSecurityLakeConnectionsToTerraform(struct?: PackSourceInputSecurityLakeConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputSecurityLakeConnectionsToHclTerraform(struct?: PackSourceInputSecurityLakeConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSecurityLakeConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSecurityLakeConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSecurityLakeConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputSecurityLakeConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSecurityLakeConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSecurityLakeConnectionsOutputReference {
    return new PackSourceInputSecurityLakeConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSecurityLakeMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSecurityLakeMetadataToTerraform(struct?: PackSourceInputSecurityLakeMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSecurityLakeMetadataToHclTerraform(struct?: PackSourceInputSecurityLakeMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSecurityLakeMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSecurityLakeMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSecurityLakeMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSecurityLakeMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSecurityLakeMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSecurityLakeMetadataOutputReference {
    return new PackSourceInputSecurityLakeMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSecurityLakePq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputSecurityLakePqToTerraform(struct?: PackSourceInputSecurityLakePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputSecurityLakePqToHclTerraform(struct?: PackSourceInputSecurityLakePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSecurityLakePqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSecurityLakePq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSecurityLakePq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputSecurityLakePreprocess {
  /**
  * Arguments to be added to the custom command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#args PackSource#args}
  */
  readonly args?: string[];
  /**
  * Command to feed the data through (via stdin) and process its output (stdout)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#command PackSource#command}
  */
  readonly command?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packSourceInputSecurityLakePreprocessToTerraform(struct?: PackSourceInputSecurityLakePreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.stringToTerraform(struct!.command),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packSourceInputSecurityLakePreprocessToHclTerraform(struct?: PackSourceInputSecurityLakePreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.stringToHclTerraform(struct!.command),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSecurityLakePreprocessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSecurityLakePreprocess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSecurityLakePreprocess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._command = value.command;
      this._disabled = value.disabled;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string; 
  public get command() {
    return this.getStringAttribute('command');
  }
  public set command(value: string) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackSourceInputSecurityLake {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_arn PackSource#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_external_id PackSource#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_account_id PackSource#aws_account_id}
  */
  readonly awsAccountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_api_key PackSource#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_authentication_method PackSource#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret PackSource#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret_key PackSource#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#checkpointing PackSource#checkpointing}
  */
  readonly checkpointing?: PackSourceInputSecurityLakeCheckpointing;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputSecurityLakeConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#duration_seconds PackSource#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access Amazon S3. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_assume_role PackSource#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Use Assume Role credentials when accessing Amazon SQS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_sqs_assume_role PackSource#enable_sqs_assume_role}
  */
  readonly enableSqsAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#encoding PackSource#encoding}
  */
  readonly encoding?: string;
  /**
  * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint PackSource#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Regex matching file names to download and process. Defaults to: .*. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#file_filter PackSource#file_filter}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly fileFilter?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_messages PackSource#max_messages}
  */
  readonly maxMessages?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputSecurityLakeMetadata[] | cdktf.IResolvable;
  /**
  * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#num_receivers PackSource#num_receivers}
  */
  readonly numReceivers?: number;
  /**
  * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#parquet_chunk_download_timeout PackSource#parquet_chunk_download_timeout}
  */
  readonly parquetChunkDownloadTimeout?: number;
  /**
  * Maximum file size for each Parquet chunk. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#parquet_chunk_size_mb PackSource#parquet_chunk_size_mb}
  */
  readonly parquetChunkSizeMb?: number;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#poll_timeout PackSource#poll_timeout}
  */
  readonly pollTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputSecurityLakePq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#preprocess PackSource#preprocess}
  */
  readonly preprocess?: PackSourceInputSecurityLakePreprocess;
  /**
  * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#processed_tag_key PackSource#processed_tag_key}
  */
  readonly processedTagKey?: string;
  /**
  * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#processed_tag_value PackSource#processed_tag_value}
  */
  readonly processedTagValue?: string;
  /**
  * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#queue_name PackSource#queue_name}
  */
  readonly queueName: string;
  /**
  * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#region PackSource#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reuse_connections PackSource#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#signature_version PackSource#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#skip_on_error PackSource#skip_on_error}
  */
  readonly skipOnError?: boolean | cdktf.IResolvable;
  /**
  * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be one of ["false", "true"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tag_after_processing PackSource#tag_after_processing}
  */
  readonly tagAfterProcessing?: string;
  /**
  * must be "security_lake"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
  /**
  * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#visibility_timeout PackSource#visibility_timeout}
  */
  readonly visibilityTimeout?: number;
}

export function packSourceInputSecurityLakeToTerraform(struct?: PackSourceInputSecurityLake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_account_id: cdktf.stringToTerraform(struct!.awsAccountId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    checkpointing: packSourceInputSecurityLakeCheckpointingToTerraform(struct!.checkpointing),
    connections: cdktf.listMapper(packSourceInputSecurityLakeConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_sqs_assume_role: cdktf.booleanToTerraform(struct!.enableSqsAssumeRole),
    encoding: cdktf.stringToTerraform(struct!.encoding),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_filter: cdktf.stringToTerraform(struct!.fileFilter),
    id: cdktf.stringToTerraform(struct!.id),
    max_messages: cdktf.numberToTerraform(struct!.maxMessages),
    metadata: cdktf.listMapper(packSourceInputSecurityLakeMetadataToTerraform, false)(struct!.metadata),
    num_receivers: cdktf.numberToTerraform(struct!.numReceivers),
    parquet_chunk_download_timeout: cdktf.numberToTerraform(struct!.parquetChunkDownloadTimeout),
    parquet_chunk_size_mb: cdktf.numberToTerraform(struct!.parquetChunkSizeMb),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    poll_timeout: cdktf.numberToTerraform(struct!.pollTimeout),
    pq: packSourceInputSecurityLakePqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    preprocess: packSourceInputSecurityLakePreprocessToTerraform(struct!.preprocess),
    processed_tag_key: cdktf.stringToTerraform(struct!.processedTagKey),
    processed_tag_value: cdktf.stringToTerraform(struct!.processedTagValue),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    skip_on_error: cdktf.booleanToTerraform(struct!.skipOnError),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tag_after_processing: cdktf.stringToTerraform(struct!.tagAfterProcessing),
    type: cdktf.stringToTerraform(struct!.type),
    visibility_timeout: cdktf.numberToTerraform(struct!.visibilityTimeout),
  }
}


export function packSourceInputSecurityLakeToHclTerraform(struct?: PackSourceInputSecurityLake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_account_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    checkpointing: {
      value: packSourceInputSecurityLakeCheckpointingToHclTerraform(struct!.checkpointing),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSecurityLakeCheckpointing",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputSecurityLakeConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSecurityLakeConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sqs_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableSqsAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    encoding: {
      value: cdktf.stringToHclTerraform(struct!.encoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_filter: {
      value: cdktf.stringToHclTerraform(struct!.fileFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_messages: {
      value: cdktf.numberToHclTerraform(struct!.maxMessages),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputSecurityLakeMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSecurityLakeMetadataList",
    },
    num_receivers: {
      value: cdktf.numberToHclTerraform(struct!.numReceivers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_download_timeout: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkDownloadTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    poll_timeout: {
      value: cdktf.numberToHclTerraform(struct!.pollTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputSecurityLakePqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSecurityLakePq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preprocess: {
      value: packSourceInputSecurityLakePreprocessToHclTerraform(struct!.preprocess),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSecurityLakePreprocess",
    },
    processed_tag_key: {
      value: cdktf.stringToHclTerraform(struct!.processedTagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    processed_tag_value: {
      value: cdktf.stringToHclTerraform(struct!.processedTagValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_on_error: {
      value: cdktf.booleanToHclTerraform(struct!.skipOnError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag_after_processing: {
      value: cdktf.stringToHclTerraform(struct!.tagAfterProcessing),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    visibility_timeout: {
      value: cdktf.numberToHclTerraform(struct!.visibilityTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSecurityLakeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSecurityLake | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccountId = this._awsAccountId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._checkpointing?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.checkpointing = this._checkpointing?.internalValue;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enableSqsAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSqsAssumeRole = this._enableSqsAssumeRole;
    }
    if (this._encoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.encoding = this._encoding;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileFilter = this._fileFilter;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxMessages !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMessages = this._maxMessages;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._numReceivers !== undefined) {
      hasAnyValues = true;
      internalValueResult.numReceivers = this._numReceivers;
    }
    if (this._parquetChunkDownloadTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkDownloadTimeout = this._parquetChunkDownloadTimeout;
    }
    if (this._parquetChunkSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkSizeMb = this._parquetChunkSizeMb;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pollTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollTimeout = this._pollTimeout;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._preprocess?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preprocess = this._preprocess?.internalValue;
    }
    if (this._processedTagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagKey = this._processedTagKey;
    }
    if (this._processedTagValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagValue = this._processedTagValue;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._skipOnError !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipOnError = this._skipOnError;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tagAfterProcessing !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagAfterProcessing = this._tagAfterProcessing;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._visibilityTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibilityTimeout = this._visibilityTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSecurityLake | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsAccountId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._breakerRulesets = undefined;
      this._checkpointing.internalValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._enableSqsAssumeRole = undefined;
      this._encoding = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileFilter = undefined;
      this._id = undefined;
      this._maxMessages = undefined;
      this._metadata.internalValue = undefined;
      this._numReceivers = undefined;
      this._parquetChunkDownloadTimeout = undefined;
      this._parquetChunkSizeMb = undefined;
      this._pipeline = undefined;
      this._pollTimeout = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._preprocess.internalValue = undefined;
      this._processedTagKey = undefined;
      this._processedTagValue = undefined;
      this._queueName = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._signatureVersion = undefined;
      this._skipOnError = undefined;
      this._socketTimeout = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tagAfterProcessing = undefined;
      this._type = undefined;
      this._visibilityTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsAccountId = value.awsAccountId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._breakerRulesets = value.breakerRulesets;
      this._checkpointing.internalValue = value.checkpointing;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enableSqsAssumeRole = value.enableSqsAssumeRole;
      this._encoding = value.encoding;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileFilter = value.fileFilter;
      this._id = value.id;
      this._maxMessages = value.maxMessages;
      this._metadata.internalValue = value.metadata;
      this._numReceivers = value.numReceivers;
      this._parquetChunkDownloadTimeout = value.parquetChunkDownloadTimeout;
      this._parquetChunkSizeMb = value.parquetChunkSizeMb;
      this._pipeline = value.pipeline;
      this._pollTimeout = value.pollTimeout;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._preprocess.internalValue = value.preprocess;
      this._processedTagKey = value.processedTagKey;
      this._processedTagValue = value.processedTagValue;
      this._queueName = value.queueName;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._signatureVersion = value.signatureVersion;
      this._skipOnError = value.skipOnError;
      this._socketTimeout = value.socketTimeout;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tagAfterProcessing = value.tagAfterProcessing;
      this._type = value.type;
      this._visibilityTimeout = value.visibilityTimeout;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_account_id - computed: false, optional: true, required: false
  private _awsAccountId?: string; 
  public get awsAccountId() {
    return this.getStringAttribute('aws_account_id');
  }
  public set awsAccountId(value: string) {
    this._awsAccountId = value;
  }
  public resetAwsAccountId() {
    this._awsAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccountIdInput() {
    return this._awsAccountId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // checkpointing - computed: false, optional: true, required: false
  private _checkpointing = new PackSourceInputSecurityLakeCheckpointingOutputReference(this, "checkpointing");
  public get checkpointing() {
    return this._checkpointing;
  }
  public putCheckpointing(value: PackSourceInputSecurityLakeCheckpointing) {
    this._checkpointing.internalValue = value;
  }
  public resetCheckpointing() {
    this._checkpointing.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkpointingInput() {
    return this._checkpointing.internalValue;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputSecurityLakeConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputSecurityLakeConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_sqs_assume_role - computed: true, optional: true, required: false
  private _enableSqsAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableSqsAssumeRole() {
    return this.getBooleanAttribute('enable_sqs_assume_role');
  }
  public set enableSqsAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableSqsAssumeRole = value;
  }
  public resetEnableSqsAssumeRole() {
    this._enableSqsAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSqsAssumeRoleInput() {
    return this._enableSqsAssumeRole;
  }

  // encoding - computed: false, optional: true, required: false
  private _encoding?: string; 
  public get encoding() {
    return this.getStringAttribute('encoding');
  }
  public set encoding(value: string) {
    this._encoding = value;
  }
  public resetEncoding() {
    this._encoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encodingInput() {
    return this._encoding;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_filter - computed: true, optional: true, required: false
  private _fileFilter?: string; 
  public get fileFilter() {
    return this.getStringAttribute('file_filter');
  }
  public set fileFilter(value: string) {
    this._fileFilter = value;
  }
  public resetFileFilter() {
    this._fileFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileFilterInput() {
    return this._fileFilter;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_messages - computed: true, optional: true, required: false
  private _maxMessages?: number; 
  public get maxMessages() {
    return this.getNumberAttribute('max_messages');
  }
  public set maxMessages(value: number) {
    this._maxMessages = value;
  }
  public resetMaxMessages() {
    this._maxMessages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMessagesInput() {
    return this._maxMessages;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputSecurityLakeMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputSecurityLakeMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // num_receivers - computed: true, optional: true, required: false
  private _numReceivers?: number; 
  public get numReceivers() {
    return this.getNumberAttribute('num_receivers');
  }
  public set numReceivers(value: number) {
    this._numReceivers = value;
  }
  public resetNumReceivers() {
    this._numReceivers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numReceiversInput() {
    return this._numReceivers;
  }

  // parquet_chunk_download_timeout - computed: true, optional: true, required: false
  private _parquetChunkDownloadTimeout?: number; 
  public get parquetChunkDownloadTimeout() {
    return this.getNumberAttribute('parquet_chunk_download_timeout');
  }
  public set parquetChunkDownloadTimeout(value: number) {
    this._parquetChunkDownloadTimeout = value;
  }
  public resetParquetChunkDownloadTimeout() {
    this._parquetChunkDownloadTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkDownloadTimeoutInput() {
    return this._parquetChunkDownloadTimeout;
  }

  // parquet_chunk_size_mb - computed: true, optional: true, required: false
  private _parquetChunkSizeMb?: number; 
  public get parquetChunkSizeMb() {
    return this.getNumberAttribute('parquet_chunk_size_mb');
  }
  public set parquetChunkSizeMb(value: number) {
    this._parquetChunkSizeMb = value;
  }
  public resetParquetChunkSizeMb() {
    this._parquetChunkSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkSizeMbInput() {
    return this._parquetChunkSizeMb;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // poll_timeout - computed: true, optional: true, required: false
  private _pollTimeout?: number; 
  public get pollTimeout() {
    return this.getNumberAttribute('poll_timeout');
  }
  public set pollTimeout(value: number) {
    this._pollTimeout = value;
  }
  public resetPollTimeout() {
    this._pollTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollTimeoutInput() {
    return this._pollTimeout;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputSecurityLakePqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputSecurityLakePq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // preprocess - computed: false, optional: true, required: false
  private _preprocess = new PackSourceInputSecurityLakePreprocessOutputReference(this, "preprocess");
  public get preprocess() {
    return this._preprocess;
  }
  public putPreprocess(value: PackSourceInputSecurityLakePreprocess) {
    this._preprocess.internalValue = value;
  }
  public resetPreprocess() {
    this._preprocess.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preprocessInput() {
    return this._preprocess.internalValue;
  }

  // processed_tag_key - computed: false, optional: true, required: false
  private _processedTagKey?: string; 
  public get processedTagKey() {
    return this.getStringAttribute('processed_tag_key');
  }
  public set processedTagKey(value: string) {
    this._processedTagKey = value;
  }
  public resetProcessedTagKey() {
    this._processedTagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagKeyInput() {
    return this._processedTagKey;
  }

  // processed_tag_value - computed: false, optional: true, required: false
  private _processedTagValue?: string; 
  public get processedTagValue() {
    return this.getStringAttribute('processed_tag_value');
  }
  public set processedTagValue(value: string) {
    this._processedTagValue = value;
  }
  public resetProcessedTagValue() {
    this._processedTagValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagValueInput() {
    return this._processedTagValue;
  }

  // queue_name - computed: false, optional: false, required: true
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // skip_on_error - computed: true, optional: true, required: false
  private _skipOnError?: boolean | cdktf.IResolvable; 
  public get skipOnError() {
    return this.getBooleanAttribute('skip_on_error');
  }
  public set skipOnError(value: boolean | cdktf.IResolvable) {
    this._skipOnError = value;
  }
  public resetSkipOnError() {
    this._skipOnError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipOnErrorInput() {
    return this._skipOnError;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tag_after_processing - computed: false, optional: true, required: false
  private _tagAfterProcessing?: string; 
  public get tagAfterProcessing() {
    return this.getStringAttribute('tag_after_processing');
  }
  public set tagAfterProcessing(value: string) {
    this._tagAfterProcessing = value;
  }
  public resetTagAfterProcessing() {
    this._tagAfterProcessing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagAfterProcessingInput() {
    return this._tagAfterProcessing;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // visibility_timeout - computed: true, optional: true, required: false
  private _visibilityTimeout?: number; 
  public get visibilityTimeout() {
    return this.getNumberAttribute('visibility_timeout');
  }
  public set visibilityTimeout(value: number) {
    this._visibilityTimeout = value;
  }
  public resetVisibilityTimeout() {
    this._visibilityTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityTimeoutInput() {
    return this._visibilityTimeout;
  }
}
export interface PackSourceInputSnmpConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputSnmpConnectionsToTerraform(struct?: PackSourceInputSnmpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputSnmpConnectionsToHclTerraform(struct?: PackSourceInputSnmpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSnmpConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSnmpConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSnmpConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputSnmpConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSnmpConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSnmpConnectionsOutputReference {
    return new PackSourceInputSnmpConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSnmpMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSnmpMetadataToTerraform(struct?: PackSourceInputSnmpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSnmpMetadataToHclTerraform(struct?: PackSourceInputSnmpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSnmpMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSnmpMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSnmpMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSnmpMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSnmpMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSnmpMetadataOutputReference {
    return new PackSourceInputSnmpMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSnmpPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputSnmpPqToTerraform(struct?: PackSourceInputSnmpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputSnmpPqToHclTerraform(struct?: PackSourceInputSnmpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSnmpPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSnmpPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSnmpPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputSnmpSnmpV3AuthV3Users {
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_key PackSource#auth_key}
  */
  readonly authKey?: string;
  /**
  * Default: "none"; must be one of ["none", "md5", "sha", "sha224", "sha256", "sha384", "sha512"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_protocol PackSource#auth_protocol}
  */
  readonly authProtocol?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * Default: "none"; Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_protocol PackSource#priv_protocol}
  */
  readonly privProtocol?: string;
}

export function packSourceInputSnmpSnmpV3AuthV3UsersToTerraform(struct?: PackSourceInputSnmpSnmpV3AuthV3Users | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_key: cdktf.stringToTerraform(struct!.authKey),
    auth_protocol: cdktf.stringToTerraform(struct!.authProtocol),
    name: cdktf.stringToTerraform(struct!.name),
    priv_protocol: cdktf.stringToTerraform(struct!.privProtocol),
  }
}


export function packSourceInputSnmpSnmpV3AuthV3UsersToHclTerraform(struct?: PackSourceInputSnmpSnmpV3AuthV3Users | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_key: {
      value: cdktf.stringToHclTerraform(struct!.authKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_protocol: {
      value: cdktf.stringToHclTerraform(struct!.authProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_protocol: {
      value: cdktf.stringToHclTerraform(struct!.privProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSnmpSnmpV3AuthV3UsersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSnmpSnmpV3AuthV3Users | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.authKey = this._authKey;
    }
    if (this._authProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.authProtocol = this._authProtocol;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._privProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.privProtocol = this._privProtocol;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSnmpSnmpV3AuthV3Users | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authKey = undefined;
      this._authProtocol = undefined;
      this._name = undefined;
      this._privProtocol = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authKey = value.authKey;
      this._authProtocol = value.authProtocol;
      this._name = value.name;
      this._privProtocol = value.privProtocol;
    }
  }

  // auth_key - computed: false, optional: true, required: false
  private _authKey?: string; 
  public get authKey() {
    return this.getStringAttribute('auth_key');
  }
  public set authKey(value: string) {
    this._authKey = value;
  }
  public resetAuthKey() {
    this._authKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authKeyInput() {
    return this._authKey;
  }

  // auth_protocol - computed: true, optional: true, required: false
  private _authProtocol?: string; 
  public get authProtocol() {
    return this.getStringAttribute('auth_protocol');
  }
  public set authProtocol(value: string) {
    this._authProtocol = value;
  }
  public resetAuthProtocol() {
    this._authProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authProtocolInput() {
    return this._authProtocol;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // priv_protocol - computed: true, optional: true, required: false
  private _privProtocol?: string; 
  public get privProtocol() {
    return this.getStringAttribute('priv_protocol');
  }
  public set privProtocol(value: string) {
    this._privProtocol = value;
  }
  public resetPrivProtocol() {
    this._privProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privProtocolInput() {
    return this._privProtocol;
  }
}

export class PackSourceInputSnmpSnmpV3AuthV3UsersList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSnmpSnmpV3AuthV3Users[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSnmpSnmpV3AuthV3UsersOutputReference {
    return new PackSourceInputSnmpSnmpV3AuthV3UsersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSnmpSnmpV3Auth {
  /**
  * Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#allow_unmatched_trap PackSource#allow_unmatched_trap}
  */
  readonly allowUnmatchedTrap?: boolean | cdktf.IResolvable;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#v3_auth_enabled PackSource#v3_auth_enabled}
  */
  readonly v3AuthEnabled?: boolean | cdktf.IResolvable;
  /**
  * User credentials for receiving v3 traps
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#v3_users PackSource#v3_users}
  */
  readonly v3Users?: PackSourceInputSnmpSnmpV3AuthV3Users[] | cdktf.IResolvable;
}

export function packSourceInputSnmpSnmpV3AuthToTerraform(struct?: PackSourceInputSnmpSnmpV3Auth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_unmatched_trap: cdktf.booleanToTerraform(struct!.allowUnmatchedTrap),
    v3_auth_enabled: cdktf.booleanToTerraform(struct!.v3AuthEnabled),
    v3_users: cdktf.listMapper(packSourceInputSnmpSnmpV3AuthV3UsersToTerraform, false)(struct!.v3Users),
  }
}


export function packSourceInputSnmpSnmpV3AuthToHclTerraform(struct?: PackSourceInputSnmpSnmpV3Auth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_unmatched_trap: {
      value: cdktf.booleanToHclTerraform(struct!.allowUnmatchedTrap),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    v3_auth_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.v3AuthEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    v3_users: {
      value: cdktf.listMapperHcl(packSourceInputSnmpSnmpV3AuthV3UsersToHclTerraform, false)(struct!.v3Users),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSnmpSnmpV3AuthV3UsersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSnmpSnmpV3AuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSnmpSnmpV3Auth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowUnmatchedTrap !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowUnmatchedTrap = this._allowUnmatchedTrap;
    }
    if (this._v3AuthEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.v3AuthEnabled = this._v3AuthEnabled;
    }
    if (this._v3Users?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.v3Users = this._v3Users?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSnmpSnmpV3Auth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowUnmatchedTrap = undefined;
      this._v3AuthEnabled = undefined;
      this._v3Users.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowUnmatchedTrap = value.allowUnmatchedTrap;
      this._v3AuthEnabled = value.v3AuthEnabled;
      this._v3Users.internalValue = value.v3Users;
    }
  }

  // allow_unmatched_trap - computed: true, optional: true, required: false
  private _allowUnmatchedTrap?: boolean | cdktf.IResolvable; 
  public get allowUnmatchedTrap() {
    return this.getBooleanAttribute('allow_unmatched_trap');
  }
  public set allowUnmatchedTrap(value: boolean | cdktf.IResolvable) {
    this._allowUnmatchedTrap = value;
  }
  public resetAllowUnmatchedTrap() {
    this._allowUnmatchedTrap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowUnmatchedTrapInput() {
    return this._allowUnmatchedTrap;
  }

  // v3_auth_enabled - computed: true, optional: true, required: false
  private _v3AuthEnabled?: boolean | cdktf.IResolvable; 
  public get v3AuthEnabled() {
    return this.getBooleanAttribute('v3_auth_enabled');
  }
  public set v3AuthEnabled(value: boolean | cdktf.IResolvable) {
    this._v3AuthEnabled = value;
  }
  public resetV3AuthEnabled() {
    this._v3AuthEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get v3AuthEnabledInput() {
    return this._v3AuthEnabled;
  }

  // v3_users - computed: false, optional: true, required: false
  private _v3Users = new PackSourceInputSnmpSnmpV3AuthV3UsersList(this, "v3_users", false);
  public get v3Users() {
    return this._v3Users;
  }
  public putV3Users(value: PackSourceInputSnmpSnmpV3AuthV3Users[] | cdktf.IResolvable) {
    this._v3Users.internalValue = value;
  }
  public resetV3Users() {
    this._v3Users.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get v3UsersInput() {
    return this._v3Users.internalValue;
  }
}
export interface PackSourceInputSnmp {
  /**
  * If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#best_effort_parsing PackSource#best_effort_parsing}
  */
  readonly bestEffortParsing?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputSnmpConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Regex matching IP addresses that are allowed to send data. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_whitelist_regex PackSource#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of events to buffer when downstream is blocking. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputSnmpMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * UDP port to receive SNMP traps on. Defaults to 162. Default: 162
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputSnmpPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#snmp_v3_auth PackSource#snmp_v3_auth}
  */
  readonly snmpV3Auth?: PackSourceInputSnmpSnmpV3Auth;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "snmp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#udp_socket_rx_buf_size PackSource#udp_socket_rx_buf_size}
  */
  readonly udpSocketRxBufSize?: number;
  /**
  * If enabled, parses varbinds as an array of objects that include OID, value, and type. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#varbinds_with_types PackSource#varbinds_with_types}
  */
  readonly varbindsWithTypes?: boolean | cdktf.IResolvable;
}

export function packSourceInputSnmpToTerraform(struct?: PackSourceInputSnmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    best_effort_parsing: cdktf.booleanToTerraform(struct!.bestEffortParsing),
    connections: cdktf.listMapper(packSourceInputSnmpConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    metadata: cdktf.listMapper(packSourceInputSnmpMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputSnmpPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    snmp_v3_auth: packSourceInputSnmpSnmpV3AuthToTerraform(struct!.snmpV3Auth),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
    udp_socket_rx_buf_size: cdktf.numberToTerraform(struct!.udpSocketRxBufSize),
    varbinds_with_types: cdktf.booleanToTerraform(struct!.varbindsWithTypes),
  }
}


export function packSourceInputSnmpToHclTerraform(struct?: PackSourceInputSnmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    best_effort_parsing: {
      value: cdktf.booleanToHclTerraform(struct!.bestEffortParsing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputSnmpConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSnmpConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputSnmpMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSnmpMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputSnmpPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSnmpPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    snmp_v3_auth: {
      value: packSourceInputSnmpSnmpV3AuthToHclTerraform(struct!.snmpV3Auth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSnmpSnmpV3Auth",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_socket_rx_buf_size: {
      value: cdktf.numberToHclTerraform(struct!.udpSocketRxBufSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    varbinds_with_types: {
      value: cdktf.booleanToHclTerraform(struct!.varbindsWithTypes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSnmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSnmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bestEffortParsing !== undefined) {
      hasAnyValues = true;
      internalValueResult.bestEffortParsing = this._bestEffortParsing;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._snmpV3Auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.snmpV3Auth = this._snmpV3Auth?.internalValue;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpSocketRxBufSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpSocketRxBufSize = this._udpSocketRxBufSize;
    }
    if (this._varbindsWithTypes !== undefined) {
      hasAnyValues = true;
      internalValueResult.varbindsWithTypes = this._varbindsWithTypes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSnmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bestEffortParsing = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxBufferSize = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._snmpV3Auth.internalValue = undefined;
      this._streamtags = undefined;
      this._type = undefined;
      this._udpSocketRxBufSize = undefined;
      this._varbindsWithTypes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bestEffortParsing = value.bestEffortParsing;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxBufferSize = value.maxBufferSize;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._snmpV3Auth.internalValue = value.snmpV3Auth;
      this._streamtags = value.streamtags;
      this._type = value.type;
      this._udpSocketRxBufSize = value.udpSocketRxBufSize;
      this._varbindsWithTypes = value.varbindsWithTypes;
    }
  }

  // best_effort_parsing - computed: true, optional: true, required: false
  private _bestEffortParsing?: boolean | cdktf.IResolvable; 
  public get bestEffortParsing() {
    return this.getBooleanAttribute('best_effort_parsing');
  }
  public set bestEffortParsing(value: boolean | cdktf.IResolvable) {
    this._bestEffortParsing = value;
  }
  public resetBestEffortParsing() {
    this._bestEffortParsing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bestEffortParsingInput() {
    return this._bestEffortParsing;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputSnmpConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputSnmpConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputSnmpMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputSnmpMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputSnmpPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputSnmpPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // snmp_v3_auth - computed: false, optional: true, required: false
  private _snmpV3Auth = new PackSourceInputSnmpSnmpV3AuthOutputReference(this, "snmp_v3_auth");
  public get snmpV3Auth() {
    return this._snmpV3Auth;
  }
  public putSnmpV3Auth(value: PackSourceInputSnmpSnmpV3Auth) {
    this._snmpV3Auth.internalValue = value;
  }
  public resetSnmpV3Auth() {
    this._snmpV3Auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snmpV3AuthInput() {
    return this._snmpV3Auth.internalValue;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_socket_rx_buf_size - computed: false, optional: true, required: false
  private _udpSocketRxBufSize?: number; 
  public get udpSocketRxBufSize() {
    return this.getNumberAttribute('udp_socket_rx_buf_size');
  }
  public set udpSocketRxBufSize(value: number) {
    this._udpSocketRxBufSize = value;
  }
  public resetUdpSocketRxBufSize() {
    this._udpSocketRxBufSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpSocketRxBufSizeInput() {
    return this._udpSocketRxBufSize;
  }

  // varbinds_with_types - computed: true, optional: true, required: false
  private _varbindsWithTypes?: boolean | cdktf.IResolvable; 
  public get varbindsWithTypes() {
    return this.getBooleanAttribute('varbinds_with_types');
  }
  public set varbindsWithTypes(value: boolean | cdktf.IResolvable) {
    this._varbindsWithTypes = value;
  }
  public resetVarbindsWithTypes() {
    this._varbindsWithTypes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get varbindsWithTypesInput() {
    return this._varbindsWithTypes;
  }
}
export interface PackSourceInputSplunkAuthTokens {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token: string;
}

export function packSourceInputSplunkAuthTokensToTerraform(struct?: PackSourceInputSplunkAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    token: cdktf.stringToTerraform(struct!.token),
  }
}


export function packSourceInputSplunkAuthTokensToHclTerraform(struct?: PackSourceInputSplunkAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkAuthTokensOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkAuthTokens | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkAuthTokens | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._token = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._token = value.token;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // token - computed: false, optional: false, required: true
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }
}

export class PackSourceInputSplunkAuthTokensList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkAuthTokens[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkAuthTokensOutputReference {
    return new PackSourceInputSplunkAuthTokensOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSplunkConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputSplunkConnectionsToTerraform(struct?: PackSourceInputSplunkConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputSplunkConnectionsToHclTerraform(struct?: PackSourceInputSplunkConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputSplunkConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkConnectionsOutputReference {
    return new PackSourceInputSplunkConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSplunkMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSplunkMetadataToTerraform(struct?: PackSourceInputSplunkMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSplunkMetadataToHclTerraform(struct?: PackSourceInputSplunkMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSplunkMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkMetadataOutputReference {
    return new PackSourceInputSplunkMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
